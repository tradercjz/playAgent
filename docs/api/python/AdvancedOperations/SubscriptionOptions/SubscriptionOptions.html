<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../../../../favicon.ico"/><link rel="icon" href="../../../../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在 Python API 中，共推荐使用四种流订阅模式：单条订阅、批量订阅（设置 msgAsTable=False ）、批量订阅（设置 msgAsTable=True ）和异构流数据表订阅。下面将通过四个示例来分别介绍如何使用这四种订阅模式，以及各种订阅之间的区别。有关流订阅相关参数的介绍，请参考章节 流订阅 。 使用单条订阅模式，不需要指定 batchSize ，此时 msgAsTable 应为 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="流订阅模式"/><title>流订阅模式</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../../../../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/api/python/AdvancedOperations/SubscriptionOptions?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/api/python/AdvancedOperations/SubscriptionOptions/?&gt;&lt;?path2project ../../../../?&gt;&lt;?path2project-uri ../../../../?&gt;&lt;?path2rootmap-uri ../../../../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;流订阅模式&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:1;1:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:1;1:1&#34;&gt;流订阅模式&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:1;1:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:1;3:1&#34;&gt;在 Python API 中，共推荐使用四种流订阅模式：单条订阅、批量订阅（设置 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:1;3:42&#34;&gt;msgAsTable=False&lt;/codeph&gt;）、批量订阅（设置 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:2;3:70&#34;&gt;msgAsTable=True&lt;/codeph&gt;）和异构流数据表订阅。下面将通过四个示例来分别介绍如何使用这四种订阅模式，以及各种订阅之间的区别。有关流订阅相关参数的介绍，请参考章节&lt;xref class=&#34;- topic/xref &#34; href=&#34;../../BasicOperations/Subscription/Subscription.md&#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;xref:1;3:154&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;流订阅&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;单条订阅&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:2;5:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:2;5:1&#34;&gt;单条订阅&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:2;5:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:2;7:1&#34;&gt;使用单条订阅模式，不需要指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:1;7:16&#34;&gt;batchSize&lt;/i&gt;，此时 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:2;7:31&#34;&gt;msgAsTable&lt;/i&gt; 应为 False，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:3;7:53&#34;&gt;throttle&lt;/i&gt; 参数无效。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:3;9:1&#34;&gt;下例中，首先通过 session.run 执行脚本来构造流数据表，然后调用 session.enableStreaming 方法启用流订阅，再定义回调函数 handler。开始订阅后，调用 session.run 执行写入脚本，API 立刻收到消息并将结果打印出来。等待 3 秒后，调用 unsubscribe 取消订阅。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:1;11:1&#34;&gt;import dolphindb as ddb import numpy as np import time s = ddb.session() s.connect(&#34;192.168.1.113&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) s.run(&#34;&#34;&#34; share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades &#34;&#34;&#34;) s.enableStreaming() def handler(lst): print(lst) s.subscribe(&#34;192.168.1.113&#34;, 8848, handler, &#34;trades&#34;, &#34;SingleMode&#34;, offset=-1) s.run(&#34;insert into trades values(take(now(), 6), take(`000905`600001`300201`000908`600002, 6), rand(1000,6)/10.0, 1..6)&#34;) time.sleep(3) s.unsubscribe(&#34;192.168.1.113&#34;, 8848, &#34;trades&#34;, &#34;SingleMode&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:4;37:1&#34;&gt;输出结果如下所示：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:2;39:1&#34;&gt;[numpy.datetime64('2023-03-17T12:06:30.439'), '000905', 36.7, 1] [numpy.datetime64('2023-03-17T12:06:30.439'), '600001', 80.7, 2] [numpy.datetime64('2023-03-17T12:06:30.439'), '300201', 68.7, 3] [numpy.datetime64('2023-03-17T12:06:30.439'), '000908', 52.2, 4] [numpy.datetime64('2023-03-17T12:06:30.439'), '600002', 45.1, 5] [numpy.datetime64('2023-03-17T12:06:30.439'), '000905', 55.1, 6]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:5;48:1&#34;&gt;在流订阅中，API 内部仅使用 PROTOCOL_DDB 协议进行反序列化。在单条订阅模式下，DolphinDB 发送的数据由 API 接收后，每一行数据将从 AnyVector 转换为 list。有关 AnyVector 转换的详细说明，请参考章节 &lt;xref class=&#34;- topic/xref &#34; href=&#34;../DataTypeCasting/PROTOCOL_DDB.md&#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;xref:2;48:127&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;PROTOCOL_DDB&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;批量订阅设置-msgastablefalse&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:3;50:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:3;50:1&#34;&gt;批量订阅（设置 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:3;50:12&#34;&gt;msgAsTable=False&lt;/codeph&gt;）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:3;50:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:6;52:1&#34;&gt;若要使用批量订阅模式，则须指定参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:4;52:19&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:5;52:33&#34;&gt;throttle&lt;/i&gt;，表示当接收到的消息条数超过 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:6;52:58&#34;&gt;batchSize&lt;/i&gt;，或者处理消息前的等待时间超过 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:7;52:85&#34;&gt;throttle&lt;/i&gt;，则会触发一次回调，将数据传递给 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:8;52:112&#34;&gt;handler&lt;/i&gt;，并且按批次来处理数据。当指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:4;52:137&#34;&gt;msgAsTable=False&lt;/codeph&gt; 时，收到的一批数据将是一个列表 list，其中每一项都是单条数据，结构和单条订阅模式中的一条数据一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:7;54:1&#34;&gt;在下例中，分别指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:5;54:11&#34;&gt;batchSize=2&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:6;54:25&#34;&gt;throttle=0.1&lt;/codeph&gt;，表示在 0.1 秒时间内，如果收到了 2 条数据，则立刻调用回调函数传入这 2 条数据；如果等待的 0.1 秒仅收到 1 条数据，则会在等待结束后调用回调函数传入这 1 条数据。与单条订阅模式相似，批量订阅模式下通过 PROTOCOL_DDB 协议进行数据类型转换，每条数据将从 AnyVector 转为 list。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:3;56:1&#34;&gt;import dolphindb as ddb import numpy as np import time s = ddb.session() s.connect(&#34;192.168.1.113&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) s.run(&#34;&#34;&#34; share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades &#34;&#34;&#34;) s.enableStreaming() def handler(lsts): print(lsts) s.subscribe(&#34;192.168.1.113&#34;, 8848, handler, &#34;trades&#34;, &#34;MultiMode1&#34;, offset=-1, batchSize=2, throttle=0.1, msgAsTable=False) s.run(&#34;insert into trades values(take(now(), 6), take(`000905`600001`300201`000908`600002, 6), rand(1000,6)/10.0, 1..6)&#34;) time.sleep(3) s.unsubscribe(&#34;192.168.1.113&#34;, 8848, &#34;trades&#34;, &#34;MultiMode1&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:8;82:1&#34;&gt;输出结果如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:4;84:1&#34;&gt;[[numpy.datetime64('2023-03-17T14:46:27.358'), '000905', 21.2, 1], [numpy.datetime64('2023-03-17T14:46:27.358'), '600001', 39.8, 2]] [[numpy.datetime64('2023-03-17T14:46:27.358'), '300201', 84.0, 3], [numpy.datetime64('2023-03-17T14:46:27.358'), '000908', 26.2, 4]] [[numpy.datetime64('2023-03-17T14:46:27.358'), '600002', 25.1, 5], [numpy.datetime64('2023-03-17T14:46:27.358'), '000905', 42.7, 6]]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;批量订阅设置-msgastabletrue&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:4;90:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:4;90:1&#34;&gt;批量订阅（设置 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:7;90:12&#34;&gt;msgAsTable=True&lt;/codeph&gt;）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:4;90:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:9;92:1&#34;&gt;开启批量订阅时，如果指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:8;92:14&#34;&gt;msgAsTable=True&lt;/codeph&gt;，则每一批数据将基于消息块（由 DolphinDB 中的参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:9;92:62&#34;&gt;maxMsgNumPerBlock&lt;/i&gt; 进行配置）处理消息。当收到的记录总数大于等于 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:10;92:105&#34;&gt;batchSize&lt;/i&gt; 时，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:11;92:119&#34;&gt;handler&lt;/i&gt; 会对所有达到条件的消息块进行处理。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:10;94:1&#34;&gt;下例中，在开启批量订阅模式后，调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:9;94:19&#34;&gt;session.run&lt;/codeph&gt; 执行脚本，向流数据表中写入 1500 条数据，此时 DolphinDB 中的参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:12;94:74&#34;&gt;maxMsgNumPerBlock&lt;/i&gt; 为默认值 1024，因此 API 接收到 1024 条数据后，消息条数恰好超过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:10;94:134&#34;&gt;batchSize=1000&lt;/codeph&gt;，立刻调用回调函数；随后收到剩下的 476 条数据，等待 0.1 秒仍无新数据，再次调用回调函数。因此最后的输出结果为两个长度分别为 1024 和 476 的 DataFrame。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:5;96:1&#34;&gt;import dolphindb as ddb import numpy as np import time s = ddb.session() s.connect(&#34;192.168.1.113&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) s.run(&#34;&#34;&#34; share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades &#34;&#34;&#34;) s.enableStreaming() def handler(lsts): print(lsts) s.subscribe(&#34;192.168.1.113&#34;, 8848, handler, &#34;trades&#34;, &#34;MultiMode2&#34;, offset=-1, batchSize=1000, throttle=0.1, msgAsTable=True) s.run(&#34;n=1500;insert into trades values(take(now(), n), take(`000905`600001`300201`000908`600002, n), rand(1000,n)/10.0, 1..n)&#34;) time.sleep(3) s.unsubscribe(&#34;192.168.1.113&#34;, 8848, &#34;trades&#34;, &#34;MultiMode2&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:11;122:1&#34;&gt;如果修改上述示例中的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:13;122:12&#34;&gt;batchSize&lt;/i&gt; 为 1500，发送的数据为 3000 条，服务端发送第一个消息块（长度为 1024）后，不触发回调函数；服务端发送第二个消息块（长度为 1024）后，API 收到的数据条数共为 2048，超过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:11;122:121&#34;&gt;batchSize=1500&lt;/codeph&gt;，立刻触发回调函数，通过 PROTOCOL_DDB 协议将收到的消息从 Table 转换为 pandas.DataFrame；服务端发送第三个消息块（长度为 952）后，经过 0.1 秒，仍没有接收到新数据，此时触发回调函数。在这种情况下，回调函数中收到的数据，长度分别为 2048 和 952。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;异构流数据表订阅&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:5;124:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:5;124:1&#34;&gt;异构流数据表订阅&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:5;124:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:12;126:1&#34;&gt;DolphinDB 自 1.30.17 及 2.00.5 版本开始，支持通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:12;126:40&#34;&gt;replay&lt;/codeph&gt; 函数将多个结构不同的流数据表回放（序列化）到一个流数据表里，这个流数据表被称为异构流数据表。Python API 自 1.30.19 版本开始新增 streamDeserializer 类，用于构造异构流数据表反序列化器，以实现对异构流数据表的订阅和反序列化操作。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;异构流数据表反序列化器&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:6;128:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:6;128:1&#34;&gt;异构流数据表反序列化器&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:6;128:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:13;130:1&#34;&gt;Python API 通过 streamDeserializer 类来构造异构流数据表反序列化器，接口定义如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:6;132:1&#34;&gt;streamDeserializer(sym2table, session=None)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;ul:1;136:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;li:1;136:1&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:14;136:3&#34;&gt;sym2table&lt;/i&gt;：字典对象，其结构与 replay 回放到异构流数据表的输入表结构保持一致。streamDeserializer 将根据 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:15;136:75&#34;&gt;sym2table&lt;/i&gt; 指定的结构对注入的数据进行反序列化。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;li:2;137:1&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:16;137:3&#34;&gt;session&lt;/i&gt;：已连接 DolphinDB 的 session 对象，默认为 None。如果不指定，将会在订阅时自动获取当前连接。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:14;139:1&#34;&gt;下例构造一个简单的异构流数据表反序列化器：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:7;141:1&#34;&gt;sd = ddb.streamDeserializer({ 'msg1': [&#34;dfs://test_StreamDeserializer_pair&#34;, &#34;pt1&#34;], 'msg2': &#34;pt2&#34;, }, session=s)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:15;148:1&#34;&gt;其中，sym2table 的键为不同输入表的标记，用于区分不同输入表的数据；sym2table 的值为表名，或由分区数据库地址和表名组成的列表（或元组）。订阅时，会通过构造时传入的 session 调用 schema 方法获得 sym2table 键值对应的表的结构，因此并不一定需要填输入表名，只需要和输入表结构一致即可。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:16;150:1&#34;&gt;关于构造 DolphinDB 异构流数据表的具体脚本，请参照&lt;xref class=&#34;- topic/xref &#34; href=&#34;../../../../tutorials/stock_market_replay.md&#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;xref:3;150:31&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;异构回放示例&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:17;152:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;b:1;152:1&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;ol:1;154:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;li:3;154:1&#34;&gt;在 DolphinDB 中构造异构流数据表时，字典中 key 对应的表应为内存表或 replayDS 定义的数据源，请参考 &lt;xref class=&#34;- topic/xref &#34; href=&#34;../../../../funcs/r/replay.dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;xref:4;154:66&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;replay&lt;/xref&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;li:4;155:1&#34;&gt;API 端构造异构流数据表反序列化器时，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:17;155:24&#34;&gt;sym2table&lt;/i&gt; 的值对应的表（可以为分区表、流数据表或者内存表）结构需要和 DolphinDB 中构造异构流数据表使用的表结构一致。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;li:5;156:1&#34;&gt;订阅异构流数据表时，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:18;156:14&#34;&gt;msgAsTable&lt;/i&gt; 不能为 True，可以指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:19;156:41&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;i:20;156:55&#34;&gt;throttle&lt;/i&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;订阅示例-1-分区表数据源作为输入表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:7;158:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:7;158:1&#34;&gt;订阅示例 1 （分区表数据源作为输入表）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:7;158:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:18;160:1&#34;&gt;下例中，首先在 DolphinDB 中定义由两个分区表组合而成的异构流数据表，然后在 Python 客户端定义异构流数据表反序列化器 sd，再根据 sd 中指定表的结构反序列化数据。在输出结果中，每条数据的末尾都增加了一个字段，用于标识当前数据的 symbol。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;构造异构流数据表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:8;162:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:8;162:1&#34;&gt;构造异构流数据表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:8;162:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:19;164:1&#34;&gt;首先在 DolphinDB 中定义输出表，即要订阅的异构流数据表。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:8;166:1&#34;&gt;try{dropStreamTable(`outTables)}catch(ex){} share streamTable(100:0, `timestampv`sym`blob`price1,[TIMESTAMP,SYMBOL,BLOB,DOUBLE]) as outTables&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:20;171:1&#34;&gt;然后定义两张输入表，均为分布式分区表。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:9;173:1&#34;&gt;n = 6; dbName = 'dfs://test_StreamDeserializer_pair' if(existsDatabase(dbName)){ dropDB(dbName)} db = database(dbName,RANGE,2012.01.01 2013.01.01 2014.01.01 2015.01.01 2016.01.01 2017.01.01 2018.01.01 2019.01.01) table1 = table(100:0, `datetimev`timestampv`sym`price1`price2, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) table2 = table(100:0, `datetimev`timestampv`sym`price1, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE]) tableInsert(table1, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n), rand(100,n)+rand(1.0, n)) tableInsert(table2, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n)) pt1 = db.createPartitionedTable(table1,'pt1',`datetimev).append!(table1) pt2 = db.createPartitionedTable(table2,'pt2',`datetimev).append!(table2)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:21;187:1&#34;&gt;将分区表转为数据源后进行回放。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:10;189:1&#34;&gt;re1 = replayDS(sqlObj=&amp;lt;select * from pt1&amp;gt;, dateColumn=`datetimev, timeColumn=`timestampv) re2 = replayDS(sqlObj=&amp;lt;select * from pt2&amp;gt;, dateColumn=`datetimev, timeColumn=`timestampv) d = dict(['msg1', 'msg2'], [re1, re2]) replay(inputTables=d, outputTables=`outTables, dateColumn=`timestampv, timeColumn=`timestampv)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;订阅异构流表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:9;196:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:9;196:1&#34;&gt;订阅异构流表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:9;196:1&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:11;198:1&#34;&gt;import dolphindb as ddb # 异构流表反序列化器返回的数据末尾为异构流表反序列化器中 sym2table 指定的 key def streamDeserializer_handler(lst): if lst[-1]==&#34;msg1&#34;: print(&#34;Msg1: &#34;, lst) elif lst[-1]=='msg2': print(&#34;Msg2: &#34;, lst) else: print(&#34;Error: &#34;, lst) s = ddb.session() s.connect(&#34;192.168.1.113&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) s.enableStreaming() # 填入分区表数据库路径和表名的 list，以获取对应表结构 sd = ddb.streamDeserializer({ 'msg1': [&#34;dfs://test_StreamDeserializer_pair&#34;, &#34;pt1&#34;], 'msg2': [&#34;dfs://test_StreamDeserializer_pair&#34;, &#34;pt2&#34;], }, session=s) s.subscribe(host=&#34;192.168.1.113&#34;, port=8848, handler=streamDeserializer_handler, tableName=&#34;outTables&#34;, actionName=&#34;action&#34;, offset=0, resub=False, msgAsTable=False, streamDeserializer=sd, userName=&#34;admin&#34;, password=&#34;123456&#34;) from threading import Event Event().wait()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:22;226:1&#34;&gt;输出结果如下所示：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:12;228:1&#34;&gt;Msg2: [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 18.43745171907358, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 65.69160503265448, 41.17562178615481, 'msg1'] Msg2: [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 93.68146854126826, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 22.181119214976206, 38.162505637388676, 'msg1'] Msg2: [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 51.19852650281973, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 16.937458558939397, 36.79589221812785, 'msg1'] Msg2: [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 0.812068443512544, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 34.11729482654482, 29.094212289899588, 'msg1'] Msg2: [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 93.43341179518029, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 9.413380537647754, 32.449754945002496, 'msg1'] Msg2: [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 65.18307867064141, 'msg2'] Msg1: [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 83.58133838768117, 54.27990723075345, 'msg1']&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;订阅示例-2-内存表作为输入表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:10;243:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:10;243:1&#34;&gt;订阅示例 2 （内存表作为输入表）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:10;243:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:23;245:1&#34;&gt;下例中，在 DolphinDB 中定义了一个由两个内存表构成的异构流数据表，并在 Python 端使用共享内存表的表名构造反序列化器，最后指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeph:13;245:73&#34;&gt;batchSize=4&lt;/codeph&gt; 进行批量订阅。可以看出，在总数据条数为 6*2=12 的情况下，数据首先按总条数分 3 批传入回调函数，在每批数据中，每条数据可能来自不同的输入表。因此，共调用回调函数 3 次，每次输出4条数据构成的一批数据。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;构造异构流表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:11;247:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:11;247:1&#34;&gt;构造异构流表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:11;247:1&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:13;249:1&#34;&gt;try{dropStreamTable(`outTables)}catch(ex){} // 构造输出流数据表 share streamTable(100:0, `timestampv`sym`blob`price1,[TIMESTAMP,SYMBOL,BLOB,DOUBLE]) as outTables n = 6; table1 = table(100:0, `datetimev`timestampv`sym`price1`price2, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE, DOUBLE]) table2 = table(100:0, `datetimev`timestampv`sym`price1, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE]) tableInsert(table1, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n), rand(100,n)+rand(1.0, n)) tableInsert(table2, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n)) share table1 as pt1 share table2 as pt2 d = dict(['msg1', 'msg2'], [pt1, pt2]) replay(inputTables=d, outputTables=`outTables, dateColumn=`timestampv, timeColumn=`timestampv)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;订阅异构流表-1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;topic:12;266:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;title:12;266:1&#34;&gt;订阅异构流表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;body:12;266:1&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:14;268:1&#34;&gt;import dolphindb as ddb def streamDeserializer_handler(lsts): print(lsts) s = ddb.session() s.connect(&#34;192.168.1.113&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) s.enableStreaming() sd = ddb.streamDeserializer({ 'msg1': &#34;pt1&#34;, 'msg2': &#34;pt2&#34;, }, session=s) s.subscribe(host=&#34;192.168.1.113&#34;, port=8848, handler=streamDeserializer_handler, tableName=&#34;outTables&#34;, actionName=&#34;action&#34;, offset=0, resub=False, batchSize=4, msgAsTable=False, streamDeserializer=sd, userName=&#34;admin&#34;, password=&#34;123456&#34;) from threading import Event Event().wait()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;p:24;289:1&#34;&gt;输出结果如下所示：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md&#34; xtrc=&#34;codeblock:15;291:1&#34;&gt;[[numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 87.90784921264276, 'msg2'], [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 14.867915444076061, 92.22166634746827, 'msg1'], [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 80.60459423460998, 'msg2'], [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 10.429520844481885, 29.480175042990595, 'msg1']] [[numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 12.45058359648101, 'msg2'], [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 55.05597074679099, 88.84371786634438, 'msg1'], [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 27.357952459948137, 'msg2'], [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 57.705578718334436, 25.98224212951027, 'msg1']] [[numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 63.73548944480717, 'msg2'], [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 65.34572763741016, 0.6374575316440314, 'msg1'], [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 89.62549424753524, 'msg2'], [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 98.75018240674399, 46.55078419903293, 'msg1']]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.md"/><meta name="wh-out-relpath" content="api/python/AdvancedOperations/SubscriptionOptions/SubscriptionOptions.html"/>

    <link rel="stylesheet" type="text/css" href="../../../../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../../../../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../../../../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../../../../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../../../../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../../../../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../../../../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../../../../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="流订阅模式" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../../../../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../../../../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../../../../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                    
                    <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="wh_topic_body">
                        
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">流订阅模式</h1><div class="- topic/body body"><p class="- topic/p p">在 Python API 中，共推荐使用四种流订阅模式：单条订阅、批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=False</code>）、批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=True</code>）和异构流数据表订阅。下面将通过四个示例来分别介绍如何使用这四种订阅模式，以及各种订阅之间的区别。有关流订阅相关参数的介绍，请参考章节<a class="- topic/xref xref" href="../../BasicOperations/Subscription/Subscription.html">流订阅</a>。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="单条订阅"><h2 class="- topic/title title topictitle2" id="ariaid-title2">单条订阅</h2><div class="- topic/body body"><p class="- topic/p p">使用单条订阅模式，不需要指定 <em class="+ topic/ph hi-d/i ph i">batchSize</em>，此时 <em class="+ topic/ph hi-d/i ph i">msgAsTable</em> 应为 False，<em class="+ topic/ph hi-d/i ph i">throttle</em> 参数无效。</p><p class="- topic/p p">下例中，首先通过 session.run 执行脚本来构造流数据表，然后调用 session.enableStreaming 方法启用流订阅，再定义回调函数 handler。开始订阅后，调用 session.run 执行写入脚本，API 立刻收到消息并将结果打印出来。等待 3 秒后，调用 unsubscribe 取消订阅。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> dolphindb <strong class="hl-keyword">as</strong> ddb
<strong class="hl-keyword">import</strong> numpy <strong class="hl-keyword">as</strong> np
<strong class="hl-keyword">import</strong> time

s = ddb.session()
s.connect(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)

s.run(<span class="hl-string">"""
share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades
"""</span>)

s.enableStreaming()

<strong class="hl-keyword">def</strong> handler(lst):
    <strong class="hl-keyword">print</strong>(lst)

s.subscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, handler, <span class="hl-string">"trades"</span>, <span class="hl-string">"SingleMode"</span>, offset=-<span class="hl-number">1</span>)

s.run(<span class="hl-string">"insert into trades values(take(now(), 6), take(`000905`600001`300201`000908`600002, 6), rand(1000,6)/10.0, 1..6)"</span>)

time.sleep(<span class="hl-number">3</span>)

s.unsubscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"trades"</span>, <span class="hl-string">"SingleMode"</span>)</pre><p class="- topic/p p">输出结果如下所示：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>[numpy.datetime64('2023-03-17T12:06:30.439'), '000905', 36.7, 1]
[numpy.datetime64('2023-03-17T12:06:30.439'), '600001', 80.7, 2]
[numpy.datetime64('2023-03-17T12:06:30.439'), '300201', 68.7, 3]
[numpy.datetime64('2023-03-17T12:06:30.439'), '000908', 52.2, 4]
[numpy.datetime64('2023-03-17T12:06:30.439'), '600002', 45.1, 5]
[numpy.datetime64('2023-03-17T12:06:30.439'), '000905', 55.1, 6]</code></pre><p class="- topic/p p">在流订阅中，API 内部仅使用 PROTOCOL_DDB 协议进行反序列化。在单条订阅模式下，DolphinDB 发送的数据由 API 接收后，每一行数据将从 AnyVector 转换为 list。有关 AnyVector 转换的详细说明，请参考章节 <a class="- topic/xref xref" href="../DataTypeCasting/PROTOCOL_DDB.html">PROTOCOL_DDB</a>。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="批量订阅设置-msgastablefalse"><h2 class="- topic/title title topictitle2" id="ariaid-title3">批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=False</code>）</h2><div class="- topic/body body"><p class="- topic/p p">若要使用批量订阅模式，则须指定参数 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em>，表示当接收到的消息条数超过 <em class="+ topic/ph hi-d/i ph i">batchSize</em>，或者处理消息前的等待时间超过 <em class="+ topic/ph hi-d/i ph i">throttle</em>，则会触发一次回调，将数据传递给 <em class="+ topic/ph hi-d/i ph i">handler</em>，并且按批次来处理数据。当指定 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=False</code> 时，收到的一批数据将是一个列表 list，其中每一项都是单条数据，结构和单条订阅模式中的一条数据一致。</p><p class="- topic/p p">在下例中，分别指定 <code class="+ topic/ph pr-d/codeph ph codeph">batchSize=2</code>，<code class="+ topic/ph pr-d/codeph ph codeph">throttle=0.1</code>，表示在 0.1 秒时间内，如果收到了 2 条数据，则立刻调用回调函数传入这 2 条数据；如果等待的 0.1 秒仅收到 1 条数据，则会在等待结束后调用回调函数传入这 1 条数据。与单条订阅模式相似，批量订阅模式下通过 PROTOCOL_DDB 协议进行数据类型转换，每条数据将从 AnyVector 转为 list。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> dolphindb <strong class="hl-keyword">as</strong> ddb
<strong class="hl-keyword">import</strong> numpy <strong class="hl-keyword">as</strong> np
<strong class="hl-keyword">import</strong> time

s = ddb.session()
s.connect(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)

s.run(<span class="hl-string">"""
share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades
"""</span>)

s.enableStreaming()

<strong class="hl-keyword">def</strong> handler(lsts):
    <strong class="hl-keyword">print</strong>(lsts)

s.subscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, handler, <span class="hl-string">"trades"</span>, <span class="hl-string">"MultiMode1"</span>, offset=-<span class="hl-number">1</span>, batchSize=<span class="hl-number">2</span>, throttle=<span class="hl-number">0.1</span>, msgAsTable=False)

s.run(<span class="hl-string">"insert into trades values(take(now(), 6), take(`000905`600001`300201`000908`600002, 6), rand(1000,6)/10.0, 1..6)"</span>)

time.sleep(<span class="hl-number">3</span>)

s.unsubscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"trades"</span>, <span class="hl-string">"MultiMode1"</span>)</pre><p class="- topic/p p">输出结果如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>[[numpy.datetime64('2023-03-17T14:46:27.358'), '000905', 21.2, 1], [numpy.datetime64('2023-03-17T14:46:27.358'), '600001', 39.8, 2]]
[[numpy.datetime64('2023-03-17T14:46:27.358'), '300201', 84.0, 3], [numpy.datetime64('2023-03-17T14:46:27.358'), '000908', 26.2, 4]]
[[numpy.datetime64('2023-03-17T14:46:27.358'), '600002', 25.1, 5], [numpy.datetime64('2023-03-17T14:46:27.358'), '000905', 42.7, 6]]</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="批量订阅设置-msgastabletrue"><h2 class="- topic/title title topictitle2" id="ariaid-title4">批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=True</code>）</h2><div class="- topic/body body"><p class="- topic/p p">开启批量订阅时，如果指定 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=True</code>，则每一批数据将基于消息块（由 DolphinDB 中的参数 <em class="+ topic/ph hi-d/i ph i">maxMsgNumPerBlock</em> 进行配置）处理消息。当收到的记录总数大于等于 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 时，<em class="+ topic/ph hi-d/i ph i">handler</em> 会对所有达到条件的消息块进行处理。</p><p class="- topic/p p">下例中，在开启批量订阅模式后，调用 <code class="+ topic/ph pr-d/codeph ph codeph">session.run</code> 执行脚本，向流数据表中写入 1500 条数据，此时 DolphinDB 中的参数 <em class="+ topic/ph hi-d/i ph i">maxMsgNumPerBlock</em> 为默认值 1024，因此 API 接收到 1024 条数据后，消息条数恰好超过 <code class="+ topic/ph pr-d/codeph ph codeph">batchSize=1000</code>，立刻调用回调函数；随后收到剩下的 476 条数据，等待 0.1 秒仍无新数据，再次调用回调函数。因此最后的输出结果为两个长度分别为 1024 和 476 的 DataFrame。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> dolphindb <strong class="hl-keyword">as</strong> ddb
<strong class="hl-keyword">import</strong> numpy <strong class="hl-keyword">as</strong> np
<strong class="hl-keyword">import</strong> time

s = ddb.session()
s.connect(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)

s.run(<span class="hl-string">"""
share streamTable(10000:0,`time`sym`price`id, [TIMESTAMP,SYMBOL,DOUBLE,INT]) as trades
"""</span>)

s.enableStreaming()

<strong class="hl-keyword">def</strong> handler(lsts):
    <strong class="hl-keyword">print</strong>(lsts)

s.subscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, handler, <span class="hl-string">"trades"</span>, <span class="hl-string">"MultiMode2"</span>, offset=-<span class="hl-number">1</span>, batchSize=<span class="hl-number">1000</span>, throttle=<span class="hl-number">0.1</span>, msgAsTable=True)

s.run(<span class="hl-string">"n=1500;insert into trades values(take(now(), n), take(`000905`600001`300201`000908`600002, n), rand(1000,n)/10.0, 1..n)"</span>)

time.sleep(<span class="hl-number">3</span>)

s.unsubscribe(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"trades"</span>, <span class="hl-string">"MultiMode2"</span>)</pre><p class="- topic/p p">如果修改上述示例中的 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 为 1500，发送的数据为 3000 条，服务端发送第一个消息块（长度为 1024）后，不触发回调函数；服务端发送第二个消息块（长度为 1024）后，API 收到的数据条数共为 2048，超过 <code class="+ topic/ph pr-d/codeph ph codeph">batchSize=1500</code>，立刻触发回调函数，通过 PROTOCOL_DDB 协议将收到的消息从 Table 转换为 pandas.DataFrame；服务端发送第三个消息块（长度为 952）后，经过 0.1 秒，仍没有接收到新数据，此时触发回调函数。在这种情况下，回调函数中收到的数据，长度分别为 2048 和 952。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="异构流数据表订阅"><h2 class="- topic/title title topictitle2" id="ariaid-title5">异构流数据表订阅</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 自 1.30.17 及 2.00.5 版本开始，支持通过 <code class="+ topic/ph pr-d/codeph ph codeph">replay</code> 函数将多个结构不同的流数据表回放（序列化）到一个流数据表里，这个流数据表被称为异构流数据表。Python API 自 1.30.19 版本开始新增 streamDeserializer 类，用于构造异构流数据表反序列化器，以实现对异构流数据表的订阅和反序列化操作。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="异构流数据表反序列化器"><h3 class="- topic/title title topictitle3" id="ariaid-title6">异构流数据表反序列化器</h3><div class="- topic/body body"><p class="- topic/p p">Python API 通过 streamDeserializer 类来构造异构流数据表反序列化器，接口定义如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">streamDeserializer(sym2table, session=None)</pre><ul class="- topic/ul ul"><li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">sym2table</em>：字典对象，其结构与 replay 回放到异构流数据表的输入表结构保持一致。streamDeserializer 将根据 <em class="+ topic/ph hi-d/i ph i">sym2table</em> 指定的结构对注入的数据进行反序列化。</li><li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">session</em>：已连接 DolphinDB 的 session 对象，默认为 None。如果不指定，将会在订阅时自动获取当前连接。</li></ul><p class="- topic/p p">下例构造一个简单的异构流数据表反序列化器：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">sd = ddb.streamDeserializer({
    <span class="hl-string">'msg1'</span>: [<span class="hl-string">"dfs://test_StreamDeserializer_pair"</span>, <span class="hl-string">"pt1"</span>],
    <span class="hl-string">'msg2'</span>: <span class="hl-string">"pt2"</span>,
}, session=s)</pre><p class="- topic/p p">其中，sym2table 的键为不同输入表的标记，用于区分不同输入表的数据；sym2table 的值为表名，或由分区数据库地址和表名组成的列表（或元组）。订阅时，会通过构造时传入的 session 调用 schema 方法获得 sym2table 键值对应的表的结构，因此并不一定需要填输入表名，只需要和输入表结构一致即可。</p><p class="- topic/p p">关于构造 DolphinDB 异构流数据表的具体脚本，请参照<a class="- topic/xref xref" href="../../../../tutorials/stock_market_replay.html">异构回放示例</a>。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><ol class="- topic/ol ol"><li class="- topic/li li">在 DolphinDB 中构造异构流数据表时，字典中 key 对应的表应为内存表或 replayDS 定义的数据源，请参考 <a class="- topic/xref xref" href="../../../../funcs/r/replay.html">replay</a>。</li><li class="- topic/li li">API 端构造异构流数据表反序列化器时，<em class="+ topic/ph hi-d/i ph i">sym2table</em> 的值对应的表（可以为分区表、流数据表或者内存表）结构需要和 DolphinDB 中构造异构流数据表使用的表结构一致。</li><li class="- topic/li li">订阅异构流数据表时，<em class="+ topic/ph hi-d/i ph i">msgAsTable</em> 不能为 True，可以指定 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em>。</li></ol></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="订阅示例-1-分区表数据源作为输入表"><h3 class="- topic/title title topictitle3" id="ariaid-title7">订阅示例 1 （分区表数据源作为输入表）</h3><div class="- topic/body body"><p class="- topic/p p">下例中，首先在 DolphinDB 中定义由两个分区表组合而成的异构流数据表，然后在 Python 客户端定义异构流数据表反序列化器 sd，再根据 sd 中指定表的结构反序列化数据。在输出结果中，每条数据的末尾都增加了一个字段，用于标识当前数据的 symbol。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="构造异构流数据表"><h4 class="- topic/title title topictitle4" id="ariaid-title8">构造异构流数据表</h4><div class="- topic/body body"><p class="- topic/p p">首先在 DolphinDB 中定义输出表，即要订阅的异构流数据表。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>try{dropStreamTable(`outTables)}catch(ex){}
share streamTable(100:0, `timestampv`sym`blob`price1,[TIMESTAMP,SYMBOL,BLOB,DOUBLE]) as outTables</code></pre><p class="- topic/p p">然后定义两张输入表，均为分布式分区表。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 6;
dbName = 'dfs://test_StreamDeserializer_pair'
if(existsDatabase(dbName)){
    dropDB(dbName)}
db = database(dbName,RANGE,2012.01.01 2013.01.01 2014.01.01 2015.01.01 2016.01.01 2017.01.01 2018.01.01 2019.01.01)
table1 = table(100:0, `datetimev`timestampv`sym`price1`price2, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE, DOUBLE])
table2 = table(100:0, `datetimev`timestampv`sym`price1, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE])
tableInsert(table1, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n), rand(100,n)+rand(1.0, n))
tableInsert(table2, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n))
pt1 = db.createPartitionedTable(table1,'pt1',`datetimev).append!(table1)
pt2 = db.createPartitionedTable(table2,'pt2',`datetimev).append!(table2)</code></pre><p class="- topic/p p">将分区表转为数据源后进行回放。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>re1 = replayDS(sqlObj=&lt;select * from pt1&gt;, dateColumn=`datetimev, timeColumn=`timestampv)
re2 = replayDS(sqlObj=&lt;select * from pt2&gt;, dateColumn=`datetimev, timeColumn=`timestampv)
d = dict(['msg1', 'msg2'], [re1, re2])
replay(inputTables=d, outputTables=`outTables, dateColumn=`timestampv, timeColumn=`timestampv)</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="订阅异构流表"><h4 class="- topic/title title topictitle4" id="ariaid-title9">订阅异构流表</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> dolphindb <strong class="hl-keyword">as</strong> ddb

<em class="hl-comment"># 异构流表反序列化器返回的数据末尾为异构流表反序列化器中 sym2table 指定的 key</em>
<strong class="hl-keyword">def</strong> streamDeserializer_handler(lst):
    <strong class="hl-keyword">if</strong> lst[-<span class="hl-number">1</span>]==<span class="hl-string">"msg1"</span>:
        <strong class="hl-keyword">print</strong>(<span class="hl-string">"Msg1: "</span>, lst)
    <strong class="hl-keyword">elif</strong> lst[-<span class="hl-number">1</span>]==<span class="hl-string">'msg2'</span>:
        <strong class="hl-keyword">print</strong>(<span class="hl-string">"Msg2: "</span>, lst)
    <strong class="hl-keyword">else</strong>:
        <strong class="hl-keyword">print</strong>(<span class="hl-string">"Error: "</span>, lst)

s = ddb.session()
s.connect(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)
s.enableStreaming()

<em class="hl-comment"># 填入分区表数据库路径和表名的 list，以获取对应表结构</em>
sd = ddb.streamDeserializer({
    <span class="hl-string">'msg1'</span>: [<span class="hl-string">"dfs://test_StreamDeserializer_pair"</span>, <span class="hl-string">"pt1"</span>],
    <span class="hl-string">'msg2'</span>: [<span class="hl-string">"dfs://test_StreamDeserializer_pair"</span>, <span class="hl-string">"pt2"</span>],
}, session=s)
s.subscribe(host=<span class="hl-string">"192.168.1.113"</span>, port=<span class="hl-number">8848</span>, handler=streamDeserializer_handler, tableName=<span class="hl-string">"outTables"</span>, actionName=<span class="hl-string">"action"</span>, offset=<span class="hl-number">0</span>, resub=False,
            msgAsTable=False, streamDeserializer=sd, userName=<span class="hl-string">"admin"</span>, password=<span class="hl-string">"123456"</span>)

<strong class="hl-keyword">from</strong> threading <strong class="hl-keyword">import</strong> Event
Event().wait()</pre><p class="- topic/p p">输出结果如下所示：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>Msg2:  [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 18.43745171907358, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 65.69160503265448, 41.17562178615481, 'msg1']
Msg2:  [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 93.68146854126826, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 22.181119214976206, 38.162505637388676, 'msg1']
Msg2:  [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 51.19852650281973, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 16.937458558939397, 36.79589221812785, 'msg1']
Msg2:  [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 0.812068443512544, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 34.11729482654482, 29.094212289899588, 'msg1']
Msg2:  [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 93.43341179518029, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 9.413380537647754, 32.449754945002496, 'msg1']
Msg2:  [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 65.18307867064141, 'msg2']
Msg1:  [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 83.58133838768117, 54.27990723075345, 'msg1']</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="订阅示例-2-内存表作为输入表"><h3 class="- topic/title title topictitle3" id="ariaid-title10">订阅示例 2 （内存表作为输入表）</h3><div class="- topic/body body"><p class="- topic/p p">下例中，在 DolphinDB 中定义了一个由两个内存表构成的异构流数据表，并在 Python 端使用共享内存表的表名构造反序列化器，最后指定 <code class="+ topic/ph pr-d/codeph ph codeph">batchSize=4</code> 进行批量订阅。可以看出，在总数据条数为 6*2=12 的情况下，数据首先按总条数分 3 批传入回调函数，在每批数据中，每条数据可能来自不同的输入表。因此，共调用回调函数 3 次，每次输出4条数据构成的一批数据。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="构造异构流表"><h4 class="- topic/title title topictitle4" id="ariaid-title11">构造异构流表</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>try{dropStreamTable(`outTables)}catch(ex){}
// 构造输出流数据表
share streamTable(100:0, `timestampv`sym`blob`price1,[TIMESTAMP,SYMBOL,BLOB,DOUBLE]) as outTables

n = 6;
table1 = table(100:0, `datetimev`timestampv`sym`price1`price2, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE, DOUBLE])
table2 = table(100:0, `datetimev`timestampv`sym`price1, [DATETIME, TIMESTAMP, SYMBOL, DOUBLE])
tableInsert(table1, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n), rand(100,n)+rand(1.0, n))
tableInsert(table2, 2012.01.01T01:21:23 + 1..n, 2018.12.01T01:21:23.000 + 1..n, take(`a`b`c,n), rand(100,n)+rand(1.0, n))
share table1 as pt1
share table2 as pt2

d = dict(['msg1', 'msg2'], [pt1, pt2])
replay(inputTables=d, outputTables=`outTables, dateColumn=`timestampv, timeColumn=`timestampv)</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="订阅异构流表-1"><h4 class="- topic/title title topictitle4" id="ariaid-title12">订阅异构流表</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> dolphindb <strong class="hl-keyword">as</strong> ddb

<strong class="hl-keyword">def</strong> streamDeserializer_handler(lsts):
    <strong class="hl-keyword">print</strong>(lsts)

s = ddb.session()
s.connect(<span class="hl-string">"192.168.1.113"</span>, <span class="hl-number">8848</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)
s.enableStreaming()

sd = ddb.streamDeserializer({
    <span class="hl-string">'msg1'</span>: <span class="hl-string">"pt1"</span>,
    <span class="hl-string">'msg2'</span>: <span class="hl-string">"pt2"</span>,
}, session=s)
s.subscribe(host=<span class="hl-string">"192.168.1.113"</span>, port=<span class="hl-number">8848</span>, handler=streamDeserializer_handler, tableName=<span class="hl-string">"outTables"</span>, actionName=<span class="hl-string">"action"</span>, offset=<span class="hl-number">0</span>, resub=False, batchSize=<span class="hl-number">4</span>,
            msgAsTable=False, streamDeserializer=sd, userName=<span class="hl-string">"admin"</span>, password=<span class="hl-string">"123456"</span>)

<strong class="hl-keyword">from</strong> threading <strong class="hl-keyword">import</strong> Event
Event().wait()</pre><p class="- topic/p p">输出结果如下所示：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>[[numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 87.90784921264276, 'msg2'], [numpy.datetime64('2012-01-01T01:21:24'), numpy.datetime64('2018-12-01T01:21:23.001'), 'a', 14.867915444076061, 92.22166634746827, 'msg1'], [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 80.60459423460998, 'msg2'], [numpy.datetime64('2012-01-01T01:21:25'), numpy.datetime64('2018-12-01T01:21:23.002'), 'b', 10.429520844481885, 29.480175042990595, 'msg1']]
[[numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 12.45058359648101, 'msg2'], [numpy.datetime64('2012-01-01T01:21:26'), numpy.datetime64('2018-12-01T01:21:23.003'), 'c', 55.05597074679099, 88.84371786634438, 'msg1'], [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 27.357952459948137, 'msg2'], [numpy.datetime64('2012-01-01T01:21:27'), numpy.datetime64('2018-12-01T01:21:23.004'), 'a', 57.705578718334436, 25.98224212951027, 'msg1']]
[[numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 63.73548944480717, 'msg2'], [numpy.datetime64('2012-01-01T01:21:28'), numpy.datetime64('2018-12-01T01:21:23.005'), 'b', 65.34572763741016, 0.6374575316440314, 'msg1'], [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 89.62549424753524, 'msg2'], [numpy.datetime64('2012-01-01T01:21:29'), numpy.datetime64('2018-12-01T01:21:23.006'), 'c', 98.75018240674399, 46.55078419903293, 'msg1']]</code></pre></div></article></article></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#%E5%8D%95%E6%9D%A1%E8%AE%A2%E9%98%85" data-tocid="单条订阅">单条订阅</a></li><li class="topic-item"><a href="#%E6%89%B9%E9%87%8F%E8%AE%A2%E9%98%85%E8%AE%BE%E7%BD%AE-msgastablefalse" data-tocid="批量订阅设置-msgastablefalse">批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=False</code>）</a></li><li class="topic-item"><a href="#%E6%89%B9%E9%87%8F%E8%AE%A2%E9%98%85%E8%AE%BE%E7%BD%AE-msgastabletrue" data-tocid="批量订阅设置-msgastabletrue">批量订阅（设置 <code class="+ topic/ph pr-d/codeph ph codeph">msgAsTable=True</code>）</a></li><li class="topic-item"><a href="#%E5%BC%82%E6%9E%84%E6%B5%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E8%AE%A2%E9%98%85" data-tocid="异构流数据表订阅">异构流数据表订阅</a><ul><li class="topic-item"><a href="#%E5%BC%82%E6%9E%84%E6%B5%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8" data-tocid="异构流数据表反序列化器">异构流数据表反序列化器</a></li><li class="topic-item"><a href="#%E8%AE%A2%E9%98%85%E7%A4%BA%E4%BE%8B-1-%E5%88%86%E5%8C%BA%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E8%A1%A8" data-tocid="订阅示例-1-分区表数据源作为输入表">订阅示例 1 （分区表数据源作为输入表）</a><ul><li class="topic-item"><a href="#%E6%9E%84%E9%80%A0%E5%BC%82%E6%9E%84%E6%B5%81%E6%95%B0%E6%8D%AE%E8%A1%A8" data-tocid="构造异构流数据表">构造异构流数据表</a></li><li class="topic-item"><a href="#%E8%AE%A2%E9%98%85%E5%BC%82%E6%9E%84%E6%B5%81%E8%A1%A8" data-tocid="订阅异构流表">订阅异构流表</a></li></ul></li><li class="topic-item"><a href="#%E8%AE%A2%E9%98%85%E7%A4%BA%E4%BE%8B-2-%E5%86%85%E5%AD%98%E8%A1%A8%E4%BD%9C%E4%B8%BA%E8%BE%93%E5%85%A5%E8%A1%A8" data-tocid="订阅示例-2-内存表作为输入表">订阅示例 2 （内存表作为输入表）</a><ul><li class="topic-item"><a href="#%E6%9E%84%E9%80%A0%E5%BC%82%E6%9E%84%E6%B5%81%E8%A1%A8" data-tocid="构造异构流表">构造异构流表</a></li><li class="topic-item"><a href="#%E8%AE%A2%E9%98%85%E5%BC%82%E6%9E%84%E6%B5%81%E8%A1%A8-1" data-tocid="订阅异构流表-1">订阅异构流表</a></li></ul></li></ul></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>