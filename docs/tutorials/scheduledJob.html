<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="DolphinDB 定时作业（scheduled job）功能，实现系统在规定时间以指定频率自动执行作业。该功能广泛应用于数据库定时计算分析（如每日休市后分钟级的 K 线计算、每月统计报表生成）、数据库管理（如数据库备份、数据同步）、操作系统管理（如删除过期日志文件）等场景。 使用函数 scheduleJob 创建定时作业。作业创建后，系统会序列化作业定义信息并保存到文件 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../sys_man/om_intro.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="定时作业"/><title>定时作业</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;定时作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;DolphinDB 定时作业（scheduled job）功能，实现系统在规定时间以指定频率自动执行作业。该功能广泛应用于数据库定时计算分析（如每日休市后分钟级的 K 线计算、每月统计报表生成）、数据库管理（如数据库备份、数据同步）、操作系统管理（如删除过期日志文件）等场景。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:10;22:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_om.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../sys_man/om_intro.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_om.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;系统运维&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 的系统运维功能及方法&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;创建定时作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;创建定时作业&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;使用函数 scheduleJob 创建定时作业。作业创建后，系统会序列化作业定义信息并保存到文件&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;7:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;homeDir&amp;gt;/sysmgmt/jobEditlog.meta&lt;/codeph&gt;。语法如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, [days], [onComplete])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobFun&lt;/i&gt; 是一个没有参数的函数，通常是一个部分应用，可以设置为自定义函数、内置函数、插件函数、函数视图和模块中的函数等。这给了作业定义极大的灵活性：凡是能用函数来表示的工作，都可以作为定时任务来运行。比如用自定义函数、插件函数等做计算分析，用内置函数 run 运行一个脚本文件，用 shell 函数执行操作系统管理等等。 函数返回值是定时作业的作业 ID。如果输入的 jobId 与已有定时作业的作业 ID 不重复，系统返回输入的 jobId。否则在 jobId 后面添加当前日期，&#34;000&#34;, &#34;001&#34; 等作为后缀，直到产生唯一的作业 ID。 当到达设定时间，定时作业将在后台运行。 两次定时任务的执行时间（&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;18:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleTime&lt;/i&gt;）的最小间隔为5分钟。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例1调用自定义函数完成定时计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例1：调用自定义函数完成定时计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;以下例子调用了自定义函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;22:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getMaxTemperature&lt;/codeph&gt;，在每天0点计算前一天某个设备温度指标的最大值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def getMaxTemperature(deviceID){ maxTemp=exec max(temperature) from loadTable(&#34;dfs://dolphindb&#34;,&#34;sensor&#34;) where ID=deviceID ,ts between (today()-1).datetime():(today().datetime()-1) return maxTemp } scheduleJob(`testJob, &#34;getMaxTemperature&#34;, getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：自定义函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;33:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getMaxTemperature&lt;/codeph&gt; 的参数是设备编号，部分应用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;33:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getMaxTemperature{1}&lt;/codeph&gt; 代表给设备编号赋值1。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例2通过-run-函数定时执行脚本&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例2：通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;35:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;run&lt;/codeph&gt; 函数定时执行脚本&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;37:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;以下例子中，在2020年每个月1号的0点使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;37:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;run&lt;/codeph&gt; 函数执行脚本文件 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;37:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;monthlyJob.dos&lt;/i&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob(`monthlyJob, &#34;Monthly Job 1&#34;, run{&#34;/home/DolphinDB/script/monthlyJob.dos&#34;}, 00:00m, 2020.01.01, 2020.12.31, 'M', 1);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：指定脚本文件 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;43:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;monthlyJob.dos&lt;/i&gt; 的完整路径作为部分应用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;43:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;run&lt;/codeph&gt; 函数的参数。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例3定时执行操作系统命令&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例3：定时执行操作系统命令&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;在以下例子中，每周日的 1 点会定时执行删除日志文件的操作系统命令。作业函数为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;47:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;shell&lt;/codeph&gt; 函数，并指定命令 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;47:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;rm /home/DolphinDB/server/dolphindb.log&lt;/i&gt; 作为参数。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob(`weeklyjob, &#34;rm log&#34;, shell{&#34;rm /home/DolphinDB/server/dolphindb.log&#34;}, 01:00m, 2020.01.01, 2021.12.31, `W`, 0);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;在实际应用中，更常用的做法是从数据库中取出数据作为参数传入作业函数，计算后将结果存入数据库。示例4中的自定义函数 computeK，从分布式数据库表 trades 中取出行情数据，计算后将结果存入分布式数据库表 OHLC 中。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例4定时计算-k-线&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例4：定时计算 K 线&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;以下例子展示了如何在每周一到每周五的15点，计算分钟级的 K 线：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def computeK(){ barMinutes = 7 sessionsStart=09:30:00.000 13:00:00.000 OHLC = select first(price) as open, max(price) as high, min(price) as low,last(price) as close, sum(volume) as volume from loadTable(&#34;dfs://stock&#34;,&#34;trades&#34;) where time &amp;gt; today() and time &amp;lt; now() group by symbol, dailyAlignedBar(timestamp, sessionsStart, barMinutes*60*1000) as barStart append!(loadTable(&#34;dfs://stock&#34;,&#34;OHLC&#34;),OHLC) } scheduleJob(`kJob, &#34;7 Minutes&#34;, computeK, 15:00m, 2020.01.01, 2021.12.31, 'W', [1,2,3,4,5]);&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例5定时任务结束后发送邮件通知&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例5：定时任务结束后发送邮件通知&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;其中，参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;74:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;onComplete&lt;/i&gt; 是一个有 4 个参数的回调函数，当定时作业执行完毕（包括有异常的情况）后，会执行该函数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;以下脚本运行前需安装 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;../plugins/httpClient/httpclient.md&#34; xtrc=&#34;xref:1;76:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;HttpClient 插件&lt;/xref&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def sendEmail(jobId, jobDesc, success, result){ desc = &#34;jobId=&#34; + jobId + &#34; jobDesc=&#34; + jobDesc if(success){ desc += &#34; successful &#34; + result res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc) } else{ desc += &#34; with error: &#34; + result res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc) } } scheduleJob(jobId=`PnL, jobDesc=&#34;Calculate Profit &amp;amp; Loss&#34;, jobFunc=run{&#34;PnL.dos&#34;}, scheduleTime=[12:00m, 02&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;查询定时作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;查询定时作业&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;95:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getScheduledJobs&lt;/codeph&gt; 查询节点中的定时作业定义信息。函数语法如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getScheduledJobs([jobIdPattern])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;103:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;103:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobIdPattern&lt;/i&gt; 是表示作业 ID 或作业 ID 模式的字符串，支持通配符&#34;%&#34;和&#34;?&#34;； 函数的返回值是表格形式的定时作业信息。若 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;104:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobId&lt;/i&gt; 没有指定，则返回所有作业； 可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;105:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;pnodeRun(getScheduledJobs)&lt;/codeph&gt; 或在 web 上的作业管理“已定时的作业”中查看查询集群的定时作业信息。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;系统会将每次作业的执行情况保存在目录 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;107:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;homeDir&amp;gt;/batchJobs&lt;/codeph&gt; 下，包括定时作业的运行日志和返回值。运行日志保存在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;107:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;jodId&amp;gt;.msg&lt;/codeph&gt; 文件中；如果定时任务有返回值，它会保存在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;107:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;jobId&amp;gt;.object&lt;/codeph&gt; 文件中。可以使用函数 getJobMessage 查看每个作业的运行日志，使用函数 getJobReturn 查看作业的返回值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;109:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobID&lt;/i&gt; 的取值：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;创建作业时，若指定的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;111:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobId&lt;/i&gt; 与已有定时作业的作业 ID 重复，系统将为其添加后缀直到作业 ID 不重复； 对多次执行的作业，每次执行定时作业时，作业 ID 是不一样的，需要用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;112:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getRecentJobs&lt;/codeph&gt; 查看已完成的定时作业。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例5查询定时作业信息&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例5：查询定时作业信息&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;首先定义一个定时作业：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def foo(){ print &#34;test scheduled job at&#34;+ now() return now() } scheduleJob(`testJob, &#34;foo&#34;, foo, 17:00m+0..2*30, today(), today(), 'D');&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;126:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;运行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;126:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getRecentJobs()&lt;/codeph&gt; 得到示例 5 的作业信息。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;128:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;jobId jobDesc startTime endTime ------ ------- ----------------------- ---------------------- testJob foo 2020.02.14T17:00:23.636 2020.02.14T17:00:23.639 testJob20200214 foo 2020.02.14T17:30:23.908 2020.02.14T17:30:23.910 testJob20200214000 foo 2020.02.14T18:00:23.148 2020.02.14T18:00:26.749&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;136:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;第一次执行的作业 ID 是“testJob”，第二次执行的作业 ID 是“testJob20200214”，……，每次执行的作业 ID 不同。根据相应的作业ID，我们可用函数 getJobMessage 和 getJobReturn 查看第3次作业的执行情况。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;138:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;gt;getJobMessage(`testJob20200214000); 2020-02-14 18:00:23.148629 Start the job [testJob20200214000]: foo 2020-02-14 18:00:23.148721 test the scheduled job at 2020.02.14T18:00:23.148 2020-02-14 18:00:26.749111 The job is done. &amp;gt;getJobReturn(`testJob20200214000); 2020.02.14T18:00:23.148&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;删除定时作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;删除定时作业&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;150:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;deleteScheduledJob&lt;/codeph&gt; 删除定时作业。语法如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;deleteScheduledJob(jobId)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;删除前可通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;158:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getScheduledJobs&lt;/codeph&gt; 获取作业 ID。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;使用该命令时，管理员可以删除其他用户创建的任务，非管理员用户只能删除自己创建的任务。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;定时作业运行时的权限&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业运行时的权限&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业运行时的权限由用户创建定时作业时的登录身份的权限决定。用户创建定时作业时，需要确保其有权限访问待使用的资源。比如当登录用户不是授权用户，就不能访问集群的分布式表，否则执行作业时就会出错。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例6无分布式表访问权限的用户创建定时作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例6：无分布式表访问权限的用户创建定时作业&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;本例中，没有访问 DFS 分布式表的权限的用户 guestUser1 将创建一个定时作业。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def foo1(){ print &#34;Test scheduled job &#34;+ now() cnt=exec count(*) from loadTable(&#34;dfs://FuturesContract&#34;,&#34;tb&#34;) print &#34;The count of table is &#34;+cnt return cnt } login(&#34;guestUser1&#34;,&#34;123456&#34;) scheduleJob(`guestGetDfsjob, &#34;dfs read&#34;, foo1, [12:00m, 21:03m, 21:45m], 2020.01.01, 2021.12.31, &#34;D&#34;);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业执行后，使用函数 getJobMessage(`guestGetDfsjob) 进行查询。结果如下所示，定时作业没有权限读取分布式数据库：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;2020-02-14 21:03:23.193039 Start the job [guestGetDfsjob]: dfs read 2020-02-14 21:03:23.193092 Test the scheduled job at 2020.02.14T21:03:23.193 2020-02-14 21:03:23.194914 Not granted to read table dfs://FuturesContract/tb&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;因此，若定时作业要访问集群中的某个分布式表，需要先以管理员 (admin) 或其他授权用户身份登录。具体操作可以通过函数 login 完成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;190:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;190:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;从上述日志中可以发现，访问分布式表后的语句没有被执行，即作业执行过程中若遇到错误，执行就会中断。为防止出现异常而停止执行后续脚本，可使用 try-catch 语句俘获异常。代码运行中可以使用函数 print 打印运行信息，输出结果记录在日志文件 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;192:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;jobId&amp;gt;.msg&lt;/codeph&gt; 中。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;定时作业的序列化与反序列化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业的序列化与反序列化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业创建后，作业的ID、描述信息、起始时间、作业频率、作业函数及创建用户（userID）将被序列化并保存到当前节点的磁盘文件中，存储路径为&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;196:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;homeDir&amp;gt;/sysmgmt/jobEditlog.meta&lt;/codeph&gt;。在节点重启时，系统将对文件反序列化以进行加载。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业函数用一个 DolphinDB 的函数来表示，函数的定义包括了一系列语句，这些语句又会调用其他函数和一些全局类对象，譬如共享变量(shared variable)。共享变量序列化时用名称来表示。反序列化时，共享变量必须存在于内存中，否则会失败。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业函数或其依赖的函数根据是否经过编译可以分为两类：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;经过编译的函数，包括内置函数和插件函数； 脚本函数，包括自定义函数、函数视图和模块中的函数等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;这两类函数的序列化方法不同，下面分别进行说明。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;经过编译的函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;经过编译的函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;对经过编译的函数进行序列化，只序列化函数名称和模块名称。反序列化时，会在系统中搜索这些模块及函数，若搜索不到则失败。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;若已创建的定时作业中使用了插件函数，必须在反序列化前进行预先加载，否则系统启动失败。系统与定时作业的相关组件资源的初始化顺序依次是：系统级初始化脚本（dolphindb.dos），函数视图（function view），用户级启动脚本（startup.dos）和定时作业。示例7进行代码演示。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例7在作业函数-jobdemo-中使用-odbc-插件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例7：在作业函数 jobDemo 中使用 odbc 插件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;use odbc def jobDemo(){ conn = odbc::connect(&#34;dsn=mysql_factorDBURL&#34;); } scheduleJob(&#34;job demo&#34;,&#34;example of init&#34;,jobDemo,15:48m, 2019.01.01, 2020.12.31, 'D')&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;223:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;创建定时作业后，由于重新启动系统时没有加载插件 odbc，所以读取定时作业时，系统无法识别函数 odbc，输出下列日志后退出：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;ERROR&amp;gt;:Failed to unmarshall the job [job demo]. Failed to deserialize assign statement. Invalid message format&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;229:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;若在启动脚本中加入下列代码以加载插件 odbc，系统将顺利启动：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;231:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;loadPlugin(&#34;plugins/odbc/odbc.cfg&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;脚本函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;脚本函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;脚本函数会序列化函数参数以及函数定义的每一个语句。语句中若又包含了依赖的脚本函数，也会序列化这些依赖函数的定义。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;创建定时作业后，若这些脚本函数被删除或被修改了，或它依赖的脚本函数被修改，不影响定时作业运行。若希望定时作业按新的函数执行，就需要先删除定时作业、然后重新创建定时作业，否则会运行已序列化的函数。其中要注意关联的函数也需要重新定义。下面举例说明：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;下面进行举例说明：&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例8创建定时作业后重新定义作业函数-f&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例8：创建定时作业后重新定义作业函数 f&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def f(){ print &#34;The old function is called &#34; } scheduleJob(`test, &#34;f&#34;, f, 11:05m, today(), today(), 'D'); go def f(){ print &#34;The new function is called &#34; }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业执行后，使用函数 getJobMessage(`test) 得到如下信息，从中看到定时作业执行的仍然是旧的自定义函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;2020-02-14 11:05:53.382225 Start the job [test]: f 2020-02-14 11:05:53.382267 The old function is called 2020-02-14 11:05:53.382277 The job is done.&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例9创建定时作业后重新定义依赖函数-foo&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例9：创建定时作业后重新定义依赖函数 foo&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业函数是函数视图 fv，fv 调用函数 foo，在创建定时作业后重新定义依赖的函数 foo，函数视图也重新生成。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;268:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def foo(){ print &#34;The old function is called &#34; } def fv(){ foo() } addFunctionView(fv) scheduleJob(`testFvJob, &#34;fv&#34;, fv, 11:36m, today(), today(), 'D'); go def foo(){ print &#34;The new function is called &#34; } dropFunctionView(`fv) addFunctionView(fv) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;286:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业执行后，使用函数 getJobMessage(`testFvJob) 得到如下信息，从中看到定时作业执行的仍然是旧的函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;2020-02-14 11:36:23.069892 Start the job [testFvJob]: fv 2020-02-14 11:36:23.069939 The old function is called 2020-02-14 11:36:23.069951 The job is done.&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例10创建一个模块-printlogdos&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例10：创建一个模块 printLog.dos&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;module printLog def printLogs(logText){ writeLog(string(now()) + &#34; : &#34; + logText) print &#34;The old function is called&#34; }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;然后创建一个定时作业调用函数 printLog::printLogs：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;306:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;use printLog def f5(){ printLogs(&#34;test my log&#34;) } scheduleJob(`testModule, &#34;f5&#34;, f5, 13:32m, today(), today(), 'D');&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;在运行定时作业之前修改模块如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;module printLog def printLogs(logText){ writeLog(string(now()) + &#34; : &#34; + logText) print &#34;The new function is called&#34; }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时作业执行后，使用函数 getJobMessage(`testModule) 得到如下信息，从中看到定时作业执行的仍然是旧的函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;2020-02-14 13:32:22.870855 Start the job [testModule]: f5 2020-02-14 13:32:22.871097 The old function is called 2020-02-14 13:32:22.871106 The job is done.&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;定时运行脚本文件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;332:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;332:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时运行脚本文件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;332:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;在创建定时作业时，若作业函数是使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;334:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;run&lt;/codeph&gt; 运行一个脚本文件，因为序列化时只保存文件名，不保存文件内容，所以需要把依赖的自定义函数都放到脚本文件中，否则会因为找不到自定义的函数而执行失败。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;示例11创建一个脚本文件-testjobdos&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;示例11：创建一个脚本文件 testjob.dos&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;foo()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;然后在 DolphinDB GUI 中执行下列脚本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def foo(){ print (&#34;Hello world!&#34;) } run &#34;/home/user/testjob.dos&#34;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;结果显示可以正常执行：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;2020.02.14 13:47:00.992: executing code (line 104-108)... Hello world!&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;再创建定时作业使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;358:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;run&lt;/codeph&gt; 运行该脚本文件，代码如下所示：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob(`dailyfoofile1, &#34;Daily Job 1&#34;, run {&#34;/home/user/testjob.dos&#34;}, 16:14m, 2020.01.01, 2020.12.31, `D`);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;直接运行作业，将会发生如下异常：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;366:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;Exception was raised when running the script [/home/user/testjob.dos]:Syntax Error: [line #3] Cannot recognize the token foo&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;异常原因：函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;370:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;foo&lt;/codeph&gt; 的定义和定时作业的执行不在同一个会话 (session) 中，作业执行时找不到函数定义。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;把函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;372:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;foo&lt;/codeph&gt; 的定义放到脚本文件中，修改 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;372:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;testjob.dos&lt;/i&gt; 文件内容如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;374:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;def foo(){ print (&#34;Hello world!&#34;) } foo()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;再重新创建定时作业运行这个脚本文件，即可顺利完成。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;常见故障排查&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;常见故障排查&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrc=&#34;tgroup:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;385:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;常见故障&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;385:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;385:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;排除操作&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:3;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业函数引用了共享变量，但是作业加载时找不到该共享变量。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:4;387:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;建议在用户的启动脚本中定义该共享变量。&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;388:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:5;388:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;作业函数引用了插件中的函数，但是作业加载前没有加载该插件。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:6;388:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;建议在用户的启动脚本中定义加载该插件。&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:7;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;定时运行一个脚本文件，执行时找不到依赖的函数。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:8;389:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;脚本文件必须包含依赖的自定义函数。&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;390:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:9;390:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;创建定时作业的用户没有访问分布式数据库表的权限。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:10;390:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;授权该用户访问相应数据库的权限。&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:11;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;在启动脚本中使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;391:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;391:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getScheduledJobs&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;391:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;deleteScheduledJob&lt;/codeph&gt; 时抛出异常。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:12;391:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;节点启动时，定时作业在启动脚本之后加载，所以不能在启动脚本中使用与定时作业相关的任何功能，包括函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;391:130&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;scheduleJob&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;391:145&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;getScheduledJobs&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;391:166&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;deleteScheduledJob&lt;/codeph&gt;。如果需要在系统启动时初始化某些定时作业相关的任务，只能在初始化定时任务模块完成后通过 postStart 脚本执行。postStart 脚本文件路径由参数 postStart 指定。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;391:282&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;if(getScheduledJobs().jobDesc.find(&#34;daily resub&#34;) == -1){ scheduleJob(jobId=`daily, jobDesc=&#34;daily resub&#34;, jobFunc=run{&#34;/home/appadmin/server/resubJob.dos&#34;}, scheduleTime=08:30m, startDate=2021.08.30, endDate=2023.12.01, frequency='D') }&lt;/codeph&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;393:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;特殊情况下，可能出现在系统重启时定时作业加载失败，甚至系统无法启动的情况。尤其是版本升级时，可能因为内置函数、插件函数等函数接口变化导致作业无法加载，或者出现一些兼容性 bug 导致系统重启失败。因此，建议用户在开发时保留定义定时作业的脚本。若因定时任务导致系统无法启动，可以先删除定时作业的序列化文件&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;393:152&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/scheduledJob.md&#34;&gt;&amp;lt;homeDir&amp;gt;/sysmgmt/jobEditlog.meta&lt;/codeph&gt;，在系统重启后再重新创建定时作业。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/scheduledJob.md"/><meta name="wh-out-relpath" content="tutorials/scheduledJob.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="定时作业" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="chap7_tutorials_system_management"><div class="title"><a href="../sys_man/om_intro.html"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/thread_intro.html">任务管理</a></div></div></li><li class="active"><div class="topicref" data-id="定时作业"><div class="title"><a href="../tutorials/scheduledJob.html">定时作业</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="cluster_manage-d9713e7993" class="topicref" data-id="cluster_manage" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action cluster_manage-d9713e7993-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/cluster_manage.html" id="cluster_manage-d9713e7993-link">集群管理</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e8269" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e8269-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/thread_intro.html" id="tocId-d9713e8269-link">任务管理</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="线程简介-d9713e8270" class="topicref" data-id="线程简介" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/thread_intro.html" id="线程简介-d9713e8270-link">线程简介</a></div></div></li><li role="treeitem"><div data-tocid="作业管理-d9713e8316" class="topicref" data-id="作业管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/job_management_tutorial.html" id="作业管理-d9713e8316-link">作业管理</a></div></div></li><li role="treeitem" class="active"><div data-tocid="定时作业-d9713e8362" class="topicref" data-id="定时作业" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob.html" id="定时作业-d9713e8362-link">定时作业</a></div></div></li><li role="treeitem"><div data-tocid="批处理作业管理-d9713e8408" class="topicref" data-id="批处理作业管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/BatchJobManagement.html" id="批处理作业管理-d9713e8408-link">批处理作业管理</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454" class="topicref" data-id="e6_97_a0_e6_a0_87_e9_a2_9810" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/e6_97_a0_e6_a0_87_e9_a2_9810.html" id="e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454-link">登录管理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="性能监控-d9713e8546" class="topicref" data-id="性能监控" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 性能监控-d9713e8546-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/perf_man.html" id="性能监控-d9713e8546-link"><span class="keyword label">运维监控</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e8639" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e8639-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/bak_resto.html" id="tocId-d9713e8639-link">安全与容灾</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">定时作业</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 定时作业（scheduled job）功能，实现系统在规定时间以指定频率自动执行作业。该功能广泛应用于数据库定时计算分析（如每日休市后分钟级的 K 线计算、每月统计报表生成）、数据库管理（如数据库备份、数据同步）、操作系统管理（如删除过期日志文件）等场景。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="创建定时作业"><h2 class="- topic/title title topictitle2" id="ariaid-title2">创建定时作业</h2><div class="- topic/body body"><p class="- topic/p p">使用函数 scheduleJob 创建定时作业。作业创建后，系统会序列化作业定义信息并保存到文件<code class="+ topic/ph pr-d/codeph ph codeph">&lt;homeDir&gt;/sysmgmt/jobEditlog.meta</code>。语法如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>scheduleJob(jobId, jobDesc, jobFunc, scheduleTime, startDate, endDate, frequency, [days], [onComplete])</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">jobFun</em> 是一个没有参数的函数，通常是一个部分应用，可以设置为自定义函数、内置函数、插件函数、函数视图和模块中的函数等。这给了作业定义极大的灵活性：凡是能用函数来表示的工作，都可以作为定时任务来运行。比如用自定义函数、插件函数等做计算分析，用内置函数 run 运行一个脚本文件，用 shell 函数执行操作系统管理等等。
函数返回值是定时作业的作业 ID。如果输入的 jobId 与已有定时作业的作业 ID 不重复，系统返回输入的 jobId。否则在 jobId 后面添加当前日期，"000", "001" 等作为后缀，直到产生唯一的作业 ID。
当到达设定时间，定时作业将在后台运行。
两次定时任务的执行时间（<em class="+ topic/ph hi-d/i ph i">scheduleTime</em>）的最小间隔为5分钟。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="示例1调用自定义函数完成定时计算"><h3 class="- topic/title title topictitle3" id="ariaid-title3">示例1：调用自定义函数完成定时计算</h3><div class="- topic/body body"><p class="- topic/p p">以下例子调用了自定义函数 <code class="+ topic/ph pr-d/codeph ph codeph">getMaxTemperature</code>，在每天0点计算前一天某个设备温度指标的最大值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def getMaxTemperature(deviceID){
    maxTemp=exec max(temperature) from loadTable("dfs://dolphindb","sensor")
            where ID=deviceID ,ts between (today()-1).datetime():(today().datetime()-1)
    return  maxTemp
}
scheduleJob(`testJob, "getMaxTemperature", getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：自定义函数 <code class="+ topic/ph pr-d/codeph ph codeph">getMaxTemperature</code> 的参数是设备编号，部分应用 <code class="+ topic/ph pr-d/codeph ph codeph">getMaxTemperature{1}</code> 代表给设备编号赋值1。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="示例2通过-run-函数定时执行脚本"><h3 class="- topic/title title topictitle3" id="ariaid-title4">示例2：通过 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 函数定时执行脚本</h3><div class="- topic/body body"><p class="- topic/p p">以下例子中，在2020年每个月1号的0点使用 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 函数执行脚本文件 <em class="+ topic/ph hi-d/i ph i">monthlyJob.dos</em>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>scheduleJob(`monthlyJob, "Monthly Job 1", run{"/home/DolphinDB/script/monthlyJob.dos"}, 00:00m, 2020.01.01, 2020.12.31, 'M', 1);</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：指定脚本文件 <em class="+ topic/ph hi-d/i ph i">monthlyJob.dos</em> 的完整路径作为部分应用 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 函数的参数。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="示例3定时执行操作系统命令"><h3 class="- topic/title title topictitle3" id="ariaid-title5">示例3：定时执行操作系统命令</h3><div class="- topic/body body"><p class="- topic/p p">在以下例子中，每周日的 1 点会定时执行删除日志文件的操作系统命令。作业函数为 <code class="+ topic/ph pr-d/codeph ph codeph">shell</code> 函数，并指定命令 <em class="+ topic/ph hi-d/i ph i">rm /home/DolphinDB/server/dolphindb.log</em> 作为参数。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>scheduleJob(`weeklyjob, "rm log", shell{"rm /home/DolphinDB/server/dolphindb.log"}, 01:00m, 2020.01.01, 2021.12.31, `W`, 0);</code></pre><p class="- topic/p p">在实际应用中，更常用的做法是从数据库中取出数据作为参数传入作业函数，计算后将结果存入数据库。示例4中的自定义函数 computeK，从分布式数据库表 trades 中取出行情数据，计算后将结果存入分布式数据库表 OHLC 中。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="示例4定时计算-k-线"><h3 class="- topic/title title topictitle3" id="ariaid-title6">示例4：定时计算 K 线</h3><div class="- topic/body body"><p class="- topic/p p">以下例子展示了如何在每周一到每周五的15点，计算分钟级的 K 线：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def computeK(){
	barMinutes = 7
	sessionsStart=09:30:00.000 13:00:00.000
	OHLC =  select first(price) as open, max(price) as high, min(price) as low,last(price) as close, sum(volume) as volume 
		from loadTable("dfs://stock","trades")
		where time &gt; today() and time &lt; now()
		group by symbol, dailyAlignedBar(timestamp, sessionsStart, barMinutes*60*1000) as barStart
	append!(loadTable("dfs://stock","OHLC"),OHLC)
}
scheduleJob(`kJob, "7 Minutes", computeK, 15:00m, 2020.01.01, 2021.12.31, 'W', [1,2,3,4,5]);</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="示例5定时任务结束后发送邮件通知"><h3 class="- topic/title title topictitle3" id="ariaid-title7">示例5：定时任务结束后发送邮件通知</h3><div class="- topic/body body"><p class="- topic/p p">其中，参数 <em class="+ topic/ph hi-d/i ph i">onComplete</em> 是一个有 4 个参数的回调函数，当定时作业执行完毕（包括有异常的情况）后，会执行该函数。</p><p class="- topic/p p">以下脚本运行前需安装 <a class="- topic/xref xref" href="../plugins/httpClient/httpclient.html">HttpClient 插件</a>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sendEmail(jobId, jobDesc, success, result){
desc = "jobId=" + jobId + " jobDesc=" + jobDesc
if(success){
desc += " successful " + result
res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)
}
else{
desc += " with error: " + result
res = httpClient::sendEmail('patrick.mahomes@dolphindb.com','password','andy.reid@dolphindb.com','This is a subject',desc)
}
}
scheduleJob(jobId=`PnL, jobDesc="Calculate Profit &amp; Loss", jobFunc=run{"PnL.dos"}, scheduleTime=[12:00m, 02</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title8" id="查询定时作业"><h2 class="- topic/title title topictitle2" id="ariaid-title8">查询定时作业</h2><div class="- topic/body body"><p class="- topic/p p">使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">getScheduledJobs</code> 查询节点中的定时作业定义信息。函数语法如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>getScheduledJobs([jobIdPattern])</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><p class="- topic/p p">参数 <em class="+ topic/ph hi-d/i ph i">jobIdPattern</em> 是表示作业 ID 或作业 ID 模式的字符串，支持通配符"%"和"?"；
函数的返回值是表格形式的定时作业信息。若 <em class="+ topic/ph hi-d/i ph i">jobId</em> 没有指定，则返回所有作业；
可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">pnodeRun(getScheduledJobs)</code> 或在 web 上的作业管理“已定时的作业”中查看查询集群的定时作业信息。</p><p class="- topic/p p">系统会将每次作业的执行情况保存在目录 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;homeDir&gt;/batchJobs</code> 下，包括定时作业的运行日志和返回值。运行日志保存在 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;jodId&gt;.msg</code> 文件中；如果定时任务有返回值，它会保存在 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;jobId&gt;.object</code> 文件中。可以使用函数 getJobMessage 查看每个作业的运行日志，使用函数 getJobReturn 查看作业的返回值。</p><p class="- topic/p p">注意 <em class="+ topic/ph hi-d/i ph i">jobID</em> 的取值：</p><p class="- topic/p p">创建作业时，若指定的 <em class="+ topic/ph hi-d/i ph i">jobId</em> 与已有定时作业的作业 ID 重复，系统将为其添加后缀直到作业 ID 不重复；
对多次执行的作业，每次执行定时作业时，作业 ID 是不一样的，需要用函数 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs</code> 查看已完成的定时作业。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="示例5查询定时作业信息"><h3 class="- topic/title title topictitle3" id="ariaid-title9">示例5：查询定时作业信息</h3><div class="- topic/body body"><p class="- topic/p p">首先定义一个定时作业：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def foo(){
	print "test scheduled job at"+ now()
	return now()
}
scheduleJob(`testJob, "foo", foo, 17:00m+0..2*30, today(), today(), 'D');</code></pre><p class="- topic/p p">运行 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs()</code> 得到示例 5 的作业信息。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>jobId	            jobDesc	startTime	            endTime
------              ------- ----------------------- ----------------------
testJob	            foo 	2020.02.14T17:00:23.636	2020.02.14T17:00:23.639
testJob20200214	    foo 	2020.02.14T17:30:23.908	2020.02.14T17:30:23.910
testJob20200214000  foo 	2020.02.14T18:00:23.148	2020.02.14T18:00:26.749</code></pre><p class="- topic/p p">第一次执行的作业 ID 是“testJob”，第二次执行的作业 ID 是“testJob20200214”，……，每次执行的作业 ID 不同。根据相应的作业ID，我们可用函数 getJobMessage 和 getJobReturn 查看第3次作业的执行情况。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&gt;getJobMessage(`testJob20200214000);
2020-02-14 18:00:23.148629 Start the job [testJob20200214000]: foo
2020-02-14 18:00:23.148721 test the scheduled job at 2020.02.14T18:00:23.148
2020-02-14 18:00:26.749111 The job is done.

&gt;getJobReturn(`testJob20200214000);
2020.02.14T18:00:23.148</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title10" id="删除定时作业"><h2 class="- topic/title title topictitle2" id="ariaid-title10">删除定时作业</h2><div class="- topic/body body"><p class="- topic/p p">使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">deleteScheduledJob</code> 删除定时作业。语法如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>deleteScheduledJob(jobId)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><ul class="- topic/ul ul"><li class="- topic/li li">删除前可通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getScheduledJobs</code> 获取作业 ID。</li><li class="- topic/li li">使用该命令时，管理员可以删除其他用户创建的任务，非管理员用户只能删除自己创建的任务。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title11" id="定时作业运行时的权限"><h2 class="- topic/title title topictitle2" id="ariaid-title11">定时作业运行时的权限</h2><div class="- topic/body body"><p class="- topic/p p">定时作业运行时的权限由用户创建定时作业时的登录身份的权限决定。用户创建定时作业时，需要确保其有权限访问待使用的资源。比如当登录用户不是授权用户，就不能访问集群的分布式表，否则执行作业时就会出错。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="示例6无分布式表访问权限的用户创建定时作业"><h3 class="- topic/title title topictitle3" id="ariaid-title12">示例6：无分布式表访问权限的用户创建定时作业</h3><div class="- topic/body body"><p class="- topic/p p">本例中，没有访问 DFS 分布式表的权限的用户 guestUser1 将创建一个定时作业。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def foo1(){
	print "Test scheduled job "+ now()
	cnt=exec count(*) from loadTable("dfs://FuturesContract","tb")
	print "The count of table is "+cnt
	return cnt
}
login("guestUser1","123456")
scheduleJob(`guestGetDfsjob, "dfs read", foo1, [12:00m, 21:03m, 21:45m], 2020.01.01, 2021.12.31, "D");</code></pre><p class="- topic/p p">作业执行后，使用函数 getJobMessage(`guestGetDfsjob) 进行查询。结果如下所示，定时作业没有权限读取分布式数据库：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2020-02-14 21:03:23.193039 Start the job [guestGetDfsjob]: dfs read
2020-02-14 21:03:23.193092 Test the scheduled job at 2020.02.14T21:03:23.193
2020-02-14 21:03:23.194914 Not granted to read table dfs://FuturesContract/tb</code></pre><p class="- topic/p p">因此，若定时作业要访问集群中的某个分布式表，需要先以管理员 (admin) 或其他授权用户身份登录。具体操作可以通过函数 login 完成。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><p class="- topic/p p">从上述日志中可以发现，访问分布式表后的语句没有被执行，即作业执行过程中若遇到错误，执行就会中断。为防止出现异常而停止执行后续脚本，可使用 try-catch 语句俘获异常。代码运行中可以使用函数 print 打印运行信息，输出结果记录在日志文件 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;jobId&gt;.msg</code> 中。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="定时作业的序列化与反序列化"><h2 class="- topic/title title topictitle2" id="ariaid-title13">定时作业的序列化与反序列化</h2><div class="- topic/body body"><p class="- topic/p p">定时作业创建后，作业的ID、描述信息、起始时间、作业频率、作业函数及创建用户（userID）将被序列化并保存到当前节点的磁盘文件中，存储路径为<code class="+ topic/ph pr-d/codeph ph codeph">&lt;homeDir&gt;/sysmgmt/jobEditlog.meta</code>。在节点重启时，系统将对文件反序列化以进行加载。</p><p class="- topic/p p">作业函数用一个 DolphinDB 的函数来表示，函数的定义包括了一系列语句，这些语句又会调用其他函数和一些全局类对象，譬如共享变量(shared variable)。共享变量序列化时用名称来表示。反序列化时，共享变量必须存在于内存中，否则会失败。</p><p class="- topic/p p">作业函数或其依赖的函数根据是否经过编译可以分为两类：</p><p class="- topic/p p">经过编译的函数，包括内置函数和插件函数；
脚本函数，包括自定义函数、函数视图和模块中的函数等。</p><p class="- topic/p p">这两类函数的序列化方法不同，下面分别进行说明。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="经过编译的函数"><h3 class="- topic/title title topictitle3" id="ariaid-title14">经过编译的函数</h3><div class="- topic/body body"><p class="- topic/p p">对经过编译的函数进行序列化，只序列化函数名称和模块名称。反序列化时，会在系统中搜索这些模块及函数，若搜索不到则失败。</p><p class="- topic/p p">若已创建的定时作业中使用了插件函数，必须在反序列化前进行预先加载，否则系统启动失败。系统与定时作业的相关组件资源的初始化顺序依次是：系统级初始化脚本（dolphindb.dos），函数视图（function view），用户级启动脚本（startup.dos）和定时作业。示例7进行代码演示。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="示例7在作业函数-jobdemo-中使用-odbc-插件"><h4 class="- topic/title title topictitle4" id="ariaid-title15">示例7：在作业函数 jobDemo 中使用 odbc 插件</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use odbc
def jobDemo(){
	conn = odbc::connect("dsn=mysql_factorDBURL");
}
scheduleJob("job demo","example of init",jobDemo,15:48m, 2019.01.01, 2020.12.31, 'D')</code></pre><p class="- topic/p p">创建定时作业后，由于重新启动系统时没有加载插件 odbc，所以读取定时作业时，系统无法识别函数 odbc，输出下列日志后退出：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>&lt;ERROR&gt;:Failed to unmarshall the job [job demo]. Failed to deserialize assign statement. Invalid message format</code></pre><p class="- topic/p p">若在启动脚本中加入下列代码以加载插件 odbc，系统将顺利启动：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>loadPlugin("plugins/odbc/odbc.cfg")</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="脚本函数"><h3 class="- topic/title title topictitle3" id="ariaid-title16">脚本函数</h3><div class="- topic/body body"><p class="- topic/p p">脚本函数会序列化函数参数以及函数定义的每一个语句。语句中若又包含了依赖的脚本函数，也会序列化这些依赖函数的定义。</p><p class="- topic/p p">创建定时作业后，若这些脚本函数被删除或被修改了，或它依赖的脚本函数被修改，不影响定时作业运行。若希望定时作业按新的函数执行，就需要先删除定时作业、然后重新创建定时作业，否则会运行已序列化的函数。其中要注意关联的函数也需要重新定义。下面举例说明：</p><p class="- topic/p p">下面进行举例说明：</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title17" id="示例8创建定时作业后重新定义作业函数-f"><h4 class="- topic/title title topictitle4" id="ariaid-title17">示例8：创建定时作业后重新定义作业函数 f</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def f(){
	print "The old function is called " 
}
scheduleJob(`test, "f", f, 11:05m, today(), today(), 'D');
go
def f(){
	print "The new function is called " 
}</code></pre><p class="- topic/p p">定时作业执行后，使用函数 getJobMessage(`test) 得到如下信息，从中看到定时作业执行的仍然是旧的自定义函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2020-02-14 11:05:53.382225 Start the job [test]: f
2020-02-14 11:05:53.382267 The old function is called 
2020-02-14 11:05:53.382277 The job is done.</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="示例9创建定时作业后重新定义依赖函数-foo"><h4 class="- topic/title title topictitle4" id="ariaid-title18">示例9：创建定时作业后重新定义依赖函数 foo</h4><div class="- topic/body body"><p class="- topic/p p">作业函数是函数视图 fv，fv 调用函数 foo，在创建定时作业后重新定义依赖的函数 foo，函数视图也重新生成。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def foo(){
	print "The old function is called " 
}
def fv(){
	foo()
}
addFunctionView(fv)  

scheduleJob(`testFvJob, "fv", fv, 11:36m, today(), today(), 'D');
go
def foo(){
	print "The new function is called " 
}
dropFunctionView(`fv)
addFunctionView(fv) </code></pre><p class="- topic/p p">定时作业执行后，使用函数 getJobMessage(`testFvJob) 得到如下信息，从中看到定时作业执行的仍然是旧的函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2020-02-14 11:36:23.069892 Start the job [testFvJob]: fv
2020-02-14 11:36:23.069939 The old function is called 
2020-02-14 11:36:23.069951 The job is done.</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title19" id="示例10创建一个模块-printlogdos"><h4 class="- topic/title title topictitle4" id="ariaid-title19">示例10：创建一个模块 printLog.dos</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>module printLog
def printLogs(logText){
	writeLog(string(now()) + " : " + logText)
	print "The old function is called"
}</code></pre><p class="- topic/p p">然后创建一个定时作业调用函数 printLog::printLogs：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use printLog
def f5(){
	printLogs("test my log")
}
scheduleJob(`testModule, "f5", f5, 13:32m, today(), today(), 'D');</code></pre><p class="- topic/p p">在运行定时作业之前修改模块如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>module printLog
def printLogs(logText){
	writeLog(string(now()) + " : " + logText)
	print "The new function is called"
}</code></pre><p class="- topic/p p">定时作业执行后，使用函数 getJobMessage(`testModule) 得到如下信息，从中看到定时作业执行的仍然是旧的函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2020-02-14 13:32:22.870855 Start the job [testModule]: f5
2020-02-14 13:32:22.871097 The old function is called
2020-02-14 13:32:22.871106 The job is done.</code></pre></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="定时运行脚本文件"><h2 class="- topic/title title topictitle2" id="ariaid-title20">定时运行脚本文件</h2><div class="- topic/body body"><p class="- topic/p p">在创建定时作业时，若作业函数是使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 运行一个脚本文件，因为序列化时只保存文件名，不保存文件内容，所以需要把依赖的自定义函数都放到脚本文件中，否则会因为找不到自定义的函数而执行失败。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="示例11创建一个脚本文件-testjobdos"><h3 class="- topic/title title topictitle3" id="ariaid-title21">示例11：创建一个脚本文件 testjob.dos</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>foo()</code></pre><p class="- topic/p p">然后在 DolphinDB GUI 中执行下列脚本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def foo(){
	print ("Hello world!")
}
run "/home/user/testjob.dos"</code></pre><p class="- topic/p p">结果显示可以正常执行：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2020.02.14 13:47:00.992: executing code (line 104-108)...
Hello world!</code></pre><p class="- topic/p p">再创建定时作业使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 运行该脚本文件，代码如下所示：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>scheduleJob(`dailyfoofile1, "Daily Job 1", run {"/home/user/testjob.dos"}, 16:14m, 2020.01.01, 2020.12.31, `D`);</code></pre><p class="- topic/p p">直接运行作业，将会发生如下异常：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>Exception was raised when running the script [/home/user/testjob.dos]:Syntax Error: [line #3] Cannot recognize the token foo</code></pre><p class="- topic/p p">异常原因：函数 <code class="+ topic/ph pr-d/codeph ph codeph">foo</code> 的定义和定时作业的执行不在同一个会话 (session) 中，作业执行时找不到函数定义。</p><p class="- topic/p p">把函数 <code class="+ topic/ph pr-d/codeph ph codeph">foo</code> 的定义放到脚本文件中，修改 <em class="+ topic/ph hi-d/i ph i">testjob.dos</em> 文件内容如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def foo(){
	print ("Hello world!")
}
foo()</code></pre><p class="- topic/p p">再重新创建定时作业运行这个脚本文件，即可顺利完成。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title22" id="常见故障排查"><h2 class="- topic/title title topictitle2" id="ariaid-title22">常见故障排查</h2><div class="- topic/body body"><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="常见故障排查__entry__1"><strong class="+ topic/ph hi-d/b ph b">常见故障</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="常见故障排查__entry__2"><strong class="+ topic/ph hi-d/b ph b">排除操作</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__1">作业函数引用了共享变量，但是作业加载时找不到该共享变量。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__2">建议在用户的启动脚本中定义该共享变量。</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__1">作业函数引用了插件中的函数，但是作业加载前没有加载该插件。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__2">建议在用户的启动脚本中定义加载该插件。</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__1">定时运行一个脚本文件，执行时找不到依赖的函数。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__2">脚本文件必须包含依赖的自定义函数。</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__1">创建定时作业的用户没有访问分布式数据库表的权限。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__2">授权该用户访问相应数据库的权限。</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__1">在启动脚本中使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">scheduleJob</code>,  <code class="+ topic/ph pr-d/codeph ph codeph">getScheduledJobs</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">deleteScheduledJob</code> 时抛出异常。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="常见故障排查__entry__2">节点启动时，定时作业在启动脚本之后加载，所以不能在启动脚本中使用与定时作业相关的任何功能，包括函数<code class="+ topic/ph pr-d/codeph ph codeph">scheduleJob</code>, <code class="+ topic/ph pr-d/codeph ph codeph">getScheduledJobs</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">deleteScheduledJob</code>。如果需要在系统启动时初始化某些定时作业相关的任务，只能在初始化定时任务模块完成后通过 postStart 脚本执行。postStart 脚本文件路径由参数 postStart 指定。<code class="+ topic/ph pr-d/codeph ph codeph">if(getScheduledJobs().jobDesc.find("daily resub") == -1){	scheduleJob(jobId=`daily, jobDesc="daily resub", jobFunc=run{"/home/appadmin/server/resubJob.dos"}, scheduleTime=08:30m, startDate=2021.08.30, endDate=2023.12.01, frequency='D')	}</code></td></tr></tbody></table></div><p class="- topic/p p">特殊情况下，可能出现在系统重启时定时作业加载失败，甚至系统无法启动的情况。尤其是版本升级时，可能因为内置函数、插件函数等函数接口变化导致作业无法加载，或者出现一些兼容性 bug 导致系统重启失败。因此，建议用户在开发时保留定义定时作业的脚本。若因定时任务导致系统无法启动，可以先删除定时作业的序列化文件<code class="+ topic/ph pr-d/codeph ph codeph">&lt;homeDir&gt;/sysmgmt/jobEditlog.meta</code>，在系统重启后再重新创建定时作业。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A" data-tocid="创建定时作业">创建定时作业</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B1%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AE%8C%E6%88%90%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97" data-tocid="示例1调用自定义函数完成定时计算">示例1：调用自定义函数完成定时计算</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B2%E9%80%9A%E8%BF%87-run-%E5%87%BD%E6%95%B0%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC" data-tocid="示例2通过-run-函数定时执行脚本">示例2：通过 <code class="+ topic/ph pr-d/codeph ph codeph">run</code> 函数定时执行脚本</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B3%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4" data-tocid="示例3定时执行操作系统命令">示例3：定时执行操作系统命令</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B4%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97-k-%E7%BA%BF" data-tocid="示例4定时计算-k-线">示例4：定时计算 K 线</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B5%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9D%9F%E5%90%8E%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5" data-tocid="示例5定时任务结束后发送邮件通知">示例5：定时任务结束后发送邮件通知</a></li></ul></li><li class="topic-item"><a href="#%E6%9F%A5%E8%AF%A2%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A" data-tocid="查询定时作业">查询定时作业</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B5%E6%9F%A5%E8%AF%A2%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A%E4%BF%A1%E6%81%AF" data-tocid="示例5查询定时作业信息">示例5：查询定时作业信息</a></li></ul></li><li class="topic-item"><a href="#%E5%88%A0%E9%99%A4%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A" data-tocid="删除定时作业">删除定时作业</a></li><li class="topic-item"><a href="#%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%9D%83%E9%99%90" data-tocid="定时作业运行时的权限">定时作业运行时的权限</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B6%E6%97%A0%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A" data-tocid="示例6无分布式表访问权限的用户创建定时作业">示例6：无分布式表访问权限的用户创建定时作业</a></li></ul></li><li class="topic-item"><a href="#%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96" data-tocid="定时作业的序列化与反序列化">定时作业的序列化与反序列化</a><ul><li class="topic-item"><a href="#%E7%BB%8F%E8%BF%87%E7%BC%96%E8%AF%91%E7%9A%84%E5%87%BD%E6%95%B0" data-tocid="经过编译的函数">经过编译的函数</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B7%E5%9C%A8%E4%BD%9C%E4%B8%9A%E5%87%BD%E6%95%B0-jobdemo-%E4%B8%AD%E4%BD%BF%E7%94%A8-odbc-%E6%8F%92%E4%BB%B6" data-tocid="示例7在作业函数-jobdemo-中使用-odbc-插件">示例7：在作业函数 jobDemo 中使用 odbc 插件</a></li></ul></li><li class="topic-item"><a href="#%E8%84%9A%E6%9C%AC%E5%87%BD%E6%95%B0" data-tocid="脚本函数">脚本函数</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B8%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E4%BD%9C%E4%B8%9A%E5%87%BD%E6%95%B0-f" data-tocid="示例8创建定时作业后重新定义作业函数-f">示例8：创建定时作业后重新定义作业函数 f</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B9%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BD%9C%E4%B8%9A%E5%90%8E%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E4%BE%9D%E8%B5%96%E5%87%BD%E6%95%B0-foo" data-tocid="示例9创建定时作业后重新定义依赖函数-foo">示例9：创建定时作业后重新定义依赖函数 foo</a></li><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B10%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%9D%97-printlogdos" data-tocid="示例10创建一个模块-printlogdos">示例10：创建一个模块 printLog.dos</a></li></ul></li></ul></li><li class="topic-item"><a href="#%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6" data-tocid="定时运行脚本文件">定时运行脚本文件</a><ul><li class="topic-item"><a href="#%E7%A4%BA%E4%BE%8B11%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6-testjobdos" data-tocid="示例11创建一个脚本文件-testjobdos">示例11：创建一个脚本文件 testjob.dos</a></li></ul></li><li class="topic-item"><a href="#%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5" data-tocid="常见故障排查">常见故障排查</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>