<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="本教程重点介绍了一些常见场景下的 SQL 编写案例。介绍如何正确编写 SQL 语句来提升脚本运行性能，通过优化前后性能对比，来说明DolphinDB SQL脚本的编写技巧。包括以下内容： 处理器：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz 核数：64 内存：512 GB 操作系统：CentOS Linux release 7.9 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="sql-编写案例"/><title>SQL 编写案例</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;sql-编写案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;SQL 编写案例&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;本教程重点介绍了一些常见场景下的 SQL 编写案例。介绍如何正确编写 SQL 语句来提升脚本运行性能，通过优化前后性能对比，来说明DolphinDB SQL脚本的编写技巧。包括以下内容：&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:33;51:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-测试环境说明&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;1. 测试环境说明&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;处理器：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;核数：64&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;内存：512 GB&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;操作系统：CentOS Linux release 7.9&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;License：免费版License，CPU 2核，内存 8GB&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;DolphinDB Server 版本：DolphinDB_Linux64_V2.00.4，单节点模式部署&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;DolphinDB GUI 版本：DolphinDB_GUI_V1.30.15&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以下章节案例中所用到的2020年06月测试数据为上交所 Level-1 快照数据，基于真实数据结构模拟2000只股票快照数据，基于 OLAP 与 TSDB 存储引擎的建库建表、数据模拟、数据插入脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;model = table(1:0, `SecurityID`DateTime`PreClosePx`OpenPx`HighPx`LowPx`LastPx`Volume`Amount`BidPrice1`BidPrice2`BidPrice3`BidPrice4`BidPrice5`BidOrderQty1`BidOrderQty2`BidOrderQty3`BidOrderQty4`BidOrderQty5`OfferPrice1`OfferPrice2`OfferPrice3`OfferPrice4`OfferPrice5`OfferQty1`OfferQty2`OfferQty3`OfferQty4`OfferQty5, [SYMBOL, DATETIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG, LONG, LONG, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG, LONG, LONG]) // OLAP 存储引擎建库建表 dbDate = database(&#34;&#34;, VALUE, 2020.06.01..2020.06.07) dbSecurityID = database(&#34;&#34;, HASH, [SYMBOL, 10]) db = database(&#34;dfs://Level1&#34;, COMPO, [dbDate, dbSecurityID]) createPartitionedTable(db, model, `Snapshot, `DateTime`SecurityID) // TSDB 存储引擎建库建表 dbDate = database(&#34;&#34;, VALUE, 2020.06.01..2020.06.07) dbSymbol = database(&#34;&#34;, HASH, [SYMBOL, 10]) db = database(&#34;dfs://Level1_TSDB&#34;, COMPO, [dbDate, dbSymbol], engine=&#34;TSDB&#34;) createPartitionedTable(db, model, `Snapshot, `DateTime`SecurityID, sortColumns=`SecurityID`DateTime) def mockHalfDayData(Date, StartTime) { t_SecurityID = table(format(600001..602000, &#34;000000&#34;) + &#34;.SH&#34; as SecurityID) t_DateTime = table(concatDateTime(Date, StartTime + 1..2400 * 3) as DateTime) t = cj(t_SecurityID, t_DateTime) size = t.size() return table(t.SecurityID as SecurityID, t.DateTime as DateTime, rand(100.0, size) as PreClosePx, rand(100.0, size) as OpenPx, rand(100.0, size) as HighPx, rand(100.0, size) as LowPx, rand(100.0, size) as LastPx, rand(10000, size) as Volume, rand(100000.0, size) as Amount, rand(100.0, size) as BidPrice1, rand(100.0, size) as BidPrice2, rand(100.0, size) as BidPrice3, rand(100.0, size) as BidPrice4, rand(100.0, size) as BidPrice5, rand(100000, size) as BidOrderQty1, rand(100000, size) as BidOrderQty2, rand(100000, size) as BidOrderQty3, rand(100000, size) as BidOrderQty4, rand(100000, size) as BidOrderQty5, rand(100.0, size) as OfferPrice1, rand(100.0, size) as OfferPrice2, rand(100.0, size) as OfferPrice3, rand(100.0, size) as OfferPrice4, rand(100.0, size) as OfferPrice5, rand(100000, size) as OfferQty1, rand(100000, size) as OfferQty2, rand(100000, size) as OfferQty3, rand(100000, size) as OfferQty4, rand(100000, size) as OfferQty5) } def mockData(DateVector, StartTimeVector) { for(Date in DateVector) { for(StartTime in StartTimeVector) { data = mockHalfDayData(Date, StartTime) // OLAP 存储引擎分布式表插入模拟数据 loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;).append!(data) // TSDB 存储引擎分布式表插入模拟数据 loadTable(&#34;dfs://Level1_TSDB&#34;, &#34;Snapshot&#34;).append!(data) } } } mockData(2020.06.01..2020.06.02, 09:30:00 13:00:00)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-条件过滤相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2. 条件过滤相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;where 条件子句包含一个或多个条件表达式，根据表达式指定的过滤条件，可以过滤出满足需求的记录。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;条件表达式中可以使用 DolphinDB 内置函数，如聚合、序列、向量函数，也可以使用用户自定义函数。需要注意的是，DolphinDB 不支持在分布式查询的 where 子句中使用聚合函数，如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;68:98&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sum&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;68:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;count&lt;/codeph&gt;。因为执行聚合函数之前，分布式查询需要通过 where 子句来筛选相关分区的数据，达到分区剪枝的效果，减少查询耗时。如果聚合函数出现在 where 子句中，则分布式查询不能缩窄相关分区范围。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-where-条件子句使用-in-关键字&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.1. where 条件子句使用 in 关键字&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：数据表 t1 含有股票的某些信息，数据表 t2 含有股票的行业信息，需要根据股票的行业信息进行过滤。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库中的表 “Snapshot” 赋给变量 t1，并模拟构建行业信息数据表 t2，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;t1 = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;) SecurityIDs = exec distinct SecurityID from t1 where date(DateTime) = 2020.06.01 t2 = table(SecurityIDs as SecurityID, take(`Mul`IoT`Eco`Csm`Edu`Food, SecurityIDs.size()) as Industry)&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;211-优化前&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.1.1. 优化前&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;将数据表 t1 与数据表 t2 根据 SecurityID 字段进行 left join，然后指定 where 条件进行过滤，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer res1 = select SecurityID, DateTime from lj(t1, t2, `SecurityID) where date(DateTime) = 2020.06.01, Industry=`Edu&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 336 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;需要注意的是，以上脚本中的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;97:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer&lt;/codeph&gt; 函数通常用于计算一行或一段脚本的执行时间，该时间指的是脚本在 DolphinDB Server 端的运行耗时，而不包括脚本运行结果集返回到客户端的耗时。若结果集数据量过大，序列化/反序列化以及网络传输的耗时可能会远远超过脚本在服务器上的运行耗时。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;212-优化后&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.1.2. 优化后&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;103:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;从数据表 t2 获取行业为 “Edu” 的股票代码向量，并使用 in 关键字指定条件范围，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;SecurityIDs = exec SecurityID from t2 where Industry=&#34;Edu&#34; timer res2 = select SecurityID, DateTime from t1 where date(DateTime) = 2020.06.01, SecurityID in SecurityIDs&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 72 ms。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, res1.values(), res2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each&lt;/codeph&gt; 函数对表的每列分别通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;118:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;eqObj&lt;/codeph&gt; 比较，返回均为 true，说明优化前后返回的结果相同。但与优化前写法相比，优化后写法查询性能提升约4倍。这是因为，在 SQL 语句中，表连接的耗时远高于 where 子句中的过滤条件的耗时，因此在能够使用字典或 in 关键字的情况下应避免使用 join。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-分组数据过滤&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.2. 分组数据过滤&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;122:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：截取单日全市场股票交易快照数据，筛选出每只股票交易量最大的前 25% 的记录。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;124:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库表并将该表对象赋值给变量 snapshot，之后可以直接引用变量 snapshot，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;126:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;snapshot = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;130:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 context by 对于股票分组，并根据 Volume 字段计算 75% 分位点的线性插值作为最小值，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer res1 = select * from snapshot where date(DateTime) = 2020.06.01 context by SecurityID having Volume &amp;gt;= percentile(Volume, 75, &#34;linear&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;138:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;context by 是 DolphinDB SQL 引入的一个关键词，用于分组计算。与 group by 用于聚合不同，context by 只是对数据分组而不做聚合操作，因此不改变数据的记录数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;having 子句总是跟在 group by 或者 context by 后，用来将结果进行过滤，只返回满足指定条件的聚合函数值的组结果。having 与 group by 搭配使用时，表示是否输出某个组的结果。having 与 context by 搭配使用时，既可以表示是否输出这个组的结果，也可以表示输出组中的哪些行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：承接以上场景，选出每只股票交易量最大的 25% 的记录后，计算 LastPx 的标准差。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;221-优化前&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.2.1. 优化前&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 context by 对股票分组，并根据 Volume 字段计算 75% 位置处的线性插值作为过滤条件的最小值，再根据 group by 对股票分组，并计算标准差，最后使用 order by 对于股票排序，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer select std(LastPx) as std from ( select SecurityID, LastPx from snapshot where date(DateTime) = 2020.06.01 context by SecurityID having Volume &amp;gt;= percentile(Volume, 75, &#34;linear&#34;)) group by SecurityID order by SecurityID&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;耗时 242 ms。&lt;/i&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;222-优化后&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.2.2. 优化后&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 group by 对股票分组，aggrTopN 高阶函数选择交易量最大的 25% 的记录，并计算标准差。示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer select aggrTopN(std, LastPx, Volume, 0.25, false) as std from snapshot where date(DateTime) = 2020.06.01 group by SecurityID order by SecurityID&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;177:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;177:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;耗时 124 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;179:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前先把数据分组并进行过滤，合并数据后再分组计算聚合值。优化后，在数据分组后，直接进行过滤和聚合，减少了中间步骤，从而提升了性能。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-where-条件子句使用逗号或-and&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.3. where 条件子句使用逗号或 and&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;where 子句中多条件如果使用 “,” 进行连接时，在查询时会按照顺序对 “,” 前的条件层层进行过滤；若使用 and 进行连接时，会对所有条件在原表内分别进行筛选后再将结果取交集。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;下面将通过几个示例，比较使用 and 和逗号再不同场景下进行条件过滤的异同。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 10000000 t = table(take(2019.01.01..2019.01.03, N) as date, take(`C`MS`MS`MS`IBM`IBM`IBM`C`C$SYMBOL, N) as sym, take(49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29, N) as price, take(2200 1900 2100 3200 6800 5400 1300 2500 8800, N) as qty)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;根据过滤条件是否使用序列相关函数，如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;197:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;deltas&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;197:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;ratios&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;197:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;ffill&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;197:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;move&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;197:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;prev&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;197:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;cumsum&lt;/codeph&gt; 等，可以分为以下两种情况。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;231-过滤条件与序列无关&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.3.1. 过滤条件与序列无关&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(10) t1 = select * from t where qty &amp;gt; 2000, date = 2019.01.02, sym = `C timer(10) t2 = select * from t where qty &amp;gt; 2000 and date = 2019.01.02 and sym = `C each(eqObj, t1.values(), t2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以上两个查询耗时分别为 902 ms、930 ms。&lt;/i&gt; 此时，使用逗号与 and 的查询性能相差不大。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;测试不同条件先后顺序对于查询性能与查询结果的影响，示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(10) t3 = select * from t where date = 2019.01.02, sym = `C, qty &amp;gt; 2000 timer(10) t4 = select * from t where date = 2019.01.02 and sym = `C and qty &amp;gt; 2000 each(eqObj, t1.values(), t3.values()) // true each(eqObj, t2.values(), t4.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以上两个查询耗时分别为 669 ms、651 ms。&lt;/i&gt; 此时，使用逗号与 and 的查询性能相差不大。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;说明过滤条件与序列无关时，条件先后顺序对于查询结果无影响。但性能方面 t3(t4) 较 t1(t2) 提升约30%，这是因为 date 字段比 qty 字段筛选性更强。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;232-过滤条件与序列有关&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;2.3.2. 过滤条件与序列有关&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(10) t1 = select * from t where ratios(qty) &amp;gt; 1, date = 2019.01.02, sym = `C timer(10) t2 = select * from t where ratios(qty) &amp;gt; 1 and date = 2019.01.02 and sym = `C each(eqObj, t1.values(), t2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以上两个查询耗时分别为 1503 ms、1465 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;此时，使用逗号与 and 的查询性能相差无几。序列条件作为第一个条件，使用逗号连接时，首先按照原表中数据的顺序进行计算，后面条件与序列无关，所以查询结果与 and 连接时保持一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;测试不同条件先后顺序对于查询性能与查询结果的影响，示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(10) t3 = select * from t where date = 2019.01.02, sym = `C, ratios(qty) &amp;gt; 1 timer(10) t4 = select * from t where date = 2019.01.02 and sym = `C and ratios(qty) &amp;gt; 1 each(eqObj, t2.values(), t4.values()) // true each(eqObj, t1.values(), t3.values()) // false&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以上两个查询耗时分别为 507 ms、1433 ms。&lt;/i&gt; 第一个 each 函数返回均为 true，即 t2 与 t4 查询结果相同；第二个 each 函数返回均为 false，即 t1 与 t3 查询结果不同。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;说明过滤条件与序列相关时，对于使用 and 连接的查询语句，条件先后顺序对于查询结果无影响，性能方面亦无差别；对于使用逗号的查询语句，序列条件在后，性能虽有提升，但查询结果不同。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;综合上述测试结果分析可知：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;过滤条件与序列无关时，使用逗号或 and 均可，这是因为系统内部对于 and 做了优化，即将 and 转换为逗号，逗号会按照条件先后顺序层层过滤，因此条件先后顺序不同，执行查询时会有所差别，建议尽可能将过滤能力较强的条件放在前面，以减少后面过滤条件需要查询的数据量；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;过滤条件与序列相关时，必须使用 and，会对所有过滤条件在原表内分别筛选，再将过滤结果取交集，因此条件先后顺序不影响查询结果与性能。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-分布式表相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3. 分布式表相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;分布式查询和普通查询的语法并无差异，理解分布式查询的工作原理有助于编写高效的 SQL 查询语句。系统首先根据 where 条件子句确定查询涉及的分区，然后分解查询语句为多个子查询，并把子查询发送到相关分区所在的位置(map)，最后在发起节点汇总所有分区的查询结果(merge)，并进行进一步的查询(reduce)。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-分区剪枝&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.1. 分区剪枝&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;268:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：查询每只股票在某个时间范围内的记录数目。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库下的表 “Snapshot” 并将该表对象赋值给变量 snapshot，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;272:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;snapshot = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;311-优化前&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;278:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;278:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.1.1. 优化前&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;278:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;280:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;where 条件子句根据日期过滤时，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;280:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;temporalFormat&lt;/codeph&gt; 函数对于日期进行格式转换，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;282:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t1 = select count(*) from snapshot where temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;gt;= &#34;2020.06.01&#34; and temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;lt;= &#34;2020.06.02&#34; group by SecurityID &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 4145 ms。&lt;/i&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;312-优化后&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.1.2. 优化后&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;294:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;date&lt;/codeph&gt; 函数将 DateTime 字段转换为 DATE 类型，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t2 = select count(*) from snapshot where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;301:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;301:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 92 ms。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;303:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, t1.values(), t2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，查询性能提升数十倍。DolphinDB 在解决海量数据的存取时，并不提供行级的索引，而是将分区作为数据库的物理索引。系统在执行分布式查询时，首先根据 where 条件确定需要的分区。大多数分布式查询只涉及分布式表的部分分区，系统无需全表扫描，从而节省大量时间。但若不能根据 where 条件确定分区，进行全表扫描，就会大大降低查询性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;309:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;可以看到以上优化前的脚本，分区字段套用了 temporalFormat 函数先对所有日期进行转换，因此系统无法做分区剪枝。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;311:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;下面例举了部分其它导致系统 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;311:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;无法做分区剪枝&lt;/b&gt; 的案例：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;313:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例1：对分区字段进行运算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;select count(*) from snapshot where date(DateTime) + 1 &amp;gt; 2020.06.01&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例2：使用链式比较。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;select count(*) from snapshot where 2020.06.01 &amp;lt; date(DateTime) &amp;lt; 2020.06.03&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例3：过滤条件未使用分区字段。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;select count(*) from snapshot where Volume &amp;lt; 500&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例4：与分区字段比较时使用其它列。AnnouncementDate 字段非 snapshot 表中字段，此处仅为举例说明。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;select count(*) from snapshot where date(DateTime) &amp;lt; AnnouncementDate - 3&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-group-by-并行查询&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.2. group by 并行查询&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;339:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;339:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：对在某个时间范围内所有股票，标记多空势力方向，并计算第一档行情买卖双方报价之差、总交易量等指标。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;341:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库中的表，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;343:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;snapshot = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;321-优化前&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;349:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;349:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.2.1. 优化前&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;349:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，筛选2020年06月01日14:30:00以后的数据，卖方价格高于买方价格的记录，标志位设置为1；否则，标志位设置为0，将结果赋给一个内存表。然后，使用 group by 子句根据 Symbol, DateTime, Flag三个字段分组，并统计分组内 OfrPx 的记录数以及 OfrSize 的和，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer { tmp_t = select *, iif(LastPx &amp;gt; OpenPx, 1, 0) as Flag from snapshot where date(DateTime) = 2020.06.01, second(DateTime) &amp;gt;= 09:30:00 t1 = select iif(max(OfferPrice1) - min(BidPrice1) == 0, 0, 1) as Price1Diff, count(OfferPrice1) as OfferPrice1Count, sum(Volume) as Volumes from tmp_t group by SecurityID, date(DateTime) as Date, Flag }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 6249 ms。&lt;/i&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;322-优化后&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.2.2. 优化后&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;不再引入中间内存表，直接从分布式表进行查询计算。示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t2 = select iif(max(OfferPrice1) - min(BidPrice1) == 0, 0, 1) as Price1Diff, count(OfferPrice1) as OfferPrice1Count, sum(Volume) as Volumes from snapshot where date(DateTime) = 2020.06.01, second(DateTime) &amp;gt;= 09:30:00 group by SecurityID, date(DateTime) as Date, iif(LastPx &amp;gt; OpenPx, 1, 0) as Flag&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;379:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;379:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 1112 ms。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, t1.values(), (select * from t2 order by SecurityID, Date, Flag).values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，优化后写法查询性能提升约 6 倍。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;性能的提升来自于两个方面：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;（1）优化前的写法先把分区数据合并到一个内存表，然后再用 group by 分组计算，比优化后的写法多了合并与拆分的两个步骤。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;（2）优化后的写法直接对分布式表进行分组计算，充分利用 CPU 多核并行计算。而优化前的写法合并成一个内存表后，只利用单核进行分组计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;393:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;393:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;作为一个通用规则，对于分布式表的查询和计算，尽可能不要生成中间结果，直接在原始的分布式表上做计算，性能最优。&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-分组查询使用-map-关键字&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.3. 分组查询使用 map 关键字&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;397:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:14;397:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：查询每只股票每分钟的记录数目。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;399:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;401:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;snapshot = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;331-优化前&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;405:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;405:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.3.1. 优化前&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;405:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;407:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer result = select count(*) from snapshot group by SecurityID, bar(DateTime, 60)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;411:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:15;411:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 996 ms。&lt;/i&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;332-优化后&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;415:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;415:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;3.3.2. 优化后&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;415:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;417:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 map 关键字。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;419:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer result = select count(*) from snapshot group by SecurityID, bar(DateTime, 60) map&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 864 ms。与优化前写法相比，查询性能提升约 10%~20%。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前分组查询或计算时分为两个步骤：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;每个分区内部计算；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;所有分区的结果进行进一步计算，以确保最终结果的正确。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;432:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;如果分区的粒度大于分组的粒度，那么第一步骤完全可以保证结果的正确。此场景中，一级分区为粒度为“天”，大于分组的粒度“分钟”，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;432:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;map&lt;/codeph&gt; 关键字，避免第二步骤的计算开销，从而提升查询性能。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-分组计算相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;434:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;434:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4. 分组计算相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;434:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-查询最新的-n-条记录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.1. 查询最新的 N 条记录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：获取每只股票最新的10条记录。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;仅对2020年06月01日的数据进行分组求 TOP 10。context by 子句对数据进行分组，返回结果中每一组的行数和组内元素数量相同，再结合 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;440:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;csort&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;440:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;top&lt;/codeph&gt; 关键字，可以获取每组数据的最新记录。以行数为960万行的数据为例：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;OLAP 存储引擎：&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t1 = select * from loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;) where date(DateTime) = 2020.06.01 context by SecurityID csort DateTime limit -10&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;448:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;448:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 4289 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;452:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:9;452:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;TSDB 存储引擎：&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:31;454:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t2 = select * from loadTable(&#34;dfs://Level1_TSDB&#34;, &#34;Snapshot&#34;) where date(DateTime) = 2020.06.01 context by SecurityID csort DateTime limit -10 &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:10;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 1122 ms。&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:32;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, t1.values(), t2.values()) //true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;TSDB 是 DolphinDB 2.0 版本推出的存储引擎，引入了排序列，相当于对分区内部建立了一个索引。因此对于时间相关、单点查询场景，性能较 OLAP 存储引擎会有进一步提升。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:11;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;此例中，TSDB 存储引擎的查询性能较 OLAP 存储引擎提升约 4 倍。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;470:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;context by 是 DolphinDB SQL 独有的创新，是对标准 SQL 语句的拓展。在关系型数据库管理系统中，一张表由行的集合组成，行之间没有顺序。可以使用如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;470:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;min&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;470:94&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;max&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;470:101&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;avg&lt;/codeph&gt; 等聚合函数来对行进行分组，但是不能对分组内的行使用序列相关的聚合函数，比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;470:145&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;first&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;470:154&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;last&lt;/codeph&gt; 等，或者使用顺序敏感的滑动窗口函数和累积计算函数，如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;470:188&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;cumsum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;470:198&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;cummax&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;470:208&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;ratios&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;470:218&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;deltas&lt;/codeph&gt;等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;DolphinDB 使用列式存储引擎，因此能更好地支持对时间序列的数据进行处理，而其特有的 context by 子句使组内处理时间序列数据更加方便。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-计算滑动-vwap&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.2. 计算滑动 VWAP&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;476:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:12;476:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：一个内存表包含3000只股票，每只股票10000条记录，使用循环与 context by 两种方法分别计算 mwavg (移动加权平均，Moving Weighted Average)，比较二者性能差异。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;478:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:33;480:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;syms = format(1..3000, &#34;SH000000&#34;) N = 10000 t = cj(table(syms as symbol), table(rand(100.0, N) as price, rand(10000, N) as volume))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:13;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;490:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用循环，每一次取出某只股票相应的10000条记录的价格、交易量字段，计算 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;490:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;mwavg&lt;/codeph&gt;，共执行3000次，然后合并每一次的计算结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:34;492:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;arr = array(ANY, syms.size()) timer { for(i in 0 : syms.size()) { price_vec = exec price from t where symbol = syms[i] volume_vec = exec volume from t where symbol = syms[i] arr[i] = mwavg(price_vec, volume_vec, 4) } res1 = reduce(join, arr) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;505:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:14;505:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 25 min。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:15;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;511:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 context by，根据股票分组，每个分组内部分别计算 mwavg。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:35;513:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer res2 = select mwavg(price, volume, 4) from t context by symbol&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:16;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 3176 ms。&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:36;522:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, res1, res2[`mwavg_price]) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:17;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;两种方法的性能相差约 400 多倍。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;528:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;原因是，context by 仅对全表数据扫描一次，并对所有股票分组，再对每组分别进行计算；而 for 循环每一次循环都要扫描全表以获取某只股票相应的10000记录，所以耗时较长。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;43-计算累积-vwap&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.3. 计算累积 VWAP&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:18;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：每分钟计算每只股票自开盘到现在的所有交易的 vwap (交易量加权平均价格，Volume Weighted Average Price)。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;534:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，载入测试数据库表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:37;536:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;snapshot = loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:101;540:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 group by 对股票分组，再对时间做分钟聚合并使用 cgroup by 分组，计算 vwap；然后使用 order by 子句对分组计算结果排序，最后对每只股票分别计算累计值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:38;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer result = select wavg(LastPx, Volume) as vwap from snapshot group by SecurityID cgroup by minute(DateTime) as Minute order by SecurityID, Minute&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:102;550:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:16;550:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 1499 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:103;554:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;cgroup by (cumulative group) 为 DolphinDB SQL 独有的功能，是对标准 SQL 语句的拓展，可以进行累计分组计算，第一次计算使用第一组记录，第二次计算使用前两组记录，第三次计算使用前三组记录，以此类推。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:104;556:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 cgroup by 时，必须同时使用 order by 对分组计算结果进行排序。cgroup by 的 SQL 语句仅支持以下聚合函数：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;556:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;556:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sum2&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;556:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sum3&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;556:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sum4&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;556:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;prod&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;556:111&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;max&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;556:118&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;min&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;556:125&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;first&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;556:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;last&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;556:142&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;count&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;556:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;size&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;556:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;avg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;556:166&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;std&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;556:173&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;var&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;556:180&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;skew&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;556:188&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;kurtosis&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;556:200&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;wsum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;556:208&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;wavg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;556:216&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;corr&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;556:224&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;covar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;556:233&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;contextCount&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;556:249&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;contextSum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;556:263&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;contextSum2&lt;/codeph&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;44-计算-n-股-vwap&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.4. 计算 N 股 VWAP&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:105;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:19;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：计算每只股票最近 1000 shares 相关的所有 trades 的 vwap。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:106;562:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;筛选1000 shares 时可能出现以下情形，如 shares 为100、300、600的3个 trades 之和恰好为1000，或者shares 为900、300两个 trades 之和超过1000。首先需要找到参与计算的 trades，使得 shares 之和恰好超过1000，且保证减掉时间点最新的一个 trade 后，shares 之和小于1000，然后计算一下它们的 vwap。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:107;564:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:39;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;n = 500000 t = table(rand(string(1..4000), n) as sym, rand(10.0, n) as price, rand(500, n) as vol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:108;573:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前:&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:109;575:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 group by 对于股票进行分组，针对每只股票分别调用自定义聚合函数 lastVolPx1，针对所有 trades 采用循环计算，并判断 shares 是否恰好超过 bound，最后计算 vwag。如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:40;577:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;defg lastVolPx1(price, vol, bound) { size = price.size() cumSum = 0 for(i in 0:size) { cumSum = cumSum + vol[size - 1 - i] if(cumSum &amp;gt;= bound) { price_tmp = price.subarray(size - 1 - i :) vol_tmp = vol.subarray(size - 1 - i :) return wavg(price_tmp, vol_tmp) } if(i == size - 1 &amp;amp;&amp;amp; cumSum &amp;lt; bound) { return wavg(price, vol) } } } timer lastVolPx_t1 = select lastVolPx1(price, vol, 1000) as lastVolPx from t group by sym&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:110;597:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:20;597:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 187 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:111;601:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后:&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:112;603:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 group by 对股票进行分组，针对每支股票分别调用自定义聚合函数 lastVolPx2，计算累积交易量向量，以及恰好满足 shares 大于 bound 的起始位置，最后计算 vwag。如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:41;605:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;defg lastVolPx2(price, vol, bound) { cumVol = vol.cumsum() if(cumVol.tail() &amp;lt;= bound) return wavg(price, vol) else { start = (cumVol &amp;lt;= cumVol.tail() - bound).sum() return wavg(price.subarray(start:), vol.subarray(start:)) } } timer lastVolPx_t2 = select lastVolPx2(price, vol, 1000) as lastVolPx from t group by sym&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:113;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:17;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 73 ms。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:42;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, lastVolPx_t1.values(), lastVolPx_t2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:114;627:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，lastVolPx2 使用了向量化编程方法，性能提升一倍多。因此，编写 DolphinDB SQL 时，应当尽可能地使用向量化函数，避免使用循环。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;45-分段统计股票价格变化率&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;629:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;629:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.5. 分段统计股票价格变化率&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;629:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:115;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:21;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：已知股票市场快照数据，根据其中某个字段，分段统计并计算每只股票价格变化率。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:116;633:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;仅对2020年06月01日的数据举例说明。首先，使用 group by 对股票以及 OfferPrice1 字段连续相同的数据分组，然后计算每只股票第一档价格的变化率，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:43;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t = select last(OfferPrice1) \ first(OfferPrice1) - 1 from loadTable(&#34;dfs://Level1&#34;, &#34;Snapshot&#34;) where date(DateTime) = 2020.06.01 group by SecurityID, segment(OfferPrice1, false) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:117;642:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:18;642:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 511 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:118;646:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;646:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;segment&lt;/codeph&gt; 函数用于向量分组，将连续相同的元素分为一组，返回与输入向量等长的向量。下一个案例中也使用了 segment 函数分组，以展示该函数在连续区间分组计算时的易用性。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;46-计算不同连续区间的最值&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;648:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;648:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.6. 计算不同连续区间的最值&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;648:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:119;650:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:22;650:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：期望根据某个字段的值，获取大于或等于目标值的连续区间窗口，并在每个窗口内取该字段最大值的第一条记录。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:120;652:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:44;654:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;t = table(2021.09.29 + 0..15 as date, 0 0 0.3 0.3 0 0.5 0.3 0.5 0 0 0.3 0 0.4 0.6 0.6 0 as value) targetVal = 0.3&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:121;662:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:122;664:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;自定义一个函数 generateGrp，如果当前值大于或等于目标值，记录下当前记录对应的分组 ID；如果下一条记录的值小于目标值，分组 ID 加 １，以保证不同的连续数据划分到不同的分组。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:45;666:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def generateGrp(targetVal, val) { arr = array(INT, val.size()) n = 1 for(i in 0 : val.size()) { if(val[i] &amp;gt;= targetVal) { arr[i] = n if(val[i + 1] &amp;lt; targetVal) n = n + 1 } } return arr }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:123;680:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 context by 根据分组 ID 分组，并结合 having 语句过滤最大值，limit 语句限制返回第一条记录。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:46;682:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(1000) { tmp = select date, value, generateGrp(targetVal, value) as grp from t res1 = select date, value from tmp where grp != 0 context by grp having value = max(value) limit 1 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:124;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:19;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 142 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:125;695:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:126;697:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;697:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;segment&lt;/codeph&gt; 函数结合 context by 语句对大于或等于目标值的连续数据分组，并使用 having 语句过滤。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:47;699:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer(1000) res2 = select * from t context by segment(value &amp;gt;= targetVal) having value &amp;gt;= targetVal and value = max(value) limit 1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:127;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:20;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 123 ms。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:48;709:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, res1.values(), res2.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:128;713:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:23;713:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，优化后写法查询性能提升约 10%。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:129;715:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;715:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;segment&lt;/codeph&gt; 函数一般用于序列相关的分组，与循环相比，性能略有提升，可以化繁为简，使代码更为优雅。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;47-不同聚合方式计算指标&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;717:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;717:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.7. 不同聚合方式计算指标&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;717:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:130;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:21;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：期望根据不同的标签对于某个字段采用不同的聚合方式。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:131;721:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例如，标签为 code1 时，每10分钟取 max；标签为 code2 时，每10分钟取 min；标签为 code3 时，每10分钟取 avg。最后获得一个行转列宽表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:132;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:49;725:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 1000000 t = table(&#34;code&#34; + string(take(1..3, N)) as tag, sort(take([2021.06.28T00:00:00, 2021.06.28T00:10:00, 2021.06.28T00:20:00], N)) as time, take([1.0, 2.0, 9.1, 2.0, 3.0, 9.1, 9.1, 2.0, 3.0], N) as value)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:133;732:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;构建一个字典，标签为键，函数名称为值。使用 group by 对时间、标签分组，并调用自定义聚合函数，实现对不同标签的 value 进行不同的运算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:50;734:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;codes = dict(`code1`code2`code3, [max, min, avg]) defg func(tag, value, codes) : codes[tag.first()](value) timer { t_tmp = select func(tag, value, codes) as value from t group by tag, interval(time, 10m, &#34;null&#34;) as time t_result = select value from t_tmp pivot by time, tag }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:134;746:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:22;746:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 76 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:135;750:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;上例中使用的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;750:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;interval&lt;/codeph&gt; 函数只能在 group by 子句中使用，不能单独使用，缺失值的填充方式可以为：&#34;prev&#34;, &#34;post&#34;, &#34;linear&#34;, &#34;null&#34;, 具体数值和 &#34;none&#34;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;48-计算股票收益波动率&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.8. 计算股票收益波动率&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:136;754:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:23;754:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：已知某只股票过去十年的日收益率，期望按月计算该股票的波动率。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:137;756:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:51;758:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 3653 t = table(2011.11.01..2021.10.31 as date, take(`AAPL, N) as code, rand([0.0573, -0.0231, 0.0765, 0.0174, -0.0025, 0.0267, 0.0304, -0.0143, -0.0256, 0.0412, 0.0810, -0.0159, 0.0058, -0.0107, -0.0090, 0.0209, -0.0053, 0.0317, -0.0117, 0.0123], N) as rate)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:138;765:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;765:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;interval&lt;/codeph&gt; 函数按日期分组，并计算标准差。其中，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:24;765:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;fill&lt;/i&gt; 类型为 &#34;prev&#34;，表示使用前一个值填充缺失值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:52;767:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer res = select std(rate) from t group by code, interval(date(date), 1, &#34;prev&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:139;771:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:25;771:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 4.029 ms。&lt;/i&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;49-计算股票组合的价值&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;773:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;773:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.9. 计算股票组合的价值&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;773:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:140;775:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:26;775:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：进行指数套利交易回测时，计算给定股票组合的价值。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:141;777:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;当数据量极大时，一般数据分析系统进行回测时，对系统内存及速度的要求极高。以下案例，展现了使用 DolphinDB SQL 语言可极为简洁地进行此类计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:142;779:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;为了简化起见，假定某个指数仅由两只股票组成：AAPL 与 FB。模拟数据如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:53;781:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;syms = take(`AAPL, 6) join take(`FB, 5) time = 2019.02.27T09:45:01.000000000 + [146, 278, 412, 445, 496, 789, 212, 556, 598, 712, 989] prices = 173.27 173.26 173.24 173.25 173.26 173.27 161.51 161.50 161.49 161.50 161.51 quotes = table(take(syms, 100000) as Symbol, take(time, 100000) as Time, take(prices, 100000) as Price) weights = dict(`AAPL`FB, 0.6 0.4) ETF = select Symbol, Time, Price*weights[Symbol] as weightedPrice from quotes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:143;794:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:144;796:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，需要将原始数据表的3列（时间，股票代码，价格）转换为同等长度但是宽度为指数成分股数量加1的数据表，然后向前补充空值（forward fill NULLs），进而计算每行的指数成分股对指数价格的贡献之和。示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:54;798:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer { colAAPL = array(DOUBLE, ETF.Time.size()) colFB = array(DOUBLE, ETF.Time.size()) for(i in 0:ETF.Time.size()) { if(ETF.Symbol[i] == `AAPL) { colAAPL[i] = ETF.weightedPrice[i] colFB[i] = NULL } if(ETF.Symbol[i] == `FB) { colAAPL[i] = NULL colFB[i] = ETF.weightedPrice[i] } } ETF_TMP1 = table(ETF.Time, ETF.Symbol, colAAPL, colFB) ETF_TMP2 = select last(colAAPL) as colAAPL, last(colFB) as colFB from ETF_TMP1 group by time, Symbol ETF_TMP3 = ETF_TMP2.ffill() t1 = select Time, rowSum(colAAPL, colFB) as rowSum from ETF_TMP3 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:145;822:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:27;822:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以上代码块耗时 713 ms。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:146;826:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:147;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 pivot by 子句根据时间、股票代码对于数据表重新排序，将时间作为行，股票代码作为列，然后使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;828:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;ffill&lt;/codeph&gt; 函数填充 NULL 元素，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;828:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;avg&lt;/codeph&gt; 函数计算均值，最后 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;828:94&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;rowSum&lt;/codeph&gt; 函数计算每个时间点的股票价值之和，仅需以下一行代码，即可实现上述所有步骤。示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:55;830:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer t2 = select rowSum(ffill(last(weightedPrice))) from ETF pivot by Time, Symbol&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:148;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:24;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 23 ms。&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:56;836:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, t1.values(), t2.values()) //true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:149;842:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:25;842:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，优化后写法查询性能提升约 30 倍。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:150;844:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;此例中，仅以两只股票举例说明，当股票数量更多时，使用循环遍历的方式更为繁琐，而且性能极低。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:151;846:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;pivot by 是 DolphinDB SQL 独有的功能，是对标准 SQL 语句的拓展，可以将表中两列或多列的内容按照两个维度重新排列，亦可配合数据转换函数使用。不仅编程简洁，而且无需产生中间过程数据表，有效避免了内存不足的问题，极大地提升了计算速度。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:152;850:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以下是与此场景类似的另外一个案例，属于物联网典型场景。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:153;852:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:26;852:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：假设一个物联网场景中存在三个测点进行实时数据采集，期望针对每个测点分别计算一分钟均值，再对同一分钟的三个测点均值求和。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:154;854:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:57;856:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 10000 t = table(take(`id1`id2`id3, N) as id, rand(2021.01.01T00:00:00.000 + 100000 * (1..10000), N) as time, rand(10.0, N) as value)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:155;863:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;863:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;bar&lt;/codeph&gt; 函数对时间做一分钟聚合，并使用 pivot by 子句根据分钟、测点对数据表重新排序，将分钟作为行，测点作为列，然后使用 ffill 函数填充 NULL 元素，使用 avg 函数计算均值，然后再使用 rowSum 函数计算每个时间点的测点值之和。最后使用 group by 子句结合 interval 函数对于缺失值进行填充。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:58;865:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timePeriod = 2021.01.01T00:00:00.000 : 2021.01.01T01:00:00.000 timer result = select sum(rowSum) as v from ( select rowSum(ffill(avg(value))) from t where id in `id1`id2`id3, time between timePeriod pivot by bar(time, 60000) as minute, id) group by interval(minute, 1m, &#34;prev&#34;) as minute&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:156;874:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:27;874:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 12 ms。&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;410-根据成交量切分时间窗口&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:33;876:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:33;876:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.10. 根据成交量切分时间窗口&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:33;876:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:157;878:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:28;878:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：已知股票市场分钟线数据，期望根据成交量对股票在时间上进行切分，最终得到时间窗口不等的若干条数据，包含累计成交量，以及每个窗口的起止时间。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:158;880:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;具体切分规则为：假如期望对某只股票成交量约150万股便进行一次时间切分。切分时，如果当前组加上下一条数据的成交量与150万更接近，则下一条数据加入当前组；否则，从下一条数据开始一个新的组。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:159;882:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:59;884:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 28 t = table(take(`600000.SH, N) as wind_code, take(2015.02.11, N) as date, take(13:03:00..13:30:00, N) as time, take([288656, 234804, 182714, 371986, 265882, 174778, 153657, 201388, 175937, 138388, 169086, 203013, 261230, 398971, 692212, 494300, 581400, 348160, 250354, 220064, 218116, 458865, 673619, 477386, 454563, 622870, 458177, 880992], N) as volume)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:160;892:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;根据切分规则，自定义一个累计函数 caclCumVol，如果当前组需要包含下一条数据的成交量，返回新的累计成交量；否则，返回下一条数据的成交量，即开始一个新的组。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:60;894:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def caclCumVol(target, cumVol, nextVol) { newVal = cumVol + nextVol if(newVal &amp;lt; target) return newVal else if(newVal - target &amp;gt; target - cumVol) return nextVol else return newVal }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:161;903:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;903:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;accumulate&lt;/codeph&gt;，迭代地应用 caclCumVol 函数到前一个累计成交量和下一个成交量上。如果累计成交量等于当前一条数据的成交量，则表示开始一个新的组，此时记录下当前这条数据的时间，作为一个窗口的起始时间，否则为空，通过 ffill 填充，使得同一组数据拥有相同的起始时间，最后根据起始时间分组并做聚合计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:61;905:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer result = select first(wind_code) as wind_code, first(date) as date, sum(volume) as sum_volume, last(time) as endTime from t group by iif(accumulate(caclCumVol{1500000}, volume) == volume, time, NULL).ffill() as startTime&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:162;911:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:29;911:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 0.9 ms。&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;411-股票因子归整&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:34;913:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:34;913:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.11. 股票因子归整&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:34;913:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:163;915:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:30;915:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：已知沪深两市某个10分钟因子，分别存储为一张分布式表，另有一张股票清单维度表存储股票代码相关信息。期望从沪市、深市分别取出部分股票代码相应因子，根据股票、日期对于因子做分组归整，并做行列转换。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:164;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，自定义一个函数 createDBAndTable，用于创建分布式库表，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:62;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def createDBAndTable(dbName, tableName) {     if(existsTable(dbName, tableName)) return loadTable(dbName, tableName)     dbDate = database(, VALUE, 2021.07.01..2021.07.31)     dbSecurityID = database(, HASH, [SYMBOL, 10])     db = database(dbName, COMPO, [dbDate, dbSecurityID])     model = table(1:0, `SecurityID`Date`Time`FactorID`FactorValue, [SYMBOL, DATE, TIME, SYMBOL, DOUBLE])     return createPartitionedTable(db, model, tableName, `Date`SecurityID) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:165;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;执行以下代码，创建两个分布式表、一个维度表，并写入模拟数据，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:63;932:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;dates = 2020.01.01..2021.10.31 time = join(09:30:00 + 1..12 * 60 * 10, 13:00:00 + 1..12 * 60 * 10) syms = format(1..2000, &#34;000000&#34;) + &#34;.SH&#34; tmp = cj(cj(table(dates), table(time)), table(syms)) t = table(tmp.syms as SecurityID, tmp.dates as Date, tmp.time as Time, take([&#34;Factor01&#34;], tmp.size()) as FactorID, rand(100.0, tmp.size()) as FactorValue) createDBAndTable(&#34;dfs://Factor10MinSH&#34;, &#34;Factor10MinSH&#34;).append!(t) syms = format(2001..4000, &#34;000000&#34;) + &#34;.SZ&#34; tmp = cj(cj(table(dates), table(time)), table(syms)) t = table(tmp.syms as SecurityID, tmp.dates as Date, tmp.time as Time, take([&#34;Factor01&#34;], tmp.size()) as FactorID, rand(100.0, tmp.size()) as FactorValue) createDBAndTable(&#34;dfs://Factor10MinSZ&#34;, &#34;Factor10MinSZ&#34;).append!(t) db = database(&#34;dfs://infodb&#34;, VALUE, 1 2 3) model = table(1:0, `SecurityID`Info, [SYMBOL, STRING]) if(!existsTable(&#34;dfs://infodb&#34;, &#34;MdSecurity&#34;)) createTable(db, model, &#34;MdSecurity&#34;) loadTable(&#34;dfs://infodb&#34;, &#34;MdSecurity&#34;).append!(     table(join(format(1..2000, &#34;000000&#34;) + &#34;.SH&#34;, format(2001..4000, &#34;000000&#34;) + &#34;.SZ&#34;) as SecurityID,           take(string(NULL), 4000) as Info)) setMaxMemSize(32)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:166;959:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:31;959:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:167;961:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，分别从沪市、深市取出因子 Factor01 在某个时间范围的数据，合并后，再从股票代码维度表中取出需要归整的股票，通过表连接方式对合并结果进行过滤，最后使用 pivot by 子句根据时间、股票代码两个维度重新排列。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:64;963:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer { nt1 = select concatDateTime(Date, Time) as TradeTime, SecurityID, FactorValue from loadTable(&#34;dfs://Factor10MinSH&#34;, &#34;Factor10MinSH&#34;) where Date between 2019.01.01 : 2020.10.31, FactorID = &#34;Factor01&#34; nt2 = select concatDateTime(Date, Time) as TradeTime, SecurityID, FactorValue from loadTable(&#34;dfs://Factor10MinSZ&#34;, &#34;Factor10MinSZ&#34;) where Date between 2019.01.01 : 2020.10.31, FactorID = &#34;Factor01&#34; unt = unionAll(nt1, nt2) sec = select SecurityID from loadTable(&#34;dfs://infodb&#34;, &#34;MdSecurity&#34;) where substr(SecurityID, 0, 3) in [&#34;001&#34;, &#34;003&#34;, &#34;005&#34;, &#34;007&#34;] res = select * from lj(sec, unt, `SecurityID) res1 = select FactorValue from res pivot by TradeTime, SecurityID }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:168;976:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:32;976:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 6922 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:169;980:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:33;980:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:170;982:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，从股票代码维度表中取出需要归整的股票列表，然后从沪深两市取出因子 Factor01。使用 in 关键字进行过滤，再使用 pivot by 根据时间、股票代码两个维度进行重新排列，最后合并结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:65;984:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer { sec = exec SecurityID from loadTable(&#34;dfs://infodb&#34;, &#34;MdSecurity&#34;) where substr(SecurityID, 0, 3) in [&#34;001&#34;, &#34;003&#34;, &#34;005&#34;, &#34;007&#34;] schema(loadTable(&#34;dfs://Factor10MinSH&#34;, &#34;Factor10MinSH&#34;)) nt1 = exec FactorValue from loadTable(&#34;dfs://Factor10MinSH&#34;, &#34;Factor10MinSH&#34;) where Date between 2019.01.01 : 2020.10.31, SecurityID in sec, FactorID = &#34;Factor01&#34; pivot by concatDateTime(Date, Time), SecurityID nt2 = exec FactorValue from loadTable(&#34;dfs://Factor10MinSZ&#34;, &#34;Factor10MinSZ&#34;) where Date between 2019.01.01 : 2020.10.31, SecurityID in sec, FactorID = &#34;Factor01&#34; pivot by concatDateTime(Date, Time), SecurityID res3 = merge(nt1.setIndexedMatrix!(), nt2.setIndexedMatrix!(), 'left') }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:171;995:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:34;995:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 4210 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:172;997:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:35;997:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前相比，优化后查询性能提升约 40%。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:173;999:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;综合对比上述写法，概括出几个 SQL 编写技巧：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:174;1001:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;（1）尽量避免不必要的表连接；&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:175;1003:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;（2）尽可能早地使用分区过滤；&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:176;1005:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;（3）推迟数据的合并。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;412-根据交易额统计单子类型&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:35;1007:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:35;1007:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;4.12. 根据交易额统计单子类型&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:35;1007:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:177;1009:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:36;1009:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：对不同日期、不同股票、买单卖单，分别统计某个时间范围内的特大单、大单、中单、小单的累计交易量、交易额。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:178;1011:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;具体规则为：交易额小于4万是小单，大于等于4万且小于20万是中单，大于等于20万且小于100万是大单，大于100万是特大单。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:179;1013:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:66;1015:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 1000000 t = table(take(2021.11.01..2021.11.15, N) as date, take([09:30:00, 09:35:00, 09:40:00, 09:45:00, 09:47:00, 09:49:00, 09:50:00, 09:55:00, 09:56:00, 10:00:00], N) as time, take(`AAPL`FB`MSFT$SYMBOL, N) as symbol, take([10000, 30000, 50000, 80000, 100000], N) as volume, rand(100.0, N) as price, take(`BUY`SELL$SYMBOL, N) as side)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:180;1027:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:37;1027:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:181;1029:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 group by 根据日期、股票、买卖方向分组，使用四个查询语句分别计算小单、中单、大单、特大单的累计交易量、交易额，再将结果合并。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:67;1031:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer { // 小单 resS = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 0 as type from t where time &amp;lt;= 10:00:00, volume * price &amp;lt; 40000 group by date, symbol, side // 中单 resM = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 1 as type from t where time &amp;lt;= 10:00:00, 40000 &amp;lt;= volume * price &amp;lt; 200000 group by date, symbol, side // 大单 resB = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 2 as type from t where time &amp;lt;= 10:00:00, 200000 &amp;lt;= volume * price &amp;lt; 1000000 group by date, symbol, side // 特大单 resX = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 3 as type from t where time &amp;lt;= 10:00:00, volume * price &amp;gt;= 1000000 group by date, symbol, side res1 = table(N:0, `date`symbol`side`volume_sum`amount_sum`type, [DATE, SYMBOL, SYMBOL, LONG, DOUBLE, INT]) res1.append!(resS).append!(resM).append!(resB).append!(resX) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:182;1059:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:38;1059:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 135 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:183;1063:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:39;1063:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;第一种优化写法：&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:184;1065:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;自定义一个函数 getType，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;1065:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;iif&lt;/codeph&gt; 函数嵌套方式得到当前成交单子类型，然后使用 group by 对日期、股票、买卖方向、单子类型分组，并计算累计交易量、交易额。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:68;1067:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def getType(amount) { return iif(amount &amp;lt; 40000, 0, iif(amount &amp;gt;= 40000 &amp;amp;&amp;amp; amount &amp;lt; 200000, 1, iif(amount &amp;gt;= 200000 &amp;amp;&amp;amp; amount &amp;lt; 1000000, 2, 3))) } timer res2 = select sum(volume) as volume_sum, sum(volume*price) as amount_sum from t where time &amp;lt;= 10:00:00 group by date, symbol, side, getType(volume * price) as type &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:185;1078:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:40;1078:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 114 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:186;1080:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:41;1080:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，优化后写法查询性能提升约 20%。&lt;/b&gt; 虽然性能略有提升，但大大简化了代码编写。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:187;1082:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;需要注意的是，此处有个优化技巧，group by 后面字段类型为 INT、LONG、SHORT、SYMBOL 时，系统内部进行了优化，查询性能会有一定提升，所以本例中 getType 函数返回类型为 INT。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:188;1084:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:42;1084:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;第二种优化写法&lt;/b&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:69;1086:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;range = [0.0, 40000.0, 200000.0, 1000000.0, 100000000.0] timer res3 = select sum(volume) as volume_sum, sum(volume*price) as amount_sum from t where time &amp;lt;= 10:00:00 group by date, symbol, side, asof(range, volume*price) as type&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:189;1095:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:43;1095:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 95 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:190;1097:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与第一种优化写法区别在于，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;1097:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;asof&lt;/codeph&gt; 函数而非自定义函数，判断交易额落在哪个区间，然后以此分组并计算累计交易量、交易额。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:70;1099:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;each(eqObj, (select date, symbol, side, type, volume_sum, amount_sum from res1 order by date, symbol, side, type).values(), res2.values()) // true each(eqObj, res2.values(), res3.values()) // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:191;1107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以下是 asof 函数在另外一个场景下的应用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:192;1109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:44;1109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：针对某个日期、某只股票，统计某一数值列落在不同的区间范围的记录数目。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:193;1111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:71;1113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 100000 t = table(take(2021.11.01, N) as date, take(`AAPL, N) as code, rand([-5, 5, 10, 15, 20, 25, 100], N) as value) range = [-9999, 0, 10, 30, 9999]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:194;1123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:45;1123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:195;1125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;自定义一个函数 generateGrp，遍历不同的区间范围，判断数值列是否包含在当前的区间范围内，区间范围遵循左闭右开原则，并返回一个布尔型向量。如果为 true，表示数值包含在当前的区间范围内，则以下划线连接区间范围的左右边界作为分组 ID；如果为 false，表示数值不包含在当前的区间范围内，则将其置为空字符串。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:196;1127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;然后使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;1127:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;reduce&lt;/codeph&gt; 将遍历结果合并，最后使用 group by 根据日期、股票、不同的区间范围分组，并聚合计算记录数目。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:72;1129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def generateGrp(range, val) { res = array(ANY, range.size()-1) for(i in 0 : (range.size()-1)) { cond = val &amp;gt;= range[i] &amp;amp;&amp;amp; val &amp;lt; range[i+1] res[i] = iif(cond, strReplace(range[i] + &#34;_&#34; + range[i+1], &#34;-&#34;, &#34;&#34;), string(NULL)) } return reduce(add, res) } timer res1 = select count(*) from t group by date, code, generateGrp(range, value) as grp&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:197;1142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:46;1142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 38 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:198;1146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:47;1146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:199;1148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;使用 asof 函数结合 group by 语句对于日期、股票、不同的区间范围分组，并聚合计算记录数目。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:73;1150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;timer res2 = select count(*) from t group by date, code, asof(range, value) as grp&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:200;1155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:48;1155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 14 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:201;1157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:49;1157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;与优化前写法相比，优化后写法查询性能提升约 2 倍多。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:202;1159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;asof 函数一般用于分段统计，与循环相比，不仅性能大大提升，而且代码更为简洁。下一个案例也是使用了 asof 函数用于统计。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-元编程相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:36;1161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:36;1161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;5. 元编程相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:36;1161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-动态生成-sql-语句案例-1&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:37;1163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:37;1163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;5.1. 动态生成 SQL 语句案例 1&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:37;1163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:203;1165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:50;1165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：已知股票市场分钟线数据，使用元编程方式，根据股票、日期分组，每隔 10 分钟做一次聚合计算。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:204;1167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:74;1169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 10000000 t = table(take(format(1..4000, &#34;000000&#34;) + &#34;.SH&#34;, N) as SecurityID, take(2021.10.01..2021.10.31, N) as TradeDate, take(join(09:30:00 + 1..120 * 60, 13:00:00 + 1..120 * 60), N) as TradeTime, rand(100.0, N) as Px) barMinutes = 10&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:205;1181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:51;1181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化前&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:206;1183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询语句拼接为一个字符串，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;1183:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;parseExpr&lt;/codeph&gt; 函数将字符串解析为元代码，再使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:64;1183:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;eval&lt;/codeph&gt; 函数执行生成的元代码。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:75;1185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;res = parseExpr(&#34;select &#34; + avg + &#34;(Px) as avgPx from t group by bar(TradeTime, &#34; + barMinutes + &#34;m) as minuteTradeTime, SecurityID, TradeDate&#34;).eval()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:207;1189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:52;1189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 219 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:208;1193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:53;1193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;优化后&lt;/b&gt;：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:209;1195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;DolphinDB 内置了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:65;1195:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sql&lt;/codeph&gt; 函数用于动态生成 SQL 语句，然后使用 eval 函数执行生成的 SQL 语句。其中，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:66;1195:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sqlCol&lt;/codeph&gt; 函数将列名转化为表达式，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:67;1195:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;makeCall&lt;/codeph&gt; 函数指定参数调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:68;1195:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;bar&lt;/codeph&gt; 函数并生成脚本，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:69;1195:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sqlColAlias&lt;/codeph&gt; 函数使用元代码和别名定义一个列。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:76;1197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;groupingCols = [sqlColAlias(makeCall(bar, sqlCol(&#34;TradeTime&#34;), duration(barMinutes.string() + &#34;m&#34;)), &#34;minuteTradeTime&#34;), sqlCol(&#34;SecurityID&#34;), sqlCol(&#34;TradeDate&#34;)] res = sql(select = sqlCol(&#34;Px&#34;, funcByName(&#34;avg&#34;), &#34;avgPx&#34;), from = t, groupBy = groupingCols, groupFlag = GROUPBY).eval()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:210;1203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:54;1203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;查询耗时 200 ms。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:211;1205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;类似地，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:70;1205:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sqlUpdate&lt;/codeph&gt; 函数用于动态生成 SQL update 语句的元代码，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:71;1205:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;sqlDelete&lt;/codeph&gt; 函数用于动态生成 SQL delete 语句的元代码。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-动态生成-sql-语句案例-2&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:38;1207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:38;1207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;5.2. 动态生成 SQL 语句案例 2&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:38;1207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:212;1209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:55;1209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;场景：每天需要执行一组查询，合并查询结果。&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:213;1211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;首先，产生模拟数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:77;1213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;N = 100000 t = table(take(50982208 51180116 41774759, N) as vn, rand(25 1180 50, N) as bc, take(814 333 666, N) as cc, take(11 12 3, N) as stt, take(2 116 14, N) as vt, take(2020.02.05..2020.02.05, N) as dsl, take(52354079..52354979, N) as mt)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:214;1224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;例如，每天需要执行一组查询，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:78;1226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;t1 = select * from t where vn=50982208, bc=25, cc=814, stt=11, vt=2, dsl=2020.02.05, mt &amp;lt; 52355979 order by mt desc limit 1 t2 = select * from t where vn=50982208, bc=25, cc=814, stt=12, vt=2, dsl=2020.02.05, mt &amp;lt; 52355979 order by mt desc limit 1 t3 = select * from t where vn=51180116, bc=25, cc=814, stt=12, vt=2, dsl=2020.02.05, mt &amp;lt; 52354979 order by mt desc limit 1 t4 = select * from t where vn=41774759, bc=1180, cc=333, stt=3, vt=116, dsl=2020.02.05, mt &amp;lt; 52355979 order by mt desc limit 1 reduce(unionAll, [t1, t2, t3, t4])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:215;1235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;以下案例通过元编程动态生成 SQL 语句实现。过滤条件包含的列和排序的列相同，可编写如下自定义函数 bundleQuery 实现相关操作：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:79;1237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;def bundleQuery(tbl, dt, dtColName, mt, mtColName, filterColValues, filterColNames){ cnt = filterColValues[0].size() filterColCnt = filterColValues.size() orderByCol = sqlCol(mtColName) selCol = sqlCol(&#34;*&#34;) filters = array(ANY, filterColCnt + 2) filters[filterColCnt] = expr(sqlCol(dtColName), ==, dt) filters[filterColCnt+1] = expr(sqlCol(mtColName), &amp;lt;, mt) queries = array(ANY, cnt) for(i in 0:cnt) { for(j in 0:filterColCnt){ filters[j] = expr(sqlCol(filterColNames[j]), ==, filterColValues[j][i]) } queries.append!(sql(select=selCol, from=tbl, where=filters, orderBy=orderByCol, ascOrder=false, limit=1)) } return loop(eval, queries).unionAll(false) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:216;1258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;bundleQuery 中各个参数的含义如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;1260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;1260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;tbl 是数据表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;1261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;dt 是过滤条件中日期的值。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;1262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;dtColName 是过滤条件中日期列的名称。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;1263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;mt 是过滤条件中 mt 的值。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;1264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;mtColName 是过滤条件中 mt 列的名称，以及排序列的名称。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;1265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;filterColValues 是其他过滤条件中的值，用元组表示，其中的每个向量表示一个过滤条件，每个向量中的元素表示该过滤条件的值。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;1266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;filterColNames 是其他过滤条件中的列名，用向量表示。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:217;1268:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;上面一组 SQL 语句，相当于执行以下代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:80;1270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;dt = 2020.02.05 dtColName = &#34;dsl&#34; mt = 52355979 mtColName = &#34;mt&#34; colNames = `vn`bc`cc`stt`vt colValues = [50982208 50982208 51180116 41774759, 25 25 25 1180, 814 814 814 333, 11 12 12 3, 2 2 2 116] bundleQuery(t, dt, dtColName, mt, mtColName, colValues, colNames)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:218;1281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;登录 admin 管理员用户后，执行以下脚本将 bundleQuery 函数定义为函数视图，以确保在集群的任何节点重启系统之后，都可直接调用该函数。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:81;1283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;addFunctionView(bundleQuery)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:219;1287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_sql_cases.md&#34;&gt;如果每次都手动编写全部 SQL 语句，工作量大，并且扩展性差，通过元编程动态生成 SQL 语句可以解决这个问题。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/ddb_sql_cases.md"/><meta name="wh-out-relpath" content="tutorials/ddb_sql_cases.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="sql-编写案例" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="sql-编写案例"><div class="title"><a href="../tutorials/ddb_sql_cases.html">SQL 编写案例</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem" class="active"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">SQL 编写案例</h1><div class="- topic/body body"><p class="- topic/p p">本教程重点介绍了一些常见场景下的 SQL 编写案例。介绍如何正确编写 SQL 语句来提升脚本运行性能，通过优化前后性能对比，来说明DolphinDB SQL脚本的编写技巧。包括以下内容：</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-测试环境说明"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 测试环境说明</h2><div class="- topic/body body"><p class="- topic/p p">处理器：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz</p><p class="- topic/p p">核数：64</p><p class="- topic/p p">内存：512 GB</p><p class="- topic/p p">操作系统：CentOS Linux release 7.9</p><p class="- topic/p p">License：免费版License，CPU 2核，内存 8GB</p><p class="- topic/p p">DolphinDB Server 版本：DolphinDB_Linux64_V2.00.4，单节点模式部署</p><p class="- topic/p p">DolphinDB GUI 版本：DolphinDB_GUI_V1.30.15</p><p class="- topic/p p">以下章节案例中所用到的2020年06月测试数据为上交所 Level-1 快照数据，基于真实数据结构模拟2000只股票快照数据，基于 OLAP 与 TSDB 存储引擎的建库建表、数据模拟、数据插入脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>model = table(1:0, `SecurityID`DateTime`PreClosePx`OpenPx`HighPx`LowPx`LastPx`Volume`Amount`BidPrice1`BidPrice2`BidPrice3`BidPrice4`BidPrice5`BidOrderQty1`BidOrderQty2`BidOrderQty3`BidOrderQty4`BidOrderQty5`OfferPrice1`OfferPrice2`OfferPrice3`OfferPrice4`OfferPrice5`OfferQty1`OfferQty2`OfferQty3`OfferQty4`OfferQty5, [SYMBOL, DATETIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG, LONG, LONG, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG, LONG, LONG])

// OLAP 存储引擎建库建表
dbDate = database("", VALUE, 2020.06.01..2020.06.07)
dbSecurityID = database("", HASH, [SYMBOL, 10])
db = database("dfs://Level1", COMPO, [dbDate, dbSecurityID])
createPartitionedTable(db, model, `Snapshot, `DateTime`SecurityID)

// TSDB 存储引擎建库建表
dbDate = database("", VALUE, 2020.06.01..2020.06.07)
dbSymbol = database("", HASH, [SYMBOL, 10])
db = database("dfs://Level1_TSDB", COMPO, [dbDate, dbSymbol], engine="TSDB")
createPartitionedTable(db, model, `Snapshot, `DateTime`SecurityID, sortColumns=`SecurityID`DateTime)

def mockHalfDayData(Date, StartTime) {
	t_SecurityID = table(format(600001..602000, "000000") + ".SH" as SecurityID)
	t_DateTime = table(concatDateTime(Date, StartTime + 1..2400 * 3) as DateTime)
	t = cj(t_SecurityID, t_DateTime)
	size = t.size()
	return  table(t.SecurityID as SecurityID, t.DateTime as DateTime, rand(100.0, size) as PreClosePx, rand(100.0, size) as OpenPx, rand(100.0, size) as HighPx, rand(100.0, size) as LowPx, rand(100.0, size) as LastPx, rand(10000, size) as Volume, rand(100000.0, size) as Amount, rand(100.0, size) as BidPrice1, rand(100.0, size) as BidPrice2, rand(100.0, size) as BidPrice3, rand(100.0, size) as BidPrice4, rand(100.0, size) as BidPrice5, rand(100000, size) as BidOrderQty1, rand(100000, size) as BidOrderQty2, rand(100000, size) as BidOrderQty3, rand(100000, size) as BidOrderQty4, rand(100000, size) as BidOrderQty5, rand(100.0, size) as OfferPrice1, rand(100.0, size) as OfferPrice2, rand(100.0, size) as OfferPrice3, rand(100.0, size) as OfferPrice4, rand(100.0, size) as OfferPrice5, rand(100000, size) as OfferQty1, rand(100000, size) as OfferQty2, rand(100000, size) as OfferQty3, rand(100000, size) as OfferQty4, rand(100000, size) as OfferQty5)
}

def mockData(DateVector, StartTimeVector) {
	for(Date in DateVector) {
		for(StartTime in StartTimeVector) {
			data = mockHalfDayData(Date, StartTime)

			// OLAP 存储引擎分布式表插入模拟数据
			loadTable("dfs://Level1", "Snapshot").append!(data)

			// TSDB 存储引擎分布式表插入模拟数据
			loadTable("dfs://Level1_TSDB", "Snapshot").append!(data)
		}
	}
}

mockData(2020.06.01..2020.06.02, 09:30:00 13:00:00)</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-条件过滤相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 条件过滤相关案例</h2><div class="- topic/body body"><p class="- topic/p p">where 条件子句包含一个或多个条件表达式，根据表达式指定的过滤条件，可以过滤出满足需求的记录。</p><p class="- topic/p p">条件表达式中可以使用 DolphinDB 内置函数，如聚合、序列、向量函数，也可以使用用户自定义函数。需要注意的是，DolphinDB 不支持在分布式查询的 where 子句中使用聚合函数，如 <code class="+ topic/ph pr-d/codeph ph codeph">sum</code>、<code class="+ topic/ph pr-d/codeph ph codeph">count</code>。因为执行聚合函数之前，分布式查询需要通过 where 子句来筛选相关分区的数据，达到分区剪枝的效果，减少查询耗时。如果聚合函数出现在 where 子句中，则分布式查询不能缩窄相关分区范围。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-where-条件子句使用-in-关键字"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1. where 条件子句使用 in 关键字</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：数据表 t1 含有股票的某些信息，数据表 t2 含有股票的行业信息，需要根据股票的行业信息进行过滤。</strong></p><p class="- topic/p p">首先，载入测试数据库中的表 “Snapshot” 赋给变量 t1，并模拟构建行业信息数据表 t2，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t1 = loadTable("dfs://Level1", "Snapshot")
SecurityIDs = exec distinct SecurityID from t1 where date(DateTime) = 2020.06.01
t2 = table(SecurityIDs as SecurityID, 
           take(`Mul`IoT`Eco`Csm`Edu`Food, SecurityIDs.size()) as Industry)</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title5" id="211-优化前"><h4 class="- topic/title title topictitle4" id="ariaid-title5">2.1.1. 优化前</h4><div class="- topic/body body"><p class="- topic/p p">将数据表 t1 与数据表 t2 根据 SecurityID 字段进行 left join，然后指定 where 条件进行过滤，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer res1 = select SecurityID, DateTime 
			 from lj(t1, t2, `SecurityID) 
			 where date(DateTime) = 2020.06.01, Industry=`Edu</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 336 ms。</em></p><p class="- topic/p p">需要注意的是，以上脚本中的 <code class="+ topic/ph pr-d/codeph ph codeph">timer</code> 函数通常用于计算一行或一段脚本的执行时间，该时间指的是脚本在 DolphinDB Server 端的运行耗时，而不包括脚本运行结果集返回到客户端的耗时。若结果集数据量过大，序列化/反序列化以及网络传输的耗时可能会远远超过脚本在服务器上的运行耗时。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title6" id="212-优化后"><h4 class="- topic/title title topictitle4" id="ariaid-title6">2.1.2. 优化后</h4><div class="- topic/body body"><p class="- topic/p p">从数据表 t2 获取行业为 “Edu” 的股票代码向量，并使用 in 关键字指定条件范围，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>SecurityIDs = exec SecurityID from t2 where Industry="Edu"
timer res2 = select SecurityID, DateTime 
			 from t1 
			 where date(DateTime) = 2020.06.01, SecurityID in SecurityIDs</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 72 ms。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, res1.values(), res2.values()) // true</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">each</code> 函数对表的每列分别通过 <code class="+ topic/ph pr-d/codeph ph codeph">eqObj</code> 比较，返回均为 true，说明优化前后返回的结果相同。但与优化前写法相比，优化后写法查询性能提升约4倍。这是因为，在 SQL 语句中，表连接的耗时远高于 where 子句中的过滤条件的耗时，因此在能够使用字典或 in 关键字的情况下应避免使用 join。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="22-分组数据过滤"><h3 class="- topic/title title topictitle3" id="ariaid-title7">2.2. 分组数据过滤</h3><div class="- topic/body body"><p class="- topic/p p">场景：截取单日全市场股票交易快照数据，筛选出每只股票交易量最大的前 25% 的记录。</p><p class="- topic/p p">首先，载入测试数据库表并将该表对象赋值给变量 snapshot，之后可以直接引用变量 snapshot，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>snapshot = loadTable("dfs://Level1", "Snapshot")</code></pre><p class="- topic/p p">使用 context by 对于股票分组，并根据 Volume 字段计算 75% 分位点的线性插值作为最小值，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer res1 = select * from snapshot 
			 where date(DateTime) = 2020.06.01 
			 context by SecurityID having Volume &gt;= percentile(Volume, 75, "linear")</code></pre><p class="- topic/p p">context by 是 DolphinDB SQL 引入的一个关键词，用于分组计算。与 group by 用于聚合不同，context by 只是对数据分组而不做聚合操作，因此不改变数据的记录数。</p><p class="- topic/p p">having 子句总是跟在 group by 或者 context by 后，用来将结果进行过滤，只返回满足指定条件的聚合函数值的组结果。having 与 group by 搭配使用时，表示是否输出某个组的结果。having 与 context by 搭配使用时，既可以表示是否输出这个组的结果，也可以表示输出组中的哪些行。</p><p class="- topic/p p">场景：承接以上场景，选出每只股票交易量最大的 25% 的记录后，计算 LastPx 的标准差。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="221-优化前"><h4 class="- topic/title title topictitle4" id="ariaid-title8">2.2.1. 优化前</h4><div class="- topic/body body"><p class="- topic/p p">使用 context by 对股票分组，并根据 Volume 字段计算 75% 位置处的线性插值作为过滤条件的最小值，再根据 group by 对股票分组，并计算标准差，最后使用 order by 对于股票排序，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer select std(LastPx) as std from (
      select SecurityID, LastPx from snapshot 
      where date(DateTime) = 2020.06.01 
      context by SecurityID 
      having Volume &gt;= percentile(Volume, 75, "linear")) 
      group by SecurityID 
      order by SecurityID</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">耗时 242 ms。</em></p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="222-优化后"><h4 class="- topic/title title topictitle4" id="ariaid-title9">2.2.2. 优化后</h4><div class="- topic/body body"><p class="- topic/p p">使用 group by 对股票分组，aggrTopN 高阶函数选择交易量最大的 25% 的记录，并计算标准差。示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer select aggrTopN(std, LastPx, Volume, 0.25, false) as std from snapshot 
	  where date(DateTime) = 2020.06.01 
	  group by SecurityID 
	  order by SecurityID</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">耗时 124 ms。</em></p><p class="- topic/p p">优化前先把数据分组并进行过滤，合并数据后再分组计算聚合值。优化后，在数据分组后，直接进行过滤和聚合，减少了中间步骤，从而提升了性能。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="23-where-条件子句使用逗号或-and"><h3 class="- topic/title title topictitle3" id="ariaid-title10">2.3. where 条件子句使用逗号或 and</h3><div class="- topic/body body"><p class="- topic/p p">where 子句中多条件如果使用 “,” 进行连接时，在查询时会按照顺序对 “,” 前的条件层层进行过滤；若使用 and 进行连接时，会对所有条件在原表内分别进行筛选后再将结果取交集。</p><p class="- topic/p p">下面将通过几个示例，比较使用 and 和逗号再不同场景下进行条件过滤的异同。</p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 10000000
t = table(take(2019.01.01..2019.01.03, N) as date, 			  
          take(`C`MS`MS`MS`IBM`IBM`IBM`C`C$SYMBOL, N) as sym, 
          take(49.6 29.46 29.52 30.02 174.97 175.23 50.76 50.32 51.29, N) as price, 
          take(2200 1900 2100 3200 6800 5400 1300 2500 8800, N) as qty)</code></pre><p class="- topic/p p">根据过滤条件是否使用序列相关函数，如 <code class="+ topic/ph pr-d/codeph ph codeph">deltas</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ratios</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ffill</code>, <code class="+ topic/ph pr-d/codeph ph codeph">move</code>, <code class="+ topic/ph pr-d/codeph ph codeph">prev</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code> 等，可以分为以下两种情况。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="231-过滤条件与序列无关"><h4 class="- topic/title title topictitle4" id="ariaid-title11">2.3.1. 过滤条件与序列无关</h4><div class="- topic/body body"><p class="- topic/p p">示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(10) t1 = select * from t where qty &gt; 2000, date = 2019.01.02, sym = `C
timer(10) t2 = select * from t where qty &gt; 2000 and date = 2019.01.02 and sym = `C

each(eqObj, t1.values(), t2.values()) // true</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">以上两个查询耗时分别为 902 ms、930 ms。</em> 此时，使用逗号与 and 的查询性能相差不大。</p><p class="- topic/p p">测试不同条件先后顺序对于查询性能与查询结果的影响，示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(10) t3 = select * from t where date = 2019.01.02, sym = `C, qty &gt; 2000
timer(10) t4 = select * from t where date = 2019.01.02 and sym = `C and qty &gt; 2000

each(eqObj, t1.values(), t3.values()) // true
each(eqObj, t2.values(), t4.values()) // true</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">以上两个查询耗时分别为 669 ms、651 ms。</em> 此时，使用逗号与 and 的查询性能相差不大。</p><p class="- topic/p p">说明过滤条件与序列无关时，条件先后顺序对于查询结果无影响。但性能方面 t3(t4) 较 t1(t2) 提升约30%，这是因为 date 字段比 qty 字段筛选性更强。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="232-过滤条件与序列有关"><h4 class="- topic/title title topictitle4" id="ariaid-title12">2.3.2. 过滤条件与序列有关</h4><div class="- topic/body body"><p class="- topic/p p">示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(10) t1 = select * from t where ratios(qty) &gt; 1, date = 2019.01.02, sym = `C
timer(10) t2 = select * from t where ratios(qty) &gt; 1 and date = 2019.01.02 and sym = `C

each(eqObj, t1.values(), t2.values()) // true</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">以上两个查询耗时分别为 1503 ms、1465 ms。</em></p><p class="- topic/p p">此时，使用逗号与 and 的查询性能相差无几。序列条件作为第一个条件，使用逗号连接时，首先按照原表中数据的顺序进行计算，后面条件与序列无关，所以查询结果与 and 连接时保持一致。</p><p class="- topic/p p">测试不同条件先后顺序对于查询性能与查询结果的影响，示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(10) t3 = select * from t where date = 2019.01.02, sym = `C, ratios(qty) &gt; 1
timer(10) t4 = select * from t where date = 2019.01.02 and sym = `C and ratios(qty) &gt; 1

each(eqObj, t2.values(), t4.values()) // true
each(eqObj, t1.values(), t3.values()) // false</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">以上两个查询耗时分别为 507 ms、1433 ms。</em> 第一个 each 函数返回均为 true，即 t2 与 t4 查询结果相同；第二个 each 函数返回均为 false，即 t1 与 t3 查询结果不同。</p><p class="- topic/p p">说明过滤条件与序列相关时，对于使用 and 连接的查询语句，条件先后顺序对于查询结果无影响，性能方面亦无差别；对于使用逗号的查询语句，序列条件在后，性能虽有提升，但查询结果不同。</p><p class="- topic/p p">综合上述测试结果分析可知：</p><ul class="- topic/ul ul"><li class="- topic/li li">过滤条件与序列无关时，使用逗号或 and 均可，这是因为系统内部对于 and 做了优化，即将 and 转换为逗号，逗号会按照条件先后顺序层层过滤，因此条件先后顺序不同，执行查询时会有所差别，建议尽可能将过滤能力较强的条件放在前面，以减少后面过滤条件需要查询的数据量；</li><li class="- topic/li li">过滤条件与序列相关时，必须使用 and，会对所有过滤条件在原表内分别筛选，再将过滤结果取交集，因此条件先后顺序不影响查询结果与性能。</li></ul></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="3-分布式表相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title13">3. 分布式表相关案例</h2><div class="- topic/body body"><p class="- topic/p p">分布式查询和普通查询的语法并无差异，理解分布式查询的工作原理有助于编写高效的 SQL 查询语句。系统首先根据 where 条件子句确定查询涉及的分区，然后分解查询语句为多个子查询，并把子查询发送到相关分区所在的位置(map)，最后在发起节点汇总所有分区的查询结果(merge)，并进行进一步的查询(reduce)。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="31-分区剪枝"><h3 class="- topic/title title topictitle3" id="ariaid-title14">3.1. 分区剪枝</h3><div class="- topic/body body"><p class="- topic/p p">场景：查询每只股票在某个时间范围内的记录数目。</p><p class="- topic/p p">首先，载入测试数据库下的表 “Snapshot” 并将该表对象赋值给变量 snapshot，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>snapshot = loadTable("dfs://Level1", "Snapshot")</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="311-优化前"><h4 class="- topic/title title topictitle4" id="ariaid-title15">3.1.1. 优化前</h4><div class="- topic/body body"><p class="- topic/p p">where 条件子句根据日期过滤时，使用 <code class="+ topic/ph pr-d/codeph ph codeph">temporalFormat</code> 函数对于日期进行格式转换，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t1 = select count(*) from snapshot 
		   where temporalFormat(DateTime, "yyyy.MM.dd") &gt;= "2020.06.01" and temporalFormat(DateTime, "yyyy.MM.dd") &lt;= "2020.06.02" 
		   group by SecurityID </code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 4145 ms。</em></p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="312-优化后"><h4 class="- topic/title title topictitle4" id="ariaid-title16">3.1.2. 优化后</h4><div class="- topic/body body"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">date</code> 函数将 DateTime 字段转换为 DATE 类型，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t2 = select count(*) from snapshot 
		   where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID </code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 92 ms。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, t1.values(), t2.values()) // true</code></pre><p class="- topic/p p">与优化前写法相比，查询性能提升数十倍。DolphinDB 在解决海量数据的存取时，并不提供行级的索引，而是将分区作为数据库的物理索引。系统在执行分布式查询时，首先根据 where 条件确定需要的分区。大多数分布式查询只涉及分布式表的部分分区，系统无需全表扫描，从而节省大量时间。但若不能根据 where 条件确定分区，进行全表扫描，就会大大降低查询性能。</p><p class="- topic/p p">可以看到以上优化前的脚本，分区字段套用了 temporalFormat 函数先对所有日期进行转换，因此系统无法做分区剪枝。</p><p class="- topic/p p">下面例举了部分其它导致系统 <strong class="+ topic/ph hi-d/b ph b">无法做分区剪枝</strong> 的案例：</p><p class="- topic/p p">例1：对分区字段进行运算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select count(*) from snapshot where date(DateTime) + 1 &gt; 2020.06.01</code></pre><p class="- topic/p p">例2：使用链式比较。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select count(*) from snapshot where 2020.06.01 &lt; date(DateTime) &lt; 2020.06.03</code></pre><p class="- topic/p p">例3：过滤条件未使用分区字段。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select count(*) from snapshot where Volume &lt; 500</code></pre><p class="- topic/p p">例4：与分区字段比较时使用其它列。AnnouncementDate 字段非 snapshot 表中字段，此处仅为举例说明。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select count(*) from snapshot where date(DateTime) &lt; AnnouncementDate - 3</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="32-group-by-并行查询"><h3 class="- topic/title title topictitle3" id="ariaid-title17">3.2. group by 并行查询</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：对在某个时间范围内所有股票，标记多空势力方向，并计算第一档行情买卖双方报价之差、总交易量等指标。</strong></p><p class="- topic/p p">首先，载入测试数据库中的表，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>snapshot = loadTable("dfs://Level1", "Snapshot")</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="321-优化前"><h4 class="- topic/title title topictitle4" id="ariaid-title18">3.2.1. 优化前</h4><div class="- topic/body body"><p class="- topic/p p">首先，筛选2020年06月01日14:30:00以后的数据，卖方价格高于买方价格的记录，标志位设置为1；否则，标志位设置为0，将结果赋给一个内存表。然后，使用 group by 子句根据 Symbol, DateTime, Flag三个字段分组，并统计分组内 OfrPx 的记录数以及 OfrSize 的和，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer {
	tmp_t = select *, iif(LastPx &gt; OpenPx, 1, 0) as Flag 
			from snapshot 
			where date(DateTime) = 2020.06.01, second(DateTime) &gt;= 09:30:00
	t1 = select iif(max(OfferPrice1) - min(BidPrice1) == 0, 0, 1) as Price1Diff, count(OfferPrice1) as OfferPrice1Count, sum(Volume) as Volumes 
			from tmp_t 
			group by SecurityID, date(DateTime) as Date, Flag
}</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 6249 ms。</em></p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title19" id="322-优化后"><h4 class="- topic/title title topictitle4" id="ariaid-title19">3.2.2. 优化后</h4><div class="- topic/body body"><p class="- topic/p p">不再引入中间内存表，直接从分布式表进行查询计算。示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t2 = select iif(max(OfferPrice1) - min(BidPrice1) == 0, 0, 1) as Price1Diff, count(OfferPrice1) as OfferPrice1Count, sum(Volume) as Volumes 
			from snapshot 
			where date(DateTime) = 2020.06.01, second(DateTime) &gt;= 09:30:00 
			group by SecurityID, date(DateTime) as Date, iif(LastPx &gt; OpenPx, 1, 0) as Flag</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 1112 ms。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, t1.values(), (select * from t2 order by SecurityID, Date, Flag).values()) // true</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">与优化前写法相比，优化后写法查询性能提升约 6 倍。</em></p><p class="- topic/p p">性能的提升来自于两个方面：</p><p class="- topic/p p">（1）优化前的写法先把分区数据合并到一个内存表，然后再用 group by 分组计算，比优化后的写法多了合并与拆分的两个步骤。</p><p class="- topic/p p">（2）优化后的写法直接对分布式表进行分组计算，充分利用 CPU 多核并行计算。而优化前的写法合并成一个内存表后，只利用单核进行分组计算。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">作为一个通用规则，对于分布式表的查询和计算，尽可能不要生成中间结果，直接在原始的分布式表上做计算，性能最优。</strong></p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title20" id="33-分组查询使用-map-关键字"><h3 class="- topic/title title topictitle3" id="ariaid-title20">3.3. 分组查询使用 map 关键字</h3><div class="- topic/body body"><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">场景：查询每只股票每分钟的记录数目。</em></p><p class="- topic/p p">首先，载入测试数据库表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>snapshot = loadTable("dfs://Level1", "Snapshot")</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title21" id="331-优化前"><h4 class="- topic/title title topictitle4" id="ariaid-title21">3.3.1. 优化前</h4><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer result = select count(*) from snapshot group by SecurityID, bar(DateTime, 60)</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 996 ms。</em></p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title22" id="332-优化后"><h4 class="- topic/title title topictitle4" id="ariaid-title22">3.3.2. 优化后</h4><div class="- topic/body body"><p class="- topic/p p">使用 map 关键字。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer result = select count(*) from snapshot group by SecurityID, bar(DateTime, 60) map</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 864 ms。与优化前写法相比，查询性能提升约 10%~20%。</strong></p><p class="- topic/p p">优化前分组查询或计算时分为两个步骤：</p><ul class="- topic/ul ul"><li class="- topic/li li">每个分区内部计算；</li><li class="- topic/li li">所有分区的结果进行进一步计算，以确保最终结果的正确。</li></ul><p class="- topic/p p">如果分区的粒度大于分组的粒度，那么第一步骤完全可以保证结果的正确。此场景中，一级分区为粒度为“天”，大于分组的粒度“分钟”，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">map</code> 关键字，避免第二步骤的计算开销，从而提升查询性能。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title23" id="4-分组计算相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title23">4. 分组计算相关案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="41-查询最新的-n-条记录"><h3 class="- topic/title title topictitle3" id="ariaid-title24">4.1. 查询最新的 N 条记录</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：获取每只股票最新的10条记录。</strong></p><p class="- topic/p p">仅对2020年06月01日的数据进行分组求 TOP 10。context by 子句对数据进行分组，返回结果中每一组的行数和组内元素数量相同，再结合 <code class="+ topic/ph pr-d/codeph ph codeph">csort</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">top</code> 关键字，可以获取每组数据的最新记录。以行数为960万行的数据为例：</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">OLAP 存储引擎：</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t1 = select * from loadTable("dfs://Level1", "Snapshot") where date(DateTime) = 2020.06.01 context by SecurityID csort DateTime limit -10</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 4289 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">TSDB 存储引擎：</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t2 = select * from loadTable("dfs://Level1_TSDB", "Snapshot") where date(DateTime) = 2020.06.01 context by SecurityID csort DateTime limit -10 </code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 1122 ms。</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, t1.values(), t2.values()) //true</code></pre><p class="- topic/p p">TSDB 是 DolphinDB 2.0 版本推出的存储引擎，引入了排序列，相当于对分区内部建立了一个索引。因此对于时间相关、单点查询场景，性能较 OLAP 存储引擎会有进一步提升。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">此例中，TSDB 存储引擎的查询性能较 OLAP 存储引擎提升约 4 倍。</strong></p><p class="- topic/p p">context by 是 DolphinDB SQL 独有的创新，是对标准 SQL 语句的拓展。在关系型数据库管理系统中，一张表由行的集合组成，行之间没有顺序。可以使用如 <code class="+ topic/ph pr-d/codeph ph codeph">min</code>, <code class="+ topic/ph pr-d/codeph ph codeph">max</code>, <code class="+ topic/ph pr-d/codeph ph codeph">avg</code> 等聚合函数来对行进行分组，但是不能对分组内的行使用序列相关的聚合函数，比如 <code class="+ topic/ph pr-d/codeph ph codeph">first</code>, <code class="+ topic/ph pr-d/codeph ph codeph">last</code> 等，或者使用顺序敏感的滑动窗口函数和累积计算函数，如 <code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cummax</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ratios</code>, <code class="+ topic/ph pr-d/codeph ph codeph">deltas</code>等。</p><p class="- topic/p p">DolphinDB 使用列式存储引擎，因此能更好地支持对时间序列的数据进行处理，而其特有的 context by 子句使组内处理时间序列数据更加方便。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title25" id="42-计算滑动-vwap"><h3 class="- topic/title title topictitle3" id="ariaid-title25">4.2. 计算滑动 VWAP</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：一个内存表包含3000只股票，每只股票10000条记录，使用循环与 context by 两种方法分别计算 mwavg (移动加权平均，Moving Weighted Average)，比较二者性能差异。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>syms = format(1..3000, "SH000000")
N = 10000
t = cj(table(syms as symbol), table(rand(100.0, N) as price, rand(10000, N) as volume))</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化前</strong>：</p><p class="- topic/p p">使用循环，每一次取出某只股票相应的10000条记录的价格、交易量字段，计算 <code class="+ topic/ph pr-d/codeph ph codeph">mwavg</code>，共执行3000次，然后合并每一次的计算结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>arr = array(ANY, syms.size())

timer {
	for(i in 0 : syms.size()) {
		price_vec = exec price from t where symbol = syms[i]
		volume_vec = exec volume from t where symbol = syms[i]
		arr[i] = mwavg(price_vec, volume_vec, 4)
	}
	res1 = reduce(join, arr)
}</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 25 min。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化后</strong>：</p><p class="- topic/p p">使用 context by，根据股票分组，每个分组内部分别计算 mwavg。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer res2 = select mwavg(price, volume, 4) from t 
			   context by symbol</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 3176 ms。</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, res1, res2[`mwavg_price]) // true</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">两种方法的性能相差约 400 多倍。</strong></p><p class="- topic/p p">原因是，context by 仅对全表数据扫描一次，并对所有股票分组，再对每组分别进行计算；而 for 循环每一次循环都要扫描全表以获取某只股票相应的10000记录，所以耗时较长。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title26" id="43-计算累积-vwap"><h3 class="- topic/title title topictitle3" id="ariaid-title26">4.3. 计算累积 VWAP</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：每分钟计算每只股票自开盘到现在的所有交易的 vwap (交易量加权平均价格，Volume Weighted Average Price)。</strong></p><p class="- topic/p p">首先，载入测试数据库表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>snapshot = loadTable("dfs://Level1", "Snapshot")</code></pre><p class="- topic/p p">使用 group by 对股票分组，再对时间做分钟聚合并使用 cgroup by 分组，计算 vwap；然后使用 order by 子句对分组计算结果排序，最后对每只股票分别计算累计值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer result = select wavg(LastPx, Volume) as vwap 
			   from snapshot 
			   group by SecurityID 
			   cgroup by minute(DateTime) as Minute 
			   order by SecurityID, Minute</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 1499 ms。</em></p><p class="- topic/p p">cgroup by (cumulative group) 为 DolphinDB SQL 独有的功能，是对标准 SQL 语句的拓展，可以进行累计分组计算，第一次计算使用第一组记录，第二次计算使用前两组记录，第三次计算使用前三组记录，以此类推。</p><p class="- topic/p p">使用 cgroup by 时，必须同时使用 order by 对分组计算结果进行排序。cgroup by 的 SQL 语句仅支持以下聚合函数：<code class="+ topic/ph pr-d/codeph ph codeph">sum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sum2</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sum3</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sum4</code>, <code class="+ topic/ph pr-d/codeph ph codeph">prod</code>, <code class="+ topic/ph pr-d/codeph ph codeph">max</code>, <code class="+ topic/ph pr-d/codeph ph codeph">min</code>, <code class="+ topic/ph pr-d/codeph ph codeph">first</code>, <code class="+ topic/ph pr-d/codeph ph codeph">last</code>, <code class="+ topic/ph pr-d/codeph ph codeph">count</code>, <code class="+ topic/ph pr-d/codeph ph codeph">size</code>, <code class="+ topic/ph pr-d/codeph ph codeph">avg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">std</code>, <code class="+ topic/ph pr-d/codeph ph codeph">var</code>, <code class="+ topic/ph pr-d/codeph ph codeph">skew</code>, <code class="+ topic/ph pr-d/codeph ph codeph">kurtosis</code>, <code class="+ topic/ph pr-d/codeph ph codeph">wsum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">wavg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">corr</code>, <code class="+ topic/ph pr-d/codeph ph codeph">covar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">contextCount</code>, <code class="+ topic/ph pr-d/codeph ph codeph">contextSum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">contextSum2</code>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title27" id="44-计算-n-股-vwap"><h3 class="- topic/title title topictitle3" id="ariaid-title27">4.4. 计算 N 股 VWAP</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：计算每只股票最近 1000 shares 相关的所有 trades 的 vwap。</strong></p><p class="- topic/p p">筛选1000 shares 时可能出现以下情形，如 shares 为100、300、600的3个 trades 之和恰好为1000，或者shares 为900、300两个 trades 之和超过1000。首先需要找到参与计算的 trades，使得 shares 之和恰好超过1000，且保证减掉时间点最新的一个 trade 后，shares 之和小于1000，然后计算一下它们的 vwap。</p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 500000
t = table(rand(string(1..4000), n) as sym, rand(10.0, n) as price, rand(500, n) as vol)</code></pre><p class="- topic/p p">优化前:</p><p class="- topic/p p">使用 group by 对于股票进行分组，针对每只股票分别调用自定义聚合函数 lastVolPx1，针对所有 trades 采用循环计算，并判断 shares 是否恰好超过 bound，最后计算 vwag。如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg lastVolPx1(price, vol, bound) {
	size = price.size()
	cumSum = 0
	for(i in 0:size) {
		cumSum = cumSum + vol[size - 1 - i]
		if(cumSum &gt;= bound) {
			price_tmp = price.subarray(size - 1 - i :)
			vol_tmp = vol.subarray(size - 1 - i :)
			return wavg(price_tmp, vol_tmp)
		}
		if(i == size - 1 &amp;&amp; cumSum &lt; bound) {
			return wavg(price, vol)
		}
	}
}

timer lastVolPx_t1 = select lastVolPx1(price, vol, 1000) as lastVolPx from t group by sym</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 187 ms。</strong></p><p class="- topic/p p">优化后:</p><p class="- topic/p p">使用 group by 对股票进行分组，针对每支股票分别调用自定义聚合函数 lastVolPx2，计算累积交易量向量，以及恰好满足 shares 大于 bound 的起始位置，最后计算 vwag。如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg lastVolPx2(price, vol, bound) {
	cumVol = vol.cumsum()
	if(cumVol.tail() &lt;= bound)
		return wavg(price, vol)
	else {
		start = (cumVol &lt;= cumVol.tail() - bound).sum()
		return wavg(price.subarray(start:), vol.subarray(start:))
	}
}

timer lastVolPx_t2 = select lastVolPx2(price, vol, 1000) as lastVolPx from t group by sym</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 73 ms。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, lastVolPx_t1.values(), lastVolPx_t2.values()) // true</code></pre><p class="- topic/p p">与优化前写法相比，lastVolPx2 使用了向量化编程方法，性能提升一倍多。因此，编写 DolphinDB SQL 时，应当尽可能地使用向量化函数，避免使用循环。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title28" id="45-分段统计股票价格变化率"><h3 class="- topic/title title topictitle3" id="ariaid-title28">4.5. 分段统计股票价格变化率</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：已知股票市场快照数据，根据其中某个字段，分段统计并计算每只股票价格变化率。</strong></p><p class="- topic/p p">仅对2020年06月01日的数据举例说明。首先，使用 group by 对股票以及 OfferPrice1 字段连续相同的数据分组，然后计算每只股票第一档价格的变化率，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t = select last(OfferPrice1) \ first(OfferPrice1) - 1 
		  from loadTable("dfs://Level1", "Snapshot") 
		  where date(DateTime) = 2020.06.01 
		  group by SecurityID, segment(OfferPrice1, false) </code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 511 ms。</em></p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">segment</code> 函数用于向量分组，将连续相同的元素分为一组，返回与输入向量等长的向量。下一个案例中也使用了 segment 函数分组，以展示该函数在连续区间分组计算时的易用性。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="46-计算不同连续区间的最值"><h3 class="- topic/title title topictitle3" id="ariaid-title29">4.6. 计算不同连续区间的最值</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：期望根据某个字段的值，获取大于或等于目标值的连续区间窗口，并在每个窗口内取该字段最大值的第一条记录。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(2021.09.29 + 0..15 as date, 
          0 0 0.3 0.3 0 0.5 0.3 0.5 0 0 0.3 0 0.4 0.6 0.6 0 as value)
targetVal = 0.3</code></pre><p class="- topic/p p">优化前：</p><p class="- topic/p p">自定义一个函数 generateGrp，如果当前值大于或等于目标值，记录下当前记录对应的分组 ID；如果下一条记录的值小于目标值，分组 ID 加 １，以保证不同的连续数据划分到不同的分组。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def generateGrp(targetVal, val) {
	arr = array(INT, val.size())
	n = 1
	for(i in 0 : val.size()) {
		if(val[i] &gt;= targetVal) {
			arr[i] = n
			if(val[i + 1] &lt; targetVal) n = n + 1
		}
	}
	return arr
}</code></pre><p class="- topic/p p">使用 context by 根据分组 ID 分组，并结合 having 语句过滤最大值，limit 语句限制返回第一条记录。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(1000) {
	tmp = select date, value, generateGrp(targetVal, value) as grp from t
	res1 = select date, value from tmp where grp != 0 
		   context by grp 
		   having value = max(value) limit 1
}</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 142 ms。</em></p><p class="- topic/p p">优化后：</p><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">segment</code> 函数结合 context by 语句对大于或等于目标值的连续数据分组，并使用 having 语句过滤。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer(1000) res2 = select * from t 
				   context by segment(value &gt;= targetVal) 
				   having value &gt;= targetVal and value = max(value) limit 1</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 123 ms。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, res1.values(), res2.values()) // true</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">与优化前写法相比，优化后写法查询性能提升约 10%。</strong></p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">segment</code> 函数一般用于序列相关的分组，与循环相比，性能略有提升，可以化繁为简，使代码更为优雅。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title30" id="47-不同聚合方式计算指标"><h3 class="- topic/title title topictitle3" id="ariaid-title30">4.7. 不同聚合方式计算指标</h3><div class="- topic/body body"><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">场景：期望根据不同的标签对于某个字段采用不同的聚合方式。</em></p><p class="- topic/p p">例如，标签为 code1 时，每10分钟取 max；标签为 code2 时，每10分钟取 min；标签为 code3 时，每10分钟取 avg。最后获得一个行转列宽表。</p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 1000000
t = table("code" + string(take(1..3, N)) as tag, 
          sort(take([2021.06.28T00:00:00, 2021.06.28T00:10:00, 2021.06.28T00:20:00], N)) as time, 
          take([1.0, 2.0, 9.1, 2.0, 3.0, 9.1, 9.1, 2.0, 3.0], N) as value)</code></pre><p class="- topic/p p">构建一个字典，标签为键，函数名称为值。使用 group by 对时间、标签分组，并调用自定义聚合函数，实现对不同标签的 value 进行不同的运算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>codes = dict(`code1`code2`code3, [max, min, avg])

defg func(tag, value, codes) : codes[tag.first()](value)
 
timer {
	t_tmp = select func(tag, value, codes) as value from t 
			group by tag, interval(time, 10m, "null") as time
	t_result = select value from t_tmp pivot by time, tag
}</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 76 ms。</em></p><p class="- topic/p p">上例中使用的 <code class="+ topic/ph pr-d/codeph ph codeph">interval</code> 函数只能在 group by 子句中使用，不能单独使用，缺失值的填充方式可以为："prev", "post", "linear", "null", 具体数值和 "none"。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title31" id="48-计算股票收益波动率"><h3 class="- topic/title title topictitle3" id="ariaid-title31">4.8. 计算股票收益波动率</h3><div class="- topic/body body"><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">场景：已知某只股票过去十年的日收益率，期望按月计算该股票的波动率。</em></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 3653
t = table(2011.11.01..2021.10.31 as date, 
          take(`AAPL, N) as code, 
          rand([0.0573, -0.0231, 0.0765, 0.0174, -0.0025, 0.0267, 0.0304, -0.0143, -0.0256, 0.0412, 0.0810, -0.0159, 0.0058, -0.0107, -0.0090, 0.0209, -0.0053, 0.0317, -0.0117, 0.0123], N) as rate)</code></pre><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">interval</code> 函数按日期分组，并计算标准差。其中，<em class="+ topic/ph hi-d/i ph i">fill</em> 类型为 "prev"，表示使用前一个值填充缺失值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer res = select std(rate) from t group by code, interval(date(date), 1, "prev")</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">查询耗时 4.029 ms。</em></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title32" id="49-计算股票组合的价值"><h3 class="- topic/title title topictitle3" id="ariaid-title32">4.9. 计算股票组合的价值</h3><div class="- topic/body body"><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">场景：进行指数套利交易回测时，计算给定股票组合的价值。</em></p><p class="- topic/p p">当数据量极大时，一般数据分析系统进行回测时，对系统内存及速度的要求极高。以下案例，展现了使用 DolphinDB SQL 语言可极为简洁地进行此类计算。</p><p class="- topic/p p">为了简化起见，假定某个指数仅由两只股票组成：AAPL 与 FB。模拟数据如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>syms = take(`AAPL, 6) join take(`FB, 5)
time = 2019.02.27T09:45:01.000000000 + [146, 278, 412, 445, 496, 789, 212, 556, 598, 712, 989]
prices = 173.27 173.26 173.24 173.25 173.26 173.27 161.51 161.50 161.49 161.50 161.51
quotes = table(take(syms, 100000) as Symbol, 
               take(time, 100000) as Time, 
               take(prices, 100000) as Price)
weights = dict(`AAPL`FB, 0.6 0.4)
ETF = select Symbol, Time, Price*weights[Symbol] as weightedPrice from quotes</code></pre><p class="- topic/p p">优化前：</p><p class="- topic/p p">首先，需要将原始数据表的3列（时间，股票代码，价格）转换为同等长度但是宽度为指数成分股数量加1的数据表，然后向前补充空值（forward fill NULLs），进而计算每行的指数成分股对指数价格的贡献之和。示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer {
	colAAPL = array(DOUBLE, ETF.Time.size())
	colFB = array(DOUBLE, ETF.Time.size())
	
	for(i in 0:ETF.Time.size()) {
		if(ETF.Symbol[i] == `AAPL) {
			colAAPL[i] = ETF.weightedPrice[i]
			colFB[i] = NULL
		}
		if(ETF.Symbol[i] == `FB) {
			colAAPL[i] = NULL
			colFB[i] = ETF.weightedPrice[i]
		}
	}
	
	ETF_TMP1 = table(ETF.Time, ETF.Symbol, colAAPL, colFB)
	ETF_TMP2 = select last(colAAPL) as colAAPL, last(colFB) as colFB from ETF_TMP1 group by time, Symbol
	ETF_TMP3 = ETF_TMP2.ffill()
	
	t1 = select Time, rowSum(colAAPL, colFB) as rowSum from ETF_TMP3
}</code></pre><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">以上代码块耗时 713 ms。</em></p><p class="- topic/p p">优化后：</p><p class="- topic/p p">使用 pivot by 子句根据时间、股票代码对于数据表重新排序，将时间作为行，股票代码作为列，然后使用 <code class="+ topic/ph pr-d/codeph ph codeph">ffill</code> 函数填充 NULL 元素，使用 <code class="+ topic/ph pr-d/codeph ph codeph">avg</code> 函数计算均值，最后 <code class="+ topic/ph pr-d/codeph ph codeph">rowSum</code> 函数计算每个时间点的股票价值之和，仅需以下一行代码，即可实现上述所有步骤。示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer t2 = select rowSum(ffill(last(weightedPrice))) from ETF pivot by Time, Symbol</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 23 ms。</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, t1.values(), t2.values()) //true</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">与优化前写法相比，优化后写法查询性能提升约 30 倍。</strong></p><p class="- topic/p p">此例中，仅以两只股票举例说明，当股票数量更多时，使用循环遍历的方式更为繁琐，而且性能极低。</p><p class="- topic/p p">pivot by 是 DolphinDB SQL 独有的功能，是对标准 SQL 语句的拓展，可以将表中两列或多列的内容按照两个维度重新排列，亦可配合数据转换函数使用。不仅编程简洁，而且无需产生中间过程数据表，有效避免了内存不足的问题，极大地提升了计算速度。</p><p class="- topic/p p">以下是与此场景类似的另外一个案例，属于物联网典型场景。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：假设一个物联网场景中存在三个测点进行实时数据采集，期望针对每个测点分别计算一分钟均值，再对同一分钟的三个测点均值求和。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 10000
t = table(take(`id1`id2`id3, N) as id, 
          rand(2021.01.01T00:00:00.000 +  100000 * (1..10000), N) as time, 
          rand(10.0, N) as value)</code></pre><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">bar</code> 函数对时间做一分钟聚合，并使用 pivot by 子句根据分钟、测点对数据表重新排序，将分钟作为行，测点作为列，然后使用 ffill 函数填充 NULL 元素，使用 avg 函数计算均值，然后再使用 rowSum 函数计算每个时间点的测点值之和。最后使用 group by 子句结合 interval 函数对于缺失值进行填充。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timePeriod = 2021.01.01T00:00:00.000 : 2021.01.01T01:00:00.000
timer result = select sum(rowSum) as v from (
    		   select rowSum(ffill(avg(value))) from t 
    		   where id in `id1`id2`id3, time between timePeriod 
    		   pivot by bar(time, 60000) as minute, id) 
    		   group by interval(minute, 1m, "prev") as minute</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 12 ms。</strong></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title33" id="410-根据成交量切分时间窗口"><h3 class="- topic/title title topictitle3" id="ariaid-title33">4.10. 根据成交量切分时间窗口</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：已知股票市场分钟线数据，期望根据成交量对股票在时间上进行切分，最终得到时间窗口不等的若干条数据，包含累计成交量，以及每个窗口的起止时间。</strong></p><p class="- topic/p p">具体切分规则为：假如期望对某只股票成交量约150万股便进行一次时间切分。切分时，如果当前组加上下一条数据的成交量与150万更接近，则下一条数据加入当前组；否则，从下一条数据开始一个新的组。</p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 28
t = table(take(`600000.SH, N) as wind_code, 
          take(2015.02.11, N) as date, 
          take(13:03:00..13:30:00, N) as time, 
          take([288656, 234804, 182714, 371986, 265882, 174778, 153657, 201388, 175937, 138388, 169086, 203013, 261230, 398971, 692212, 494300, 581400, 348160, 250354, 220064, 218116, 458865, 673619, 477386, 454563, 622870, 458177, 880992], N) as volume)</code></pre><p class="- topic/p p">根据切分规则，自定义一个累计函数 caclCumVol，如果当前组需要包含下一条数据的成交量，返回新的累计成交量；否则，返回下一条数据的成交量，即开始一个新的组。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def caclCumVol(target, cumVol, nextVol) {
	newVal = cumVol + nextVol
	if(newVal &lt; target) return newVal
	else if(newVal - target &gt; target - cumVol) return nextVol
	else return newVal
}</code></pre><p class="- topic/p p">使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">accumulate</code>，迭代地应用 caclCumVol 函数到前一个累计成交量和下一个成交量上。如果累计成交量等于当前一条数据的成交量，则表示开始一个新的组，此时记录下当前这条数据的时间，作为一个窗口的起始时间，否则为空，通过 ffill 填充，使得同一组数据拥有相同的起始时间，最后根据起始时间分组并做聚合计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer result = select first(wind_code) as wind_code, first(date) as date, sum(volume) as sum_volume, last(time) as endTime 
			   from t 
			   group by iif(accumulate(caclCumVol{1500000}, volume) == volume, time, NULL).ffill() as startTime</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 0.9 ms。</strong></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title34" id="411-股票因子归整"><h3 class="- topic/title title topictitle3" id="ariaid-title34">4.11. 股票因子归整</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：已知沪深两市某个10分钟因子，分别存储为一张分布式表，另有一张股票清单维度表存储股票代码相关信息。期望从沪市、深市分别取出部分股票代码相应因子，根据股票、日期对于因子做分组归整，并做行列转换。</strong></p><p class="- topic/p p">首先，自定义一个函数 createDBAndTable，用于创建分布式库表，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createDBAndTable(dbName, tableName) {
    if(existsTable(dbName, tableName)) return loadTable(dbName, tableName)
    dbDate = database(, VALUE, 2021.07.01..2021.07.31)
    dbSecurityID = database(, HASH, [SYMBOL, 10])
    db = database(dbName, COMPO, [dbDate, dbSecurityID])
    model = table(1:0, `SecurityID`Date`Time`FactorID`FactorValue, [SYMBOL, DATE, TIME, SYMBOL, DOUBLE])
    return createPartitionedTable(db, model, tableName, `Date`SecurityID)
}</code></pre><p class="- topic/p p">执行以下代码，创建两个分布式表、一个维度表，并写入模拟数据，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dates = 2020.01.01..2021.10.31
time = join(09:30:00 + 1..12 * 60 * 10, 13:00:00 + 1..12 * 60 * 10)

syms = format(1..2000, "000000") + ".SH"
tmp = cj(cj(table(dates), table(time)), table(syms))
t = table(tmp.syms as SecurityID, tmp.dates as Date, tmp.time as Time, take(["Factor01"], tmp.size()) as FactorID, rand(100.0, tmp.size()) as FactorValue)

createDBAndTable("dfs://Factor10MinSH", "Factor10MinSH").append!(t)

syms = format(2001..4000, "000000") + ".SZ"
tmp = cj(cj(table(dates), table(time)), table(syms))
t = table(tmp.syms as SecurityID, tmp.dates as Date, tmp.time as Time, take(["Factor01"], tmp.size()) as FactorID, rand(100.0, tmp.size()) as FactorValue)
createDBAndTable("dfs://Factor10MinSZ", "Factor10MinSZ").append!(t)

db = database("dfs://infodb", VALUE, 1 2 3)
model = table(1:0, `SecurityID`Info, [SYMBOL, STRING])
if(!existsTable("dfs://infodb", "MdSecurity")) createTable(db, model, "MdSecurity")
loadTable("dfs://infodb", "MdSecurity").append!(
    table(join(format(1..2000, "000000") + ".SH", format(2001..4000, "000000") + ".SZ") as SecurityID, 
          take(string(NULL), 4000) as Info))

setMaxMemSize(32)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化前</strong>：</p><p class="- topic/p p">首先，分别从沪市、深市取出因子 Factor01 在某个时间范围的数据，合并后，再从股票代码维度表中取出需要归整的股票，通过表连接方式对合并结果进行过滤，最后使用 pivot by 子句根据时间、股票代码两个维度重新排列。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer {
    nt1 = select concatDateTime(Date, Time) as TradeTime, SecurityID, FactorValue from loadTable("dfs://Factor10MinSH", "Factor10MinSH") where Date between 2019.01.01 : 2020.10.31, FactorID = "Factor01"
    nt2 = select concatDateTime(Date, Time) as TradeTime, SecurityID, FactorValue from loadTable("dfs://Factor10MinSZ", "Factor10MinSZ") where Date between 2019.01.01 : 2020.10.31, FactorID = "Factor01"
    unt = unionAll(nt1, nt2)
    
    sec = select SecurityID from loadTable("dfs://infodb", "MdSecurity") where substr(SecurityID, 0, 3) in ["001", "003", "005", "007"]
    res = select * from lj(sec, unt, `SecurityID)

    res1 = select FactorValue from res pivot by TradeTime, SecurityID
}</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 6922 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化后</strong>：</p><p class="- topic/p p">首先，从股票代码维度表中取出需要归整的股票列表，然后从沪深两市取出因子 Factor01。使用 in 关键字进行过滤，再使用 pivot by 根据时间、股票代码两个维度进行重新排列，最后合并结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer {
    sec = exec SecurityID from loadTable("dfs://infodb", "MdSecurity") where substr(SecurityID, 0, 3) in ["001", "003", "005", "007"]
    schema(loadTable("dfs://Factor10MinSH", "Factor10MinSH"))
    nt1 = exec FactorValue from loadTable("dfs://Factor10MinSH", "Factor10MinSH") where Date between 2019.01.01 : 2020.10.31, SecurityID in sec, FactorID = "Factor01" pivot by concatDateTime(Date, Time), SecurityID
    nt2 = exec FactorValue from loadTable("dfs://Factor10MinSZ", "Factor10MinSZ") where Date between 2019.01.01 : 2020.10.31, SecurityID in sec, FactorID = "Factor01" pivot by concatDateTime(Date, Time), SecurityID

    res3 = merge(nt1.setIndexedMatrix!(), nt2.setIndexedMatrix!(), 'left')
}</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 4210 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">与优化前相比，优化后查询性能提升约 40%。</strong></p><p class="- topic/p p">综合对比上述写法，概括出几个 SQL 编写技巧：</p><p class="- topic/p p">（1）尽量避免不必要的表连接；</p><p class="- topic/p p">（2）尽可能早地使用分区过滤；</p><p class="- topic/p p">（3）推迟数据的合并。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title35" id="412-根据交易额统计单子类型"><h3 class="- topic/title title topictitle3" id="ariaid-title35">4.12. 根据交易额统计单子类型</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：对不同日期、不同股票、买单卖单，分别统计某个时间范围内的特大单、大单、中单、小单的累计交易量、交易额。</strong></p><p class="- topic/p p">具体规则为：交易额小于4万是小单，大于等于4万且小于20万是中单，大于等于20万且小于100万是大单，大于100万是特大单。</p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 1000000
t = table(take(2021.11.01..2021.11.15, N) as date, 
          take([09:30:00, 09:35:00, 09:40:00, 09:45:00, 09:47:00, 09:49:00, 09:50:00, 09:55:00, 09:56:00, 10:00:00], N) as time, 
          take(`AAPL`FB`MSFT$SYMBOL, N) as symbol, 
          take([10000, 30000, 50000, 80000, 100000], N) as volume, 
          rand(100.0, N) as price, 
          take(`BUY`SELL$SYMBOL, N) as side)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化前</strong>：</p><p class="- topic/p p">使用 group by 根据日期、股票、买卖方向分组，使用四个查询语句分别计算小单、中单、大单、特大单的累计交易量、交易额，再将结果合并。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer {
	// 小单
	resS = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 0 as type 
			from t 
			where time &lt;= 10:00:00, volume * price &lt; 40000 
			group by date, symbol, side
	// 中单
	resM = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 1 as type 
			from t 
			where time &lt;= 10:00:00, 40000 &lt;= volume * price &lt; 200000 
			group by date, symbol, side
	// 大单
	resB = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 2 as type 
			from t 
			where time &lt;= 10:00:00, 200000 &lt;= volume * price &lt; 1000000 
			group by date, symbol, side
	// 特大单
	resX = select sum(volume) as volume_sum, sum(volume * price) as amount_sum, 3 as type 
			from t 
			where time &lt;= 10:00:00, volume * price &gt;= 1000000 
			group by date, symbol, side
	
	res1 = table(N:0, `date`symbol`side`volume_sum`amount_sum`type, [DATE, SYMBOL, SYMBOL, LONG, DOUBLE, INT])
	res1.append!(resS).append!(resM).append!(resB).append!(resX)
}</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 135 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">第一种优化写法：</strong></p><p class="- topic/p p">自定义一个函数 getType，使用 <code class="+ topic/ph pr-d/codeph ph codeph">iif</code> 函数嵌套方式得到当前成交单子类型，然后使用 group by 对日期、股票、买卖方向、单子类型分组，并计算累计交易量、交易额。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def getType(amount) {
	return iif(amount &lt; 40000, 0, iif(amount &gt;= 40000 &amp;&amp; amount &lt; 200000, 1, iif(amount &gt;= 200000 &amp;&amp; amount &lt; 1000000, 2, 3)))
}

timer res2 = select sum(volume) as volume_sum, sum(volume*price) as amount_sum 
				from t 
				where time &lt;= 10:00:00
				group by date, symbol, side, getType(volume * price) as type </code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 114 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">与优化前写法相比，优化后写法查询性能提升约 20%。</strong> 虽然性能略有提升，但大大简化了代码编写。</p><p class="- topic/p p">需要注意的是，此处有个优化技巧，group by 后面字段类型为 INT、LONG、SHORT、SYMBOL 时，系统内部进行了优化，查询性能会有一定提升，所以本例中 getType 函数返回类型为 INT。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">第二种优化写法</strong>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>range = [0.0, 40000.0, 200000.0, 1000000.0, 100000000.0]

timer res3 = select sum(volume) as volume_sum, sum(volume*price) as amount_sum 
				from t 
				where time &lt;= 10:00:00 
				group by date, symbol, side, asof(range, volume*price) as type</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 95 ms。</strong></p><p class="- topic/p p">与第一种优化写法区别在于，使用 <code class="+ topic/ph pr-d/codeph ph codeph">asof</code> 函数而非自定义函数，判断交易额落在哪个区间，然后以此分组并计算累计交易量、交易额。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(eqObj, (select date, symbol, side, type, volume_sum, amount_sum 
             from res1 order by date, symbol, side, type).values(), res2.values()) // true
each(eqObj, res2.values(), res3.values()) // true</code></pre><p class="- topic/p p">以下是 asof 函数在另外一个场景下的应用。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：针对某个日期、某只股票，统计某一数值列落在不同的区间范围的记录数目。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 100000
t = table(take(2021.11.01, N) as date, 
          take(`AAPL, N) as code, 
          rand([-5, 5, 10, 15, 20, 25, 100], N) as value)
range = [-9999, 0, 10, 30, 9999]</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化前</strong>：</p><p class="- topic/p p">自定义一个函数 generateGrp，遍历不同的区间范围，判断数值列是否包含在当前的区间范围内，区间范围遵循左闭右开原则，并返回一个布尔型向量。如果为 true，表示数值包含在当前的区间范围内，则以下划线连接区间范围的左右边界作为分组 ID；如果为 false，表示数值不包含在当前的区间范围内，则将其置为空字符串。</p><p class="- topic/p p">然后使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">reduce</code> 将遍历结果合并，最后使用 group by 根据日期、股票、不同的区间范围分组，并聚合计算记录数目。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def generateGrp(range, val) {
	res = array(ANY, range.size()-1)
	for(i in 0 : (range.size()-1)) {
		cond = val &gt;= range[i] &amp;&amp; val &lt; range[i+1]
		res[i] = iif(cond, strReplace(range[i] + "_" + range[i+1], "-", ""), string(NULL))
	}
	return reduce(add, res)
}

timer res1 = select count(*) from t group by date, code, generateGrp(range, value) as grp</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 38 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化后</strong>：</p><p class="- topic/p p">使用 asof 函数结合 group by 语句对于日期、股票、不同的区间范围分组，并聚合计算记录数目。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer res2 = select count(*) from t 
			group by date, code, asof(range, value) as grp</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 14 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">与优化前写法相比，优化后写法查询性能提升约 2 倍多。</strong></p><p class="- topic/p p">asof 函数一般用于分段统计，与循环相比，不仅性能大大提升，而且代码更为简洁。下一个案例也是使用了 asof 函数用于统计。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title36" id="5-元编程相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title36">5. 元编程相关案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title37" id="51-动态生成-sql-语句案例-1"><h3 class="- topic/title title topictitle3" id="ariaid-title37">5.1. 动态生成 SQL 语句案例 1</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：已知股票市场分钟线数据，使用元编程方式，根据股票、日期分组，每隔 10 分钟做一次聚合计算。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 10000000
t = table(take(format(1..4000, "000000") + ".SH", N) as SecurityID, 
          take(2021.10.01..2021.10.31, N) as TradeDate, 
          take(join(09:30:00 + 1..120 * 60, 13:00:00 + 1..120 * 60), N) as TradeTime, 
          rand(100.0, N) as Px)

barMinutes = 10</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化前</strong>：</p><p class="- topic/p p">查询语句拼接为一个字符串，使用 <code class="+ topic/ph pr-d/codeph ph codeph">parseExpr</code> 函数将字符串解析为元代码，再使用 <code class="+ topic/ph pr-d/codeph ph codeph">eval</code> 函数执行生成的元代码。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>res = parseExpr("select " + avg + "(Px) as avgPx from t group by bar(TradeTime, " + barMinutes + "m) as minuteTradeTime, SecurityID, TradeDate").eval()</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 219 ms。</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">优化后</strong>：</p><p class="- topic/p p">DolphinDB 内置了 <code class="+ topic/ph pr-d/codeph ph codeph">sql</code> 函数用于动态生成 SQL 语句，然后使用 eval 函数执行生成的 SQL 语句。其中，<code class="+ topic/ph pr-d/codeph ph codeph">sqlCol</code> 函数将列名转化为表达式，<code class="+ topic/ph pr-d/codeph ph codeph">makeCall</code> 函数指定参数调用 <code class="+ topic/ph pr-d/codeph ph codeph">bar</code> 函数并生成脚本，<code class="+ topic/ph pr-d/codeph ph codeph">sqlColAlias</code> 函数使用元代码和别名定义一个列。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>groupingCols = [sqlColAlias(makeCall(bar, sqlCol("TradeTime"), duration(barMinutes.string() + "m")), "minuteTradeTime"), sqlCol("SecurityID"), sqlCol("TradeDate")]
res = sql(select = sqlCol("Px", funcByName("avg"), "avgPx"), 
          from = t, groupBy = groupingCols, groupFlag = GROUPBY).eval()</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">查询耗时 200 ms。</strong></p><p class="- topic/p p">类似地，<code class="+ topic/ph pr-d/codeph ph codeph">sqlUpdate</code> 函数用于动态生成 SQL update 语句的元代码，<code class="+ topic/ph pr-d/codeph ph codeph">sqlDelete</code> 函数用于动态生成 SQL delete 语句的元代码。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title38" id="52-动态生成-sql-语句案例-2"><h3 class="- topic/title title topictitle3" id="ariaid-title38">5.2. 动态生成 SQL 语句案例 2</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">场景：每天需要执行一组查询，合并查询结果。</strong></p><p class="- topic/p p">首先，产生模拟数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>N = 100000
t = table(take(50982208 51180116 41774759, N) as vn, 
          rand(25 1180 50, N) as bc, 
          take(814 333 666, N) as cc, 
          take(11 12 3, N) as stt, 
          take(2 116 14, N) as vt, 
          take(2020.02.05..2020.02.05, N) as dsl, 
          take(52354079..52354979, N) as mt)</code></pre><p class="- topic/p p">例如，每天需要执行一组查询，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t1 = select * from t where vn=50982208, bc=25, cc=814, stt=11, vt=2, dsl=2020.02.05, mt &lt; 52355979 order by mt desc limit 1
t2 = select * from t where vn=50982208, bc=25, cc=814, stt=12, vt=2, dsl=2020.02.05, mt &lt; 52355979 order by mt desc limit 1
t3 = select * from t where vn=51180116, bc=25, cc=814, stt=12, vt=2, dsl=2020.02.05, mt &lt; 52354979 order by mt desc limit 1
t4 = select * from t where vn=41774759, bc=1180, cc=333, stt=3, vt=116, dsl=2020.02.05, mt &lt; 52355979 order by mt desc limit 1

reduce(unionAll, [t1, t2, t3, t4])</code></pre><p class="- topic/p p">以下案例通过元编程动态生成 SQL 语句实现。过滤条件包含的列和排序的列相同，可编写如下自定义函数 bundleQuery 实现相关操作：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def bundleQuery(tbl, dt, dtColName, mt, mtColName, filterColValues, filterColNames){
	cnt = filterColValues[0].size()
	filterColCnt = filterColValues.size()
	orderByCol = sqlCol(mtColName)
	selCol = sqlCol("*")
	filters = array(ANY, filterColCnt + 2)
	filters[filterColCnt] = expr(sqlCol(dtColName), ==, dt)
	filters[filterColCnt+1] = expr(sqlCol(mtColName), &lt;, mt)
	
	queries = array(ANY, cnt)
	for(i in 0:cnt)	{
		for(j in 0:filterColCnt){
			filters[j] = expr(sqlCol(filterColNames[j]), ==, filterColValues[j][i])
		}
		queries.append!(sql(select=selCol, from=tbl, where=filters, orderBy=orderByCol, ascOrder=false, limit=1))
	}
	return loop(eval, queries).unionAll(false)
}</code></pre><p class="- topic/p p">bundleQuery 中各个参数的含义如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">tbl 是数据表。</li><li class="- topic/li li">dt 是过滤条件中日期的值。</li><li class="- topic/li li">dtColName 是过滤条件中日期列的名称。</li><li class="- topic/li li">mt 是过滤条件中 mt 的值。</li><li class="- topic/li li">mtColName 是过滤条件中 mt 列的名称，以及排序列的名称。</li><li class="- topic/li li">filterColValues 是其他过滤条件中的值，用元组表示，其中的每个向量表示一个过滤条件，每个向量中的元素表示该过滤条件的值。</li><li class="- topic/li li">filterColNames 是其他过滤条件中的列名，用向量表示。</li></ul><p class="- topic/p p">上面一组 SQL 语句，相当于执行以下代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dt = 2020.02.05
dtColName = "dsl"
mt = 52355979
mtColName = "mt"
colNames = `vn`bc`cc`stt`vt
colValues = [50982208 50982208 51180116 41774759, 25 25 25 1180, 814 814 814 333, 11 12 12 3, 2 2 2 116]

bundleQuery(t, dt, dtColName, mt, mtColName, colValues, colNames)</code></pre><p class="- topic/p p">登录 admin 管理员用户后，执行以下脚本将 bundleQuery 函数定义为函数视图，以确保在集群的任何节点重启系统之后，都可直接调用该函数。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>addFunctionView(bundleQuery)</code></pre><p class="- topic/p p">如果每次都手动编写全部 SQL 语句，工作量大，并且扩展性差，通过元编程动态生成 SQL 语句可以解决这个问题。</p></div></article></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E8%AF%B4%E6%98%8E" data-tocid="1-测试环境说明">1. 测试环境说明</a></li><li class="topic-item"><a href="#2-%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="2-条件过滤相关案例">2. 条件过滤相关案例</a><ul><li class="topic-item"><a href="#21-where-%E6%9D%A1%E4%BB%B6%E5%AD%90%E5%8F%A5%E4%BD%BF%E7%94%A8-in-%E5%85%B3%E9%94%AE%E5%AD%97" data-tocid="21-where-条件子句使用-in-关键字">2.1. where 条件子句使用 in 关键字</a><ul><li class="topic-item"><a href="#211-%E4%BC%98%E5%8C%96%E5%89%8D" data-tocid="211-优化前">2.1.1. 优化前</a></li><li class="topic-item"><a href="#212-%E4%BC%98%E5%8C%96%E5%90%8E" data-tocid="212-优化后">2.1.2. 优化后</a></li></ul></li><li class="topic-item"><a href="#22-%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%E8%BF%87%E6%BB%A4" data-tocid="22-分组数据过滤">2.2. 分组数据过滤</a><ul><li class="topic-item"><a href="#221-%E4%BC%98%E5%8C%96%E5%89%8D" data-tocid="221-优化前">2.2.1. 优化前</a></li><li class="topic-item"><a href="#222-%E4%BC%98%E5%8C%96%E5%90%8E" data-tocid="222-优化后">2.2.2. 优化后</a></li></ul></li><li class="topic-item"><a href="#23-where-%E6%9D%A1%E4%BB%B6%E5%AD%90%E5%8F%A5%E4%BD%BF%E7%94%A8%E9%80%97%E5%8F%B7%E6%88%96-and" data-tocid="23-where-条件子句使用逗号或-and">2.3. where 条件子句使用逗号或 and</a><ul><li class="topic-item"><a href="#231-%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BA%8F%E5%88%97%E6%97%A0%E5%85%B3" data-tocid="231-过滤条件与序列无关">2.3.1. 过滤条件与序列无关</a></li><li class="topic-item"><a href="#232-%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BA%8F%E5%88%97%E6%9C%89%E5%85%B3" data-tocid="232-过滤条件与序列有关">2.3.2. 过滤条件与序列有关</a></li></ul></li></ul></li><li class="topic-item"><a href="#3-%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="3-分布式表相关案例">3. 分布式表相关案例</a><ul><li class="topic-item"><a href="#31-%E5%88%86%E5%8C%BA%E5%89%AA%E6%9E%9D" data-tocid="31-分区剪枝">3.1. 分区剪枝</a><ul><li class="topic-item"><a href="#311-%E4%BC%98%E5%8C%96%E5%89%8D" data-tocid="311-优化前">3.1.1. 优化前</a></li><li class="topic-item"><a href="#312-%E4%BC%98%E5%8C%96%E5%90%8E" data-tocid="312-优化后">3.1.2. 优化后</a></li></ul></li><li class="topic-item"><a href="#32-group-by-%E5%B9%B6%E8%A1%8C%E6%9F%A5%E8%AF%A2" data-tocid="32-group-by-并行查询">3.2. group by 并行查询</a><ul><li class="topic-item"><a href="#321-%E4%BC%98%E5%8C%96%E5%89%8D" data-tocid="321-优化前">3.2.1. 优化前</a></li><li class="topic-item"><a href="#322-%E4%BC%98%E5%8C%96%E5%90%8E" data-tocid="322-优化后">3.2.2. 优化后</a></li></ul></li><li class="topic-item"><a href="#33-%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8-map-%E5%85%B3%E9%94%AE%E5%AD%97" data-tocid="33-分组查询使用-map-关键字">3.3. 分组查询使用 map 关键字</a><ul><li class="topic-item"><a href="#331-%E4%BC%98%E5%8C%96%E5%89%8D" data-tocid="331-优化前">3.3.1. 优化前</a></li><li class="topic-item"><a href="#332-%E4%BC%98%E5%8C%96%E5%90%8E" data-tocid="332-优化后">3.3.2. 优化后</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E5%88%86%E7%BB%84%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="4-分组计算相关案例">4. 分组计算相关案例</a><ul><li class="topic-item"><a href="#41-%E6%9F%A5%E8%AF%A2%E6%9C%80%E6%96%B0%E7%9A%84-n-%E6%9D%A1%E8%AE%B0%E5%BD%95" data-tocid="41-查询最新的-n-条记录">4.1. 查询最新的 N 条记录</a></li><li class="topic-item"><a href="#42-%E8%AE%A1%E7%AE%97%E6%BB%91%E5%8A%A8-vwap" data-tocid="42-计算滑动-vwap">4.2. 计算滑动 VWAP</a></li><li class="topic-item"><a href="#43-%E8%AE%A1%E7%AE%97%E7%B4%AF%E7%A7%AF-vwap" data-tocid="43-计算累积-vwap">4.3. 计算累积 VWAP</a></li><li class="topic-item"><a href="#44-%E8%AE%A1%E7%AE%97-n-%E8%82%A1-vwap" data-tocid="44-计算-n-股-vwap">4.4. 计算 N 股 VWAP</a></li><li class="topic-item"><a href="#45-%E5%88%86%E6%AE%B5%E7%BB%9F%E8%AE%A1%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E5%8F%98%E5%8C%96%E7%8E%87" data-tocid="45-分段统计股票价格变化率">4.5. 分段统计股票价格变化率</a></li><li class="topic-item"><a href="#46-%E8%AE%A1%E7%AE%97%E4%B8%8D%E5%90%8C%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E7%9A%84%E6%9C%80%E5%80%BC" data-tocid="46-计算不同连续区间的最值">4.6. 计算不同连续区间的最值</a></li><li class="topic-item"><a href="#47-%E4%B8%8D%E5%90%8C%E8%81%9A%E5%90%88%E6%96%B9%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%8C%87%E6%A0%87" data-tocid="47-不同聚合方式计算指标">4.7. 不同聚合方式计算指标</a></li><li class="topic-item"><a href="#48-%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E6%94%B6%E7%9B%8A%E6%B3%A2%E5%8A%A8%E7%8E%87" data-tocid="48-计算股票收益波动率">4.8. 计算股票收益波动率</a></li><li class="topic-item"><a href="#49-%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E7%BB%84%E5%90%88%E7%9A%84%E4%BB%B7%E5%80%BC" data-tocid="49-计算股票组合的价值">4.9. 计算股票组合的价值</a></li><li class="topic-item"><a href="#410-%E6%A0%B9%E6%8D%AE%E6%88%90%E4%BA%A4%E9%87%8F%E5%88%87%E5%88%86%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3" data-tocid="410-根据成交量切分时间窗口">4.10. 根据成交量切分时间窗口</a></li><li class="topic-item"><a href="#411-%E8%82%A1%E7%A5%A8%E5%9B%A0%E5%AD%90%E5%BD%92%E6%95%B4" data-tocid="411-股票因子归整">4.11. 股票因子归整</a></li><li class="topic-item"><a href="#412-%E6%A0%B9%E6%8D%AE%E4%BA%A4%E6%98%93%E9%A2%9D%E7%BB%9F%E8%AE%A1%E5%8D%95%E5%AD%90%E7%B1%BB%E5%9E%8B" data-tocid="412-根据交易额统计单子类型">4.12. 根据交易额统计单子类型</a></li></ul></li><li class="topic-item"><a href="#5-%E5%85%83%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="5-元编程相关案例">5. 元编程相关案例</a><ul><li class="topic-item"><a href="#51-%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90-sql-%E8%AF%AD%E5%8F%A5%E6%A1%88%E4%BE%8B-1" data-tocid="51-动态生成-sql-语句案例-1">5.1. 动态生成 SQL 语句案例 1</a></li><li class="topic-item"><a href="#52-%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90-sql-%E8%AF%AD%E5%8F%A5%E6%A1%88%E4%BE%8B-2" data-tocid="52-动态生成-sql-语句案例-2">5.2. 动态生成 SQL 语句案例 2</a></li></ul></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>