<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="因子挖掘是量化交易的基础。除传统的基本面因子外，从中高频行情数据中挖掘有价值的因子，并进一步建模和回测以构建交易系统，是一个量化团队的必经之路。金融或者量化金融是一个高度市场化、多方机构高度博弈的领域。因子的有效时间会随着博弈程度的加剧而缩短，如何使用更加高效的工具和流程，更快的找到新的有效的因子，是每一个交易团队必须面对的问题。 近年来，DolphinDB ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="因子计算最佳实践"/><title>因子计算最佳实践</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;因子计算最佳实践&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子计算最佳实践&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子挖掘是量化交易的基础。除传统的基本面因子外，从中高频行情数据中挖掘有价值的因子，并进一步建模和回测以构建交易系统，是一个量化团队的必经之路。金融或者量化金融是一个高度市场化、多方机构高度博弈的领域。因子的有效时间会随着博弈程度的加剧而缩短，如何使用更加高效的工具和流程，更快的找到新的有效的因子，是每一个交易团队必须面对的问题。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;近年来，DolphinDB 越来越成为国内乃至国际上大量基金（私募和公募）、资管机构、券商自营团队进行因子挖掘的利器。基于大量客户的反馈，我们特撰写此白皮书，&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;5:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;总结使用 DolphinDB 进行因子挖掘的最佳实践。&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:126;162:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-概述&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1. 概述&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;交易团队用于因子挖掘的常见技术栈有几个大的类别:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;使用 python、matlab 等数据分析工具&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;委托第三方开发有图形界面的因子挖掘工具&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;使用 java、c++ 等编程语言自行开发挖掘工具&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在 DolphinDB 等专业工具上进行二次开发&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;我们暂且不讨论各个技术栈的优缺点。但不管使用何种技术栈，都必须解决以下几个问题:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能处理不同频率不同规模的数据集&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能计算不同风格的因子&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能处理因子数量不断增长的问题&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能高效的存取原始数据和因子数据&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能提升因子挖掘的开发效率&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能提升因子计算的运行效率（高吞吐，低延时）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能解决研究的因子用于生产（实盘交易）的问题&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;能解决多个交易员（研究员）或交易团队一起使用时的各种工程问题，如代码管理、单元测试、权限管理、大规模计算等&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 作为分布式计算、实时流计算及分布式存储一体化的高性能时序数据库，非常适合因子的存储、计算、建模、回测和实盘交易。通过部署 DolphinDB 单机或集群环境，用户可以快速地处理 GB 级别甚至 PB 级别的海量数据集，日级、分钟级、快照和逐笔委托数据均能高效响应。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 内置了多范式的编程语言（函数式，命令式，向量式、SQL式），可以帮助研发人员高效开发不同风格的因子。此外，DolphinDB 还提供了丰富且性能高效的函数库（超1400个内置函数），尤其是窗口处理方面经过优化的内置算子，大大缩短了因子计算的延时。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 自带的数据回放和流式增量计算引擎可以方便地解决因子挖掘中研发和生产一体化的问题。DolphinDB 的分布式存储和计算框架，天生便于解决工程中的可靠性、扩展性等问题。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;本文基于国内 A 股市场各个频率的数据来演示 DolphinDB 计算和规划因子库存储的方案。根据批量因子计算、实时因子计算、多因子建模、因子库存储规划、因子计算工程化等各个场景的实操演练，以及针对不同方案的对比分析，本文总结出了在 DolphinDB 中进行因子计算的最佳实践。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-测试数据集&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2. 测试数据集&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;本文的因子计算基于三类国内 A 股行情数据集：逐笔数据、快照数据和 K 线数据（分钟 K 线和日 K 线）。快照数据以两种形式存储：（1）各档数据分别存储为一列；（2）用 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/progr/data_types_forms/arrayVector.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;34:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;array vector&lt;/xref&gt; 将所有档位的数据存储为一列。&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;5&#34; xtrc=&#34;tgroup:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:4;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:5;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据集&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;36:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;简称&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;36:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;代码样例中的分区数据库路径&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:4;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;代码样例中的表名&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:5;36:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分区机制&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;逐笔成交&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:7;38:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;level2_tick&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:8;38:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dfs://tick_SH_L2_TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:9;38:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;tick_SH_L2_TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:10;38:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;VALUE:每交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:11;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;快照&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:12;39:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;level2_snapshot&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:13;39:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dfs://snapshot_SH_L2_TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:14;39:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;snapshot_SH_L2_TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:15;39:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;VALUE:每交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:16;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;快照(向量存储)&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:17;40:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;level2_snapshot&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:18;40:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dfs://LEVEL2_Snapshot_ArrayVector&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:19;40:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;Snap&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:20;40:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;VALUE:每交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:21;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟K线&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:22;41:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;k_line&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:23;41:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dfs://k_minute_level&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:24;41:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;k_minute&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:25;41:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;VALUE:交易月, HASH: [SYMBOL, 3]&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;42:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:26;42:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日K线&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:27;42:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;k_line&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:28;42:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dfs://k_day_level&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:29;42:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;k_day&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:30;42:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;VALUE:年&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-逐笔成交数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2.1. 逐笔成交数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;script/factorPractice/images/level2_tick_samples.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; dita-ot:image-width=&#34;530&#34; dita-ot:image-height=&#34;122&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;逐笔成交数据&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;逐笔成交是交易所公布买卖双方具体成交的每一笔数据，每3秒发布一次，每次包含这3秒内的所有成交记录。每一笔成交撮合，都由买方和卖方的一笔具体委托组成。上述数据样例采用字段 BuyNo 和 SellNo 标注买卖双方的委托单号，其它关键字段分别为： SecurityID（标的物代码），TradeTime（成交时刻），TradePrice（成交价格），TradeQty（本笔成交量）和 TradeAmount（本笔成交金额）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;51:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;每个交易日的原始数据量在 8 GB 上下。根据上表的分区机制进行建库建表，点击查看对应脚本：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.1_createTickDbAndTable_main.dos&#34; xtrc=&#34;xref:2;51:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔成交数据建库建表完整代码&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-快照数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2.2. 快照数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;script/factorPractice/images/snapshot_samples.png&#34; placement=&#34;break&#34; xtrc=&#34;image:2;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; dita-ot:image-width=&#34;1328&#34; dita-ot:image-height=&#34;101&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:2;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;快照数据&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;股票交易所每3秒发布一次，每次涵盖这3秒结束时的日内累计成交量(TotalVolumeTrade)，日内累计成交金额(TotalValueTrade)，3秒终了时的盘口买卖双方挂单（买方为 Bid，卖方在有些数据源字段为 Offer，在有些数据源字段为 Ask，其余字段以此类推：BidPrice 为买方各档价格，OfferPrice 为卖方各档价格，OrderQty 为买卖双方各档的委托单总量， Orders 为买卖双方委托单数），3秒终了时的最近一笔成交价格（LastPx），全天开盘价（OpenPx），日内截止当下最高价（HighPx），日内截止当下最低价（LowPx）等各字段。其他和逐笔成交一致的字段不再赘述，涵义一致，详情可参见交易所数据说明字典。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;每个交易日的原始数据量约在 10G 左右。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在 DolphinDB 2.0版本的 TSDB 存储引擎中，支持 array vector 的存储机制，即可以允许数据表中一个 cell 存储一个向量。在本白皮书的案例中，后面文章会详细介绍 array vector 存储方案和普通存储方案的区别。快照数据的买10档或卖10档在本例中作为一个 vector 存入单个 cell 中，其他各字段和普通快照数据表都相同。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;两种存储模式的建库建表可以参考&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.2_createSnapshotDbAndTable_main.dos&#34; xtrc=&#34;xref:3;64:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;Snapshot普通及arrayVector形式建库和建表完整代码&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;快照数据的 array_vector 存储形式： &lt;image class=&#34;- topic/image &#34; href=&#34;script/factorPractice/images/snapshot_in_array_vector_samples.png&#34; xtrc=&#34;image:3;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; dita-ot:image-width=&#34;1322&#34; dita-ot:image-height=&#34;101&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:3;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;array_vector快照数据&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-分钟k数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2.3. 分钟K数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;script/factorPractice/images/kline_samples.png&#34; placement=&#34;break&#34; xtrc=&#34;image:4;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; dita-ot:image-width=&#34;700&#34; dita-ot:image-height=&#34;101&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:4;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟K数据&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;包含每只股票，每分钟的开盘价、最高价、最低价、收盘价，四个价格字段，同时记录本分钟的成交量和成交金额。另外，数据 K 线可以依据基本字段计算衍生字段，比如：k 线均价(vwap 价格)。k 线数据是由逐笔成交数据聚合产生，具体代码可以参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#基于快照数据的分钟聚合&#34; xtrc=&#34;xref:4;74:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;基于快照数据的分钟聚合&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日 K 数据，存储形式和字段跟分钟 k 线一致，可以由分钟 k 线或高频数据聚合产生，这里不作赘述。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日 K 数据，分钟数据的建库建表可以参考：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.3_createTableKMinute_main.dos&#34; xtrc=&#34;xref:5;78:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;k 线数据建库建表完整代码&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-投研阶段的因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3. 投研阶段的因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在投研阶段，会通过历史数据批量计算生成因子。通常，推荐研究员将每一种因子的计算都封装成自定义函数。根据因子类型和使用者习惯的不同，DolphinDB 提供了面板和 SQL 两种计算方式。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在面板计算中，自定义函数的参数一般为向量，矩阵或表，输出一般为向量，矩阵或表；在 SQL 模式中，自定义函数的参数一般为向量（列），输出一般为向量。因子函数的粒度尽可能小，只包含计算单个因子的业务逻辑，也不用考虑并行计算加速等问题。这样做的优点包括：（1）易于实现流批一体，（2）便于团队的因子代码提交和管理，（3）方便用统一的框架运行因子计算作业。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-面板数据模式&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.1. 面板数据模式&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;面板数据(panel data)是以时间为索引，标的为列，指标作为内容的一种数据载体，它非常适用于以标的集合为单位的指标计算，将数据以面板作为载体，可以大大简化脚本的复杂度，通常最后的计算表达式可以从原始的数学公式中一对一的翻译过来。除此之外，可以充分利用DolphinDB矩阵计算的高效能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在因子计算中，面板数据通常可以通过&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;88:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;panel&lt;/codeph&gt;函数，或者&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;88:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;exec&lt;/codeph&gt;搭配&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;88:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;pivot by&lt;/codeph&gt;得到，具体样例如下表：每一行是一个时间点，每一列是一个股票。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt; 000001 000002 000003 000004 ... --------- ---------- ------- ------ --- 2020.01.02T09:29:00.000|3066.336 3212.982 257.523 2400.042 ... 2020.01.02T09:30:00.000|3070.247 3217.087 258.696 2402.221 ... 2020.01.02T09:31:00.000|3070.381 3217.170 259.066 2402.029 ...&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在面板数据上，由于是以时间为索引，标的为列，因子可以方便地在截面上做各类运算。DolphinDB 包含 row 系列函数以及各类滑动窗口函数，在下面两个因子计算例子中，原本复杂的计算逻辑，在面板数据中，可以用一行代码轻松实现。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;Alpha 1 因子计算中，下例使用了rowRank 函数，可以在面板数据中的每一个时间截面对各标的进行排名；iif 条件运算，可以在标的向量层面直接筛选及计算；mimax 及 mstd 等滑动窗口函数也是在标的层面垂直计算的。因此，在面板计算中合理应用 DolphinDB 的内置函数，可以从不同维度进行计算。&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//alpha 1 //Alpha#001公式：rank(Ts_ArgMax(SignedPower((returns&amp;lt;0?stddev(returns,20):close), 2), 5))-0.5 @state def alpha1TS(close){ return mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20),close), 2.0), 5) } def alpha1Panel(close){ return rowRank(X=alpha1TS(close), percent=true) - 0.5 } input = exec close from loadTable(&#34;dfs://k_minute&#34;,&#34;k_minute&#34;) where date(tradetime) between 2020.01.01 : 2020.01.31 pivot by tradetime, securityid res = alpha1Panel(input)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;119:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;119:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;Alpha 98 因子计算中，同时使用了三个面板数据，分别是vwap, open和vol。不仅各矩阵内部运用了rowRank函数横向截面运算以及m系列垂直滑动窗口计算，矩阵之间也进行了二元运算。用一行代码解决了多维度的复杂的嵌套计算逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;121:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//alpha 98 //Alpha #98计算公式: (rank(decay_linear(correlation(vwap, sum(adv5, 26.4719), 4.58418), 7.18088)) - rank(decay_linear(Ts_Rank(Ts_ArgMin(correlation(rank(open), rank(adv15), 20.8187), 8.62571), 6.95668), 8.07206))) def prepareDataForDDBPanel(raw_data, start_time, end_time){ t = select tradetime,securityid, vwap,vol,open from raw_data where date(tradetime) between start_time : end_time return dict(`vwap`open`vol, panel(t.tradetime, t.securityid, [t.vwap, t.open, t.vol])) } @state def alpha98Panel(vwap, open, vol){ return rowRank(X = mavg(mcorr(vwap, msum(mavg(vol, 5), 26), 5), 1..7),percent=true) - rowRank(X=mavg(mrank(9 - mimin(mcorr(rowRank(X=open,percent=true), rowRank(X=mavg(vol, 15),percent=true), 21), 9), true, 7), 1..8),percent=true) } raw_data = loadTable(&#34;dfs://k_minute&#34;,&#34;k_day&#34;) start_time = 2020.01.01 end_time = 2020.12.31 input = prepareDataForDDBPanel(raw_data, start_time, end_time) timer alpha98DDBPanel = alpha98Panel(input.vwap, input.open, input.vol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;基于面板数据的因子计算，耗时主要在面板数据准备和因子计算两个阶段。在很多场景下，面板数据准备的耗时可能超过因子计算本身。为解决这个问题，DolphinDB的TSDB引擎提供了宽表存储，即把面板数据直接存储在数据库表中（面板中每一个列存储为表中的每一个列），这样通过SQL查询可以直接获取面板数据，而不需要通过转置行列来获取，从而大大缩短准备面板数据的时间。在本文的第5章中，我们有详细的宽表和竖表存储性能的对比。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-sql模式&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.2. SQL模式&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB在存储和计算框架上都是基于列式结构，表中的一个列可以直接作为一个向量化函数的输入参数。因此如果一个因子的计算逻辑只涉及股票自身的时间序列数据，不涉及多个股票横截面上的信息，可以直接在SQL中按股票分组，然后在select中调用因子函数计算每个股票在一段时间内的因子值。如果数据在数据库中本身是按股票分区存储的，那么可以非常高效地实现数据库内并行计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;def sum_diff(x, y){ return (x-y)\(x+y) } @state def factorDoubleEMA(price){ ema_2 = ema(price, 2) ema_4 = ema(price, 4) sum_diff_1000 = 1000 * sum_diff(ema_2, ema_4) return ema(sum_diff_1000, 2) - ema(sum_diff_1000, 3) } res = select tradetime, securityid, `doubleEMA as factorname, factorDoubleEMA(close) as val from loadTable(&#34;dfs://k_minute&#34;,&#34;k_minute&#34;) where tradetime between 2020.01.01 : 2020.01.31 context by securityid&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在上面的例子中，我们定义了一个因子函数 factorDoubleEMA，只需要用到股票的价格序列信息。我们在 SQL 中通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;165:64&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;context by&lt;/codeph&gt; 子句按股票代码分组，然后调用factorDoubleEMA函数，计算每个股票的因子序列。值得注意的是，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;165:128&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;context by&lt;/codeph&gt; 是 DolphinDB SQL 对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;165:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;group by&lt;/codeph&gt; 的扩展，是 DolphinDB 特有的 SQL 语句。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;165:197&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;group by&lt;/codeph&gt; 只适用于聚合计算，也就是说输入长度为n，输出长度是1。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;165:235&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;context by&lt;/codeph&gt; 适用于向量计算，输入长度是n，输出长度也是n。另外因子函数 factorDOubleEMA 除了可以接受一个向量作为输入，也可以接受一个面板数据作为输入。这也是我们前面强调的，因子函数的粒度尽可能细，这样可以应用于很多场景。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;时间序列的因子函数非常普遍，talib 中的所有技术分析指标都属于此类函数，因此都可以使用上述SQL方式或面板数据模式来调用。但是3.1中提到的 alpha1 和 alpha98 等因子，涉及到时间序列和横截面两个维度的计算，我们称之为截面因子，无法将因子逻辑封装在一个自定义函数中，然后在一个 SQL 语句中被调用。通常面对截面因子，我们建议将表作为自定义因子函数的入参，内部用 SQL 进行操作，函数最后返回一个表。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//alpha1 def alpha1SQL(t){ res = select tradetime, securityid, mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5) as val from t context by securityid return select tradetime, securityid, rank(val, percent=true) - 0.5 as val from res context by tradetime } input = select tradetime,securityid, close from loadTable(&#34;dfs://k_day_level&#34;,&#34;k_day&#34;) where tradetime between 2010.01.01 : 2010.12.31 alpha1DDBSql = alpha1SQL(input) //alpha98 def alpha98SQL(mutable t){ update t set adv5 = mavg(vol, 5), adv15 = mavg(vol, 15) context by securityid update t set rank_open = rank(X = open,percent=true), rank_adv15 =rank(X=adv15,percent=true) context by date(tradetime) update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by securityid return select tradetime,securityid, `alpha98 as factorname, rank(X =decay7,percent=true)-rank(X =decay8,percent=true) as val from t context by date(tradetime) } input = select tradetime,securityid, vwap,vol,open from loadTable(&#34;dfs://k_day_level&#34;,&#34;k_day&#34;) where tradetime between 2010.01.01 : 2010.12.31 alpha98DDBSql = alpha98SQL(input)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-不同频率的因子开发举例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3. 不同频率的因子开发举例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;不同频率数据的因子，有着不同的特点。本章节将分别举例分钟频、日频、快照、逐笔数据的特点因子，阐述不同频率数据计算因子的最佳实践。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;331-分钟级和日级数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3.1. 分钟级和日级数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日级数据的计算，通常是涉及多个截面的复杂计算，在&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#面板数据模式&#34; xtrc=&#34;xref:6;195:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;面板数据模式&lt;/xref&gt;中已展现。对于稍简单的计算，则与分钟级数据的因子相像。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;针对分钟级数据，下面的例子是日内收益率偏度的因子计算，对于这类只涉及表内字段的计算，通常使用 SQL 模式，配合 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;197:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;group by&lt;/codeph&gt; 语句将计算分组：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;defg dayReturnSkew(close){ return skew(ratios(close)) } minReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable(&#34;dfs://k_minute_level&#34;, &#34;k_minute&#34;) where date(tradetime) between 2020.01.02 : 2020.01.31 group by date(tradetime) as tradetime, securityid // output tradetime securityid factorname val ---------- ---------- ------------- ------- 2020.01.02 000019 dayReturnSkew 11.8328 2020.01.02 000048 dayReturnSkew 11.0544 2020.01.02 000050 dayReturnSkew 10.6186&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;332-基于快照数据的有状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3.2. 基于快照数据的有状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;有状态的因子，意为因子的计算需要基于之前的计算结果，如一般的滑动窗口计算，聚合计算等，都是有状态的因子计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;218:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;下例flow这个自定义函数中，参数为四个列字段，运用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;218:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;mavg&lt;/codeph&gt; 滑动平均函数以及 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;218:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;iif&lt;/codeph&gt; 条件运算函数，可以直接在SQL中得到因子结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state def flow(buy_vol, sell_vol, askPrice1, bidPrice1){ buy_vol_ma = round(mavg(buy_vol, 5*60), 5) sell_vol_ma = round(mavg(sell_vol, 5*60), 5) buy_prop = iif(abs(buy_vol_ma+sell_vol_ma) &amp;lt; 0, 0.5 , buy_vol_ma/ (buy_vol_ma+sell_vol_ma)) spd = askPrice1 - bidPrice1 spd = iif(spd &amp;lt; 0, 0, spd) spd_ma = round(mavg(spd, 5*60), 5) return iif(spd_ma == 0, 0, buy_prop / spd_ma) } res_flow = select TradeTime, SecurityID, `flow as factorname, flow(BidOrderQty[1],OfferOrderQty[1], OfferPrice[1], BidPrice[1]) as val from loadTable(&#34;dfs://LEVEL2_Snapshot_ArrayVector&#34;,&#34;Snap&#34;) where date(TradeTime) &amp;lt;= 2020.01.30 and date(TradeTime) &amp;gt;= 2020.01.01 context by SecurityID // output sample TradeTime SecurityID factorname val ----------------------- ---------- ---------- ----------------- 2020.01.22T14:46:27.000 110065 flow 3.7587 2020.01.22T14:46:30.000 110065 flow 3.7515 2020.01.22T14:46:33.000 110065 flow 3.7443 ...&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;333-快照数据的多档赋权无状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3.3. 快照数据的多档赋权无状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;计算Level 2的多档快照数据，传统的方式是将多档量价数据存储成为多个列, 再将多档挂单或者报价用 matrix 转换与权重做计算。 更推荐的做法是，将多档数据存储为 array vector，仍旧可以用原来的自定义函数，但是资源消耗包括效率都有提升。 下面的例子是计算多档报价的权重偏度因子，使用 array vector 后计算时间从4秒缩短到2秒。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;def mathWghtCovar(x, y, w){ v = (x - rowWavg(x, w)) * (y - rowWavg(y, w)) return rowWavg(v, w) } @state def mathWghtSkew(x, w){ x_var = mathWghtCovar(x, x, w) x_std = sqrt(x_var) x_1 = x - rowWavg(x, w) x_2 = x_1*x_1 len = size(w) adj = sqrt((len - 1) * len) \ (len - 2) skew = rowWsum(x_2, x_1) \ (x_var * x_std) * adj \ len return iif(x_std==0, 0, skew) } //weights: w = 10 9 8 7 6 5 4 3 2 1 //权重偏度因子： resWeight = select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(BidPrice, w) as val from loadTable(&#34;dfs://LEVEL2_Snapshot_ArrayVector&#34;,&#34;Snap&#34;) where date(TradeTime) = 2020.01.02 map resWeight1 = select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(matrix(BidPrice0,BidPrice1,BidPrice2,BidPrice3,BidPrice4,BidPrice5,BidPrice6,BidPrice7,BidPrice8,BidPrice9), w) as val from loadTable(&#34;dfs://snapshot_SH_L2_TSDB&#34;, &#34;snapshot_SH_L2_TSDB&#34;) where date(TradeTime) = 2020.01.02 map // output TradeTime SecurityID factorname val ----------------------- ---------- ---------- ------ ... 2020.01.02T09:30:09.000 113537 array_1 -0.8828 2020.01.02T09:30:12.000 113537 array_1 0.7371 2020.01.02T09:30:15.000 113537 array_1 0.6041 ...&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;334-基于快照数据的分钟聚合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;284:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;284:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3.4. 基于快照数据的分钟聚合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;284:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;286:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;投研中经常需要基于快照数据聚合分钟线的 OHLC ，下例就是这一场景中的通用做法：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//基于快照因子的分钟聚合OHLC，vwap tick_aggr = select first(LastPx) as open, max(LastPx) as high, min(LastPx) as low, last(LastPx) as close, sum(totalvolumetrade) as vol,sum(lastpx*totalvolumetrade) as val,wavg(lastpx, totalvolumetrade) as vwap from loadTable(&#34;dfs://LEVEL2_Snapshot_ArrayVector&#34;,&#34;Snap&#34;) where date(TradeTime) &amp;lt;= 2020.01.30 and date(TradeTime) &amp;gt;= 2020.01.01 group by SecurityID, bar(TradeTime,1m) &lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;335-逐笔数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3.5. 逐笔数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;295:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;逐笔数据量较大，一般会针对成交量等字段进行计算，下面的例子计算了每天主买成交量占全部成交量的比例，同样使用 SQL 模式，发挥库内并行计算的优势，并使用 csort 语句用来对组内数据按照时间顺序排序：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;297:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state def buyTradeRatio(buyNo, sellNo, tradeQty){ return cumsum(iif(buyNo&amp;gt;sellNo, tradeQty, 0))\cumsum(tradeQty) } factor = select TradeTime, SecurityID, `buyTradeRatio as factorname, buyTradeRatio(BuyNo, SellNo, TradeQty) as val from loadTable(&#34;dfs://tick_SH_L2_TSDB&#34;,&#34;tick_SH_L2_TSDB&#34;) where date(TradeTime)&amp;lt;2020.01.31 and time(TradeTime)&amp;gt;=09:30:00.000 context by SecurityID, date(TradeTime) csort TradeTime // output TradeTime SecurityID factorname val ------------------- ---------- ---------- ------ 2020.01.08T09:30:07 511850 buyTradeRatio 0.0086 2020.01.08T09:30:31 511850 buyTradeRatio 0.0574 2020.01.08T09:30:36 511850 buyTradeRatio 0.0569 ...&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-生产环境的流式因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4. 生产环境的流式因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在生产环境中，DolphinDB 提供了实时流计算框架。在流计算框架下，用户在投研阶段封装好的基于批量数据开发的因子函数，可以无缝投入交易和投资方面的生产程序中，这就是通常所说的批流一体。使用流批一体可以加速用户的开发和部署。同时流计算框架还在算法的路径上，做了极致的优化，在具有高效开发的优势的同时，又兼顾了计算的高效性能。在这一章中，将会基于实际的状态因子案例，展示实时流计算的使用方法。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 流计算解决方案的核心部件是流计算引擎和流数据表。流计算引擎用于时间序列处理、横截面处理、窗口处理、表关联、异常检测等操作。流数据表可以看作是一个简化版的消息中间件，或者说是消息中间件中的一个主题（topic），可以往其发布（publish）数据，也可以从其订阅（subscribe）数据。流计算引擎和流数据表均继承于 DolphinDB 的数据表（table），因此都可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;318:200&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;append!&lt;/codeph&gt; 函数往其注入数据。流计算引擎的输出也是数据表的形式，因此多个计算引擎可以跟搭积木一样自由组合，形成流式处理的流水线。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;script/factorPractice/images/factor_streams.png&#34; placement=&#34;break&#34; xtrc=&#34;image:5;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; dita-ot:image-width=&#34;1194&#34; dita-ot:image-height=&#34;624&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:5;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子数据流处理流程图&lt;/alt&gt;&lt;/image&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-流式增量计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.1. 流式增量计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;金融方面的原始数据和计算指标，在时间上通常有延续性的关系。以最简单的五周期移动均线 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;324:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;mavg(close,5)&lt;/codeph&gt; 为例，当新一个周期的数据传入模型时，可以将之前最远的第五周期值从 sum 中减出，再把最新一个周期的值加入 sum ，这样就不必每个周期只更新一个值时都重算一遍 sum 。这种增量计算是流计算的核心，可以大大降低实时计算的延时。DolphinDB内置了大量量化金融中需要用到的基本算子，并为这些算子实现了高效的增量算法。不仅如此，DolphinDB还支持自定义函数的增量实现。在前一章节中，部分自定义的因子函数加了修饰符 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;324:270&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state&lt;/codeph&gt; ，表示该函数支持增量计算。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;411-主买成交量占比因子的流式处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.1.1. 主买成交量占比因子的流式处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;328:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#逐笔数据&#34; xtrc=&#34;xref:7;328:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔数据&lt;/xref&gt;的逐笔数据因子的例子展示了主买成交量占比因子（buyTradeRatio）的批量实现方式。以下代码演示如何使用响应式状态引擎（reactive state engine）来实现该因子的流式增量计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;330:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state def buyTradeRatio(buyNo, sellNo, tradeQty){ return cumsum(iif(buyNo&amp;gt;sellNo, tradeQty, 0))\cumsum(tradeQty) } tickStream = table(1:0, `SecurityID`TradeTime`TradePrice`TradeQty`TradeAmount`BuyNo`SellNo, [SYMBOL,DATETIME,DOUBLE,INT,DOUBLE,LONG,LONG]) result = table(1:0, `SecurityID`TradeTime`Factor, [SYMBOL,DATETIME,DOUBLE]) factors = &amp;lt;[TradeTime, buyTradeRatio(BuyNo, SellNo, TradeQty)]&amp;gt; demoEngine = createReactiveStateEngine(name=&#34;demo&#34;, metrics=factors, dummyTable=tickStream, outputTable=result, keyColumn=&#34;SecurityID&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;上述代码创建了一个名为demo的响应式状态引擎，SecurityID作为分组键，输入的消息格式同内存表tickStream。需要计算的指标定义在factors中，其中1个是输入表中的原始字段TradeTime，另一个是我们需要计算的因子的函数表示。输出到内存表result，除了在factors中定义的指标外，输出结果还会添加分组键。请注意，自定义的因子函数跟批计算中的完全一致！创建完引擎之后，我们即可往引擎中插入几条数据，并观察计算结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;insert into demoEngine values(`000155, 2020.01.01T09:30:00, 30.85, 100, 3085, 4951, 0) insert into demoEngine values(`000155, 2020.01.01T09:30:01, 30.86, 100, 3086, 4951, 1) insert into demoEngine values(`000155, 2020.01.01T09:30:02, 30.80, 200, 6160, 5501, 5600) select * from result SecurityID TradeTime Factor ---------- ------------------- ------ 000155 2020.01.01T09:30:00 1 000155 2020.01.01T09:30:01 1 000155 2020.01.01T09:30:02 0.5&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;从这个例子可以看出，在DolphinDB中实现因子的流式增量计算非常简单。如果在投研阶段，已经用我们推荐的方式自定义了一个因子函数，在生产阶段只要程序性的创建一个流式计算引擎即可实现目标。这也是为什么我们一再强调，自定义的因子函数必须使用规范的接口，而且只包含核心的因子逻辑，不用考虑并行计算等问题。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;412-大小单的流式处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.1.2. 大小单的流式处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;362:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;资金流分析是逐笔委托数据的一个重要应用场景。在实时处理逐笔数据时，大小单的统计是资金流分析的一个具体应用。大小单在一定程度上能反映主力、散户的动向。但在实时场景中，大小单的生成有很多难点：（1） 大小单的计算涉及历史状态，如若不能实现增量计算，当计算下午的数据时，可能需要回溯有关这笔订单上午的数据，效率会非常低下。 （2）计算涉及至少两个阶段。在第一阶段需要根据订单分组，根据订单的累计成交量判断大小单，在第二阶段要根据股票来分组，统计每个股票的大小单数量及金额。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;大小单是一个动态的概念。一个小单在成交量增加后可能变成一个大单。DolphinDB的两个内置函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;364:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dynamicGroupCumsum&lt;/codeph&gt;和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;364:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dynamicGroupCumcount&lt;/codeph&gt;用于对动态组的增量计算。完整的代码请参考：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.1.2_streamComputationOfSmallInflowRate_main.dos&#34; xtrc=&#34;xref:8;364:113&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;大小单的流式处理&lt;/xref&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;366:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state def factorSmallOrderNetAmountRatio(tradeAmount, sellCumAmount, sellOrderFlag, prevSellCumAmount, prevSellOrderFlag, buyCumAmount, buyOrderFlag, prevBuyCumAmount, prevBuyOrderFlag){ cumsumTradeAmount = cumsum(tradeAmount) smallSellCumAmount, bigSellCumAmount = dynamicGroupCumsum(sellCumAmount, prevSellCumAmount, sellOrderFlag, prevSellOrderFlag, 2) smallBuyCumAmount, bigBuyCumAmount = dynamicGroupCumsum(buyCumAmount, prevBuyCumAmount, buyOrderFlag, prevBuyOrderFlag, 2) f = (smallBuyCumAmount - smallSellCumAmount) \ cumsumTradeAmount return smallBuyCumAmount, smallSellCumAmount, cumsumTradeAmount, f } def createStreamEngine(result){ tradeSchema = createTradeSchema() result1Schema = createResult1Schema() result2Schema = createResult2Schema() engineNames = [&#34;rse1&#34;, &#34;rse2&#34;, &#34;res3&#34;] cleanStreamEngines(engineNames) metrics3 = &amp;lt;[TradeTime, factorSmallOrderNetAmountRatio(tradeAmount, sellCumAmount, sellOrderFlag, prevSellCumAmount, prevSellOrderFlag, buyCumAmount, buyOrderFlag, prevBuyCumAmount, prevBuyOrderFlag)]&amp;gt; rse3 = createReactiveStateEngine(name=engineNames[2], metrics=metrics3, dummyTable=result2Schema, outputTable=result, keyColumn=&#34;SecurityID&#34;) metrics2 = &amp;lt;[BuyNo, SecurityID, TradeTime, TradeAmount, BuyCumAmount, PrevBuyCumAmount, BuyOrderFlag, PrevBuyOrderFlag, factorOrderCumAmount(TradeAmount)]&amp;gt; rse2 = createReactiveStateEngine(name=engineNames[1], metrics=metrics2, dummyTable=result1Schema, outputTable=rse3, keyColumn=&#34;SellNo&#34;) metrics1 = &amp;lt;[SecurityID, SellNo, TradeTime, TradeAmount, factorOrderCumAmount(TradeAmount)]&amp;gt; return createReactiveStateEngine(name=engineNames[0], metrics=metrics1, dummyTable=tradeSchema, outputTable=rse2, keyColumn=&#34;BuyNo&#34;) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;394:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;自定义函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;394:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factorSmallOrderNetAmountRatio&lt;/codeph&gt;是一个状态因子函数，用于计算小单的净流入资金占总的交易资金的比例。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;394:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;createStreamEngine&lt;/codeph&gt;创建流式计算引擎。我们一共创建了3个级联的响应式状态引擎，后一个作为前一个的输出，因此从最后一个引擎开始创建。前两个计算引擎rse1和rse2分别以买方订单号（BuyNo)和卖方订单号（SellNo）作为分组键，计算每个订单的累计交易量，并以此区分是大单或小单。第三个引擎rse3把股票代码（SecurityID）作为分组键，统计每个股票的小单净流入资金占总交易资金的比例。下面我们输入一些样本数据来观察流计算引擎的运行。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;result = createResultTable() rse = createStreamEngine(result) insert into rse values(`000155, 1000, 1001, 2020.01.01T09:30:00, 20000) insert into rse values(`000155, 1000, 1002, 2020.01.01T09:30:01, 40000) insert into rse values(`000155, 1000, 1003, 2020.01.01T09:30:02, 60000) insert into rse values(`000155, 1004, 1003, 2020.01.01T09:30:03, 30000) select * from result SecurityID TradeTime smallBuyOrderAmount smallSellOrderAmount totalOrderAmount factor ---------- ------------------- ------------------- -------------------- ---------------- ------ 000155 2020.01.01T09:30:00 20000 20000 20000 0 000155 2020.01.01T09:30:01 60000 60000 60000 0 000155 2020.01.01T09:30:02 0 120000 120000 -1 000155 2020.01.01T09:30:03 30000 150000 150000 -0.8&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;413-复杂因子alpha-1流式计算的快捷实现&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.1.3. 复杂因子Alpha #1流式计算的快捷实现&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;从前一个大小单的例子可以看到，有些因子的流式实现比较复杂，需要创建多个引擎进行流水线处理来完成。完全用手工的方式来创建多个引擎其实是一件耗时的工作。如果输入的指标计算只涉及一个分组键，DolphinDB提供了一个解析引擎&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;416:111&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;streamEngineParser&lt;/codeph&gt;来解决此问题。下面我们以面板数据模式一节的alpha #1因子为例，展示&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;416:167&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;streamEngineParser&lt;/codeph&gt;的使用方法。完整代码参考&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.1.3_StreamComputationOfAlpha1Factor_main.dos&#34; xtrc=&#34;xref:9;416:199&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;Alpha #1流式计算&lt;/xref&gt;。以下为核心代码。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@state def alpha1TS(close){ return mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20),close), 2.0), 5) } def alpha1Panel(close){ return rowRank(X=alpha1TS(close), percent=true) - 0.5 } inputSchema = table(1:0, [&#34;SecurityID&#34;,&#34;TradeTime&#34;,&#34;close&#34;], [SYMBOL,TIMESTAMP,DOUBLE]) result = table(10000:0, [&#34;TradeTime&#34;,&#34;SecurityID&#34;, &#34;factor&#34;], [TIMESTAMP,SYMBOL,DOUBLE]) metrics = &amp;lt;[SecurityID, alpha1Panel(close)]&amp;gt; streamEngine = streamEngineParser(name=&#34;alpha1Parser&#34;, metrics=metrics, dummyTable=inputSchema, outputTable=result, keyColumn=&#34;SecurityID&#34;, timeColumn=`tradetime, triggeringPattern='keyCount', triggeringInterval=4000)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;433:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子alpha1实际上包含了时间序列处理和横截面处理，需要响应式状态引擎和横截面引擎串联来处理才能完成。但以上代码仅仅使用了streamEngineParser就创建了全部引擎，大大简化了创建过程。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;前面三个例子展示了DolphinDB如何通过流计算引擎实现因子在生产环境中的增量计算。值得注意的是，流式计算时直接使用了投研阶段生成的核心因子代码，这很好的解决了传统金融分析面临的批流一体问题。在传统的研究框架下，用户往往需要对同一个因子计算逻辑写两套代码，一套用于在历史数据上建模、回测，另外一套专门处理盘中传入的实时数据。这是因为数据传入程序的形状(机制)不统一，又甚至是编程语言也无法统一。比如研究分析使用了 python 或者 R，在 python 或 R 的研究程序确定模型和参数后，生产交易的程序必须用 C++ 再实现这套模型，才能保证交易时的执行效率。在两套代码完成后，还要再校验它们计算出来的结果是否一致。这样的业务流程毫无疑问加重了研究员和程序员们的负担，也让基金经理们没法更快地让新交易思路迭代上线。在DolphinDB的流式计算中，实时行情订阅、行情数据收录、交易实时计算、盘后研究建模，全都用同一套代码完成，保证在历史回放和生产交易当中数据完全一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;除了三个例子中用到的响应式状态引擎(reactive state engine)和横截面引擎（cross sectional engine），DolphinDB 还提供了多种流数据处理引擎包括做流表连接的 asof join engine，equal join engine，lookup join engine，window join engine ，时间序列聚合引擎（time series engine），异常检测引擎(anomaly detection engine)，会话窗口引擎（session window engine）等。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-数据回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.2. 数据回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;前一节我们介绍了因子计算的批流一体实现方案，简单地说，就是一套代码（自定义的因子函数），两种引擎（批计算引擎和流计算引擎）。事实上，DolphinDB提供一种更为简洁的批流一体实现方案，那就是在历史数据建模时，通过数据回放，也用流引擎来实现计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#sql模式&#34; xtrc=&#34;xref:10;444:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;SQL语句方式批处理计算factorDoubleEMA因子&lt;/xref&gt;的例子中，这里介绍如何使用流计算的方式回放数据，计算 factorDoubleEMA 的因子值。全部代码参考&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.2_streamComputationOfDoubleEmaFactor_main.dos&#34; xtrc=&#34;xref:11;444:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;流计算factorDoubleEMA因子&lt;/xref&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//创建流引擎，并传入因子算法factorDoubleEMA factors = &amp;lt;[TradeTime, factorDoubleEMA(close)]&amp;gt; demoEngine = createReactiveStateEngine(name=engineName, metrics=factors, dummyTable=inputDummyTable, outputTable=resultTable, keyColumn=&#34;SecurityID&#34;) //demo_engine订阅snapshotStreamTable流数据表 subscribeTable(tableName=snapshotSharedTableName, actionName=actionName, handler=append!{demoEngine}, msgAsTable=true) //创建播放数据源供replay函数历史回放；盘中的时候，改为行情数据直接写入snapshotStreamTable流数据表 inputDS = replayDS(&amp;lt;select SecurityID, TradeTime, LastPx from tableHandle where date(TradeTime)&amp;lt;2020.07.01&amp;gt;, `TradeTime, `TradeTime)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;43-对接交易系统&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4.3. 对接交易系统&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 本身具有多种常用编程语言的API，包括C++, java, javascript, c#, python, go等。使用这些语言的程序，都可以调用该语言的 DolphinDB 接口，订阅到 DolphinDB 服务器的流数据。本例提供一个简单的&lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/factorPractice/appendix_4.3.1_python_callback_handler_subscribing_stream_main.py&#34; xtrc=&#34;xref:12;460:133&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;python接口订阅流数据&lt;/xref&gt;样例。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB-Python API订阅流数据例子：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;current_ddb_session.subscribe(host=DDB_datanode_host,tableName=stream_table_shared_name,actionName=action_name,offset=0,resub=False,filter=None,port=DDB_server_port, handler=python_callback_handler,#此处传入python端要接收消息的回调函数 )&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;470:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在金融生产环境中，更常见的情况，是流数据实时的灌注到消息队列中，供下游的其他模块消费。DolphinDB 也支持将实时计算结果推送到消息中间件，与交易程序对接。示例中提供的样例，使用 DolphinDB 的开源 ZMQ 插件，将实时计算的结果推送到 ZMQ 消息队列，供下游ZMQ协议的订阅程序消费(交易或展示)。除ZMQ之外，其他支持的工具都在 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;plugin_development_tutorial.md&#34; xtrc=&#34;xref:13;470:175&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 插件库&lt;/xref&gt;中提供。所有已有的 DolphinDB 插件都是开源的，插件的编写组件也是开源的，用户也可按自己的需要编写。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB向ZMQ消息队列推送流数据代码样例：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;474:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;启动下游的ZMQ数据消费程序，作为监听端(ZeroMQ消息队列的服务端)，完整代码见&lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/factorPractice/appendix_4.3.2_zmq_consuming_ddb_stream_main.py&#34; xtrc=&#34;xref:14;474:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;向ZMQ推送流数据&lt;/xref&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;476:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;zmq_context = Context() zmq_bingding_socket = zmq_context.socket(SUB)#见完整版代码设定socket选项 zmq_bingding_socket.bind(&#34;tcp://*:55556&#34;) async def loop_runner(): while True: msg=await zmq_bingding_socket.recv()#阻塞循环until收到流数据 print(msg)#在此编写下游消息处理代码 asyncio.run(loop_runner())&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;487:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;487:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;启动因子数据的流处理计算和发布&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;489:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在外部消费ZMQ消息的程序启动后，DolphinDB端要启动流计算，并开始对外发布计算结果。以下是&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.3.3_streamComputationOfDoubleEmaFactorPublishingOnZMQ_main.dos&#34; xtrc=&#34;xref:15;489:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB端的代码&lt;/xref&gt;。输出结果表之前的所有代码部分，和&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#数据回放&#34; xtrc=&#34;xref:16;489:183&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;流处理计算doubleEma因子&lt;/xref&gt;例子的一致，故下例代码中不再赘述。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;491:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;resultSchema=table(1:0,[&#34;SecurityID&#34;,&#34;TradeTime&#34;,&#34;factor&#34;], [SYMBOL,TIMESTAMP,DOUBLE])//输出到消息队列的表结构 def zmqPusherTable(zmqSubscriberAddress,schemaTable){ SignalSender=def (x) {return x} pushingSocket = zmq::socket(&#34;ZMQ_PUB&#34;, SignalSender) zmq::connect(pushingSocket, zmqSubscriberAddress) pusher = zmq::createPusher(pushingSocket, schemaTable) return pusher } zmqSubscriberAddress=&#34;tcp://192.168.1.195:55556&#34;//引擎demoEngine向zmq队列推送，使用时根据不同的zmq地址修改此字符串 pusherTable=zmqPusherTable(zmqSubscriberAddress,resultSchema)//生成一个逻辑表向上述地址发送zmq包，字段结构参照resultSchema demoEngine = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics=&amp;lt;[TradeTime,doubleEma(LastPx)]&amp;gt;, dummyTable=snapshotSchema, outputTable=pusherTable, keyColumn=&#34;SecurityID&#34;,keepOrder=true)//创建流引擎，output指定输出到pusher表&lt;/codeblock&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-因子的存储和查询&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5. 因子的存储和查询&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;511:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;无论是批量计算还是实时计算，将 DolphinDB 中计算生成的因子保存下来提供给投研做后续的分析都是很有意义的。本章主要是根据存储、查询，使用方式等方面，来分析如何基于使用场景来选择更高效的存储模型。本章测试均为在 Linux 系统上部署的单节点集群，其中包含三个数据节点，每个节点设置16线程并采用三块固态硬盘进行数据存贮。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;513:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在实际考虑数据存储方案，我们需要从以下三个方面考虑：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;选择 OLAP 引擎还是 TSDB 引擎。OLAP 最适合全量跑批计算，TSDB 则在序列查询上优势突出，性能和功能上比较全面。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;515:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的存储方式是单值纵表方式还是多值宽表方式。 单值方式的最大优点是灵活性强，增加因子和股票时，不用修改表结构；缺点是数据冗余度高。多值宽表的数据冗余度很低，配合 TSDB 引擎的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;515:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;array vector&lt;/codeph&gt;，使用宽表结构节省了行数，提高了存储效率，但若出现新因子或新股票，需要重新生成因子表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;516:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分区方式选择。可用于分区的列包括时间列，股票代码列和因子列。OLAP 引擎推荐的分区大小为原始数据100MB左右。为保证最佳性能，TSDB 引擎推荐单分区数据量大小保持在 100MB-1GB 范围内性能最佳。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;519:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;结合以上考虑因素，我们以4000只股票，1000个因子，存储分钟级因子库为例，有如下三种选择：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以纵表存储,使用 OLAP 引擎，每行按时间存储一只股票一个因子数据，分区方案 VALUE(月)+ VALUE(因子名)。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;522:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以纵表存储,使用 TSDB 引擎，每行按时间存储一只股票一个因子数据，分区方案 VALUE(月)+ VALUE(因子名)， 按股票代码+时间排序。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以宽表存储,使用 TSDB 引擎，每行按时间存储全部股票一个因子，或者一支股票全部因子数据，分区方案 VALUE(月)+ VALUE(因子名)，按因子名+时间排序。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;525:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP 引擎是纯列式存储，不适合表过宽，若存储宽表的列数超过 80，写入性能会逐渐下降。本例中每行存储全部股票的一个因子，因此按股票代码作为宽表的列，列数过多，所以不使用宽表的方式存储。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;528:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表结构：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:2;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:6;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:7;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:8;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:9;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:31;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;tradetime&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:32;530:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;securityid&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:33;530:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factorname&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:34;530:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factorval&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:35;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:36;532:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000001&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:37;532:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:38;532:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:9;533:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:39;533:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:40;533:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000001&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:41;533:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor2&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:42;533:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;142.20&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:10;534:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:43;534:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:44;534:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000002&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:45;534:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:46;534:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;142.20&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:11;535:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:47;535:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:48;535:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000002&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:49;535:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor2&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:50;535:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;142.20&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;537:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表结构:&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:3;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;9&#34; xtrc=&#34;tgroup:3;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:10;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:11;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:12;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:13;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:14;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:15;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:16;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col8&#34; colnum=&#34;8&#34; xtrc=&#34;colspec:17;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col9&#34; colnum=&#34;9&#34; xtrc=&#34;colspec:18;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:3;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:12;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:51;539:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;tradetime&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:52;539:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factorname&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:53;539:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000001&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:54;539:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000002&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:55;539:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000003&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:56;539:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000004&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:57;539:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz000005&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:58;539:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;......&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:59;539:90&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;sz600203&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:3;541:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:13;541:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:60;541:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:61;541:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:62;541:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:63;541:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:64;541:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:65;541:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:66;541:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:67;541:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;.......&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:68;541:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:14;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:69;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2020:12:31 09:30:00&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:70;542:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;factor2&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:71;542:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:72;542:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:73;542:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:74;542:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:75;542:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:76;542:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;.......&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:77;542:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;143.20&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-因子存储&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.1. 因子存储&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;546:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;我们以存储5个因子一年的分钟级数据来进行测试，比对这三种存储模式在数据大小、实际使用的存储空间、写入速度等方面的优劣。&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:4;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;9&#34; xtrc=&#34;tgroup:4;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:19;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:20;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:21;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:22;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:23;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:24;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:25;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col8&#34; colnum=&#34;8&#34; xtrc=&#34;colspec:26;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col9&#34; colnum=&#34;9&#34; xtrc=&#34;colspec:27;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:4;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:15;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:78;549:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:79;549:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:80;549:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据总行数&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:81;549:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;单行字节&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:82;549:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:83;549:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据落盘大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:84;549:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;压缩比&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:85;549:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;写入磁盘耗时&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:86;549:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;IO峰值(m/s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:4;551:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:16;551:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:87;551:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:88;551:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:89;551:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1,268,080,000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:90;551:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:91;551:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;28.34&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:92;551:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;9.62&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:93;551:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.34&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:94;551:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;150&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:95;551:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;430&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:17;552:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:96;552:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:97;552:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:98;552:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1,268,080,000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:99;552:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:100;552:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;28.34&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:101;552:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;9.03&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:102;552:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.32&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:103;552:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;226&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:104;552:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;430&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:18;553:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:105;553:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:106;553:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:107;553:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;317,020&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:108;553:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;32,012&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:109;553:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;9.45&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:110;553:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.50&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:111;553:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.90&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:112;553:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;38&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:113;553:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;430&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;555:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;从比对结果来看，宽表 TSDB 模式的写入速度是纵表 OLAP 的4倍，纵表 TSDB 的5倍，存储空间上 OLAP 纵表和 TSDB 纵表相近，TSDB 宽表略小于前二者，压缩比上纵表 TSDB 最优，纵表 OLAP 次之，宽表 TSDB 最差。原因如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;556:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;556:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;实际产生的数据字节上，纵表模式是宽表模式的三倍，决定了宽表 TSDB 的的写入速度最优，磁盘使用空间最优，同时宽表 TSDB 模式的压缩比也会相对差一些。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;557:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;模拟数据随机性很多大，也影响了 TSDB 引擎宽表的数据压缩。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB 引擎会进行数据排序，生成索引，所以同样是纵表，TSDB 引擎在存储空间、存储速度、压缩比方面都要略逊于 OLAP 引擎。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;具体存储脚本参考&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;script/factorPractice/appendix_5.1_factorDataSimulation.zip&#34; xtrc=&#34;xref:17;560:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子数据存储模拟脚本&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-因子查询&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;563:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;563:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.2. 因子查询&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;563:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;564:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;下面我们模拟大数据量来进行查询测试，模拟4000支股票，200个因子，一年的分钟级数据，详细数据信息及分区信息见下面表格：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:5;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;10&#34; xtrc=&#34;tgroup:5;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:28;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:29;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:30;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:31;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:32;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:33;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:34;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col8&#34; colnum=&#34;8&#34; xtrc=&#34;colspec:35;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col9&#34; colnum=&#34;9&#34; xtrc=&#34;colspec:36;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col10&#34; colnum=&#34;10&#34; xtrc=&#34;colspec:37;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:5;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:19;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:114;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:115;566:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:116;566:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;股票数&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:117;566:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子数&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:118;566:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;时间跨度&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:119;566:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据级别&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:120;566:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据总行数&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:121;566:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;每行字节&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:122;566:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col10&#34; dita-ot:x=&#34;10&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:123;566:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据分区&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:5;568:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:20;568:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:124;568:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:125;568:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:126;568:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:127;568:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;200&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:128;568:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;一年&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:129;568:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟级&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:130;568:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;50,723,200,000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:131;568:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:132;568:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1133.75&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col10&#34; dita-ot:x=&#34;10&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:133;568:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日(VALUE分区)+因子(VALUE分区)&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:21;569:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:134;569:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:135;569:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:136;569:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:137;569:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;200&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:138;569:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;一年&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:139;569:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟级&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:140;569:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;50,723,200,000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:141;569:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:142;569:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1133.75&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col10&#34; dita-ot:x=&#34;10&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:143;569:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;月(VALUE分区)+因子(VALUE分区)&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:22;570:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:144;570:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:145;570:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:146;570:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;4000&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:147;570:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;200&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:148;570:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;一年&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:149;570:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟级&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:150;570:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;12,680,800&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:151;570:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;32012&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col9&#34; dita-ot:x=&#34;9&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:152;570:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;340.19&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col10&#34; dita-ot:x=&#34;10&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:153;570:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;月(VALUE分区)+因子(VALUE分区)&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;573:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;下面我们通过多个角度的查询测试来比对这三种存储方式的查询性能。&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_5.2_factorQueryTest.dos&#34; xtrc=&#34;xref:18;573:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子查询测试脚本&lt;/xref&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;575:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;575:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;575:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询1个因子1只股票指定时间点数据&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:6;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;5&#34; xtrc=&#34;tgroup:6;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:38;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:39;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:40;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:41;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:42;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:6;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:23;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:154;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:155;577:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:156;577:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询行数&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:157;577:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;字节数&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:158;577:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(ms)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:6;579:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:24;579:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:159;579:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:160;579:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:161;579:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:162;579:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:163;579:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1100&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:25;580:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:164;580:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:165;580:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:166;580:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:167;580:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;24&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:168;580:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;6&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:26;581:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:169;581:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:170;581:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:171;581:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:172;581:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;20&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:173;581:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;2&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;583:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在点查询上 TSDB 引擎优势明显，而宽表 TSDB 因为数据行数少，速度上还要快于纵表 TSDB 模式。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;585:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询1个因子1只股票一年分钟级数据&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:7;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:7;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:43;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:44;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:45;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:46;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:7;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:27;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:174;587:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:175;587:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:176;587:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(MB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:177;587:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:7;589:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:28;589:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:178;589:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:179;589:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:180;589:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.5&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:181;589:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:29;590:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:182;590:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:183;590:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:184;590:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.5&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:185;590:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.03&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:30;591:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:186;591:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:187;591:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:188;591:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.2&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:189;591:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.02&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;593:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询单因子单股票一年的分钟级数据宽表 TSDB 引擎速度最快，这是因为 TSDB 引擎分区较大，读取的文件少，且数据有排序，而 OLAP 引擎本身数据分区较小，需要扫描的行数又同样不少，所以速度最慢。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;596:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;596:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询1个因子全市场股票一年分钟级数据&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:8;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:8;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:47;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:48;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:49;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:50;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:8;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:31;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:190;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:191;598:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:192;598:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:193;598:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:8;600:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:32;600:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:194;600:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:195;600:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:196;600:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:197;600:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:33;601:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:198;601:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:199;601:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:200;601:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:201;601:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;12.4&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:34;602:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:202;602:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:203;602:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:204;602:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.9&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:205;602:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.8&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;604:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表 TSDB 读取速度最快，读取的总数据量比较大时，这几种模式都会读取很多完整分区，而宽表 TSDB 模式因为实际数据比较小，所以速度上是纵表 OLAP 的一半，是纵表 TSDB 的三分之一左右。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;607:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;607:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询3个因子全市场股票一年分钟级数据&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:9;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:9;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:51;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:52;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:53;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:54;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:9;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:35;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:206;609:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:207;609:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:208;609:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:209;609:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:9;611:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:36;611:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:210;611:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:211;611:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:212;611:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;17.0&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:213;611:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;17.7&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:37;612:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:214;612:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:215;612:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:216;612:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;17.0&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:217;612:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;25.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:38;613:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:218;613:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:219;613:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:220;613:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:221;613:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;10.7&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;615:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;更大数据量的数据读取，查询耗时线性增长，同样原因，宽表 TSDB 读取速度仍然最快。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;617:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;617:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;查询1只股票全部因子一年的分钟级数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;619:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表在进行该查询时，查询 SQL 应只选择需要股票代码列，SQL 如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;621:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//纵表查询sql, 查询全部字段，使用通配符* tsdb_symbol_all=select * from tsdb_min_factor where symbol=`sz000056 //宽表查询sql,只检索部分字段，详细列出 select mtime,factorname,sz000001 from tsdb_wide_min_factor &lt;/codeblock&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:10;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:10;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:55;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:56;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:57;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:58;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:10;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:39;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:222;629:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:223;629:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:224;629:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(MB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:225;629:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:10;631:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:40;631:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:226;631:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:227;631:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:228;631:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;312&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:229;631:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7min58s&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:41;632:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:230;632:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:231;632:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:232;632:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;312&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:233;632:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.5s&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:42;633:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:234;633:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:235;633:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:236;633:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;260&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:237;633:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;0.5s&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以上结果可以看到，宽表 TSDB 引擎和纵表 TSDB 都可以很快的查出数据，而纵表模式 OLAP 则需要百倍以上的时间才能查询出数据。这是因为纵表模式 OLAP 的分区字段是时间和因子，这种情况下查询某只股票所有的因子需要扫描全部分区的全部列才能取出所需的数据；而宽表 TSDB 引擎只需要取三列数据，所以可以很快查出数据。对比纵表 TSDB 和 OLAP 引擎的耗时，可以发现纵表 TSDB 查询速度也比较快，这是因为 TSDB 引擎按股票代码维护了索引，以实现快速检索。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;637:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;综上所述，因子的存储需根据用户的查询习惯去做规划。根据上述性能对比，本节涉及的查询推荐使用宽表 TSDB 的方式存储因子。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;53-在线获取面板数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.3. 在线获取面板数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;对于不同的存储模式，可通过以下 DolphinDB 脚本在线生成面板数据。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;643:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:31;643:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;643:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;生成1个因子全市场股票一年分钟级面板数据&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;645:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//纵表模式取面板数据sql olap_factor_year_pivot_1=select val from olap_min_factor where factorcode=`f0002 pivot by tradetime,symbol //宽表模式取面板数据sql wide_tsdb_factor_year=select * from tsdb_wide_min_factor where factorname =`f0001&lt;/codeblock&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:11;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:11;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:59;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:60;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:61;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:62;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:11;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:43;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:238;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:239;651:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:240;651:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:241;651:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:11;653:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:44;653:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:242;653:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:243;653:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:244;653:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.9&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:245;653:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;41.2&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:45;654:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:246;654:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:247;654:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:248;654:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.9&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:249;654:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;32.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:46;655:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:250;655:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:251;655:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:252;655:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;1.9&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:253;655:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;3.3&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;657:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表 TSDB 模式查询面板数据时的速度是纵表 OLAP 和纵表 TSDB 的10倍以上，这是因为宽表 TSDB 的数据本身就以类似面板数据的方式存储，不需要再转换为面板数据，而纵表模式无论 OLAP 引擎还是 TSDB 引擎查询出数据后还要使用 pivot by 进行列转行操作，这个命令要进行数据比对去重、排序等操作，所以耗时较大，数据量过大时，该部分耗时将成为一笔巨大的开销，其性能也将大幅落后于宽表 TSDB 模式。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:32;659:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;659:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;生成3个因子全市场股票一年分钟级面板数据&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;661:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//纵表模式取面板数据sql olap_factor_year_pivot=select val from olap_min_factor where factorcode in ('f0001','f0002','f0003') pivot by tradetime,symbol ,factorcode //宽表模式取面板数据sql wide_tsdb_factor_year=select * from tsdb_wide_min_factor where factorname in ('f0001','f0002','f0003')&lt;/codeblock&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:12;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:12;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:63;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:64;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:65;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:66;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:12;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:47;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:254;667:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;横纵方式&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:255;667:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据引擎&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:256;667:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;数据大小(GB)&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:257;667:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;耗时(s)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:12;669:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:48;669:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:258;669:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:259;669:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;OLAP&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:260;669:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:261;669:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;10分钟以上 中止&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:49;670:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:262;670:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;纵表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:263;670:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:264;670:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:265;670:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;10分钟以上 中止&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:50;671:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:266;671:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:267;671:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;TSDB&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:268;671:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;5.7&lt;/entry&gt;&lt;entry align=&#34;right&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:269;671:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;9.5&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;673:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;宽表 TSDB 引擎具有最佳的查询性能，随着数据量上升，纵表数据列转行操作要额外增加 piovt by 的列，从而增加更多的去重、排序操作，导致生成面板数据的耗时进一步增加。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;677:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;使用宽表 TSDB 模式存储在以下方面均有明显优势：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;678:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:33;678:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;存储空间：虽然宽表 TSDB 在压缩比上相对逊色，但是由于宽表模式本书数据字节只有纵表模式的三分之一，所以在磁盘空间上宽表 TSDB 模式使用最小；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:34;679:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;存储速度：宽表 TSDB 模式的在写入相同有效数据的情况下写入速度是纵表 OLAP 的4倍，纵表 TSDB 的5倍；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:35;680:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;直接检索数据： 宽表 TSDB 模式在不同场景的查询速度至少是纵表 OLAP 和纵表 TSDB 的1.5倍，甚至可能达到100倍以上；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:36;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以面板模式检索数据：宽表 TSDB 模式的查询速度是纵表 OLAP 和纵表 TSDB 的至少10倍以上；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:37;682:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在以非分区维度检索数据：例如，按因子分区的按股票检索数据，此场景宽表 TSDB 模式查询速度是纵表 OLAP 和纵表 TSDB 的300倍和500倍。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;684:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;综上，如果一定时期内股票和因子数量固定，因子存储的最佳选择方式为 TSDB 宽表的模式进行存储，用户可以根据实际场景的查询需求，来选择生成以股票名或因子名做为列的宽表。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-因子回测和建模&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;6. 因子回测和建模&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;688:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;很多时候，计算因子只是投研阶段的第一部分，而最重要的部分其实在于如何挑选最为有效的因子。在本章节中，将会讲述如何在DolphinDB中做因子间的相关性分析，以及回归分析。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-因子回测&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;6.1. 因子回测&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;692:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的建模和计算等，一旦从图表上分析出有方向性的结论，就要做成策略。按照确定的因子信号来设计出来的一套买卖条件，就是所谓的投资策略。把一套投资策略代入到历史数据当中，计算按照这样的策略条件去做交易是否长期有利可图的过程就是回测。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;事件驱动型回测主要用来分析少量标的，中高频的交易策略。在按因子配置投资组合的策略类型中不是核心或重点，这里不做详细阐述。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;696:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;本章主要介绍的案例是向量化的因子回测。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;首先，在k线数据上，实现了一个按多日股票收益率连乘打分的因子。之后根据分值排序高低分配标的持仓权重。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;700:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;得到分配持仓权重后，再与持仓股票的日收益率做矩阵乘法，最后按天相加，可得整个投资组合的回报率变化曲线。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;702:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;完整实例代码参考：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_6.1_vectorisedFactorBacktest_main.dos&#34; xtrc=&#34;xref:19;702:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;向量化因子回测完整代码&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62-因子相关性分析&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;6.2. 因子相关性分析&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;707:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在之前的章节中，存储因子的库表可以是多值模型，也可以是单值模型。在求因子间相关性时，推荐利用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;707:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;array vector&lt;/codeph&gt; 将同一股票同一时间的多个因子放在一个列中，这样可以避免枚举多个列名。下面以单值模型为例，演示如何有效地先在股票内求因子间相关性，然后根据股票个数求均值。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:11;709:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:38;709:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;709:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;单值模型计算因子间自相关性矩阵&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;711:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;其原理是先将当天的因子根据时间和标的，转换成 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;711:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;array vector&lt;/codeph&gt; ，再对生成的小内存表进行计算求值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;713:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;day_data = select toArray(val) as factor_value from loadTable(&#34;dfs://MIN_FACTOR_OLAP_VERTICAL&#34;,&#34;min_factor&#34;) where date(tradetime) = 2020.01.03 group by tradetime, securityid result = select toArray(matrix(factor_value).corrMatrix()) as corr from day_data group by securityid corrMatrix = result.corr.matrix().avg().reshape(size(distinct(day_data.factorname)):size(distinct(day_data.factorname)))&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;63-多因子建模&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;6.3. 多因子建模&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;721:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在大部分场景中，多因子投资模型的搭建可分为：1，简单加权法；2，回归法；两种方式均可以在 DolphinDB 中实现。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:12;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:39;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;723:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;简单加权法&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:101;725:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;对不同的因子不同的权重，计算出所有因子预测的各只股票的预期回报率的加权平均值，然后选择预期回报率最高的股票。这类方法比较简单，故不在本小节赘述。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:40;727:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:102;727:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;回归法&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:103;729:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在DolphinDB中，有很多相关的内置函数。细节使用请参考文档：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;machine_learning.md&#34; xtrc=&#34;xref:20;729:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB教程：机器学习&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:104;731:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;其中对于线性回归内置了多种模型，包括普通最小二乘法回归（OLS Regression），脊回归（Ridge Regression），广义线性模型（Generalized Linear Model）等。 目前，普通最小二乘法回归 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;732:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;olsEx&lt;/codeph&gt;，脊回归 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;732:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;ridge&lt;/codeph&gt; 中的 'cholesky' 算法，广义线性模型 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;732:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;glm&lt;/codeph&gt; 都支持分布式并行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:105;734:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;其他回归模型，DolphinDB 支持 Lasso 回归，ElasticNet 回归，随机森林回归，AdaBoost 回归等。其中，AdaBoost 回归 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;734:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;adaBoostRegressor&lt;/codeph&gt; ， &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;734:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;randomForestRegressor&lt;/codeph&gt; 支持分布式并行计算。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-因子计算的工程化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;737:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;737:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7. 因子计算的工程化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;737:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:106;739:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在实际量化投研过程，研究员要聚焦策略因子研发，而因子计算框架的开发维护通常是IT部门人员来负责，为了加强协作，通常要进行工程化管理。好的工程化管理能减少重复、冗余工作，极大的提高生产效率，使策略投研更加高效。本章节将会通过一些案例来介绍如何对因子计算进行工程化管理。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;71-代码管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;741:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;741:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.1. 代码管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;741:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:107;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的开发往往涉及到QUANT团队和IT团队。QUANT团队主要负责因子开发和维护因子逻辑代码。IT团队负责因子计算框架的开发和运维。因此要把计算框架的代码和因子本身的逻辑代码做到有效的分离，降低耦合，并且可以支持因子开发团队单独提交因子逻辑代码，计算框架能够自动更新并进行因子重算等任务。本节我们主要讨论因子逻辑代码管理，计算框架和运维请参考7.3和7.6。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:108;745:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;我们推荐用户使用自定义函数来封装核心的因子逻辑，每个因子对应一个自定义函数。DolphinDB对自定义函数的管理提供了两种方法，函数视图（Function View）和模块（Module）。函数视图的优点包括：（1）集中管理，添加到集群后，所有节点都可以使用；（2）支持权限管理。函数视图的主要缺点是无法进行模块化管理，当数量增加时，运维难度增加。模块的优缺点正好同函数视图相反。模块可以将大量函数按目录树结构组织在不同模块中。既可以在系统初始化时预加载，也可以在需要使用的时候使用use语句，引入这个模块。但是模块必须复制到每个需要使用的节点才可以使用，另外无法对模块中的函数进行权限管理。后续版本会统一函数视图和模块的优点。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;72-单元测试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:33;748:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:33;748:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.2. 单元测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:33;748:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:109;750:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;遇到因子代码重构、计算框架调整、数据库升级等情况，必须对最基本的因子逻辑进行正确性测试。DolphinDB内置了单元测试框架，可用于自动化测试。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:110;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;这个单元测试框架主要包含了以下内容：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:13;754:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:41;754:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;754:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;test&lt;/codeph&gt;函数，可以测试一个单元测试文件或一个目录下的所有单元测试文件。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:42;755:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@testing宏，用于描述一个测试case。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:43;756:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;assert语句，判断结果是否符合预期。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:44;757:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;eqObj等函数，用于测试结果是否符合预期。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:111;759:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;下面通过对因子函数factorDoubleEMA的测试来展示单元测试的撰写。全部代码请点击&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_7.2_doubleEMATest.dos&#34; xtrc=&#34;xref:21;759:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;脚本&lt;/xref&gt;。下面的代码展示了三个测试cases，两个用于批处理，一个用于流计算处理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;761:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;@testing: case = &#34;factorDoubleEMA_without_null&#34; re = factorDoubleEMA(0.1 0.1 0.2 0.2 0.15 0.3 0.2 0.5 0.1 0.2) assert 1, eqObj(re, NULL NULL NULL NULL NULL 5.788743 -7.291889 7.031123 -24.039933 -16.766359, 6) @testing: case = &#34;factorDoubleEMA_with_null&#34; re = factorDoubleEMA(NULL 0.1 0.2 0.2 0.15 NULL 0.2 0.5 0.1 0.2) assert 1, eqObj(re, NULL NULL NULL NULL NULL NULL 63.641310 60.256608 8.156385 -0.134531, 6) @testing: case = &#34;factorDoubleEMA_streaming&#34; try{dropStreamEngine(&#34;factorDoubleEMA&#34;)}catch(ex){} input = table(take(1, 10) as id, 0.1 0.1 0.2 0.2 0.15 0.3 0.2 0.5 0.1 0.2 as price) out = table(10:0, `id`price, [INT,DOUBLE]) rse = createReactiveStateEngine(name=&#34;factorDoubleEMA&#34;, metrics=&amp;lt;factorDoubleEMA(price)&amp;gt;, dummyTable=input, outputTable=out, keyColumn='id') rse.append!(input) assert 1, eqObj(out.price, NULL NULL NULL NULL NULL 5.788743 -7.291889 7.031123 -24.039933 -16.766359, 6)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;73-并行计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:34;779:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:34;779:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.3. 并行计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:34;779:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:112;781:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;到现在为止，我们讨论的都是因子的核心逻辑实现，尚未涉及通过并行计算或分布式计算来加快计算速度的问题。在因子计算的工程实践中，可以通过并行来加速的维度包括：证券（股票），因子和时间。在DolphinDB中，实现并行（或分布式）计算的技术路径有以下4个途径。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:14;782:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:45;782:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;通过SQL语句来实现隐式的并行计算。当SQL语句作用于一个分布式表时，引擎会尽可能下推计算到各个分区执行。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:46;783:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;创建多个数据源（data source），然后使用mr函数（map reduce）来实现并行计算。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:47;784:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;用户通过&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;784:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt;或&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;784:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJobEx&lt;/codeph&gt;提交多个任务。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:48;785:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;用peach或ploop实现并行。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:113;787:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;我们不建议在因子计算中采用peach或ploop的方式来实现并行。DolphinDB中可用于计算的线程分为两类，分别称之为worker和executor。一般worker用于接受一个任务（job），并将任务分解成多个子任务（task）在本地的executor或远程的worker上执行。一般executor执行的都是本地的耗时比较短的子任务，也就是说在executor上执行的任务一般不会再分解出子任务。peach或ploop将所有的子任务都在本地的exeuctor执行。如果子任务本身再分解出子任务（譬如子任务是一个分布式SQL Query），将严重影响整个系统的吞吐量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:114;789:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;下面我们讨论前三种方法在因子的并行计算中的应用。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;731-分布式sql&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:35;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:35;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.3.1. 分布式SQL&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:35;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:115;793:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分布式SQL的第一个应用是计算无状态的因子。对于无状态的因子，即计算本身可能只涉及单条记录内一个或者几个字段。这样的计算可以利用分布式表的机制，在各分区内并行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:116;795:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#快照数据的多档赋权无状态因子计算&#34; xtrc=&#34;xref:22;795:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;权重偏度因子&lt;/xref&gt;为例，此因子计算只用了一个字段，且计算逻辑不涉及前后数据，所以在SQL中调用时，DolphinDB会自动在各分区内并行计算。如果目标数据是内存表，可以使其变为内存分区表，使之并行计算。内存分区表的创建，参考&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;795:132&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;createPartitionedTable&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;797:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;resWeight = select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(BidPrice, w) as val from loadTable(&#34;dfs://LEVEL2_Snapshot_ArrayVector&#34;,&#34;Snap&#34;) where date(TradeTime) = 2020.01.02&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:117;801:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分布式SQL的第二个应用场景是计算按标的分组的时序相关因子。对于组内计算的因子，在SQL模式中，将组字段设为分区字段，可以用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;801:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;context by&lt;/codeph&gt;组字段并行。如若计算涉及到的数据不跨分区，则可以用 map 语句，加速结果输出。如若计算涉及到的数据跨分区，则SQL会在分区内并行计算，最后在结果部分检查再合并。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:118;803:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#分钟级和日级数据&#34; xtrc=&#34;xref:23;803:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;日内收益率偏度的因子 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;803:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dayReturnSkew&lt;/codeph&gt;&lt;/xref&gt;计算为例， 这个计算本身是需要对标的分组，在组内每天分别做计算。涉及到的数据为分钟频数据，数据源是按月分区，标的 HASH 3 分区。因此，我们在做计算的时候除了可以用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;803:126&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;context by&lt;/codeph&gt;组字段并行以外，还可以用 map 语句加速输出结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;805:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;minReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable(&#34;dfs://k_minute_level&#34;, &#34;k_minute&#34;) where date(tradetime) between 2020.01.02 : 2020.01.31 group by date(tradetime) as tradetime, securityid map&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;732-map-reduce&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:36;809:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:36;809:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.3.2. map reduce&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:36;809:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:119;811:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;当用户不想根据分区做并行计算时，可以通过mr函数自定义做并行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:120;813:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;以第三章中介绍的&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#sql模式&#34; xtrc=&#34;xref:24;813:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;factorDoubleEMA因子&lt;/xref&gt;为例。DoubleEMA因子的计算是对标的分组，在组内连续做窗口计算。此类计算由于将窗口的划分会跨时间分区，所以在SQL计算中会先在分区内做计算，然后最后合并再做一次计算，耗时会比较长。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:121;815:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;更合理的做法是，如果分区只按照标的分区，那么计算就可以直接在分区内做完而不用合并检查最终结果了。此时可以用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;815:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;repartitionDS&lt;/codeph&gt; 函数先将原本的数据重新分区再通过map reduce的方式做并行计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//将原数据按股票重新10个HASH分区 ds = repartitionDS(&amp;lt;select * from loadTable(&#34;dfs://k_minute_level&#34;, &#34;k_minute&#34;) where date(tradetime) between 2020.01.02 : 2020.03.31&amp;gt;, `securityid, HASH,10) def factorDoubleEMAMap(table){ return select tradetime, securityid, `doubleEMA as factorname, factorDoubleEMA(close) as val from table context by securityid map } res = mr(ds,factorDoubleEMAMap,,unionAll)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;733-通过submitjob提交任务&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:37;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:37;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.3.3. 通过submitJob提交任务&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:37;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:122;830:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;之前的两种并行计算都是在前台执行的，并行度是由参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;830:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;localExecutors&lt;/codeph&gt; 设置。而有些作业可能很大，或者用户不想影响前台使用，此时可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;830:77&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt; 提交任务。submitJob的并行度由 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;830:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;maxBatchJobWorker&lt;/codeph&gt; 参数设置。由于后台作业之间是独立的，通常不需要返回到前端的任务都推荐用后台提交 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;830:169&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt; 的形式。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:123;832:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;仍旧以 dayReturnSkew 因子为例。通常我们是需要将因子写入因子库表的，此时可以将整一个过程提交几个后台作业去执行，而在客户端中，同时可以继续做其他计算。由于此例存入的因子库的分区是按月和因子名VALUE分区，故此时应按照月份去提交作业。这样既可以并行写入不会冲突，又可以将作业提交到后台，不影响前台提交其他任务。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;def writeDayReturnSkew(dBegin,dEnd){ dReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable(&#34;dfs://k_minute_level&#34;, &#34;k_minute&#34;) where date(tradetime) between dBegin : dEnd group by date(tradetime) as tradetime, securityid //写入因子库 loadTable(&#34;dfs://K_FACTOR_VERTICAL&#34;,&#34;factor_k&#34;).append!(dReturn) } for (i in 0..11){ dBegin = monthBegin(temporalAdd(2020.01.01,i,&#34;M&#34;)) dEnd = monthEnd(temporalAdd(2020.01.01,i,&#34;M&#34;)) submitJob(&#34;writeDayReturnSkew&#34;,&#34;writeDayReturnSkew_&#34;+dBegin+&#34;_&#34;+dEnd, writeDayReturnSkew,dBegin,dEnd) }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;74-内存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:38;848:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:38;848:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.4. 内存管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:38;848:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:124;850:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;内存管理一直是运维人员和研究人员关注的重中之重，本节将从批和流两个角度简单介绍如何在DolphinDB中高效地使用内存。更多有关内存管理的详细内容，请参阅&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;memory_management.md&#34; xtrc=&#34;xref:25;850:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;850:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB内存管理教程&lt;/codeph&gt;&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:125;852:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在配置 DolphinDB 环境时，计算和事务的内存占用可在单节点的 ”dolphindb.cfg” 或集群的 cluster.cfg 中，通过参数”maxMemSize“配置单节点最大可用内存。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:15;854:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:49;854:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:126;854:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;批处理的内存管理&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:127;856:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;如&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#sql模式&#34; xtrc=&#34;xref:26;856:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;sql模式的例子&lt;/xref&gt;，若对半年的快照数据做操作，批处理方式的中间变量占用内存达到21GB，如果设置的内存小于21GB，则会报Out of Memory错误。这种情况下可以将作业拆分后再提交。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:128;858:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在调试大任务量的计算完成后，可通过 undef 函数将变量赋值为 NULL，或者关闭 session 来及时释放变量的内存。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:50;860:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:129;860:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;流计算的内存管理&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:130;862:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;如&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#数据回放&#34; xtrc=&#34;xref:27;862:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;数据回放的例子&lt;/xref&gt;，代码中对中间流表调用了函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;862:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;enableTableShareAndPersistence&lt;/codeph&gt; 以持久化，指定缓存开始为80万行。当流表数据量超过80万行时，旧的数据会持久化到磁盘上，以空出内存里的空间供新数据写入，这样该流表就可以连续处理远远超过80万行的数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;75-权限管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:39;865:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:39;865:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.5. 权限管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:39;865:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:131;867:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子数据是非常重要的数据，一般来说，用户并不能随意访问所有因子，因此需要对因子数据做好权限管理。DolphinDB database 提供了强大、灵活、安全的权限控制系统，可以满足因子库表级，函数视图级的管理。更多有关权限管理的详细内容，请参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;ACL_and_Security.md&#34; xtrc=&#34;xref:28;867:123&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;权限管理教程&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:132;869:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在实际的生产中通常使用以下三种管理方式：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:16;871:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:51;871:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:133;871:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;研发人员是管理员，完全掌握数据库&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:134;873:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;这种情况可以授予研发组 DB_OWNER 的权限(创建数据库并管理其创建的数据库的权限)，使其可以自行创建数据库、表，并对自己创建的数据、表进行权限管理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;875:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;login(&#34;admin&#34;, &#34;123456&#34;); createUser(&#34;user1&#34;, &#34;passwd1&#34;) grant(&#34;user1&#34;, DB_OWNER)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:52;881:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:135;881:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;运维人员管理数据库，研发人员只有库表的读写权限&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:136;883:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;这种情况，数据库管理人员可以将数据表的权限授予给因子研发人员，或者创建一个group组，将权限授予这个组，再将需要权限的人员添加到这个组中统一进行管理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;885:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//以用户的方式进行授权 createUser(&#34;user1&#34;, &#34;passwd1&#34;) grant(&#34;user1&#34;, TABLE_READ, &#34;dfs://db1/pt1&#34;) //以group的方式进行授权 createGroup(&#34;group1name&#34;, &#34;user1&#34;) grant(&#34;group1name&#34;, TABLE_READ, &#34;dfs://db1/pt1&#34;)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:53;895:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:137;895:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;研发人员只可读部分而非全库表数据权限&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:138;897:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;DolphinDB 本身并不直接支持表内数据级的权限控制，但是通过DolphinDB本身灵活的权限控制，我们可以通过其他方式来实现表内数据级的权限控制。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:139;899:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;这里我们可以通过对用户授予functionview 权限 VIEW_EXEC 这种方式来实现表内数据级的权限控制。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:140;901:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;完整代码参考：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_7.5.3_factorTableControll.dos&#34; xtrc=&#34;xref:29;901:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子表权限控制&lt;/xref&gt;。通过这份代码，用户&#34;u1&#34;虽然没有表的读权限，但是可以获得表内factor1因子的数据。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:31;903:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//创建用户u1,我们想授予u1 只能读取因子factor1的权限 createUser(&#34;u1&#34;, &#34;111111&#34;) //定义只取因子的函数 def getFactor1Table(){ t=select * from loadTable(&#34;dfs://db1&#34;,&#34;factor&#34;) where factor_name=&#34;factor1&#34;; return t; } //将函数保存到系统中 addFunctionView(getFactor1Table) //将该函数权限授予用户u1 grant(&#34;u1&#34;, VIEW_EXEC, &#34;getFactor1Table&#34;); //注意新授予的权限，用户需要重新登录才能加载 factor1_tab=getFactor1Table()&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;76-任务管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:40;920:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:40;920:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.6. 任务管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:40;920:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:141;922:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子计算的任务通常分为全量计算所有因子任务、交互式单因子重算任务、所有因子增量计算任务这三种，本章会对每一种因子计算任务进行详细介绍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:142;924:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子任务可以通过以下三种方式执行:&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:2;926:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:54;926:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;通过交互的方式执行。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:55;927:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;927:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt;提交一个Job来执行。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:56;928:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;通过 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;scheduledJob.md&#34; xtrc=&#34;xref:30;928:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;scheduleJob&lt;/xref&gt; 提交一个定时任务来进行周期性的执行。&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;761-全量计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:41;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:41;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.6.1. 全量计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:41;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:143;932:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的全量跑批任务，通常是系统初始化因子数据时的一次性任务，或者较长周期进行一次的任务，这类任务可以通过单次触发或者定时任务(scheduleJob)的方式进行管理。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:17;935:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:57;935:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:144;935:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;单次触发的任务：这种任务可以通过 gui 直接执行，也可以通过 api 来调用命令，最好的方式是通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;935:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt; 函数提交任务。通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;935:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;submitJob&lt;/codeph&gt; 提交的任务，会提交到服务器的Job 队列中执行，不再受客户端影响，并且可以通过&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;935:127&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;getRecentJobs&lt;/codeph&gt;观察到任务是否完成。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:32;937:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//对于跑批的任务封装函数 def bacthExeCute(){} // 通过summitjob进行提交 submitJob(&#34;batchTask&#34;,&#34;batchTask&#34;, bacthExeCute)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:58;944:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:145;944:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;周期性任务：如果计算的因子频率较低需要每天盘后或者其他周期定期全部重算一次，那我们可以使用定时任务(ScheduleJob)的方式进行管理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:33;946:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;//设置一段时间每天执行 scheduleJob(jobId=`daily, jobDesc=&#34;Daily Job 1&#34;, jobFunc=bacthExeCute, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='D')&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;762-因子运维管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:42;952:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:42;952:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;7.6.2. 因子运维管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:42;952:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:146;954:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在因子研发过程中，当碰到因子算法、参数调整的情况，我们会需要对该因子进行重新计算，同时需要将计算的新的因子数据更新到数据库中，对于因子更新的频率通常我们有两种方式：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:18;956:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:59;956:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:147;956:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的数据频率较高，数据量很大&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:148;958:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的数据频率较高，数据量很大时，我们推荐在因子数据分区时拉长时间维度，以因子名进行VALUE分区。这样可以使每个因子的数据独立的保存在一个分区中，控制分区大小在一个合适的范围。当我们碰到因子重算的情况，便可以用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;958:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dropPartition&lt;/codeph&gt;函数先删除这个因子所对应的分区数据，然后直接重算这个因子并保存到数据表中。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:60;961:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:149;961:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;因子的数据频率较低，因子的总数据量较小&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:150;963:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;当因子的数据频率较低，因子的总数据量较小时，如若将每个因子划分为独立的分区会使得每个分区特别小，而过小的分区可能会影响写入速度。这种情况下，我们可以按照因子 HASH 分区。使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;963:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;update!&lt;/codeph&gt; 来进行因子数据更新操作，或使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;963:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;upsert&lt;/codeph&gt; 来进行插入更新操作。此外，对于 TSDB 引擎，可以设置参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;963:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;keepDuplicates=LAST&lt;/codeph&gt; , 此时可以直接使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;963:192&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;append!&lt;/codeph&gt; 或者 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;963:205&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;tableInsert&lt;/codeph&gt; 插入数据，从而达到效率更高的更新数据的效果。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:151;966:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;966:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;update!&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;966:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;upsert&lt;/codeph&gt; 以及 TSDB 引擎特殊设置下的直接 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;966:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;append!&lt;/codeph&gt; 覆盖数据，这三种更新操作都建议在数据量较小，且更新不频繁的情况下使用。对于需要大量因子重算的数据更新的场景，我们推荐使用&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;966:111&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;单因子独立分区&lt;/b&gt;的方式。当因子重算时先用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;966:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;dropPartition&lt;/codeph&gt;函数删除因子所在分区，再重算写入新因子入库。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;8-实际案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:43;968:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:43;968:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8. 实际案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:43;968:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;81-日频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:44;970:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:44;970:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.1. 日频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:44;970:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:152;972:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;日频的数据，一般是由逐笔数据或者其他高频数据聚合而成。日频的数据量不大，在日频数据上经常会计算一些动量因子，或者一些复杂的需要观察长期数据的因子。因此在分区考虑上，建议按年分区即可。在因子计算上，日频因子通常会涉及时间和股票多个维度，因此建议用面板模式计算。当然也可以根据不同存储模式，选择不同的计算模式。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:153;974:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.1_case1_daily.dos&#34; xtrc=&#34;xref:31;974:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;日频因子全流程代码汇总&lt;/xref&gt;中，模拟了 10 年 4000 只股票的数据，总数据量压缩前大约为 1 GB。代码中会展现上述教程中所涉及日频因子的最佳实践，因子包括 Alpha 1、Alpha 98 ，以及不同计算方式（面板或者SQL模式）写入单值模型、多值模型的最佳实践。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;82-分钟频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:45;979:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:45;979:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.2. 分钟频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:45;979:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:154;981:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;分钟频的数据，一般是从逐笔数据或快照数据合成而来。分钟频的数据相比日频的数据较大，在分区设计上建议按月VALUE分区，股票HASH的组合分区。在分钟频的数据上，一般会计算日内的收益率等因子。对于这类因子，建议使用SQL的方式以字段作为参数。很多时候，会将投研的因子，在每日收盘之后，增量做所有因子的计算，此时，也需要对于每日增量的因子做工程化管理。建议将所有此类因子用维度表做一个维护，用定时作业将这些因子批量做计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:155;983:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.2_case2_minute.dos&#34; xtrc=&#34;xref:32;983:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;分钟频因子全流程代码汇总&lt;/xref&gt;中，模拟了一年4000只股票的数据，总数据量压缩前大约20GB。其中，会展现上述教程中所有涉及分钟频率的因子的最佳实践，因子包括日内收益偏度因子，factorDoubleEMA等因子，，后续将因子写入单值模型、多值模型的全过程，以及每日增量计算所有因子的工程化最佳实践。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;83-快照因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:46;986:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:46;986:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.3. 快照因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:46;986:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:156;988:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;快照数据，一般指3s一条的多档数据。在实际生产中，往往会根据这样的数据产生实时的因子，或根据多档报价、成交量计算，或根据重要字段做计算。这一类因子，推荐使用字段名作为自定义函数的参数。除此之外，由于快照数据的多档的特殊性，普通存储会占用很大的空间，故在存储模式上，我们也推荐将多档数据存为ArrayVector的形式。如此一来，既能节省磁盘空间，又能使代码简洁，省去选取多个重复字段的困扰。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:157;990:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.3_case3_snapshot.dos&#34; xtrc=&#34;xref:33;990:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;快照因子全流程代码汇总&lt;/xref&gt;中，模拟数据生成了20天快照数据，并将其存储为了普通快照数据和ArrayVector快照数据两种。代码中也展示了对于有状态因子flow和无状态因子权重偏度的在流批一体中的最佳实践。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;84-逐笔因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:47;992:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:47;992:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;8.4. 逐笔因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:47;992:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:158;994:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;逐笔成交数据，是交易所提供的最详细的每一笔撮合成交数据。每3秒发布一次，每次提供这3秒内的所有撮合记录。涉及逐笔成交数据的因子都是高频因子，推荐调试建模阶段可以在小数据量上使用批处理计算。一旦模型定型，就可以用批处理中同样的计算代码，迁移到流计算中实时处理(这就是所谓的批流一体)，比批处理方式节省内存，同时实时性也更高，模型迭代也更快。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:159;996:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.4_case4_streamTick.dos&#34; xtrc=&#34;xref:34;996:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔因子全流程代码汇总&lt;/xref&gt;中，会展现上述教程中所有涉及逐笔成交数据的因子计算、流计算。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;9-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:48;998:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:48;998:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;9. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:48;998:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:160;999:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;用DolphinDB来进行因子的计算时，可选择面板和SQL两种方式来封装因子的核心逻辑。面板方式使用矩阵来计算因子，实现思路非常简练；而SQL方式要求投研人员使用向量化的思路进行因子开发。无论哪种方式，DolphinDB均支持批流一体的实现。DolphinDB内置了相关性和回归分析等计算工具，可分析因子的有效性，可对多因子建模。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:161;1001:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;在因子库的规划上，如果追求灵活性，建议采用单值纵表模型。如果追求效率和性能，推荐使用TSDB引擎，启用多值宽表模式，标的（股票代码）作为表的列。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:162;1003:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;最后，基于大部分团队的IT和投研相对独立的事实，给出了在代码管理上的工程化方案，投研团队通过模块和自定义函数封装核心因子业务逻辑，IT团队则维护框架代码。同时利用权限模块有效隔离各团队之间的数据访问权限。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;10-附录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:49;1006:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:49;1006:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;10. 附录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:49;1006:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:163;1008:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.1_createTickDbAndTable_main.dos&#34; xtrc=&#34;xref:35;1008:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔数据建库建表&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:164;1010:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.2_createSnapshotDbAndTable_main.dos&#34; xtrc=&#34;xref:36;1010:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;快照数据建库建表&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:165;1012:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_2.3_createTableKMinute_main.dos&#34; xtrc=&#34;xref:37;1012:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;k线数据建库建表&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:166;1014:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.1.2_streamComputationOfSmallInflowRate_main.dos&#34; xtrc=&#34;xref:38;1014:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;流计算大小单因子&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:167;1016:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.1.3_StreamComputationOfAlpha1Factor_main.dos&#34; xtrc=&#34;xref:39;1016:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;Alpha #1流式计算&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:168;1018:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.2_streamComputationOfDoubleEmaFactor_main.dos&#34; xtrc=&#34;xref:40;1018:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;流计算doubleEma因子&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:169;1020:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/factorPractice/appendix_4.3.1_python_callback_handler_subscribing_stream_main.py&#34; xtrc=&#34;xref:41;1020:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;python接口订阅流数据&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:170;1022:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/factorPractice/appendix_4.3.2_zmq_consuming_ddb_stream_main.py&#34; xtrc=&#34;xref:42;1022:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;通过ZMQ消息队列收取DolphinDB推送来的流数据&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:171;1024:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_4.3.3_streamComputationOfDoubleEmaFactorPublishingOnZMQ_main.dos&#34; xtrc=&#34;xref:43;1024:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;流计算因子结果推送到外部ZMQ消息队列&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:172;1026:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;script/factorPractice/appendix_5.1_factorDataSimulation.zip&#34; xtrc=&#34;xref:44;1026:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子存储模拟测试&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:173;1028:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_5.2_factorQueryTest.dos&#34; xtrc=&#34;xref:45;1028:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子查询测试脚本&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:174;1030:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_6.1_vectorisedFactorBacktest_main.dos&#34; xtrc=&#34;xref:46;1030:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子向量化回测&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:175;1032:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_7.2_doubleEMATest.dos&#34; xtrc=&#34;xref:47;1032:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;单元测试&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:176;1034:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_7.5.3_factorTableControll.dos&#34; xtrc=&#34;xref:48;1034:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;因子表权限控制&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:177;1036:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.1_case1_daily.dos&#34; xtrc=&#34;xref:49;1036:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;日频因子全流程代码汇总&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:178;1038:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.2_case2_minute.dos&#34; xtrc=&#34;xref:50;1038:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;分钟频因子全流程代码汇总&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:179;1040:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.3_case3_snapshot.dos&#34; xtrc=&#34;xref:51;1040:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;快照因子全流程代码汇总&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:180;1042:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/factorPractice/appendix_8.4_case4_streamTick.dos&#34; xtrc=&#34;xref:52;1042:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔因子全流程代码汇总&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:181;1044:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;script/factorPractice/factorPractice.zip&#34; xtrc=&#34;xref:53;1044:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/best_practice_for_factor_calculation.md&#34;&gt;&lt;?ditaot usertext?&gt;所有代码附件目录&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/best_practice_for_factor_calculation.md"/><meta name="wh-out-relpath" content="tutorials/best_practice_for_factor_calculation.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="因子计算最佳实践" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/OHLC_2.html">金融场景案例</a></div></div></li><li class="active"><div class="topicref" data-id="因子计算最佳实践"><div class="title"><a href="../tutorials/best_practice_for_factor_calculation.html">因子计算最佳实践</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="k-线计算-d9713e102569" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="k-线计算-d9713e102569-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="使用-klinechart-展示-dolphindb-k-线-d9713e102615" class="topicref" data-id="使用-klinechart-展示-dolphindb-k-线" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/displaying_the_dolphindb_k-line_with_klinechart.html" id="使用-klinechart-展示-dolphindb-k-线-d9713e102615-link">使用 KLineChart 展示 DolphinDB K 线</a></div></div></li><li role="treeitem"><div data-tocid="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661" class="topicref" data-id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_HDF5_vs_DolphinDB.html" id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661-link">Python + HDF5 因子计算与 DolphinDB 一体化因子计算方案对比</a></div></div></li><li role="treeitem"><div data-tocid="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707" class="topicref" data-id="python--文件存储与-dolphindb-因子计算性能比较" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_VS_PythonFile_Storage.html" id="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707-link">Python + 文件存储与 DolphinDB 因子计算性能比较</a></div></div></li><li role="treeitem"><div data-tocid="python-parser-在金融量化分析场景的应用入门-d9713e102753" class="topicref" data-id="python-parser-在金融量化分析场景的应用入门" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/py_parser__quant_fin.html" id="python-parser-在金融量化分析场景的应用入门-d9713e102753-link">Python Parser 在金融量化分析场景的应用入门</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e102799" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc_2.html" id="处理-level-2-行情数据实例-d9713e102799-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="存储金融数据的分区方案最佳实践-d9713e102845" class="topicref" data-id="存储金融数据的分区方案最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_partitioned_storage.html" id="存储金融数据的分区方案最佳实践-d9713e102845-link">存储金融数据的分区方案最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="公募基金历史数据基础分析教程-d9713e102891" class="topicref" data-id="公募基金历史数据基础分析教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/public_fund_basic_analysis.html" id="公募基金历史数据基础分析教程-d9713e102891-link">公募基金历史数据基础分析教程</a></div></div></li><li role="treeitem"><div data-tocid="股票行情回放-d9713e102937" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay_2.html" id="股票行情回放-d9713e102937-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="搭建行情回放服务的最佳实践-d9713e102983" class="topicref" data-id="搭建行情回放服务的最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/appendices_market_replay_bp.html" id="搭建行情回放服务的最佳实践-d9713e102983-link">搭建行情回放服务的最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="国内股票行情数据导入实例-d9713e103029" class="topicref" data-id="国内股票行情数据导入实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stockdata_csv_import_demo.html" id="国内股票行情数据导入实例-d9713e103029-link">国内股票行情数据导入实例</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e103076" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV_2.html" id="基金份额参考价值-iopv-计算-d9713e103076-link">基金份额参考价值 IOPV 计算</a></div></div></li><li role="treeitem"><div data-tocid="基于快照行情的股票和基金-k-线合成-d9713e103122" class="topicref" data-id="基于快照行情的股票和基金-k-线合成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k.html" id="基于快照行情的股票和基金-k-线合成-d9713e103122-link">基于快照行情的股票和基金 K 线合成</a></div></div></li><li role="treeitem"><div data-tocid="计算基金日频因子-d9713e103168" class="topicref" data-id="计算基金日频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/fund_factor_contrasted_by_py.html" id="计算基金日频因子-d9713e103168-link">计算基金日频因子</a></div></div></li><li role="treeitem"><div data-tocid="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214" class="topicref" data-id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/orderBookSnapshotEngine.html" id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214-link">基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</a></div></div></li><li role="treeitem"><div data-tocid="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260" class="topicref" data-id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/LoadDataForPoc.html" id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260-link">金融 PoC 用户历史数据导入指导手册之股票 Level-2 逐笔篇</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e103306" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility_2.html" id="金融实时实际波动率预测-d9713e103306-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e103352" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant_2.html" id="金融因子流式实现-d9713e103352-link">金融因子流式实现</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e103398" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features_2.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e103398-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc_2.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="量化金融范例-d9713e103490" class="topicref" data-id="量化金融范例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/quant_finance_examples.html" id="量化金融范例-d9713e103490-link">量化金融范例</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e103536" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000_2.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e103536-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="深度不平衡买卖压力指标波动率计算-d9713e103583" class="topicref" data-id="深度不平衡买卖压力指标波动率计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/sql_performance_optimization_wap_di_rv.html" id="深度不平衡买卖压力指标波动率计算-d9713e103583-link">深度不平衡、买卖压力指标、波动率计算</a></div></div></li><li role="treeitem"><div data-tocid="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629" class="topicref" data-id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/insight_plugin_orderbook_engine_application.html" id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629-link">实时合成自定义频订单簿快照：DolphinDB INSIGHT 行情插件与订单簿引擎应用</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e103675" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order_2.html" id="实时计算分钟资金流-d9713e103675-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算高频因子-d9713e103721" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming_2.html" id="实时计算高频因子-d9713e103721-link">实时计算高频因子</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e103767" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily_2.html" id="实时计算日累计逐单资金流-d9713e103767-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e103813" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc_2.html" id="实时计算涨幅榜-d9713e103813-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="实时选取外汇行情多价源最优价-d9713e103859" class="topicref" data-id="实时选取外汇行情多价源最优价" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_price_selection.html" id="实时选取外汇行情多价源最优价-d9713e103859-link">实时选取外汇行情多价源最优价</a></div></div></li><li role="treeitem"><div data-tocid="外汇掉期估值计算-d9713e103905" class="topicref" data-id="外汇掉期估值计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/FxSwapValuation.html" id="外汇掉期估值计算-d9713e103905-link">外汇掉期估值计算</a></div></div></li><li role="treeitem"><div data-tocid="因子计算平台构建-d9713e103951" class="topicref" data-id="因子计算平台构建" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_Celery.html" id="因子计算平台构建-d9713e103951-link">因子计算平台构建</a></div></div></li><li role="treeitem" class="active"><div data-tocid="因子计算最佳实践-d9713e103997" class="topicref" data-id="因子计算最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practice_for_factor_calculation.html" id="因子计算最佳实践-d9713e103997-link">因子计算最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="mvo_tutorial-d9713e104043" class="topicref" data-id="mvo_tutorial" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/MVO.html" id="mvo_tutorial-d9713e104043-link">优化投资组合：DolphinDB 最优化求解系列函数应用指南</a></div></div></li><li role="treeitem"><div data-tocid="中高频多因子库存储最佳实践-d9713e104090" class="topicref" data-id="中高频多因子库存储最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_multi_factor.html" id="中高频多因子库存储最佳实践-d9713e104090-link">中高频多因子库存储最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136" class="topicref" data-id="alphalens-在-dolphindb-中的应用因子分析建模实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Practical_Factor_Analysis_Modeling.html" id="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136-link">Alphalens 在 DolphinDB 中的应用：因子分析建模实践</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-dolphinscheduler-的集成-d9713e104182" class="topicref" data-id="dolphindb-与-dolphinscheduler-的集成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphinscheduler_integration.html" id="dolphindb-与-dolphinscheduler-的集成-d9713e104182-link">DolphinDB 与 DolphinScheduler 的集成</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-python-airflow-最佳实践-d9713e104228" class="topicref" data-id="dolphindb-与-python-airflow-最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_airflow.html" id="dolphindb-与-python-airflow-最佳实践-d9713e104228-link">DolphinDB 与 Python AirFlow 最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="gplearn-d9713e104274" class="topicref" data-id="gplearn" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/gplearn.html" id="gplearn-d9713e104274-link">Shark GPLearn 快速上手</a></div></div></li><li role="treeitem"><div data-tocid="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320" class="topicref" data-id="利用jit加速计算-etf-期权隐含波动率和希腊值" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/IV_Greeks_Calculation_for_ETF_Options_Using_JIT.html" id="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320-link">利用JIT加速计算 ETF 期权隐含波动率和希腊值</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366" class="topicref" data-id="基于-dolphindb-的-brinson-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/brinson.html" id="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366-link">基于 DolphinDB 的 Brinson 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412" class="topicref" data-id="基于-dolphindb-的-campisi-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/campisi.html" id="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412-link">基于 DolphinDB 的 Campisi 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="期货分钟频cta策略回测案例-d9713e104458" class="topicref" data-id="期货分钟频cta策略回测案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/futures_minute_frequency_cta_strategy_backtest_example.html" id="期货分钟频cta策略回测案例-d9713e104458-link">期货分钟频CTA策略回测案例</a></div></div></li><li role="treeitem"><div data-tocid="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504" class="topicref" data-id="exchdata-交易所历史股票数据自动化导入功能模块使用教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/exchdata_exchange_historical_stock_data_auto_import_module_tutorial.html" id="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504-link">ExchData 交易所历史股票数据自动化导入功能模块使用教程</a></div></div></li><li role="treeitem"><div data-tocid="ficc_func_uasge_and_performance-d9713e104550" class="topicref" data-id="ficc_func_uasge_and_performance" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_func_uasge_and_performance.html" id="ficc_func_uasge_and_performance-d9713e104550-link">FICC 固收系列函数使用示例及性能</a></div></div></li><li role="treeitem"><div data-tocid="title1-d9713e104597" class="topicref" data-id="title1" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_funcs_application.html" id="title1-d9713e104597-link">FICC 固收系列函数应用场景</a></div></div></li><li role="treeitem"><div data-tocid="最优化函数_socp_的使用及转化案例-d9713e104643" class="topicref" data-id="最优化函数_socp_的使用及转化案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/socp_usage_case.html" id="最优化函数_socp_的使用及转化案例-d9713e104643-link">最优化函数 socp 的使用及转化案例</a></div></div></li><li role="treeitem"><div data-tocid="k_line_calculation-d9713e104689" class="topicref" data-id="k_line_calculation" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k_line_calculation%20.html" id="k_line_calculation-d9713e104689-link">基于期货快照行情数据计算合约 K 线以及主连行情</a></div></div></li><li role="treeitem"><div data-tocid="backtest_introduction_usage-d9713e104735" class="topicref" data-id="backtest_introduction_usage" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/backtest_introduction_usage.html" id="backtest_introduction_usage-d9713e104735-link">融资融券策略回测使用说明及回测案例</a></div></div></li><li role="treeitem"><div data-tocid="stock_backtest-d9713e104781" class="topicref" data-id="stock_backtest" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_backtest.html" id="stock_backtest-d9713e104781-link">股票中低频投资组合回测案例实现</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">因子计算最佳实践</h1><div class="- topic/body body"><p class="- topic/p p">因子挖掘是量化交易的基础。除传统的基本面因子外，从中高频行情数据中挖掘有价值的因子，并进一步建模和回测以构建交易系统，是一个量化团队的必经之路。金融或者量化金融是一个高度市场化、多方机构高度博弈的领域。因子的有效时间会随着博弈程度的加剧而缩短，如何使用更加高效的工具和流程，更快的找到新的有效的因子，是每一个交易团队必须面对的问题。</p><p class="- topic/p p">近年来，DolphinDB 越来越成为国内乃至国际上大量基金（私募和公募）、资管机构、券商自营团队进行因子挖掘的利器。基于大量客户的反馈，我们特撰写此白皮书，<strong class="+ topic/ph hi-d/b ph b">总结使用 DolphinDB 进行因子挖掘的最佳实践。</strong></p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-概述"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 概述</h2><div class="- topic/body body"><p class="- topic/p p">交易团队用于因子挖掘的常见技术栈有几个大的类别:</p><ul class="- topic/ul ul"><li class="- topic/li li">使用 python、matlab 等数据分析工具</li><li class="- topic/li li">委托第三方开发有图形界面的因子挖掘工具</li><li class="- topic/li li">使用 java、c++ 等编程语言自行开发挖掘工具</li><li class="- topic/li li">在 DolphinDB 等专业工具上进行二次开发</li></ul><p class="- topic/p p">我们暂且不讨论各个技术栈的优缺点。但不管使用何种技术栈，都必须解决以下几个问题:</p><ul class="- topic/ul ul"><li class="- topic/li li">能处理不同频率不同规模的数据集</li><li class="- topic/li li">能计算不同风格的因子</li><li class="- topic/li li">能处理因子数量不断增长的问题</li><li class="- topic/li li">能高效的存取原始数据和因子数据</li><li class="- topic/li li">能提升因子挖掘的开发效率</li><li class="- topic/li li">能提升因子计算的运行效率（高吞吐，低延时）</li><li class="- topic/li li">能解决研究的因子用于生产（实盘交易）的问题</li><li class="- topic/li li">能解决多个交易员（研究员）或交易团队一起使用时的各种工程问题，如代码管理、单元测试、权限管理、大规模计算等</li></ul><p class="- topic/p p">DolphinDB 作为分布式计算、实时流计算及分布式存储一体化的高性能时序数据库，非常适合因子的存储、计算、建模、回测和实盘交易。通过部署 DolphinDB 单机或集群环境，用户可以快速地处理 GB 级别甚至 PB 级别的海量数据集，日级、分钟级、快照和逐笔委托数据均能高效响应。</p><p class="- topic/p p">DolphinDB 内置了多范式的编程语言（函数式，命令式，向量式、SQL式），可以帮助研发人员高效开发不同风格的因子。此外，DolphinDB 还提供了丰富且性能高效的函数库（超1400个内置函数），尤其是窗口处理方面经过优化的内置算子，大大缩短了因子计算的延时。</p><p class="- topic/p p">DolphinDB 自带的数据回放和流式增量计算引擎可以方便地解决因子挖掘中研发和生产一体化的问题。DolphinDB 的分布式存储和计算框架，天生便于解决工程中的可靠性、扩展性等问题。</p><p class="- topic/p p">本文基于国内 A 股市场各个频率的数据来演示 DolphinDB 计算和规划因子库存储的方案。根据批量因子计算、实时因子计算、多因子建模、因子库存储规划、因子计算工程化等各个场景的实操演练，以及针对不同方案的对比分析，本文总结出了在 DolphinDB 中进行因子计算的最佳实践。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-测试数据集"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 测试数据集</h2><div class="- topic/body body"><p class="- topic/p p">本文的因子计算基于三类国内 A 股行情数据集：逐笔数据、快照数据和 K 线数据（分钟 K 线和日 K 线）。快照数据以两种形式存储：（1）各档数据分别存储为一列；（2）用 <a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/progr/data_types_forms/arrayVector.html" target="_blank" rel="external noopener">array vector</a> 将所有档位的数据存储为一列。</p><div class="table-container"><table class="- topic/table table" data-cols="5"><caption></caption><colgroup><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-测试数据集__entry__1">数据集</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-测试数据集__entry__2">简称</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="2-测试数据集__entry__3">代码样例中的分区数据库路径</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="2-测试数据集__entry__4">代码样例中的表名</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="2-测试数据集__entry__5">分区机制</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__1">逐笔成交</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__2">level2_tick</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__3">dfs://tick_SH_L2_TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__4">tick_SH_L2_TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__5">VALUE:每交易日, HASH: [SYMBOL, 20]</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__1">快照</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__2">level2_snapshot</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__3">dfs://snapshot_SH_L2_TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__4">snapshot_SH_L2_TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__5">VALUE:每交易日, HASH: [SYMBOL, 20]</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__1">快照(向量存储)</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__2">level2_snapshot</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__3">dfs://LEVEL2_Snapshot_ArrayVector</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__4">Snap</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__5">VALUE:每交易日, HASH: [SYMBOL, 20]</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__1">分钟K线</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__2">k_line</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__3">dfs://k_minute_level</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__4">k_minute</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__5">VALUE:交易月, HASH: [SYMBOL, 3]</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__1">日K线</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-测试数据集__entry__2">k_line</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__3">dfs://k_day_level</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__4">k_day</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="2-测试数据集__entry__5">VALUE:年</td></tr></tbody></table></div></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-逐笔成交数据"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1. 逐笔成交数据</h3><div class="- topic/body body"><br/><img class="- topic/image image" src="script/factorPractice/images/level2_tick_samples.png" alt="逐笔成交数据"/><br/><p class="- topic/p p">逐笔成交是交易所公布买卖双方具体成交的每一笔数据，每3秒发布一次，每次包含这3秒内的所有成交记录。每一笔成交撮合，都由买方和卖方的一笔具体委托组成。上述数据样例采用字段 BuyNo 和 SellNo 标注买卖双方的委托单号，其它关键字段分别为： SecurityID（标的物代码），TradeTime（成交时刻），TradePrice（成交价格），TradeQty（本笔成交量）和 TradeAmount（本笔成交金额）。</p><p class="- topic/p p">每个交易日的原始数据量在 8 GB 上下。根据上表的分区机制进行建库建表，点击查看对应脚本：<a class="- topic/xref xref" href="script/factorPractice/appendix_2.1_createTickDbAndTable_main.dos">逐笔成交数据建库建表完整代码</a>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="22-快照数据"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.2. 快照数据</h3><div class="- topic/body body"><br/><img class="- topic/image image" src="script/factorPractice/images/snapshot_samples.png" alt="快照数据"/><br/><p class="- topic/p p">股票交易所每3秒发布一次，每次涵盖这3秒结束时的日内累计成交量(TotalVolumeTrade)，日内累计成交金额(TotalValueTrade)，3秒终了时的盘口买卖双方挂单（买方为 Bid，卖方在有些数据源字段为 Offer，在有些数据源字段为 Ask，其余字段以此类推：BidPrice 为买方各档价格，OfferPrice 为卖方各档价格，OrderQty 为买卖双方各档的委托单总量， Orders 为买卖双方委托单数），3秒终了时的最近一笔成交价格（LastPx），全天开盘价（OpenPx），日内截止当下最高价（HighPx），日内截止当下最低价（LowPx）等各字段。其他和逐笔成交一致的字段不再赘述，涵义一致，详情可参见交易所数据说明字典。</p><p class="- topic/p p">每个交易日的原始数据量约在 10G 左右。</p><p class="- topic/p p">在 DolphinDB 2.0版本的 TSDB 存储引擎中，支持 array vector 的存储机制，即可以允许数据表中一个 cell 存储一个向量。在本白皮书的案例中，后面文章会详细介绍 array vector 存储方案和普通存储方案的区别。快照数据的买10档或卖10档在本例中作为一个 vector 存入单个 cell 中，其他各字段和普通快照数据表都相同。</p><p class="- topic/p p">两种存储模式的建库建表可以参考<a class="- topic/xref xref" href="script/factorPractice/appendix_2.2_createSnapshotDbAndTable_main.dos">Snapshot普通及arrayVector形式建库和建表完整代码</a></p><p class="- topic/p p">快照数据的 array_vector 存储形式：
<img class="- topic/image image" src="script/factorPractice/images/snapshot_in_array_vector_samples.png" alt="array_vector快照数据"/><br/></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="23-分钟k数据"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.3. 分钟K数据</h3><div class="- topic/body body"><br/><img class="- topic/image image" src="script/factorPractice/images/kline_samples.png" alt="分钟K数据"/><br/><p class="- topic/p p">包含每只股票，每分钟的开盘价、最高价、最低价、收盘价，四个价格字段，同时记录本分钟的成交量和成交金额。另外，数据 K 线可以依据基本字段计算衍生字段，比如：k 线均价(vwap 价格)。k 线数据是由逐笔成交数据聚合产生，具体代码可以参考<a class="- topic/xref xref" href="#%E5%9F%BA%E4%BA%8E%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E9%92%9F%E8%81%9A%E5%90%88">基于快照数据的分钟聚合</a>。</p><p class="- topic/p p">日 K 数据，存储形式和字段跟分钟 k 线一致，可以由分钟 k 线或高频数据聚合产生，这里不作赘述。</p><p class="- topic/p p">日 K 数据，分钟数据的建库建表可以参考：<a class="- topic/xref xref" href="script/factorPractice/appendix_2.3_createTableKMinute_main.dos">k 线数据建库建表完整代码</a></p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="3-投研阶段的因子计算"><h2 class="- topic/title title topictitle2" id="ariaid-title7">3. 投研阶段的因子计算</h2><div class="- topic/body body"><p class="- topic/p p">在投研阶段，会通过历史数据批量计算生成因子。通常，推荐研究员将每一种因子的计算都封装成自定义函数。根据因子类型和使用者习惯的不同，DolphinDB 提供了面板和 SQL 两种计算方式。</p><p class="- topic/p p">在面板计算中，自定义函数的参数一般为向量，矩阵或表，输出一般为向量，矩阵或表；在 SQL 模式中，自定义函数的参数一般为向量（列），输出一般为向量。因子函数的粒度尽可能小，只包含计算单个因子的业务逻辑，也不用考虑并行计算加速等问题。这样做的优点包括：（1）易于实现流批一体，（2）便于团队的因子代码提交和管理，（3）方便用统一的框架运行因子计算作业。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="31-面板数据模式"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.1. 面板数据模式</h3><div class="- topic/body body"><p class="- topic/p p">面板数据(panel data)是以时间为索引，标的为列，指标作为内容的一种数据载体，它非常适用于以标的集合为单位的指标计算，将数据以面板作为载体，可以大大简化脚本的复杂度，通常最后的计算表达式可以从原始的数学公式中一对一的翻译过来。除此之外，可以充分利用DolphinDB矩阵计算的高效能。</p><p class="- topic/p p">在因子计算中，面板数据通常可以通过<code class="+ topic/ph pr-d/codeph ph codeph">panel</code>函数，或者<code class="+ topic/ph pr-d/codeph ph codeph">exec</code>搭配<code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code>得到，具体样例如下表：每一行是一个时间点，每一列是一个股票。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>                         000001     000002  000003  000004  ...
                        --------- ---------- ------- ------ ---
2020.01.02T09:29:00.000|3066.336 3212.982  257.523 2400.042 ...
2020.01.02T09:30:00.000|3070.247  3217.087 258.696 2402.221 ...
2020.01.02T09:31:00.000|3070.381 3217.170  259.066 2402.029 ...</code></pre><p class="- topic/p p">在面板数据上，由于是以时间为索引，标的为列，因子可以方便地在截面上做各类运算。DolphinDB 包含 row 系列函数以及各类滑动窗口函数，在下面两个因子计算例子中，原本复杂的计算逻辑，在面板数据中，可以用一行代码轻松实现。</p><ul class="- topic/ul ul"><li class="- topic/li li">Alpha 1 因子计算中，下例使用了rowRank 函数，可以在面板数据中的每一个时间截面对各标的进行排名；iif 条件运算，可以在标的向量层面直接筛选及计算；mimax 及 mstd 等滑动窗口函数也是在标的层面垂直计算的。因此，在面板计算中合理应用 DolphinDB 的内置函数，可以从不同维度进行计算。</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//alpha 1 
//Alpha#001公式：rank(Ts_ArgMax(SignedPower((returns&lt;0?stddev(returns,20):close), 2), 5))-0.5

@state
def alpha1TS(close){
	return mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20),close), 2.0), 5)
}

def alpha1Panel(close){
	return rowRank(X=alpha1TS(close), percent=true) - 0.5
}

input = exec close from loadTable("dfs://k_minute","k_minute") where date(tradetime) between 2020.01.01 : 2020.01.31 pivot by tradetime, securityid
res = alpha1Panel(input)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">Alpha 98 因子计算中，同时使用了三个面板数据，分别是vwap, open和vol。不仅各矩阵内部运用了rowRank函数横向截面运算以及m系列垂直滑动窗口计算，矩阵之间也进行了二元运算。用一行代码解决了多维度的复杂的嵌套计算逻辑。</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//alpha 98
//Alpha #98计算公式:
(rank(decay_linear(correlation(vwap, sum(adv5, 26.4719), 4.58418), 7.18088)) -
rank(decay_linear(Ts_Rank(Ts_ArgMin(correlation(rank(open), rank(adv15), 20.8187), 8.62571), 6.95668), 8.07206)))

def prepareDataForDDBPanel(raw_data, start_time, end_time){
	t = select tradetime,securityid, vwap,vol,open from raw_data where date(tradetime) between start_time : end_time
	return dict(`vwap`open`vol, panel(t.tradetime, t.securityid, [t.vwap, t.open, t.vol]))
}

@state
def alpha98Panel(vwap, open, vol){
	return rowRank(X = mavg(mcorr(vwap, msum(mavg(vol, 5), 26), 5), 1..7),percent=true) - rowRank(X=mavg(mrank(9 - mimin(mcorr(rowRank(X=open,percent=true), rowRank(X=mavg(vol, 15),percent=true), 21), 9), true, 7), 1..8),percent=true)
}

raw_data = loadTable("dfs://k_minute","k_day")
start_time = 2020.01.01
end_time = 2020.12.31
input = prepareDataForDDBPanel(raw_data, start_time, end_time)
timer alpha98DDBPanel = alpha98Panel(input.vwap, input.open, input.vol)</code></pre><p class="- topic/p p">基于面板数据的因子计算，耗时主要在面板数据准备和因子计算两个阶段。在很多场景下，面板数据准备的耗时可能超过因子计算本身。为解决这个问题，DolphinDB的TSDB引擎提供了宽表存储，即把面板数据直接存储在数据库表中（面板中每一个列存储为表中的每一个列），这样通过SQL查询可以直接获取面板数据，而不需要通过转置行列来获取，从而大大缩短准备面板数据的时间。在本文的第5章中，我们有详细的宽表和竖表存储性能的对比。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="32-sql模式"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.2. SQL模式</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB在存储和计算框架上都是基于列式结构，表中的一个列可以直接作为一个向量化函数的输入参数。因此如果一个因子的计算逻辑只涉及股票自身的时间序列数据，不涉及多个股票横截面上的信息，可以直接在SQL中按股票分组，然后在select中调用因子函数计算每个股票在一段时间内的因子值。如果数据在数据库中本身是按股票分区存储的，那么可以非常高效地实现数据库内并行计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)\(x+y)
}

@state
def factorDoubleEMA(price){
    ema_2 = ema(price, 2)
    ema_4 = ema(price, 4)
    sum_diff_1000 = 1000 * sum_diff(ema_2, ema_4)
    return ema(sum_diff_1000, 2) - ema(sum_diff_1000, 3)
}

res = select tradetime, securityid, `doubleEMA as factorname, factorDoubleEMA(close) as val from loadTable("dfs://k_minute","k_minute") where  tradetime between 2020.01.01 : 2020.01.31 context by securityid</code></pre><p class="- topic/p p">在上面的例子中，我们定义了一个因子函数 factorDoubleEMA，只需要用到股票的价格序列信息。我们在 SQL 中通过 <code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 子句按股票代码分组，然后调用factorDoubleEMA函数，计算每个股票的因子序列。值得注意的是，<code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 是 DolphinDB SQL 对 <code class="+ topic/ph pr-d/codeph ph codeph">group by</code> 的扩展，是 DolphinDB 特有的 SQL 语句。<code class="+ topic/ph pr-d/codeph ph codeph">group by</code> 只适用于聚合计算，也就是说输入长度为n，输出长度是1。<code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 适用于向量计算，输入长度是n，输出长度也是n。另外因子函数 factorDOubleEMA 除了可以接受一个向量作为输入，也可以接受一个面板数据作为输入。这也是我们前面强调的，因子函数的粒度尽可能细，这样可以应用于很多场景。</p><p class="- topic/p p">时间序列的因子函数非常普遍，talib 中的所有技术分析指标都属于此类函数，因此都可以使用上述SQL方式或面板数据模式来调用。但是3.1中提到的 alpha1 和 alpha98 等因子，涉及到时间序列和横截面两个维度的计算，我们称之为截面因子，无法将因子逻辑封装在一个自定义函数中，然后在一个 SQL 语句中被调用。通常面对截面因子，我们建议将表作为自定义因子函数的入参，内部用 SQL 进行操作，函数最后返回一个表。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//alpha1
def alpha1SQL(t){
	res = select tradetime, securityid, mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5) as val from t context by securityid
	return select tradetime, securityid, rank(val, percent=true) - 0.5 as val from res context by tradetime
}
input = select tradetime,securityid, close from loadTable("dfs://k_day_level","k_day") where tradetime between 2010.01.01 : 2010.12.31
alpha1DDBSql = alpha1SQL(input)

//alpha98
def alpha98SQL(mutable t){
	update t set adv5 = mavg(vol, 5), adv15 = mavg(vol, 15) context by securityid
	update t set rank_open = rank(X = open,percent=true), rank_adv15 =rank(X=adv15,percent=true) context by date(tradetime)
	update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by securityid
	return select tradetime,securityid, `alpha98 as factorname, rank(X =decay7,percent=true)-rank(X =decay8,percent=true) as val from t context by date(tradetime)
}
input = select tradetime,securityid, vwap,vol,open from  loadTable("dfs://k_day_level","k_day") where tradetime between 2010.01.01 : 2010.12.31
alpha98DDBSql = alpha98SQL(input)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="33-不同频率的因子开发举例"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.3. 不同频率的因子开发举例</h3><div class="- topic/body body"><p class="- topic/p p">不同频率数据的因子，有着不同的特点。本章节将分别举例分钟频、日频、快照、逐笔数据的特点因子，阐述不同频率数据计算因子的最佳实践。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="331-分钟级和日级数据"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.3.1. 分钟级和日级数据</h4><div class="- topic/body body"><p class="- topic/p p">日级数据的计算，通常是涉及多个截面的复杂计算，在<a class="- topic/xref xref" href="#%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F">面板数据模式</a>中已展现。对于稍简单的计算，则与分钟级数据的因子相像。</p><p class="- topic/p p">针对分钟级数据，下面的例子是日内收益率偏度的因子计算，对于这类只涉及表内字段的计算，通常使用 SQL 模式，配合 <code class="+ topic/ph pr-d/codeph ph codeph">group by</code> 语句将计算分组：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg dayReturnSkew(close){
	return skew(ratios(close))	
}

minReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable("dfs://k_minute_level", "k_minute") where date(tradetime) between 2020.01.02 : 2020.01.31 group by date(tradetime) as tradetime, securityid

// output
tradetime  securityid factorname    val               
---------- ---------- ------------- -------
2020.01.02 000019     dayReturnSkew 11.8328
2020.01.02 000048     dayReturnSkew 11.0544
2020.01.02 000050     dayReturnSkew 10.6186</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="332-基于快照数据的有状态因子计算"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.3.2. 基于快照数据的有状态因子计算</h4><div class="- topic/body body"><p class="- topic/p p">有状态的因子，意为因子的计算需要基于之前的计算结果，如一般的滑动窗口计算，聚合计算等，都是有状态的因子计算。</p><p class="- topic/p p">下例flow这个自定义函数中，参数为四个列字段，运用 <code class="+ topic/ph pr-d/codeph ph codeph">mavg</code> 滑动平均函数以及 <code class="+ topic/ph pr-d/codeph ph codeph">iif</code> 条件运算函数，可以直接在SQL中得到因子结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def flow(buy_vol, sell_vol, askPrice1, bidPrice1){
        buy_vol_ma = round(mavg(buy_vol, 5*60), 5)
        sell_vol_ma = round(mavg(sell_vol, 5*60), 5)
        buy_prop = iif(abs(buy_vol_ma+sell_vol_ma) &lt; 0, 0.5 , buy_vol_ma/ (buy_vol_ma+sell_vol_ma))
        spd = askPrice1 - bidPrice1
        spd = iif(spd &lt; 0, 0, spd)
        spd_ma = round(mavg(spd, 5*60), 5)
        return iif(spd_ma == 0, 0, buy_prop / spd_ma)
}

res_flow = select TradeTime, SecurityID, `flow as factorname, flow(BidOrderQty[1],OfferOrderQty[1], OfferPrice[1], BidPrice[1]) as val from loadTable("dfs://LEVEL2_Snapshot_ArrayVector","Snap") where date(TradeTime) &lt;= 2020.01.30 and date(TradeTime) &gt;= 2020.01.01 context by SecurityID

// output sample
TradeTime               SecurityID factorname val              
----------------------- ---------- ---------- -----------------
2020.01.22T14:46:27.000 110065     flow       3.7587
2020.01.22T14:46:30.000 110065     flow       3.7515
2020.01.22T14:46:33.000 110065     flow       3.7443
...</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="333-快照数据的多档赋权无状态因子计算"><h4 class="- topic/title title topictitle4" id="ariaid-title13">3.3.3. 快照数据的多档赋权无状态因子计算</h4><div class="- topic/body body"><p class="- topic/p p">计算Level 2的多档快照数据，传统的方式是将多档量价数据存储成为多个列, 再将多档挂单或者报价用 matrix 转换与权重做计算。
更推荐的做法是，将多档数据存储为 array vector，仍旧可以用原来的自定义函数，但是资源消耗包括效率都有提升。
下面的例子是计算多档报价的权重偏度因子，使用 array vector 后计算时间从4秒缩短到2秒。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def mathWghtCovar(x, y, w){
	v = (x - rowWavg(x, w)) * (y - rowWavg(y, w))
	return rowWavg(v, w)
}

@state
def mathWghtSkew(x, w){
	x_var = mathWghtCovar(x, x, w)
	x_std = sqrt(x_var)
	x_1 = x - rowWavg(x, w)
	x_2 = x_1*x_1
	len = size(w)
	adj = sqrt((len - 1) * len) \ (len - 2)
	skew = rowWsum(x_2, x_1) \ (x_var * x_std) * adj \ len
	return iif(x_std==0, 0, skew)
}

//weights:
w = 10 9 8 7 6 5 4 3 2 1

//权重偏度因子：
resWeight =  select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(BidPrice, w)  as val from loadTable("dfs://LEVEL2_Snapshot_ArrayVector","Snap")  where date(TradeTime) = 2020.01.02 map
resWeight1 =  select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(matrix(BidPrice0,BidPrice1,BidPrice2,BidPrice3,BidPrice4,BidPrice5,BidPrice6,BidPrice7,BidPrice8,BidPrice9), w)  as val from loadTable("dfs://snapshot_SH_L2_TSDB", "snapshot_SH_L2_TSDB")  where date(TradeTime) = 2020.01.02 map

// output
TradeTime               SecurityID factorname val               
----------------------- ---------- ---------- ------
...
2020.01.02T09:30:09.000 113537     array_1    -0.8828 
2020.01.02T09:30:12.000 113537     array_1    0.7371 
2020.01.02T09:30:15.000 113537     array_1    0.6041 
...</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="334-基于快照数据的分钟聚合"><h4 class="- topic/title title topictitle4" id="ariaid-title14">3.3.4. 基于快照数据的分钟聚合</h4><div class="- topic/body body"><p class="- topic/p p">投研中经常需要基于快照数据聚合分钟线的 OHLC ，下例就是这一场景中的通用做法：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//基于快照因子的分钟聚合OHLC，vwap
tick_aggr = select first(LastPx) as open, max(LastPx) as high, min(LastPx) as low, last(LastPx) as close, sum(totalvolumetrade) as vol,sum(lastpx*totalvolumetrade) as val,wavg(lastpx, totalvolumetrade) as vwap from loadTable("dfs://LEVEL2_Snapshot_ArrayVector","Snap") where date(TradeTime) &lt;= 2020.01.30 and date(TradeTime) &gt;= 2020.01.01 group by SecurityID, bar(TradeTime,1m) </code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="335-逐笔数据"><h4 class="- topic/title title topictitle4" id="ariaid-title15">3.3.5. 逐笔数据</h4><div class="- topic/body body"><p class="- topic/p p">逐笔数据量较大，一般会针对成交量等字段进行计算，下面的例子计算了每天主买成交量占全部成交量的比例，同样使用 SQL 模式，发挥库内并行计算的优势，并使用 csort 语句用来对组内数据按照时间顺序排序：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def buyTradeRatio(buyNo, sellNo, tradeQty){
    return cumsum(iif(buyNo&gt;sellNo, tradeQty, 0))\cumsum(tradeQty)
}

factor = select TradeTime, SecurityID, `buyTradeRatio as factorname, buyTradeRatio(BuyNo, SellNo, TradeQty) as val from loadTable("dfs://tick_SH_L2_TSDB","tick_SH_L2_TSDB") where date(TradeTime)&lt;2020.01.31 and time(TradeTime)&gt;=09:30:00.000 context by SecurityID, date(TradeTime) csort TradeTime

// output
TradeTime           SecurityID factorname val              
------------------- ---------- ---------- ------
2020.01.08T09:30:07 511850     buyTradeRatio    0.0086
2020.01.08T09:30:31 511850     buyTradeRatio    0.0574
2020.01.08T09:30:36 511850     buyTradeRatio    0.0569
...</code></pre></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title16" id="4-生产环境的流式因子计算"><h2 class="- topic/title title topictitle2" id="ariaid-title16">4. 生产环境的流式因子计算</h2><div class="- topic/body body"><p class="- topic/p p">在生产环境中，DolphinDB 提供了实时流计算框架。在流计算框架下，用户在投研阶段封装好的基于批量数据开发的因子函数，可以无缝投入交易和投资方面的生产程序中，这就是通常所说的批流一体。使用流批一体可以加速用户的开发和部署。同时流计算框架还在算法的路径上，做了极致的优化，在具有高效开发的优势的同时，又兼顾了计算的高效性能。在这一章中，将会基于实际的状态因子案例，展示实时流计算的使用方法。</p><p class="- topic/p p">DolphinDB 流计算解决方案的核心部件是流计算引擎和流数据表。流计算引擎用于时间序列处理、横截面处理、窗口处理、表关联、异常检测等操作。流数据表可以看作是一个简化版的消息中间件，或者说是消息中间件中的一个主题（topic），可以往其发布（publish）数据，也可以从其订阅（subscribe）数据。流计算引擎和流数据表均继承于 DolphinDB 的数据表（table），因此都可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">append!</code> 函数往其注入数据。流计算引擎的输出也是数据表的形式，因此多个计算引擎可以跟搭积木一样自由组合，形成流式处理的流水线。</p><br/><img class="- topic/image image" src="script/factorPractice/images/factor_streams.png" alt="因子数据流处理流程图"/><br/></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="41-流式增量计算"><h3 class="- topic/title title topictitle3" id="ariaid-title17">4.1. 流式增量计算</h3><div class="- topic/body body"><p class="- topic/p p">金融方面的原始数据和计算指标，在时间上通常有延续性的关系。以最简单的五周期移动均线 <code class="+ topic/ph pr-d/codeph ph codeph">mavg(close,5)</code> 为例，当新一个周期的数据传入模型时，可以将之前最远的第五周期值从 sum 中减出，再把最新一个周期的值加入 sum ，这样就不必每个周期只更新一个值时都重算一遍 sum 。这种增量计算是流计算的核心，可以大大降低实时计算的延时。DolphinDB内置了大量量化金融中需要用到的基本算子，并为这些算子实现了高效的增量算法。不仅如此，DolphinDB还支持自定义函数的增量实现。在前一章节中，部分自定义的因子函数加了修饰符 <code class="+ topic/ph pr-d/codeph ph codeph">@state</code> ，表示该函数支持增量计算。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="411-主买成交量占比因子的流式处理"><h4 class="- topic/title title topictitle4" id="ariaid-title18">4.1.1. 主买成交量占比因子的流式处理</h4><div class="- topic/body body"><p class="- topic/p p"><a class="- topic/xref xref" href="#%E9%80%90%E7%AC%94%E6%95%B0%E6%8D%AE">逐笔数据</a>的逐笔数据因子的例子展示了主买成交量占比因子（buyTradeRatio）的批量实现方式。以下代码演示如何使用响应式状态引擎（reactive state engine）来实现该因子的流式增量计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def buyTradeRatio(buyNo, sellNo, tradeQty){
    return cumsum(iif(buyNo&gt;sellNo, tradeQty, 0))\cumsum(tradeQty)
}

tickStream = table(1:0, `SecurityID`TradeTime`TradePrice`TradeQty`TradeAmount`BuyNo`SellNo, [SYMBOL,DATETIME,DOUBLE,INT,DOUBLE,LONG,LONG])
result = table(1:0, `SecurityID`TradeTime`Factor, [SYMBOL,DATETIME,DOUBLE])
factors = &lt;[TradeTime, buyTradeRatio(BuyNo, SellNo, TradeQty)]&gt;
demoEngine = createReactiveStateEngine(name="demo", metrics=factors, dummyTable=tickStream, outputTable=result, keyColumn="SecurityID")</code></pre><p class="- topic/p p">上述代码创建了一个名为demo的响应式状态引擎，SecurityID作为分组键，输入的消息格式同内存表tickStream。需要计算的指标定义在factors中，其中1个是输入表中的原始字段TradeTime，另一个是我们需要计算的因子的函数表示。输出到内存表result，除了在factors中定义的指标外，输出结果还会添加分组键。请注意，自定义的因子函数跟批计算中的完全一致！创建完引擎之后，我们即可往引擎中插入几条数据，并观察计算结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>insert into demoEngine values(`000155, 2020.01.01T09:30:00, 30.85, 100, 3085, 4951, 0)
insert into demoEngine values(`000155, 2020.01.01T09:30:01, 30.86, 100, 3086, 4951, 1)
insert into demoEngine values(`000155, 2020.01.01T09:30:02, 30.80, 200, 6160, 5501, 5600)

select * from result

SecurityID TradeTime           Factor
---------- ------------------- ------
000155     2020.01.01T09:30:00 1
000155     2020.01.01T09:30:01 1
000155     2020.01.01T09:30:02 0.5</code></pre><p class="- topic/p p">从这个例子可以看出，在DolphinDB中实现因子的流式增量计算非常简单。如果在投研阶段，已经用我们推荐的方式自定义了一个因子函数，在生产阶段只要程序性的创建一个流式计算引擎即可实现目标。这也是为什么我们一再强调，自定义的因子函数必须使用规范的接口，而且只包含核心的因子逻辑，不用考虑并行计算等问题。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title19" id="412-大小单的流式处理"><h4 class="- topic/title title topictitle4" id="ariaid-title19">4.1.2. 大小单的流式处理</h4><div class="- topic/body body"><p class="- topic/p p">资金流分析是逐笔委托数据的一个重要应用场景。在实时处理逐笔数据时，大小单的统计是资金流分析的一个具体应用。大小单在一定程度上能反映主力、散户的动向。但在实时场景中，大小单的生成有很多难点：（1） 大小单的计算涉及历史状态，如若不能实现增量计算，当计算下午的数据时，可能需要回溯有关这笔订单上午的数据，效率会非常低下。 （2）计算涉及至少两个阶段。在第一阶段需要根据订单分组，根据订单的累计成交量判断大小单，在第二阶段要根据股票来分组，统计每个股票的大小单数量及金额。</p><p class="- topic/p p">大小单是一个动态的概念。一个小单在成交量增加后可能变成一个大单。DolphinDB的两个内置函数<code class="+ topic/ph pr-d/codeph ph codeph">dynamicGroupCumsum</code>和<code class="+ topic/ph pr-d/codeph ph codeph">dynamicGroupCumcount</code>用于对动态组的增量计算。完整的代码请参考：<a class="- topic/xref xref" href="script/factorPractice/appendix_4.1.2_streamComputationOfSmallInflowRate_main.dos">大小单的流式处理</a>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def factorSmallOrderNetAmountRatio(tradeAmount, sellCumAmount, sellOrderFlag, prevSellCumAmount, prevSellOrderFlag, buyCumAmount, buyOrderFlag, prevBuyCumAmount, prevBuyOrderFlag){
	cumsumTradeAmount = cumsum(tradeAmount)
	smallSellCumAmount, bigSellCumAmount = dynamicGroupCumsum(sellCumAmount, prevSellCumAmount, sellOrderFlag, prevSellOrderFlag, 2)
	smallBuyCumAmount, bigBuyCumAmount = dynamicGroupCumsum(buyCumAmount, prevBuyCumAmount, buyOrderFlag, prevBuyOrderFlag, 2) 
	f = (smallBuyCumAmount - smallSellCumAmount) \ cumsumTradeAmount
	return smallBuyCumAmount, smallSellCumAmount, cumsumTradeAmount, f
}

def createStreamEngine(result){
	tradeSchema = createTradeSchema()
	result1Schema = createResult1Schema()
	result2Schema = createResult2Schema()
	engineNames = ["rse1", "rse2", "res3"]
	cleanStreamEngines(engineNames)
	
	metrics3 = &lt;[TradeTime, factorSmallOrderNetAmountRatio(tradeAmount, sellCumAmount, sellOrderFlag, prevSellCumAmount, prevSellOrderFlag, buyCumAmount, buyOrderFlag, prevBuyCumAmount, prevBuyOrderFlag)]&gt;
	rse3 = createReactiveStateEngine(name=engineNames[2], metrics=metrics3, dummyTable=result2Schema, outputTable=result, keyColumn="SecurityID")
	
	metrics2 = &lt;[BuyNo, SecurityID, TradeTime, TradeAmount, BuyCumAmount, PrevBuyCumAmount, BuyOrderFlag, PrevBuyOrderFlag, factorOrderCumAmount(TradeAmount)]&gt;
	rse2 = createReactiveStateEngine(name=engineNames[1], metrics=metrics2, dummyTable=result1Schema, outputTable=rse3, keyColumn="SellNo")
	
	metrics1 = &lt;[SecurityID, SellNo, TradeTime, TradeAmount, factorOrderCumAmount(TradeAmount)]&gt;
	return createReactiveStateEngine(name=engineNames[0], metrics=metrics1, dummyTable=tradeSchema, outputTable=rse2, keyColumn="BuyNo")
}</code></pre><p class="- topic/p p">自定义函数<code class="+ topic/ph pr-d/codeph ph codeph">factorSmallOrderNetAmountRatio</code>是一个状态因子函数，用于计算小单的净流入资金占总的交易资金的比例。<code class="+ topic/ph pr-d/codeph ph codeph">createStreamEngine</code>创建流式计算引擎。我们一共创建了3个级联的响应式状态引擎，后一个作为前一个的输出，因此从最后一个引擎开始创建。前两个计算引擎rse1和rse2分别以买方订单号（BuyNo)和卖方订单号（SellNo）作为分组键，计算每个订单的累计交易量，并以此区分是大单或小单。第三个引擎rse3把股票代码（SecurityID）作为分组键，统计每个股票的小单净流入资金占总交易资金的比例。下面我们输入一些样本数据来观察流计算引擎的运行。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>result = createResultTable()
rse = createStreamEngine(result)
insert into rse values(`000155, 1000, 1001, 2020.01.01T09:30:00, 20000)
insert into rse values(`000155, 1000, 1002, 2020.01.01T09:30:01, 40000)
insert into rse values(`000155, 1000, 1003, 2020.01.01T09:30:02, 60000)
insert into rse values(`000155, 1004, 1003, 2020.01.01T09:30:03, 30000)

select * from result

SecurityID TradeTime smallBuyOrderAmount smallSellOrderAmount totalOrderAmount factor
---------- ------------------- ------------------- -------------------- ---------------- ------
000155     2020.01.01T09:30:00 20000               20000                20000            0
000155     2020.01.01T09:30:01 60000               60000                60000            0
000155     2020.01.01T09:30:02 0                   120000               120000           -1
000155     2020.01.01T09:30:03 30000               150000               150000           -0.8</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title20" id="413-复杂因子alpha-1流式计算的快捷实现"><h4 class="- topic/title title topictitle4" id="ariaid-title20">4.1.3. 复杂因子Alpha #1流式计算的快捷实现</h4><div class="- topic/body body"><p class="- topic/p p">从前一个大小单的例子可以看到，有些因子的流式实现比较复杂，需要创建多个引擎进行流水线处理来完成。完全用手工的方式来创建多个引擎其实是一件耗时的工作。如果输入的指标计算只涉及一个分组键，DolphinDB提供了一个解析引擎<code class="+ topic/ph pr-d/codeph ph codeph">streamEngineParser</code>来解决此问题。下面我们以面板数据模式一节的alpha #1因子为例，展示<code class="+ topic/ph pr-d/codeph ph codeph">streamEngineParser</code>的使用方法。完整代码参考<a class="- topic/xref xref" href="script/factorPractice/appendix_4.1.3_StreamComputationOfAlpha1Factor_main.dos">Alpha #1流式计算</a>。以下为核心代码。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def alpha1TS(close){
	return mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20),close), 2.0), 5)
}

def alpha1Panel(close){
	return rowRank(X=alpha1TS(close), percent=true) - 0.5
}

inputSchema = table(1:0, ["SecurityID","TradeTime","close"], [SYMBOL,TIMESTAMP,DOUBLE])
result = table(10000:0, ["TradeTime","SecurityID", "factor"], [TIMESTAMP,SYMBOL,DOUBLE])
metrics = &lt;[SecurityID, alpha1Panel(close)]&gt;
streamEngine = streamEngineParser(name="alpha1Parser", metrics=metrics, dummyTable=inputSchema, outputTable=result, keyColumn="SecurityID", timeColumn=`tradetime, triggeringPattern='keyCount', triggeringInterval=4000)</code></pre><p class="- topic/p p">因子alpha1实际上包含了时间序列处理和横截面处理，需要响应式状态引擎和横截面引擎串联来处理才能完成。但以上代码仅仅使用了streamEngineParser就创建了全部引擎，大大简化了创建过程。</p><p class="- topic/p p">前面三个例子展示了DolphinDB如何通过流计算引擎实现因子在生产环境中的增量计算。值得注意的是，流式计算时直接使用了投研阶段生成的核心因子代码，这很好的解决了传统金融分析面临的批流一体问题。在传统的研究框架下，用户往往需要对同一个因子计算逻辑写两套代码，一套用于在历史数据上建模、回测，另外一套专门处理盘中传入的实时数据。这是因为数据传入程序的形状(机制)不统一，又甚至是编程语言也无法统一。比如研究分析使用了 python 或者 R，在 python 或 R 的研究程序确定模型和参数后，生产交易的程序必须用 C++ 再实现这套模型，才能保证交易时的执行效率。在两套代码完成后，还要再校验它们计算出来的结果是否一致。这样的业务流程毫无疑问加重了研究员和程序员们的负担，也让基金经理们没法更快地让新交易思路迭代上线。在DolphinDB的流式计算中，实时行情订阅、行情数据收录、交易实时计算、盘后研究建模，全都用同一套代码完成，保证在历史回放和生产交易当中数据完全一致。</p><p class="- topic/p p">除了三个例子中用到的响应式状态引擎(reactive state engine)和横截面引擎（cross sectional engine），DolphinDB 还提供了多种流数据处理引擎包括做流表连接的 asof join engine，equal join engine，lookup join engine，window join engine ，时间序列聚合引擎（time series engine），异常检测引擎(anomaly detection engine)，会话窗口引擎（session window engine）等。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="42-数据回放"><h3 class="- topic/title title topictitle3" id="ariaid-title21">4.2. 数据回放</h3><div class="- topic/body body"><p class="- topic/p p">前一节我们介绍了因子计算的批流一体实现方案，简单地说，就是一套代码（自定义的因子函数），两种引擎（批计算引擎和流计算引擎）。事实上，DolphinDB提供一种更为简洁的批流一体实现方案，那就是在历史数据建模时，通过数据回放，也用流引擎来实现计算。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="#sql%E6%A8%A1%E5%BC%8F">SQL语句方式批处理计算factorDoubleEMA因子</a>的例子中，这里介绍如何使用流计算的方式回放数据，计算 factorDoubleEMA 的因子值。全部代码参考<a class="- topic/xref xref" href="script/factorPractice/appendix_4.2_streamComputationOfDoubleEmaFactor_main.dos">流计算factorDoubleEMA因子</a></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//创建流引擎，并传入因子算法factorDoubleEMA
factors = &lt;[TradeTime, factorDoubleEMA(close)]&gt;
demoEngine = createReactiveStateEngine(name=engineName, metrics=factors, dummyTable=inputDummyTable, outputTable=resultTable, keyColumn="SecurityID")
	
//demo_engine订阅snapshotStreamTable流数据表
subscribeTable(tableName=snapshotSharedTableName, actionName=actionName, handler=append!{demoEngine}, msgAsTable=true)

//创建播放数据源供replay函数历史回放；盘中的时候，改为行情数据直接写入snapshotStreamTable流数据表
inputDS = replayDS(&lt;select SecurityID, TradeTime, LastPx from tableHandle where date(TradeTime)&lt;2020.07.01&gt;, `TradeTime, `TradeTime)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title22" id="43-对接交易系统"><h3 class="- topic/title title topictitle3" id="ariaid-title22">4.3. 对接交易系统</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 本身具有多种常用编程语言的API，包括C++, java, javascript, c#, python, go等。使用这些语言的程序，都可以调用该语言的 DolphinDB 接口，订阅到 DolphinDB 服务器的流数据。本例提供一个简单的<a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.1_python_callback_handler_subscribing_stream_main.py">python接口订阅流数据</a>样例。</p><p class="- topic/p p">DolphinDB-Python API订阅流数据例子：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>current_ddb_session.subscribe(host=DDB_datanode_host,tableName=stream_table_shared_name,actionName=action_name,offset=0,resub=False,filter=None,port=DDB_server_port,
handler=python_callback_handler,#此处传入python端要接收消息的回调函数
)</code></pre><p class="- topic/p p">在金融生产环境中，更常见的情况，是流数据实时的灌注到消息队列中，供下游的其他模块消费。DolphinDB 也支持将实时计算结果推送到消息中间件，与交易程序对接。示例中提供的样例，使用 DolphinDB 的开源 ZMQ 插件，将实时计算的结果推送到 ZMQ 消息队列，供下游ZMQ协议的订阅程序消费(交易或展示)。除ZMQ之外，其他支持的工具都在 <a class="- topic/xref xref" href="plugin_development_tutorial.html">DolphinDB 插件库</a>中提供。所有已有的 DolphinDB 插件都是开源的，插件的编写组件也是开源的，用户也可按自己的需要编写。</p><p class="- topic/p p">DolphinDB向ZMQ消息队列推送流数据代码样例：</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">启动下游的ZMQ数据消费程序，作为监听端(ZeroMQ消息队列的服务端)，完整代码见<a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.2_zmq_consuming_ddb_stream_main.py">向ZMQ推送流数据</a></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>zmq_context = Context()
zmq_bingding_socket = zmq_context.socket(SUB)#见完整版代码设定socket选项
zmq_bingding_socket.bind("tcp://*:55556")		
async def loop_runner():    
    while True:
        msg=await zmq_bingding_socket.recv()#阻塞循环until收到流数据
        print(msg)#在此编写下游消息处理代码	
asyncio.run(loop_runner())</code></pre></li><li class="- topic/li li"><p class="- topic/p p">启动因子数据的流处理计算和发布</p><p class="- topic/p p">在外部消费ZMQ消息的程序启动后，DolphinDB端要启动流计算，并开始对外发布计算结果。以下是<a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.3_streamComputationOfDoubleEmaFactorPublishingOnZMQ_main.dos">DolphinDB端的代码</a>。输出结果表之前的所有代码部分，和<a class="- topic/xref xref" href="#%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%BE">流处理计算doubleEma因子</a>例子的一致，故下例代码中不再赘述。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>resultSchema=table(1:0,["SecurityID","TradeTime","factor"], [SYMBOL,TIMESTAMP,DOUBLE])//输出到消息队列的表结构

def zmqPusherTable(zmqSubscriberAddress,schemaTable){
	SignalSender=def (x) {return x}
	pushingSocket = zmq::socket("ZMQ_PUB", SignalSender)
	zmq::connect(pushingSocket, zmqSubscriberAddress)
	pusher = zmq::createPusher(pushingSocket, schemaTable)
	return pusher
}

zmqSubscriberAddress="tcp://192.168.1.195:55556"//引擎demoEngine向zmq队列推送，使用时根据不同的zmq地址修改此字符串

pusherTable=zmqPusherTable(zmqSubscriberAddress,resultSchema)//生成一个逻辑表向上述地址发送zmq包，字段结构参照resultSchema

demoEngine = createReactiveStateEngine(name="reactiveDemo", metrics=&lt;[TradeTime,doubleEma(LastPx)]&gt;, dummyTable=snapshotSchema, outputTable=pusherTable, keyColumn="SecurityID",keepOrder=true)//创建流引擎，output指定输出到pusher表</code></pre></li></ol></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title23" id="5-因子的存储和查询"><h2 class="- topic/title title topictitle2" id="ariaid-title23">5. 因子的存储和查询</h2><div class="- topic/body body"><p class="- topic/p p">无论是批量计算还是实时计算，将 DolphinDB 中计算生成的因子保存下来提供给投研做后续的分析都是很有意义的。本章主要是根据存储、查询，使用方式等方面，来分析如何基于使用场景来选择更高效的存储模型。本章测试均为在 Linux 系统上部署的单节点集群，其中包含三个数据节点，每个节点设置16线程并采用三块固态硬盘进行数据存贮。</p><p class="- topic/p p">在实际考虑数据存储方案，我们需要从以下三个方面考虑：</p><ul class="- topic/ul ul"><li class="- topic/li li">选择 OLAP 引擎还是 TSDB 引擎。OLAP 最适合全量跑批计算，TSDB 则在序列查询上优势突出，性能和功能上比较全面。</li><li class="- topic/li li">因子的存储方式是单值纵表方式还是多值宽表方式。 单值方式的最大优点是灵活性强，增加因子和股票时，不用修改表结构；缺点是数据冗余度高。多值宽表的数据冗余度很低，配合 TSDB 引擎的<code class="+ topic/ph pr-d/codeph ph codeph">array vector</code>，使用宽表结构节省了行数，提高了存储效率，但若出现新因子或新股票，需要重新生成因子表。</li><li class="- topic/li li">分区方式选择。可用于分区的列包括时间列，股票代码列和因子列。OLAP 引擎推荐的分区大小为原始数据100MB左右。为保证最佳性能，TSDB 引擎推荐单分区数据量大小保持在 100MB-1GB 范围内性能最佳。</li></ul><p class="- topic/p p">结合以上考虑因素，我们以4000只股票，1000个因子，存储分钟级因子库为例，有如下三种选择：</p><ul class="- topic/ul ul"><li class="- topic/li li">以纵表存储,使用 OLAP 引擎，每行按时间存储一只股票一个因子数据，分区方案 VALUE(月)+ VALUE(因子名)。</li><li class="- topic/li li">以纵表存储,使用 TSDB 引擎，每行按时间存储一只股票一个因子数据，分区方案 VALUE(月)+ VALUE(因子名)， 按股票代码+时间排序。</li><li class="- topic/li li">以宽表存储,使用 TSDB 引擎，每行按时间存储全部股票一个因子，或者一支股票全部因子数据，分区方案 VALUE(月)+ VALUE(因子名)，按因子名+时间排序。</li></ul><p class="- topic/p p">OLAP 引擎是纯列式存储，不适合表过宽，若存储宽表的列数超过 80，写入性能会逐渐下降。本例中每行存储全部股票的一个因子，因此按股票代码作为宽表的列，列数过多，所以不使用宽表的方式存储。</p><p class="- topic/p p">纵表结构：</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="5-因子的存储和查询__entry__1">tradetime</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__2">securityid</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__3">factorname</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__4">factorval</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__1">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__2">sz000001</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__3">factor1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__4">143.20</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__1">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__2">sz000001</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__3">factor2</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__4">142.20</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__1">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__2">sz000002</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__3">factor1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__4">142.20</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__1">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__2">sz000002</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__3">factor2</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__4">142.20</td></tr></tbody></table></div><p class="- topic/p p">宽表结构:</p><div class="table-container"><table class="- topic/table table" data-cols="9"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="5-因子的存储和查询__entry__21">tradetime</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__22">factorname</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__23">sz000001</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__24">sz000002</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__25">sz000003</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__26">sz000004</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__27">sz000005</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__28">......</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="5-因子的存储和查询__entry__29">sz600203</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__21">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__22">factor1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__23">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__24">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__25">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__26">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__27">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__28">.......</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__29">143.20</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__21">2020:12:31 09:30:00</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__22">factor2</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__23">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__24">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__25">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__26">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__27">143.20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__28">.......</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="5-因子的存储和查询__entry__29">143.20</td></tr></tbody></table></div></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="51-因子存储"><h3 class="- topic/title title topictitle3" id="ariaid-title24">5.1. 因子存储</h3><div class="- topic/body body"><p class="- topic/p p">我们以存储5个因子一年的分钟级数据来进行测试，比对这三种存储模式在数据大小、实际使用的存储空间、写入速度等方面的优劣。</p><div class="table-container"><table class="- topic/table table" data-cols="9"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="51-因子存储__entry__1">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="51-因子存储__entry__2">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__3">数据总行数</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__4">单行字节</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__5">数据大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__6">数据落盘大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__7">压缩比</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__8">写入磁盘耗时</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="51-因子存储__entry__9">IO峰值(m/s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__2">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__3">1,268,080,000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__4">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__5">28.34</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__6">9.62</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__7">0.34</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__8">150</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__9">430</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__3">1,268,080,000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__4">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__5">28.34</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__6">9.03</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__7">0.32</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__8">226</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__9">430</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__1">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="51-因子存储__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__3">317,020</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__4">32,012</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__5">9.45</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__6">8.50</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__7">0.90</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__8">38</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="51-因子存储__entry__9">430</td></tr></tbody></table></div><p class="- topic/p p">从比对结果来看，宽表 TSDB 模式的写入速度是纵表 OLAP 的4倍，纵表 TSDB 的5倍，存储空间上 OLAP 纵表和 TSDB 纵表相近，TSDB 宽表略小于前二者，压缩比上纵表 TSDB 最优，纵表 OLAP 次之，宽表 TSDB 最差。原因如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">实际产生的数据字节上，纵表模式是宽表模式的三倍，决定了宽表 TSDB 的的写入速度最优，磁盘使用空间最优，同时宽表 TSDB 模式的压缩比也会相对差一些。</li><li class="- topic/li li">模拟数据随机性很多大，也影响了 TSDB 引擎宽表的数据压缩。</li><li class="- topic/li li">TSDB 引擎会进行数据排序，生成索引，所以同样是纵表，TSDB 引擎在存储空间、存储速度、压缩比方面都要略逊于 OLAP 引擎。</li></ul><p class="- topic/p p">具体存储脚本参考<a class="- topic/xref xref" href="script/factorPractice/appendix_5.1_factorDataSimulation.zip">因子数据存储模拟脚本</a>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title25" id="52-因子查询"><h3 class="- topic/title title topictitle3" id="ariaid-title25">5.2. 因子查询</h3><div class="- topic/body body"><p class="- topic/p p">下面我们模拟大数据量来进行查询测试，模拟4000支股票，200个因子，一年的分钟级数据，详细数据信息及分区信息见下面表格：</p><div class="table-container"><table class="- topic/table table" data-cols="10"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__1">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__2">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__3">股票数</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__4">因子数</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__5">时间跨度</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__6">数据级别</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__7">数据总行数</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__8">每行字节</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__9">数据大小(GB)</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__10">数据分区</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__2">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__3">4000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__4">200</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__5">一年</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__6">分钟级</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__7">50,723,200,000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__8">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__9">1133.75</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__10">日(VALUE分区)+因子(VALUE分区)</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__3">4000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__4">200</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__5">一年</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__6">分钟级</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__7">50,723,200,000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__8">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__9">1133.75</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__10">月(VALUE分区)+因子(VALUE分区)</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__1">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__3">4000</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__4">200</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__5">一年</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__6">分钟级</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__7">12,680,800</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__8">32012</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__9">340.19</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__10">月(VALUE分区)+因子(VALUE分区)</td></tr></tbody></table></div><p class="- topic/p p">下面我们通过多个角度的查询测试来比对这三种存储方式的查询性能。<a class="- topic/xref xref" href="script/factorPractice/appendix_5.2_factorQueryTest.dos">因子查询测试脚本</a></p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">查询1个因子1只股票指定时间点数据</p><div class="table-container"><table class="- topic/table table" data-cols="5"><caption></caption><colgroup><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__41">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__42">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__43">查询行数</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__44">字节数</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__45">耗时(ms)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__41">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__42">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__43">1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__44">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__45">1100</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__41">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__42">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__43">1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__44">24</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__45">6</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__41">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__42">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__43">1</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__44">20</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__45">2</td></tr></tbody></table></div><p class="- topic/p p">在点查询上 TSDB 引擎优势明显，而宽表 TSDB 因为数据行数少，速度上还要快于纵表 TSDB 模式。</p></li><li class="- topic/li li"><p class="- topic/p p">查询1个因子1只股票一年分钟级数据</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__61">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__62">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__63">数据大小(MB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__64">耗时(s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__61">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__62">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__63">1.5</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__64">0.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__61">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__62">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__63">1.5</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__64">0.03</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__61">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__62">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__63">1.2</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__64">0.02</td></tr></tbody></table></div><p class="- topic/p p">查询单因子单股票一年的分钟级数据宽表 TSDB 引擎速度最快，这是因为 TSDB 引擎分区较大，读取的文件少，且数据有排序，而 OLAP 引擎本身数据分区较小，需要扫描的行数又同样不少，所以速度最慢。</p></li><li class="- topic/li li"><p class="- topic/p p">查询1个因子全市场股票一年分钟级数据</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__77">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__78">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__79">数据大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__80">耗时(s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__77">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__78">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__79">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__80">8.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__77">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__78">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__79">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__80">12.4</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__77">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__78">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__79">1.9</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__80">3.8</td></tr></tbody></table></div><p class="- topic/p p">宽表 TSDB 读取速度最快，读取的总数据量比较大时，这几种模式都会读取很多完整分区，而宽表 TSDB 模式因为实际数据比较小，所以速度上是纵表 OLAP 的一半，是纵表 TSDB 的三分之一左右。</p></li><li class="- topic/li li"><p class="- topic/p p">查询3个因子全市场股票一年分钟级数据</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__93">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__94">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__95">数据大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__96">耗时(s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__93">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__94">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__95">17.0</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__96">17.7</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__93">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__94">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__95">17.0</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__96">25.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__93">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__94">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__95">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__96">10.7</td></tr></tbody></table></div><p class="- topic/p p">更大数据量的数据读取，查询耗时线性增长，同样原因，宽表 TSDB 读取速度仍然最快。</p></li><li class="- topic/li li"><p class="- topic/p p">查询1只股票全部因子一年的分钟级数据</p><p class="- topic/p p">宽表在进行该查询时，查询 SQL 应只选择需要股票代码列，SQL 如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//纵表查询sql, 查询全部字段，使用通配符*
tsdb_symbol_all=select  * from tsdb_min_factor where symbol=`sz000056 

//宽表查询sql,只检索部分字段，详细列出
select mtime,factorname,sz000001 from tsdb_wide_min_factor
</code></pre><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__109">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="52-因子查询__entry__110">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__111">数据大小(MB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="52-因子查询__entry__112">耗时</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__109">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__110">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__111">312</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__112">7min58s</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__109">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__110">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__111">312</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__112">1.5s</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__109">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="52-因子查询__entry__110">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__111">260</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="52-因子查询__entry__112">0.5s</td></tr></tbody></table></div></li></ul><p class="- topic/p p">以上结果可以看到，宽表 TSDB 引擎和纵表 TSDB 都可以很快的查出数据，而纵表模式 OLAP 则需要百倍以上的时间才能查询出数据。这是因为纵表模式 OLAP 的分区字段是时间和因子，这种情况下查询某只股票所有的因子需要扫描全部分区的全部列才能取出所需的数据；而宽表 TSDB 引擎只需要取三列数据，所以可以很快查出数据。对比纵表 TSDB 和 OLAP 引擎的耗时，可以发现纵表 TSDB 查询速度也比较快，这是因为 TSDB 引擎按股票代码维护了索引，以实现快速检索。</p><p class="- topic/p p">综上所述，因子的存储需根据用户的查询习惯去做规划。根据上述性能对比，本节涉及的查询推荐使用宽表 TSDB 的方式存储因子。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title26" id="53-在线获取面板数据"><h3 class="- topic/title title topictitle3" id="ariaid-title26">5.3. 在线获取面板数据</h3><div class="- topic/body body"><p class="- topic/p p">对于不同的存储模式，可通过以下 DolphinDB 脚本在线生成面板数据。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">生成1个因子全市场股票一年分钟级面板数据</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//纵表模式取面板数据sql
olap_factor_year_pivot_1=select val from olap_min_factor where factorcode=`f0002 pivot by tradetime,symbol 
//宽表模式取面板数据sql
wide_tsdb_factor_year=select * from tsdb_wide_min_factor where factorname =`f0001</code></pre><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="53-在线获取面板数据__entry__1">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="53-在线获取面板数据__entry__2">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="53-在线获取面板数据__entry__3">数据大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="53-在线获取面板数据__entry__4">耗时(s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__2">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__3">1.9</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__4">41.2</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__1">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__3">1.9</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__4">32.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__1">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__2">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__3">1.9</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__4">3.3</td></tr></tbody></table></div><p class="- topic/p p">宽表 TSDB 模式查询面板数据时的速度是纵表 OLAP 和纵表 TSDB 的10倍以上，这是因为宽表 TSDB 的数据本身就以类似面板数据的方式存储，不需要再转换为面板数据，而纵表模式无论 OLAP 引擎还是 TSDB 引擎查询出数据后还要使用 pivot by 进行列转行操作，这个命令要进行数据比对去重、排序等操作，所以耗时较大，数据量过大时，该部分耗时将成为一笔巨大的开销，其性能也将大幅落后于宽表 TSDB 模式。</p></li><li class="- topic/li li"><p class="- topic/p p">生成3个因子全市场股票一年分钟级面板数据</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//纵表模式取面板数据sql
olap_factor_year_pivot=select val from olap_min_factor where factorcode in ('f0001','f0002','f0003') pivot by tradetime,symbol ,factorcode
//宽表模式取面板数据sql
wide_tsdb_factor_year=select * from tsdb_wide_min_factor where factorname in ('f0001','f0002','f0003')</code></pre><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="53-在线获取面板数据__entry__17">横纵方式</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="53-在线获取面板数据__entry__18">数据引擎</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="53-在线获取面板数据__entry__19">数据大小(GB)</th><th class="- topic/entry entry align-right colsep-0 rowsep-0" id="53-在线获取面板数据__entry__20">耗时(s)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__17">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__18">OLAP</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__19">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__20">10分钟以上 中止</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__17">纵表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__18">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__19">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__20">10分钟以上 中止</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__17">宽表</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__18">TSDB</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__19">5.7</td><td class="- topic/entry entry align-right colsep-0 rowsep-0" headers="53-在线获取面板数据__entry__20">9.5</td></tr></tbody></table></div></li></ul><p class="- topic/p p">宽表 TSDB 引擎具有最佳的查询性能，随着数据量上升，纵表数据列转行操作要额外增加 piovt by 的列，从而增加更多的去重、排序操作，导致生成面板数据的耗时进一步增加。</p><p class="- topic/p p">使用宽表 TSDB 模式存储在以下方面均有明显优势：</p><ul class="- topic/ul ul"><li class="- topic/li li">存储空间：虽然宽表 TSDB 在压缩比上相对逊色，但是由于宽表模式本书数据字节只有纵表模式的三分之一，所以在磁盘空间上宽表 TSDB 模式使用最小；</li><li class="- topic/li li">存储速度：宽表 TSDB 模式的在写入相同有效数据的情况下写入速度是纵表 OLAP 的4倍，纵表 TSDB 的5倍；</li><li class="- topic/li li">直接检索数据： 宽表 TSDB 模式在不同场景的查询速度至少是纵表 OLAP 和纵表 TSDB 的1.5倍，甚至可能达到100倍以上；</li><li class="- topic/li li">以面板模式检索数据：宽表 TSDB 模式的查询速度是纵表 OLAP 和纵表 TSDB 的至少10倍以上；</li><li class="- topic/li li">在以非分区维度检索数据：例如，按因子分区的按股票检索数据，此场景宽表 TSDB 模式查询速度是纵表 OLAP 和纵表 TSDB 的300倍和500倍。</li></ul><p class="- topic/p p">综上，如果一定时期内股票和因子数量固定，因子存储的最佳选择方式为 TSDB 宽表的模式进行存储，用户可以根据实际场景的查询需求，来选择生成以股票名或因子名做为列的宽表。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title27" id="6-因子回测和建模"><h2 class="- topic/title title topictitle2" id="ariaid-title27">6. 因子回测和建模</h2><div class="- topic/body body"><p class="- topic/p p">很多时候，计算因子只是投研阶段的第一部分，而最重要的部分其实在于如何挑选最为有效的因子。在本章节中，将会讲述如何在DolphinDB中做因子间的相关性分析，以及回归分析。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title28" id="61-因子回测"><h3 class="- topic/title title topictitle3" id="ariaid-title28">6.1. 因子回测</h3><div class="- topic/body body"><p class="- topic/p p">因子的建模和计算等，一旦从图表上分析出有方向性的结论，就要做成策略。按照确定的因子信号来设计出来的一套买卖条件，就是所谓的投资策略。把一套投资策略代入到历史数据当中，计算按照这样的策略条件去做交易是否长期有利可图的过程就是回测。</p><p class="- topic/p p">事件驱动型回测主要用来分析少量标的，中高频的交易策略。在按因子配置投资组合的策略类型中不是核心或重点，这里不做详细阐述。</p><p class="- topic/p p">本章主要介绍的案例是向量化的因子回测。</p><p class="- topic/p p">首先，在k线数据上，实现了一个按多日股票收益率连乘打分的因子。之后根据分值排序高低分配标的持仓权重。</p><p class="- topic/p p">得到分配持仓权重后，再与持仓股票的日收益率做矩阵乘法，最后按天相加，可得整个投资组合的回报率变化曲线。</p><p class="- topic/p p">完整实例代码参考：<a class="- topic/xref xref" href="script/factorPractice/appendix_6.1_vectorisedFactorBacktest_main.dos">向量化因子回测完整代码</a></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="62-因子相关性分析"><h3 class="- topic/title title topictitle3" id="ariaid-title29">6.2. 因子相关性分析</h3><div class="- topic/body body"><p class="- topic/p p">在之前的章节中，存储因子的库表可以是多值模型，也可以是单值模型。在求因子间相关性时，推荐利用 <code class="+ topic/ph pr-d/codeph ph codeph">array vector</code> 将同一股票同一时间的多个因子放在一个列中，这样可以避免枚举多个列名。下面以单值模型为例，演示如何有效地先在股票内求因子间相关性，然后根据股票个数求均值。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">单值模型计算因子间自相关性矩阵</p><p class="- topic/p p">其原理是先将当天的因子根据时间和标的，转换成 <code class="+ topic/ph pr-d/codeph ph codeph">array vector</code> ，再对生成的小内存表进行计算求值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>day_data = select toArray(val) as factor_value from loadTable("dfs://MIN_FACTOR_OLAP_VERTICAL","min_factor") where date(tradetime) = 2020.01.03 group by tradetime, securityid
result = select toArray(matrix(factor_value).corrMatrix()) as corr from day_data group by securityid
corrMatrix = result.corr.matrix().avg().reshape(size(distinct(day_data.factorname)):size(distinct(day_data.factorname)))</code></pre></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title30" id="63-多因子建模"><h3 class="- topic/title title topictitle3" id="ariaid-title30">6.3. 多因子建模</h3><div class="- topic/body body"><p class="- topic/p p">在大部分场景中，多因子投资模型的搭建可分为：1，简单加权法；2，回归法；两种方式均可以在 DolphinDB 中实现。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">简单加权法</p><p class="- topic/p p">对不同的因子不同的权重，计算出所有因子预测的各只股票的预期回报率的加权平均值，然后选择预期回报率最高的股票。这类方法比较简单，故不在本小节赘述。</p></li><li class="- topic/li li"><p class="- topic/p p">回归法</p><p class="- topic/p p">在DolphinDB中，有很多相关的内置函数。细节使用请参考文档：<a class="- topic/xref xref" href="machine_learning.html">DolphinDB教程：机器学习</a></p><p class="- topic/p p">其中对于线性回归内置了多种模型，包括普通最小二乘法回归（OLS Regression），脊回归（Ridge Regression），广义线性模型（Generalized Linear Model）等。
目前，普通最小二乘法回归 <code class="+ topic/ph pr-d/codeph ph codeph">olsEx</code>，脊回归 <code class="+ topic/ph pr-d/codeph ph codeph">ridge</code> 中的 'cholesky' 算法，广义线性模型 <code class="+ topic/ph pr-d/codeph ph codeph">glm</code> 都支持分布式并行计算。</p><p class="- topic/p p">其他回归模型，DolphinDB 支持 Lasso 回归，ElasticNet 回归，随机森林回归，AdaBoost 回归等。其中，AdaBoost 回归 <code class="+ topic/ph pr-d/codeph ph codeph">adaBoostRegressor</code> ， <code class="+ topic/ph pr-d/codeph ph codeph">randomForestRegressor</code> 支持分布式并行计算。</p></li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title31" id="7-因子计算的工程化"><h2 class="- topic/title title topictitle2" id="ariaid-title31">7. 因子计算的工程化</h2><div class="- topic/body body"><p class="- topic/p p">在实际量化投研过程，研究员要聚焦策略因子研发，而因子计算框架的开发维护通常是IT部门人员来负责，为了加强协作，通常要进行工程化管理。好的工程化管理能减少重复、冗余工作，极大的提高生产效率，使策略投研更加高效。本章节将会通过一些案例来介绍如何对因子计算进行工程化管理。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title32" id="71-代码管理"><h3 class="- topic/title title topictitle3" id="ariaid-title32">7.1. 代码管理</h3><div class="- topic/body body"><p class="- topic/p p">因子的开发往往涉及到QUANT团队和IT团队。QUANT团队主要负责因子开发和维护因子逻辑代码。IT团队负责因子计算框架的开发和运维。因此要把计算框架的代码和因子本身的逻辑代码做到有效的分离，降低耦合，并且可以支持因子开发团队单独提交因子逻辑代码，计算框架能够自动更新并进行因子重算等任务。本节我们主要讨论因子逻辑代码管理，计算框架和运维请参考7.3和7.6。</p><p class="- topic/p p">我们推荐用户使用自定义函数来封装核心的因子逻辑，每个因子对应一个自定义函数。DolphinDB对自定义函数的管理提供了两种方法，函数视图（Function View）和模块（Module）。函数视图的优点包括：（1）集中管理，添加到集群后，所有节点都可以使用；（2）支持权限管理。函数视图的主要缺点是无法进行模块化管理，当数量增加时，运维难度增加。模块的优缺点正好同函数视图相反。模块可以将大量函数按目录树结构组织在不同模块中。既可以在系统初始化时预加载，也可以在需要使用的时候使用use语句，引入这个模块。但是模块必须复制到每个需要使用的节点才可以使用，另外无法对模块中的函数进行权限管理。后续版本会统一函数视图和模块的优点。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title33" id="72-单元测试"><h3 class="- topic/title title topictitle3" id="ariaid-title33">7.2. 单元测试</h3><div class="- topic/body body"><p class="- topic/p p">遇到因子代码重构、计算框架调整、数据库升级等情况，必须对最基本的因子逻辑进行正确性测试。DolphinDB内置了单元测试框架，可用于自动化测试。</p><p class="- topic/p p">这个单元测试框架主要包含了以下内容：</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">test</code>函数，可以测试一个单元测试文件或一个目录下的所有单元测试文件。</li><li class="- topic/li li">@testing宏，用于描述一个测试case。</li><li class="- topic/li li">assert语句，判断结果是否符合预期。</li><li class="- topic/li li">eqObj等函数，用于测试结果是否符合预期。</li></ul><p class="- topic/p p">下面通过对因子函数factorDoubleEMA的测试来展示单元测试的撰写。全部代码请点击<a class="- topic/xref xref" href="script/factorPractice/appendix_7.2_doubleEMATest.dos">脚本</a>。下面的代码展示了三个测试cases，两个用于批处理，一个用于流计算处理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@testing: case = "factorDoubleEMA_without_null"
re = factorDoubleEMA(0.1 0.1 0.2 0.2 0.15 0.3 0.2 0.5 0.1 0.2)
assert 1, eqObj(re, NULL NULL NULL NULL NULL 5.788743 -7.291889 7.031123 -24.039933 -16.766359, 6)

@testing: case = "factorDoubleEMA_with_null"
re = factorDoubleEMA(NULL 0.1 0.2 0.2 0.15 NULL 0.2 0.5 0.1 0.2)
assert 1, eqObj(re, NULL NULL NULL NULL NULL NULL 63.641310 60.256608  8.156385 -0.134531, 6)

@testing: case = "factorDoubleEMA_streaming"
try{dropStreamEngine("factorDoubleEMA")}catch(ex){}
input = table(take(1, 10) as id, 0.1 0.1 0.2 0.2 0.15 0.3 0.2 0.5 0.1 0.2 as price)
out = table(10:0, `id`price, [INT,DOUBLE])
rse = createReactiveStateEngine(name="factorDoubleEMA", metrics=&lt;factorDoubleEMA(price)&gt;, dummyTable=input, outputTable=out, keyColumn='id')
rse.append!(input)
assert 1, eqObj(out.price, NULL NULL NULL NULL NULL 5.788743 -7.291889 7.031123 -24.039933 -16.766359, 6)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title34" id="73-并行计算"><h3 class="- topic/title title topictitle3" id="ariaid-title34">7.3. 并行计算</h3><div class="- topic/body body"><p class="- topic/p p">到现在为止，我们讨论的都是因子的核心逻辑实现，尚未涉及通过并行计算或分布式计算来加快计算速度的问题。在因子计算的工程实践中，可以通过并行来加速的维度包括：证券（股票），因子和时间。在DolphinDB中，实现并行（或分布式）计算的技术路径有以下4个途径。</p><ul class="- topic/ul ul"><li class="- topic/li li">通过SQL语句来实现隐式的并行计算。当SQL语句作用于一个分布式表时，引擎会尽可能下推计算到各个分区执行。</li><li class="- topic/li li">创建多个数据源（data source），然后使用mr函数（map reduce）来实现并行计算。</li><li class="- topic/li li">用户通过<code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code>或<code class="+ topic/ph pr-d/codeph ph codeph">submitJobEx</code>提交多个任务。</li><li class="- topic/li li">用peach或ploop实现并行。</li></ul><p class="- topic/p p">我们不建议在因子计算中采用peach或ploop的方式来实现并行。DolphinDB中可用于计算的线程分为两类，分别称之为worker和executor。一般worker用于接受一个任务（job），并将任务分解成多个子任务（task）在本地的executor或远程的worker上执行。一般executor执行的都是本地的耗时比较短的子任务，也就是说在executor上执行的任务一般不会再分解出子任务。peach或ploop将所有的子任务都在本地的exeuctor执行。如果子任务本身再分解出子任务（譬如子任务是一个分布式SQL Query），将严重影响整个系统的吞吐量。</p><p class="- topic/p p">下面我们讨论前三种方法在因子的并行计算中的应用。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title35" id="731-分布式sql"><h4 class="- topic/title title topictitle4" id="ariaid-title35">7.3.1. 分布式SQL</h4><div class="- topic/body body"><p class="- topic/p p">分布式SQL的第一个应用是计算无状态的因子。对于无状态的因子，即计算本身可能只涉及单条记录内一个或者几个字段。这样的计算可以利用分布式表的机制，在各分区内并行计算。</p><p class="- topic/p p">以<a class="- topic/xref xref" href="#%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E6%A1%A3%E8%B5%8B%E6%9D%83%E6%97%A0%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97">权重偏度因子</a>为例，此因子计算只用了一个字段，且计算逻辑不涉及前后数据，所以在SQL中调用时，DolphinDB会自动在各分区内并行计算。如果目标数据是内存表，可以使其变为内存分区表，使之并行计算。内存分区表的创建，参考<code class="+ topic/ph pr-d/codeph ph codeph">createPartitionedTable</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>resWeight =  select TradeTime, SecurityID, `mathWghtSkew as factorname, mathWghtSkew(BidPrice, w)  as val from loadTable("dfs://LEVEL2_Snapshot_ArrayVector","Snap")  where date(TradeTime) = 2020.01.02</code></pre><p class="- topic/p p">分布式SQL的第二个应用场景是计算按标的分组的时序相关因子。对于组内计算的因子，在SQL模式中，将组字段设为分区字段，可以用<code class="+ topic/ph pr-d/codeph ph codeph">context by</code>组字段并行。如若计算涉及到的数据不跨分区，则可以用 map 语句，加速结果输出。如若计算涉及到的数据跨分区，则SQL会在分区内并行计算，最后在结果部分检查再合并。</p><p class="- topic/p p">以<a class="- topic/xref xref" href="#%E5%88%86%E9%92%9F%E7%BA%A7%E5%92%8C%E6%97%A5%E7%BA%A7%E6%95%B0%E6%8D%AE">日内收益率偏度的因子 <code class="+ topic/ph pr-d/codeph ph codeph">dayReturnSkew</code></a>计算为例， 这个计算本身是需要对标的分组，在组内每天分别做计算。涉及到的数据为分钟频数据，数据源是按月分区，标的 HASH 3 分区。因此，我们在做计算的时候除了可以用<code class="+ topic/ph pr-d/codeph ph codeph">context by</code>组字段并行以外，还可以用 map 语句加速输出结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>minReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable("dfs://k_minute_level", "k_minute") where date(tradetime) between 2020.01.02 : 2020.01.31 group by date(tradetime) as tradetime, securityid map</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title36" id="732-map-reduce"><h4 class="- topic/title title topictitle4" id="ariaid-title36">7.3.2. map reduce</h4><div class="- topic/body body"><p class="- topic/p p">当用户不想根据分区做并行计算时，可以通过mr函数自定义做并行计算。</p><p class="- topic/p p">以第三章中介绍的<a class="- topic/xref xref" href="#sql%E6%A8%A1%E5%BC%8F">factorDoubleEMA因子</a>为例。DoubleEMA因子的计算是对标的分组，在组内连续做窗口计算。此类计算由于将窗口的划分会跨时间分区，所以在SQL计算中会先在分区内做计算，然后最后合并再做一次计算，耗时会比较长。</p><p class="- topic/p p">更合理的做法是，如果分区只按照标的分区，那么计算就可以直接在分区内做完而不用合并检查最终结果了。此时可以用 <code class="+ topic/ph pr-d/codeph ph codeph">repartitionDS</code> 函数先将原本的数据重新分区再通过map reduce的方式做并行计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//将原数据按股票重新10个HASH分区
ds = repartitionDS(&lt;select * from loadTable("dfs://k_minute_level", "k_minute") where date(tradetime) between 2020.01.02 : 2020.03.31&gt;, `securityid, HASH,10)

def factorDoubleEMAMap(table){
	return select tradetime, securityid, `doubleEMA as factorname, factorDoubleEMA(close) as val from table context by securityid map
}

res = mr(ds,factorDoubleEMAMap,,unionAll)</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title37" id="733-通过submitjob提交任务"><h4 class="- topic/title title topictitle4" id="ariaid-title37">7.3.3. 通过submitJob提交任务</h4><div class="- topic/body body"><p class="- topic/p p">之前的两种并行计算都是在前台执行的，并行度是由参数 <code class="+ topic/ph pr-d/codeph ph codeph">localExecutors</code> 设置。而有些作业可能很大，或者用户不想影响前台使用，此时可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code> 提交任务。submitJob的并行度由 <code class="+ topic/ph pr-d/codeph ph codeph">maxBatchJobWorker</code> 参数设置。由于后台作业之间是独立的，通常不需要返回到前端的任务都推荐用后台提交 <code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code> 的形式。</p><p class="- topic/p p">仍旧以 dayReturnSkew 因子为例。通常我们是需要将因子写入因子库表的，此时可以将整一个过程提交几个后台作业去执行，而在客户端中，同时可以继续做其他计算。由于此例存入的因子库的分区是按月和因子名VALUE分区，故此时应按照月份去提交作业。这样既可以并行写入不会冲突，又可以将作业提交到后台，不影响前台提交其他任务。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def writeDayReturnSkew(dBegin,dEnd){
	dReturn = select `dayReturnSkew as factorname, dayReturnSkew(close) as val from loadTable("dfs://k_minute_level", "k_minute") where date(tradetime) between dBegin : dEnd group by date(tradetime) as tradetime, securityid
	//写入因子库
	loadTable("dfs://K_FACTOR_VERTICAL","factor_k").append!(dReturn)
	}

for (i in 0..11){
	dBegin = monthBegin(temporalAdd(2020.01.01,i,"M"))
	dEnd = monthEnd(temporalAdd(2020.01.01,i,"M"))
	submitJob("writeDayReturnSkew","writeDayReturnSkew_"+dBegin+"_"+dEnd, writeDayReturnSkew,dBegin,dEnd)
}</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title38" id="74-内存管理"><h3 class="- topic/title title topictitle3" id="ariaid-title38">7.4. 内存管理</h3><div class="- topic/body body"><p class="- topic/p p">内存管理一直是运维人员和研究人员关注的重中之重，本节将从批和流两个角度简单介绍如何在DolphinDB中高效地使用内存。更多有关内存管理的详细内容，请参阅<a class="- topic/xref xref" href="memory_management.html"><code class="+ topic/ph pr-d/codeph ph codeph">DolphinDB内存管理教程</code></a>。</p><p class="- topic/p p">在配置 DolphinDB 环境时，计算和事务的内存占用可在单节点的 ”dolphindb.cfg” 或集群的 cluster.cfg 中，通过参数”maxMemSize“配置单节点最大可用内存。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">批处理的内存管理</p><p class="- topic/p p">如<a class="- topic/xref xref" href="#sql%E6%A8%A1%E5%BC%8F">sql模式的例子</a>，若对半年的快照数据做操作，批处理方式的中间变量占用内存达到21GB，如果设置的内存小于21GB，则会报Out of Memory错误。这种情况下可以将作业拆分后再提交。</p><p class="- topic/p p">在调试大任务量的计算完成后，可通过 undef 函数将变量赋值为 NULL，或者关闭 session 来及时释放变量的内存。</p></li><li class="- topic/li li"><p class="- topic/p p">流计算的内存管理</p><p class="- topic/p p">如<a class="- topic/xref xref" href="#%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%BE">数据回放的例子</a>，代码中对中间流表调用了函数 <code class="+ topic/ph pr-d/codeph ph codeph">enableTableShareAndPersistence</code> 以持久化，指定缓存开始为80万行。当流表数据量超过80万行时，旧的数据会持久化到磁盘上，以空出内存里的空间供新数据写入，这样该流表就可以连续处理远远超过80万行的数据。</p></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title39" id="75-权限管理"><h3 class="- topic/title title topictitle3" id="ariaid-title39">7.5. 权限管理</h3><div class="- topic/body body"><p class="- topic/p p">因子数据是非常重要的数据，一般来说，用户并不能随意访问所有因子，因此需要对因子数据做好权限管理。DolphinDB database 提供了强大、灵活、安全的权限控制系统，可以满足因子库表级，函数视图级的管理。更多有关权限管理的详细内容，请参考<a class="- topic/xref xref" href="ACL_and_Security.html">权限管理教程</a>。</p><p class="- topic/p p">在实际的生产中通常使用以下三种管理方式：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">研发人员是管理员，完全掌握数据库</p><p class="- topic/p p">这种情况可以授予研发组 DB_OWNER 的权限(创建数据库并管理其创建的数据库的权限)，使其可以自行创建数据库、表，并对自己创建的数据、表进行权限管理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>login("admin", "123456");
createUser("user1", "passwd1")
grant("user1", DB_OWNER)</code></pre></li><li class="- topic/li li"><p class="- topic/p p">运维人员管理数据库，研发人员只有库表的读写权限</p><p class="- topic/p p">这种情况，数据库管理人员可以将数据表的权限授予给因子研发人员，或者创建一个group组，将权限授予这个组，再将需要权限的人员添加到这个组中统一进行管理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//以用户的方式进行授权
createUser("user1", "passwd1")
grant("user1", TABLE_READ, "dfs://db1/pt1")

//以group的方式进行授权
createGroup("group1name", "user1")
grant("group1name", TABLE_READ, "dfs://db1/pt1")</code></pre></li><li class="- topic/li li"><p class="- topic/p p">研发人员只可读部分而非全库表数据权限</p><p class="- topic/p p">DolphinDB 本身并不直接支持表内数据级的权限控制，但是通过DolphinDB本身灵活的权限控制，我们可以通过其他方式来实现表内数据级的权限控制。</p><p class="- topic/p p">这里我们可以通过对用户授予functionview 权限 VIEW_EXEC 这种方式来实现表内数据级的权限控制。</p><p class="- topic/p p">完整代码参考：<a class="- topic/xref xref" href="script/factorPractice/appendix_7.5.3_factorTableControll.dos">因子表权限控制</a>。通过这份代码，用户"u1"虽然没有表的读权限，但是可以获得表内factor1因子的数据。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//创建用户u1,我们想授予u1 只能读取因子factor1的权限
createUser("u1", "111111")
//定义只取因子的函数
def getFactor1Table(){
    t=select * from loadTable("dfs://db1","factor") where factor_name="factor1";
    return t;
}
//将函数保存到系统中
addFunctionView(getFactor1Table)
//将该函数权限授予用户u1
grant("u1", VIEW_EXEC, "getFactor1Table");
//注意新授予的权限，用户需要重新登录才能加载

factor1_tab=getFactor1Table()</code></pre></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title40" id="76-任务管理"><h3 class="- topic/title title topictitle3" id="ariaid-title40">7.6. 任务管理</h3><div class="- topic/body body"><p class="- topic/p p">因子计算的任务通常分为全量计算所有因子任务、交互式单因子重算任务、所有因子增量计算任务这三种，本章会对每一种因子计算任务进行详细介绍。</p><p class="- topic/p p">因子任务可以通过以下三种方式执行:</p><ol class="- topic/ol ol"><li class="- topic/li li">通过交互的方式执行。</li><li class="- topic/li li">通过 <code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code>提交一个Job来执行。</li><li class="- topic/li li">通过 <a class="- topic/xref xref" href="scheduledJob.html">scheduleJob</a>   提交一个定时任务来进行周期性的执行。</li></ol></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title41" id="761-全量计算"><h4 class="- topic/title title topictitle4" id="ariaid-title41">7.6.1. 全量计算</h4><div class="- topic/body body"><p class="- topic/p p">因子的全量跑批任务，通常是系统初始化因子数据时的一次性任务，或者较长周期进行一次的任务，这类任务可以通过单次触发或者定时任务(scheduleJob)的方式进行管理。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">单次触发的任务：这种任务可以通过 gui 直接执行，也可以通过 api 来调用命令，最好的方式是通过 <code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code> 函数提交任务。通过 <code class="+ topic/ph pr-d/codeph ph codeph">submitJob</code> 提交的任务，会提交到服务器的Job 队列中执行，不再受客户端影响，并且可以通过<code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs</code>观察到任务是否完成。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//对于跑批的任务封装函数
def bacthExeCute(){}
// 通过summitjob进行提交
submitJob("batchTask","batchTask", bacthExeCute)</code></pre></li><li class="- topic/li li"><p class="- topic/p p">周期性任务：如果计算的因子频率较低需要每天盘后或者其他周期定期全部重算一次，那我们可以使用定时任务(ScheduleJob)的方式进行管理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//设置一段时间每天执行
scheduleJob(jobId=`daily, jobDesc="Daily Job 1", jobFunc=bacthExeCute, scheduleTime=17:23m, startDate=2018.01.01, endDate=2018.12.31, frequency='D')</code></pre></li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title42" id="762-因子运维管理"><h4 class="- topic/title title topictitle4" id="ariaid-title42">7.6.2. 因子运维管理</h4><div class="- topic/body body"><p class="- topic/p p">在因子研发过程中，当碰到因子算法、参数调整的情况，我们会需要对该因子进行重新计算，同时需要将计算的新的因子数据更新到数据库中，对于因子更新的频率通常我们有两种方式：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">因子的数据频率较高，数据量很大</p><p class="- topic/p p">因子的数据频率较高，数据量很大时，我们推荐在因子数据分区时拉长时间维度，以因子名进行VALUE分区。这样可以使每个因子的数据独立的保存在一个分区中，控制分区大小在一个合适的范围。当我们碰到因子重算的情况，便可以用<code class="+ topic/ph pr-d/codeph ph codeph">dropPartition</code>函数先删除这个因子所对应的分区数据，然后直接重算这个因子并保存到数据表中。</p></li><li class="- topic/li li"><p class="- topic/p p">因子的数据频率较低，因子的总数据量较小</p><p class="- topic/p p">当因子的数据频率较低，因子的总数据量较小时，如若将每个因子划分为独立的分区会使得每个分区特别小，而过小的分区可能会影响写入速度。这种情况下，我们可以按照因子 HASH 分区。使用 <code class="+ topic/ph pr-d/codeph ph codeph">update!</code> 来进行因子数据更新操作，或使用 <code class="+ topic/ph pr-d/codeph ph codeph">upsert</code> 来进行插入更新操作。此外，对于 TSDB 引擎，可以设置参数 <code class="+ topic/ph pr-d/codeph ph codeph">keepDuplicates=LAST</code> , 此时可以直接使用 <code class="+ topic/ph pr-d/codeph ph codeph">append!</code> 或者 <code class="+ topic/ph pr-d/codeph ph codeph">tableInsert</code> 插入数据，从而达到效率更高的更新数据的效果。</p></li></ul><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">update!</code> , <code class="+ topic/ph pr-d/codeph ph codeph">upsert</code> 以及 TSDB 引擎特殊设置下的直接 <code class="+ topic/ph pr-d/codeph ph codeph">append!</code> 覆盖数据，这三种更新操作都建议在数据量较小，且更新不频繁的情况下使用。对于需要大量因子重算的数据更新的场景，我们推荐使用<strong class="+ topic/ph hi-d/b ph b">单因子独立分区</strong>的方式。当因子重算时先用<code class="+ topic/ph pr-d/codeph ph codeph">dropPartition</code>函数删除因子所在分区，再重算写入新因子入库。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title43" id="8-实际案例"><h2 class="- topic/title title topictitle2" id="ariaid-title43">8. 实际案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title44" id="81-日频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title44">8.1. 日频因子</h3><div class="- topic/body body"><p class="- topic/p p">日频的数据，一般是由逐笔数据或者其他高频数据聚合而成。日频的数据量不大，在日频数据上经常会计算一些动量因子，或者一些复杂的需要观察长期数据的因子。因此在分区考虑上，建议按年分区即可。在因子计算上，日频因子通常会涉及时间和股票多个维度，因此建议用面板模式计算。当然也可以根据不同存储模式，选择不同的计算模式。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="script/factorPractice/appendix_8.1_case1_daily.dos">日频因子全流程代码汇总</a>中，模拟了 10 年 4000 只股票的数据，总数据量压缩前大约为 1 GB。代码中会展现上述教程中所涉及日频因子的最佳实践，因子包括 Alpha 1、Alpha 98 ，以及不同计算方式（面板或者SQL模式）写入单值模型、多值模型的最佳实践。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title45" id="82-分钟频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title45">8.2. 分钟频因子</h3><div class="- topic/body body"><p class="- topic/p p">分钟频的数据，一般是从逐笔数据或快照数据合成而来。分钟频的数据相比日频的数据较大，在分区设计上建议按月VALUE分区，股票HASH的组合分区。在分钟频的数据上，一般会计算日内的收益率等因子。对于这类因子，建议使用SQL的方式以字段作为参数。很多时候，会将投研的因子，在每日收盘之后，增量做所有因子的计算，此时，也需要对于每日增量的因子做工程化管理。建议将所有此类因子用维度表做一个维护，用定时作业将这些因子批量做计算。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="script/factorPractice/appendix_8.2_case2_minute.dos">分钟频因子全流程代码汇总</a>中，模拟了一年4000只股票的数据，总数据量压缩前大约20GB。其中，会展现上述教程中所有涉及分钟频率的因子的最佳实践，因子包括日内收益偏度因子，factorDoubleEMA等因子，，后续将因子写入单值模型、多值模型的全过程，以及每日增量计算所有因子的工程化最佳实践。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title46" id="83-快照因子"><h3 class="- topic/title title topictitle3" id="ariaid-title46">8.3. 快照因子</h3><div class="- topic/body body"><p class="- topic/p p">快照数据，一般指3s一条的多档数据。在实际生产中，往往会根据这样的数据产生实时的因子，或根据多档报价、成交量计算，或根据重要字段做计算。这一类因子，推荐使用字段名作为自定义函数的参数。除此之外，由于快照数据的多档的特殊性，普通存储会占用很大的空间，故在存储模式上，我们也推荐将多档数据存为ArrayVector的形式。如此一来，既能节省磁盘空间，又能使代码简洁，省去选取多个重复字段的困扰。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="script/factorPractice/appendix_8.3_case3_snapshot.dos">快照因子全流程代码汇总</a>中，模拟数据生成了20天快照数据，并将其存储为了普通快照数据和ArrayVector快照数据两种。代码中也展示了对于有状态因子flow和无状态因子权重偏度的在流批一体中的最佳实践。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title47" id="84-逐笔因子"><h3 class="- topic/title title topictitle3" id="ariaid-title47">8.4. 逐笔因子</h3><div class="- topic/body body"><p class="- topic/p p">逐笔成交数据，是交易所提供的最详细的每一笔撮合成交数据。每3秒发布一次，每次提供这3秒内的所有撮合记录。涉及逐笔成交数据的因子都是高频因子，推荐调试建模阶段可以在小数据量上使用批处理计算。一旦模型定型，就可以用批处理中同样的计算代码，迁移到流计算中实时处理(这就是所谓的批流一体)，比批处理方式节省内存，同时实时性也更高，模型迭代也更快。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="script/factorPractice/appendix_8.4_case4_streamTick.dos">逐笔因子全流程代码汇总</a>中，会展现上述教程中所有涉及逐笔成交数据的因子计算、流计算。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title48" id="9-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title48">9. 总结</h2><div class="- topic/body body"><p class="- topic/p p">用DolphinDB来进行因子的计算时，可选择面板和SQL两种方式来封装因子的核心逻辑。面板方式使用矩阵来计算因子，实现思路非常简练；而SQL方式要求投研人员使用向量化的思路进行因子开发。无论哪种方式，DolphinDB均支持批流一体的实现。DolphinDB内置了相关性和回归分析等计算工具，可分析因子的有效性，可对多因子建模。</p><p class="- topic/p p">在因子库的规划上，如果追求灵活性，建议采用单值纵表模型。如果追求效率和性能，推荐使用TSDB引擎，启用多值宽表模式，标的（股票代码）作为表的列。</p><p class="- topic/p p">最后，基于大部分团队的IT和投研相对独立的事实，给出了在代码管理上的工程化方案，投研团队通过模块和自定义函数封装核心因子业务逻辑，IT团队则维护框架代码。同时利用权限模块有效隔离各团队之间的数据访问权限。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title49" id="10-附录"><h2 class="- topic/title title topictitle2" id="ariaid-title49">10. 附录</h2><div class="- topic/body body"><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_2.1_createTickDbAndTable_main.dos">逐笔数据建库建表</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_2.2_createSnapshotDbAndTable_main.dos">快照数据建库建表</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_2.3_createTableKMinute_main.dos">k线数据建库建表</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.1.2_streamComputationOfSmallInflowRate_main.dos">流计算大小单因子</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.1.3_StreamComputationOfAlpha1Factor_main.dos">Alpha #1流式计算</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.2_streamComputationOfDoubleEmaFactor_main.dos">流计算doubleEma因子</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.1_python_callback_handler_subscribing_stream_main.py">python接口订阅流数据</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.2_zmq_consuming_ddb_stream_main.py">通过ZMQ消息队列收取DolphinDB推送来的流数据</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_4.3.3_streamComputationOfDoubleEmaFactorPublishingOnZMQ_main.dos">流计算因子结果推送到外部ZMQ消息队列</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_5.1_factorDataSimulation.zip">因子存储模拟测试</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_5.2_factorQueryTest.dos">因子查询测试脚本</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_6.1_vectorisedFactorBacktest_main.dos">因子向量化回测</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_7.2_doubleEMATest.dos">单元测试</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_7.5.3_factorTableControll.dos">因子表权限控制</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_8.1_case1_daily.dos">日频因子全流程代码汇总</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_8.2_case2_minute.dos">分钟频因子全流程代码汇总</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_8.3_case3_snapshot.dos">快照因子全流程代码汇总</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/appendix_8.4_case4_streamTick.dos">逐笔因子全流程代码汇总</a></p><p class="- topic/p p"><a class="- topic/xref xref" href="script/factorPractice/factorPractice.zip">所有代码附件目录</a></p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%A6%82%E8%BF%B0" data-tocid="1-概述">1. 概述</a></li><li class="topic-item"><a href="#2-%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E9%9B%86" data-tocid="2-测试数据集">2. 测试数据集</a><ul><li class="topic-item"><a href="#21-%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE" data-tocid="21-逐笔成交数据">2.1. 逐笔成交数据</a></li><li class="topic-item"><a href="#22-%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE" data-tocid="22-快照数据">2.2. 快照数据</a></li><li class="topic-item"><a href="#23-%E5%88%86%E9%92%9Fk%E6%95%B0%E6%8D%AE" data-tocid="23-分钟k数据">2.3. 分钟K数据</a></li></ul></li><li class="topic-item"><a href="#3-%E6%8A%95%E7%A0%94%E9%98%B6%E6%AE%B5%E7%9A%84%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="3-投研阶段的因子计算">3. 投研阶段的因子计算</a><ul><li class="topic-item"><a href="#31-%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F" data-tocid="31-面板数据模式">3.1. 面板数据模式</a></li><li class="topic-item"><a href="#32-sql%E6%A8%A1%E5%BC%8F" data-tocid="32-sql模式">3.2. SQL模式</a></li><li class="topic-item"><a href="#33-%E4%B8%8D%E5%90%8C%E9%A2%91%E7%8E%87%E7%9A%84%E5%9B%A0%E5%AD%90%E5%BC%80%E5%8F%91%E4%B8%BE%E4%BE%8B" data-tocid="33-不同频率的因子开发举例">3.3. 不同频率的因子开发举例</a><ul><li class="topic-item"><a href="#331-%E5%88%86%E9%92%9F%E7%BA%A7%E5%92%8C%E6%97%A5%E7%BA%A7%E6%95%B0%E6%8D%AE" data-tocid="331-分钟级和日级数据">3.3.1. 分钟级和日级数据</a></li><li class="topic-item"><a href="#332-%E5%9F%BA%E4%BA%8E%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%89%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="332-基于快照数据的有状态因子计算">3.3.2. 基于快照数据的有状态因子计算</a></li><li class="topic-item"><a href="#333-%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E6%A1%A3%E8%B5%8B%E6%9D%83%E6%97%A0%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="333-快照数据的多档赋权无状态因子计算">3.3.3. 快照数据的多档赋权无状态因子计算</a></li><li class="topic-item"><a href="#334-%E5%9F%BA%E4%BA%8E%E5%BF%AB%E7%85%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E9%92%9F%E8%81%9A%E5%90%88" data-tocid="334-基于快照数据的分钟聚合">3.3.4. 基于快照数据的分钟聚合</a></li><li class="topic-item"><a href="#335-%E9%80%90%E7%AC%94%E6%95%B0%E6%8D%AE" data-tocid="335-逐笔数据">3.3.5. 逐笔数据</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%9A%84%E6%B5%81%E5%BC%8F%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="4-生产环境的流式因子计算">4. 生产环境的流式因子计算</a><ul><li class="topic-item"><a href="#41-%E6%B5%81%E5%BC%8F%E5%A2%9E%E9%87%8F%E8%AE%A1%E7%AE%97" data-tocid="41-流式增量计算">4.1. 流式增量计算</a><ul><li class="topic-item"><a href="#411-%E4%B8%BB%E4%B9%B0%E6%88%90%E4%BA%A4%E9%87%8F%E5%8D%A0%E6%AF%94%E5%9B%A0%E5%AD%90%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86" data-tocid="411-主买成交量占比因子的流式处理">4.1.1. 主买成交量占比因子的流式处理</a></li><li class="topic-item"><a href="#412-%E5%A4%A7%E5%B0%8F%E5%8D%95%E7%9A%84%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86" data-tocid="412-大小单的流式处理">4.1.2. 大小单的流式处理</a></li><li class="topic-item"><a href="#413-%E5%A4%8D%E6%9D%82%E5%9B%A0%E5%AD%90alpha-1%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%9A%84%E5%BF%AB%E6%8D%B7%E5%AE%9E%E7%8E%B0" data-tocid="413-复杂因子alpha-1流式计算的快捷实现">4.1.3. 复杂因子Alpha #1流式计算的快捷实现</a></li></ul></li><li class="topic-item"><a href="#42-%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%BE" data-tocid="42-数据回放">4.2. 数据回放</a></li><li class="topic-item"><a href="#43-%E5%AF%B9%E6%8E%A5%E4%BA%A4%E6%98%93%E7%B3%BB%E7%BB%9F" data-tocid="43-对接交易系统">4.3. 对接交易系统</a></li></ul></li><li class="topic-item"><a href="#5-%E5%9B%A0%E5%AD%90%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2" data-tocid="5-因子的存储和查询">5. 因子的存储和查询</a><ul><li class="topic-item"><a href="#51-%E5%9B%A0%E5%AD%90%E5%AD%98%E5%82%A8" data-tocid="51-因子存储">5.1. 因子存储</a></li><li class="topic-item"><a href="#52-%E5%9B%A0%E5%AD%90%E6%9F%A5%E8%AF%A2" data-tocid="52-因子查询">5.2. 因子查询</a></li><li class="topic-item"><a href="#53-%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE" data-tocid="53-在线获取面板数据">5.3. 在线获取面板数据</a></li></ul></li><li class="topic-item"><a href="#6-%E5%9B%A0%E5%AD%90%E5%9B%9E%E6%B5%8B%E5%92%8C%E5%BB%BA%E6%A8%A1" data-tocid="6-因子回测和建模">6. 因子回测和建模</a><ul><li class="topic-item"><a href="#61-%E5%9B%A0%E5%AD%90%E5%9B%9E%E6%B5%8B" data-tocid="61-因子回测">6.1. 因子回测</a></li><li class="topic-item"><a href="#62-%E5%9B%A0%E5%AD%90%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90" data-tocid="62-因子相关性分析">6.2. 因子相关性分析</a></li><li class="topic-item"><a href="#63-%E5%A4%9A%E5%9B%A0%E5%AD%90%E5%BB%BA%E6%A8%A1" data-tocid="63-多因子建模">6.3. 多因子建模</a></li></ul></li><li class="topic-item"><a href="#7-%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%8C%96" data-tocid="7-因子计算的工程化">7. 因子计算的工程化</a><ul><li class="topic-item"><a href="#71-%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86" data-tocid="71-代码管理">7.1. 代码管理</a></li><li class="topic-item"><a href="#72-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95" data-tocid="72-单元测试">7.2. 单元测试</a></li><li class="topic-item"><a href="#73-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" data-tocid="73-并行计算">7.3. 并行计算</a><ul><li class="topic-item"><a href="#731-%E5%88%86%E5%B8%83%E5%BC%8Fsql" data-tocid="731-分布式sql">7.3.1. 分布式SQL</a></li><li class="topic-item"><a href="#732-map-reduce" data-tocid="732-map-reduce">7.3.2. map reduce</a></li><li class="topic-item"><a href="#733-%E9%80%9A%E8%BF%87submitjob%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1" data-tocid="733-通过submitjob提交任务">7.3.3. 通过submitJob提交任务</a></li></ul></li><li class="topic-item"><a href="#74-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" data-tocid="74-内存管理">7.4. 内存管理</a></li><li class="topic-item"><a href="#75-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86" data-tocid="75-权限管理">7.5. 权限管理</a></li><li class="topic-item"><a href="#76-%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86" data-tocid="76-任务管理">7.6. 任务管理</a><ul><li class="topic-item"><a href="#761-%E5%85%A8%E9%87%8F%E8%AE%A1%E7%AE%97" data-tocid="761-全量计算">7.6.1. 全量计算</a></li><li class="topic-item"><a href="#762-%E5%9B%A0%E5%AD%90%E8%BF%90%E7%BB%B4%E7%AE%A1%E7%90%86" data-tocid="762-因子运维管理">7.6.2. 因子运维管理</a></li></ul></li></ul></li><li class="topic-item"><a href="#8-%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B" data-tocid="8-实际案例">8. 实际案例</a><ul><li class="topic-item"><a href="#81-%E6%97%A5%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="81-日频因子">8.1. 日频因子</a></li><li class="topic-item"><a href="#82-%E5%88%86%E9%92%9F%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="82-分钟频因子">8.2. 分钟频因子</a></li><li class="topic-item"><a href="#83-%E5%BF%AB%E7%85%A7%E5%9B%A0%E5%AD%90" data-tocid="83-快照因子">8.3. 快照因子</a></li><li class="topic-item"><a href="#84-%E9%80%90%E7%AC%94%E5%9B%A0%E5%AD%90" data-tocid="84-逐笔因子">8.4. 逐笔因子</a></li></ul></li><li class="topic-item"><a href="#9-%E6%80%BB%E7%BB%93" data-tocid="9-总结">9. 总结</a></li><li class="topic-item"><a href="#10-%E9%99%84%E5%BD%95" data-tocid="10-附录">10. 附录</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>