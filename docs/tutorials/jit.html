<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="DolphinDB 从 1.01 版本开始支持 JIT，本篇教程将结合实际例子介绍 JIT 的使用和注意事项。 即时编译（英文: Just-in-time compilation, 缩写: JIT），又译为及时编译或实时编译，是动态编译的一种形式，可提高程序运行效率。 通常程序有两种运行方式：编译执行和解释执行。编译执行在程序执行前全部翻译为机器码，特点是运行效率较高，以 C/C++ ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="即时编译jit"/><title>即时编译（JIT）</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;即时编译jit&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;即时编译（JIT）&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 从 1.01 版本开始支持 JIT，本篇教程将结合实际例子介绍 JIT 的使用和注意事项。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:41;60:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-jit简介&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;1. JIT简介&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;即时编译（英文: Just-in-time compilation, 缩写: JIT），又译为及时编译或实时编译，是动态编译的一种形式，可提高程序运行效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;通常程序有两种运行方式：编译执行和解释执行。编译执行在程序执行前全部翻译为机器码，特点是运行效率较高，以 C/C++ 为代表。解释执行是由解释器对程序逐句解释并执行，灵活性较强，但是执行效率较低，以 Python 为代表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;即时编译融合了两者的优点，在运行时将代码翻译为机器码，可以达到与静态编译语言相近的执行效率。Python 的第三方实现 PyPy 通过 JIT 明显改善了解释器的性能。绝大多数的 Java 实现都依赖 JIT 以提高代码的运行效率。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-jit-在-dolphindb-中的作用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;2. JIT 在 DolphinDB 中的作用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 的编程语言是解释执行，运行程序时首先对程序进行语法分析生成语法树，然后递归执行。在不能使用向量化的情况下，解释成本会比较高。这是由于 DolphinDB 底层由 C++ 实现，脚本中的一次函数调用会转化为多次 C++ 内的虚拟函数调用。for 循环，while 循环和 if-else 等语句中，由于要反复调用函数，十分耗时，在某些场景下不能满足实时性的需求。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 中的即时编译功能显著提高了for循环，while循环和if-else等语句的运行速度，特别适合于无法使用向量化运算但又对运行速度有极高要求的场景，例如高频因子计算、实时流数据处理等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;下面，我们使用一个最简单的例子，对比使用和不使用JIT的情况下，do-while循环计算1到1000000之和100次所需要的时间。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;def sum_without_jit(v) { s = 0F i = 0 n = size(v) do { s += v[i] i += 1 } while(i &amp;lt; n) return s } @jit def sum_with_jit(v) { s = 0F i = 0 n = size(v) do { s += v[i] i += 1 } while(i &amp;lt; n) return s } vec = 1..1000000 timer(100) sum_without_jit(vec) // 91017 ms timer(100) sum_with_jit(vec) // 217 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;51:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;不使用 JIT 的耗时是使用 JIT 的 419 倍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;请注意，以上例子仅是为了展示在 do-while 循环中 JIT 的性能优势。实际应用中，类似上例的简单循环计算，一般应当优先使用DolphinDB的内置函数进行向量化运算，这是由于很多内置函数采用了进一步的优化，而且使用内置函数更为方便。上例中，若使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;53:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;sum&lt;/codeph&gt; 函数，耗时是JIT的20%左右。一般来说，循环的操作与计算越复杂，JIT 相对于使用内置函数的优势越大。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://zhuanlan.zhihu.com/p/77988657&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;57:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;?ditaot usertext?&gt;知乎上的一篇专栏&lt;/xref&gt;中，我们展示了如何使用在 DolphinDB 中使用向量化运算，其中计算交易信号的式子如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;direction = (iif(signal&amp;gt;t1, 1h, iif(signal&amp;lt;t10, 0h, 00h)) - iif(signal&amp;lt;t2, 1h, iif(signal&amp;gt;t20, 0h, 00h))).ffill().nullFill(0h)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;对于 DolphinDB 初学者来说，需要了解 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;63:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;iif&lt;/codeph&gt; 函数才可写出以上语句。使用 for 循环改写以上语句则较为容易：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def calculate_with_jit(signal, n, t1, t10, t20, t2) { cur = 0 idx = 0 output = array(INT, n, n) for (s in signal) { if(s &amp;gt; t1) { // (t1, inf) cur = 1 } else if(s &amp;gt;= t10) { // [t10, t1] if(cur == -1) cur = 0 } else if(s &amp;gt; t20) { // [t20, t10) cur = 0 } else if(s &amp;gt;= t2) { // [t2, t20] if(cur == 1) cur = 0 } else { // (-inf, t2) cur = -1 } output[idx] = cur idx += 1 } return output }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在上述脚本中把@jit去掉，并将函数名改为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;90:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;calculate_without_jit&lt;/codeph&gt; ，以产生不使用JIT的自定义函数。对比三种方法的耗时：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;n = 10000000 t1= 60 t10 = 50 t20 = 30 t2 = 20 signal = rand(100.0, n) timer ffill!(iif(signal&amp;gt;t1, 1h, iif(signal&amp;lt;t10, 0h, 00h)) - iif(signal&amp;lt;t2, 1h, iif(signal&amp;gt;t20, 0h, 00h))).nullFill(0h) // 410.920 ms timer calculate_with_jit(signal, size(signal), t1, t10, t20, t2) // 170.7513 ms timer calculate_without_jit(signal, size(signal), t1, t10, t20, t2) // 14044.0641 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;本例中，使用JIT的速度是向量化运算的2.4倍，是不用JIT的82倍。这里JIT的速度比向量化运算还要快，是因为向量化运算中调用了很多次DolphinDB的内置函数，产生了很多中间结果， 涉及到多次内存分配以及虚拟函数调用，而JIT生成的代码则没有这些额外的开销。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;某些计算无法使用向量化，比如计算期权隐含波动率(implied volatility)时，需要使用牛顿法，无法使用向量化运算。这种情况下如果需要满足一定的实时性，可以选择使用DolphinDB的插件，亦可使用JIT。两者的区别在于，在任何场景下都可以使用插件，但是需要使用 C++ 编写，比较复杂；JIT的编写相对而言较为容易，但是适用的场景较为有限。JIT的运行速度与使用C++插件的速度非常接近。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-如何在-dolphindb-中使用-jit&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3. 如何在 DolphinDB 中使用 JIT&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-使用方法&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.1. 使用方法&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 目前仅支持对用户自定义函数进行 JIT。只需在函数定义之前的一行添加 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;114:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit&lt;/b&gt; 的标识即可：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def myFunc(/* arguments */) { /* implementation */ }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;用户在调用此函数时，DolphinDB会将函数的代码实时编译为机器码后执行。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-支持语句&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.2. 支持语句&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;目前 DolphinDB 支持在 JIT 中使用以下几种语句：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;129:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;赋值语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;131:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def func() { y = 1 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;138:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;请注意，multiple assign 目前是不支持的，例如：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;140:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def func() { a, b = 1, 2 } func() 运行以上语句会抛出异常。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;148:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;return 语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;150:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def func() { return 1 }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;157:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;if-else 语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;159:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def myAbs(x) { if(x &amp;gt; 0) return x else return -x }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;167:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;do-while 语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;169:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def mySqrt(x) { diff = 0.0000001 guess = 1.0 guess = (x / guess + guess) / 2.0 do { guess = (x / guess + guess) / 2.0 } while(abs(guess * guess - x) &amp;gt;= diff) return guess }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;182:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;for 语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;184:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def mySum(vec) { s = 0 for(i in vec) { s += i } return s }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;195:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;break 和 continue语句，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;197:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def mySum(vec) { s = 0 for (i in vec) { if(i % 2 == 0) continue s += i } return s }&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 支持在 JIT 中以上语句的任意嵌套。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-支持的运算符和函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.3. 支持的运算符和函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;目前DolphinDB支持在JIT中使用以下的运算符：add(+), sub(-), multiply(*), divide(/), and(&amp;amp;&amp;amp;), or(||), bitand(&amp;amp;), bitor(|), bitxor(^), eq(==), neq(!=), ge(&amp;gt;=), gt(&amp;gt;), le(&amp;lt;=), lt(&amp;lt;), neg(-), mod(%), seq(..), at([])，以上运算在所有数据类型下的实现都与非JIT的实现一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;目前DolphinDB支持在JIT中使用以下的数学函数： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;216:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;exp&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;216:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;log&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;216:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;sin&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;216:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;asin&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;216:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cos&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;216:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;acos&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;216:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;tan&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;216:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;atan&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;216:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;abs&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;216:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;ceil&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;216:114&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;floor&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;216:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;sqrt&lt;/codeph&gt;。以上数学函数在JIT中出现时， 如果接受的参数为scalar，那么在最后生成的机器码中会调用glibc中对应的函数或者经过优化的C实现的函数；如果接收的参数为array，那么最后会调用DolphinDB提供的数学函数。这样的好处是通过直接调用C实现的代码提升函数运行效率，减少不必要的虚拟函数调用和内存分配。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;目前DolphinDB支持在JIT中使用以下的内置函数：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;220:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;take&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;220:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;seq&lt;/codeph&gt; , &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;220:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;array&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;220:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;size&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;220:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;isValid&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;220:73&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;rand&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;220:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfNormal&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;220:94&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfBeta&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;220:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfBinomial&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;220:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfChiSquare&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;220:136&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfExp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;220:146&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfF&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;220:154&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfGamma&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;220:166&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfKolmogorov&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;220:183&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfcdfLogistic&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;220:201&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfNormal&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;220:214&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfUniform&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;220:228&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfWeibull&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;220:242&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cdfZipf&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;220:253&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invBeta&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;220:264&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invBinomial&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;220:279&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invChiSquare&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;220:295&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invExp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;220:305&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invF&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;220:313&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invGamma&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;220:325&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invLogistic&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;220:340&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invNormal&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;220:353&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invPoisson&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;220:367&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invStudent&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;220:381&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invUniform&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;220:395&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;invWeibull&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;220:409&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cbrt&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;220:417&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;deg2rad&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;220:428&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;rad2deg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;220:439&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;det&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;220:446&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;dot&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;220:453&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;flatten&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;220:464&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;sum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;220:471&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;avg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;220:478&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;count&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;220:487&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;size&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;220:495&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;min&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;220:502&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;max&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;220:509&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;iif&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;220:516&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;round&lt;/codeph&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;222:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;需要注意，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;222:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;array&lt;/codeph&gt; 函数的第一个参数必须直接指定具体的数据类型，不能通过变量传递指定。这是由于JIT编译时必须知道所有变量的类型，而 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;222:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;array&lt;/codeph&gt; 函数返回结果的类型由第一个参数指定，因此编译时必须该值必须已知。 此外，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;223:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;round&lt;/codeph&gt; 函数在使用时必须指定第二个参数，且该参数须大于0。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;目前DolphinDB已支持 cum 系列函数，但须注意目前仅支持输入类型为 Vector。 支持的单目函数有：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:64;226:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cummax&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:65;226:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cummin&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:66;226:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cummed&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:67;226:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumfirstNot&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:68;226:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumlastNot&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:69;226:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumrank&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:70;226:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumcount&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:71;226:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumpercentile&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:72;226:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumstd&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:73;226:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumstdp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:74;226:130&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumvar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:75;226:140&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumvarp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:76;226:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumsum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:77;226:161&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumsum2&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:78;226:172&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumsum3&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:79;226:183&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumsum4&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:80;226:194&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumavg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:81;226:204&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumprod&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:82;226:215&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumPositiveStreak&lt;/codeph&gt;。 支持的双目函数有：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:83;227:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumbeta&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:84;227:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumwsum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:85;227:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumwavg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:86;227:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumcovar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:87;227:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;cumcorr&lt;/codeph&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-空值的处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;229:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;229:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.4. 空值的处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;229:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;231:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;JIT中所有的函数和运算符处理空值的方法都与原生函数和运算符一致，即每个数据类型都用该类型的最小值来表示该类型的空值，用户不需要专门处理空值。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-jit函数之间的调用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.5. JIT函数之间的调用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB的JIT函数可以调用另一个JIT函数。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def myfunc1(x) { return sqrt(x) + exp(x) } @jit def myfunc2(x) { return myfunc1(x) } myfunc2(1.5)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在上面的例子中，内部会先编译 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:88;251:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;myfunc1&lt;/codeph&gt; , 生成一个签名为 double myfunc1(double) 的native函数， &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:89;251:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;myfunc2&lt;/codeph&gt; 生成的机器码中直接调用这个函数，而不是在运行时判断 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:90;251:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;myfunc1&lt;/codeph&gt; 是否为JIT函数后再执行，从而达到最高的执行效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;请注意，JIT函数内不可以调用非JIT的用户自定义函数，因为这样无法进行类型推导。关于类型推导下面会提到。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;36-jit-的编译成本以及缓存机制&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.6. JIT 的编译成本以及缓存机制&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 的 JIT 底层依赖&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://llvm.org/&#34; scope=&#34;external&#34; xtrc=&#34;xref:2;257:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;?ditaot usertext?&gt;LLVM&lt;/xref&gt;实现，每个用户自定义函数在编译时都会生成自己的module，相互独立。编译主要包含以下几个步骤：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;LLVM相关变量和环境的初始化&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;根据DolphinDB脚本的语法树生成LLVM的IR&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;调用LLVM优化第二步生成的IR，然后编译为机器码&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;以上步骤中第一步耗时一般在5ms以内，后面两步的耗时与实际脚本的复杂度成正比，总体而言编译耗时基本上在50ms以内。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;对于一个JIT函数以及一个参数类型组合，DolphinDB只会编译一次。系统会对JIT函数编译的结果进行缓存。系统根据用户调用一个JIT函数时提供的参数的数据类型得到一个对应的字符串，然后在一个哈希表中寻找这个字符串对应的编译结果，如果存在则直接调用；如果不存在则开始编译，并将编译结果保存到此哈希表中，然后执行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;对需要反复执行的任务，或者运行时间远超编译耗时的任务，JIT会显著提高运行速度。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;37-支持函数作为函数参数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.7. 支持函数作为函数参数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;从1.2.0版本开始，DolphinDB的JIT支持函数以及部分应用（包括嵌套的部分应用）作为函数参数。下面举例说明：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;273:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def foo(f, x, y){return f(x,y)} @jit def h(x,y){return x+y} @jit def g(x,y){return foo(h, x, y)}&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;上例中，函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:91;283:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;g&lt;/codeph&gt;中引用的函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:92;283:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;foo&lt;/codeph&gt;的第一个参数是函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:93;283:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;h&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;285:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def h(a,b,c){return a + b + c} @jit def foo(f,x,y){return f(x,y)} @jit def g(x,y,z){return foo(h{x}, y, z)}&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;295:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;上例中，将部分应用h作为第一个参数传给foo。其中部分应用的自由参数可以是任意的，可为h{,x}，h{,,x}或者h{x,,y}等等。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;297:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def f1(x,y,z){return x + y + z} @jit def f2(g2){return g2(1)} @jit def f3(g3){return f2(g3{2})} @jit def f4(){return f3(f1{,,3})} f4()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;嵌套部分应用也是支持的，在上面的例子中，f4中将f1{,,3}传给f3, 在f3中对这个函数参数又进行了一次部分应用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;需要注意的是，如果同一个函数参数在一个JIT函数中有多种签名，由于编译实现的限制，执行时会报异常。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def foo(x,y){return x + y} @jit def f1(f){return f(1,2) + f(1.0,2)} @jit def f2(){return f1(foo)} f2() //抛出异常&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;38-对数据形式的拓展支持&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;330:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;330:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;3.8. 对数据形式的拓展支持&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;330:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;332:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB 的 JIT 对以下数据形式实现了拓展支持：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;矩阵&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;335:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;集合&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;字典&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;表&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;元组&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;339:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;数组向量&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-类型推导&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;343:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;343:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;4. 类型推导&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;343:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;345:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在使用LLVM生成IR之前，必须知道脚本中所有变量的类型，这个步骤就是类型推导。DolphinDB的JIT使用的类型推导方式是局部推导，比如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;347:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def foo() { x = 1 y = 1.1 z = x + y return z }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;357:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;通过 x = 1 确定x的类型是int；通过 y = 1.1 确定y的类型是 double；通过 z = x + y 以及上面推得的x和y的类型，确定z的类型也是double；通过 return z 确定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:94;357:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;foo&lt;/codeph&gt; 函数的返回类型是double。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;359:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;如果函数有参数的话，比如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;361:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def foo(x) { return x + 1 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:95;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;foo&lt;/codeph&gt; 函数的返回类型就依赖于输入值x的类型。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;上面我们提到了目前JIT支持的数据类型，如果函数内部出现了不支持的类型，或者输入的变量类型不支持，那么就会导致整个函数的变量类型推导失败，在运行时会抛出异常。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def foo(x) { return x + 1 } foo(123) // 正常执行 foo(1:2) // 正常执行 foo(&#34;abc&#34;) // 抛出异常，因为目前不支持STRING foo((1 2, 3 4, 5 6)) // 抛出异常，因为目前不支持tuple&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;384:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;因此，为了能够正常使用JIT函数，用户应该避免在函数内或者参数中使用尚不支持的函数。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-实例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;386:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;386:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;5. 实例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;386:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-计算隐含波动率-implied-volatility&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;388:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;388:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;5.1. 计算隐含波动率 (implied volatility)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;388:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;390:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;上面提到过某些计算无法进行向量化运算，计算隐含波动率 (implied volatility)就是一个例子：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def GBlackScholes(future_price, strike, input_ttm, risk_rate, b_rate, input_vol, is_call) { ttm = input_ttm + 0.000000000000001; vol = input_vol + 0.000000000000001; d1 = (log(future_price/strike) + (b_rate + vol*vol/2) * ttm) / (vol * sqrt(ttm)); d2 = d1 - vol * sqrt(ttm); if (is_call) { return future_price * exp((b_rate - risk_rate) * ttm) * cdfNormal(0, 1, d1) - strike * exp(-risk_rate*ttm) * cdfNormal(0, 1, d2); } else { return strike * exp(-risk_rate*ttm) * cdfNormal(0, 1, -d2) - future_price * exp((b_rate - risk_rate) * ttm) * cdfNormal(0, 1, -d1); } } @jit def ImpliedVolatility(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) { high=5.0; low = 0.0; do { if (GBlackScholes(future_price, strike, ttm, risk_rate, b_rate, (high+low)/2, is_call) &amp;gt; option_price) { high = (high+low)/2; } else { low = (high + low) /2; } } while ((high-low) &amp;gt; 0.00001); return (high + low) /2; } @jit def test_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) { n = size(future_price) ret = array(DOUBLE, n, n) i = 0 do { ret[i] = ImpliedVolatility(future_price[i], strike[i], ttm[i], risk_rate[i], b_rate[i], option_price[i], is_call[i]) i += 1 } while(i &amp;lt; n) return ret } n = 100000 future_price=take(rand(10.0,1)[0], n) strike_price=take(rand(10.0,1)[0], n) strike=take(rand(10.0,1)[0], n) input_ttm=take(rand(10.0,1)[0], n) risk_rate=take(rand(10.0,1)[0], n) b_rate=take(rand(10.0,1)[0], n) vol=take(rand(10.0,1)[0], n) input_vol=take(rand(10.0,1)[0], n) multi=take(rand(10.0,1)[0], n) is_call=take(rand(10.0,1)[0], n) ttm=take(rand(10.0,1)[0], n) option_price=take(rand(10.0,1)[0], n) timer(10) test_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) // 2621.73 ms timer(10) test_non_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) // 302714.74 ms &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;上面的例子中， &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:96;455:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;ImpliedVolatility&lt;/codeph&gt; 会调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:97;455:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;GBlackScholes&lt;/codeph&gt; 函数。函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:98;455:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;test_non_jit&lt;/codeph&gt; 可通过把 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:99;455:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;test_jit&lt;/codeph&gt; 定义之前的@jit去掉以获取。JIT版本 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:100;455:107&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;test_jit&lt;/codeph&gt; 运行速度是非JIT版本 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:101;455:130&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;test_non_jit&lt;/codeph&gt; 的115倍。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-计算-greeks&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;5.2. 计算 Greeks&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;量化金融中经常使用&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://www.wikiwand.com/en/Greeks_(finance)&#34; scope=&#34;external&#34; xtrc=&#34;xref:3;459:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;?ditaot usertext?&gt;Greeks&lt;/xref&gt;进行风险评估，下面以charm(delta衰减)为例展示JIT的使用：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;461:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def myMax(a,b){ if(a&amp;gt;b){ return a }else{ return b } } @jit def NormDist(x) { return cdfNormal(0, 1, x); } @jit def ND(x) { return (1.0/sqrt(2*pi)) * exp(-(x*x)/2.0) } @jit def CalculateCharm(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) { day_year = 245.0; d1 = (log(future_price/strike_price) + (b_rate + (vol*vol)/2.0) * input_ttm) / (myMax(vol,0.00001) * sqrt(input_ttm)); d2 = d1 - vol * sqrt(input_ttm); if (is_call) { return -exp((b_rate - risk_rate) * input_ttm) * (ND(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) + (b_rate-risk_rate) * NormDist(d1)) * future_price * multi / day_year; } else { return -exp((b_rate - risk_rate) * input_ttm) * (ND(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) - (b_rate-risk_rate) * NormDist(-d1)) * future_price * multi / day_year; } } @jit def test_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) { n = size(future_price) ret = array(DOUBLE, n, n) i = 0 do { ret[i] = CalculateCharm(future_price[i], strike_price[i], input_ttm[i], risk_rate[i], b_rate[i], vol[i], multi[i], is_call[i]) i += 1 } while(i &amp;lt; n) return ret } def ND_validate(x) { return (1.0/sqrt(2*pi)) * exp(-(x*x)/2.0) } def NormDist_validate(x) { return cdfNormal(0, 1, x); } def CalculateCharm_vectorized(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) { day_year = 245.0; d1 = (log(future_price/strike_price) + (b_rate + pow(vol, 2)/2.0) * input_ttm) / (max(vol, 0.00001) * sqrt(input_ttm)); d2 = d1 - vol * sqrt(input_ttm); return iif(is_call,-exp((b_rate - risk_rate) * input_ttm) * (ND_validate(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) + (b_rate-risk_rate) * NormDist_validate(d1)) * future_price * multi / day_year,-exp((b_rate - risk_rate) * input_ttm) * (ND_validate(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) - (b_rate-risk_rate) * NormDist_validate(-d1)) * future_price * multi / day_year) } n = 1000000 future_price=rand(10.0,n) strike_price=rand(10.0,n) strike=rand(10.0,n) input_ttm=rand(10.0,n) risk_rate=rand(10.0,n) b_rate=rand(10.0,n) vol=rand(10.0,n) input_vol=rand(10.0,n) multi=rand(10.0,n) is_call=rand(true false,n) ttm=rand(10.0,n) option_price=rand(10.0,n) timer(10) test_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) // 1834 ms timer(10) test_none_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) // 224099 ms timer(10) CalculateCharm_vectorized(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) // 3118 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;本例比上一节更加复杂，涉及到更多的函数调用和更复杂的计算。JIT比非JIT快120倍，比向量化版本快70%。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;53-计算止损点-stoploss&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;5.3. 计算止损点 (stoploss)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;546:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在这篇&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://zhuanlan.zhihu.com/p/47236676&#34; scope=&#34;external&#34; xtrc=&#34;xref:4;546:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;?ditaot usertext?&gt;知乎专栏&lt;/xref&gt;中，我们展示了如何使用DolphinDB进行技术信号回测，下面我们用JIT来实现其中的stoploss函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def stoploss_JIT(ret, threshold) { n = ret.size() i = 0 curRet = 1.0 curMaxRet = 1.0 indicator = take(true, n) do { indicator[i] = false curRet *= (1 + ret[i]) if(curRet &amp;gt; curMaxRet) { curMaxRet = curRet } drawDown = 1 - curRet / curMaxRet; if(drawDown &amp;gt;= threshold) { break } i += 1 } while(i &amp;lt; n) return indicator } def stoploss_no_JIT(ret, threshold) { n = ret.size() i = 0 curRet = 1.0 curMaxRet = 1.0 indicator = take(true, n) do { indicator[i] = false curRet *= (1 + ret[i]) if(curRet &amp;gt; curMaxRet) { curMaxRet = curRet } drawDown = 1 - curRet / curMaxRet; if(drawDown &amp;gt;= threshold) { break } i += 1 } while(i &amp;lt; n) return indicator } def stoploss_vectorization(ret, threshold){ cumret = cumprod(1+ret) drawDown = 1 - cumret / cumret.cummax() firstCutIndex = at(drawDown &amp;gt;= threshold).first() + 1 indicator = take(false, ret.size()) if(isValid(firstCutIndex) and firstCutIndex &amp;lt; ret.size()) indicator[firstCutIndex:] = true return indicator } ret = take(0.0008 -0.0008, 1000000) threshold = 0.10 timer(10) stoploss_JIT(ret, threshold) // 59 ms timer(10) stoploss_no_JIT(ret, threshold) // 14622 ms timer(10) stoploss_vectorization(ret, threshold) // 152 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;608:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;用JIT实现的版本比向量化版本快了 1.5 倍左右，比非 JIT 版本快 248倍左右。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;610:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;本例中计算止损，只需要找到drawdown大于threshold的第一天，一般不需要使用所有的行。如果数据中最后一天才会达到threshold，那么JIT版本的速度会和向量化计算十分接近。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;54-计算持仓成本&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;612:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;612:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;5.4. 计算持仓成本&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;612:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;614:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;若同一个标的的买入卖出交易反复发生，要计算每一笔卖出交易的盈利（或亏损），需要计算平均持仓成本。第一笔买入交易的价格为持仓成本；后续买入交易后，平均持仓成本为之前平均持仓成本与最新交易价格的加权平均；卖出后，平均持仓成本不变；若全部卖出，则重新开始计算持仓成本。这是一个典型的路径依赖问题，不能向量化解决。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;616:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;下例中 trades 表的字段 price 表示交易价格，amount 表示交易量（正数为买入，负数为卖出）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;618:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;不使用JIT计算持仓成本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;def holdingCost_no_JIT(price, amount){ holding = 0.0 cost = 0.0 avgPrice = 0.0 n = size(price) avgPrices = array(DOUBLE, n, n, 0) for (i in 0:n){ holding += amount[i] if (amount[i] &amp;gt; 0){ cost += amount[i] * price[i] avgPrice = cost/holding } else{ cost += amount[i] * avgPrice } avgPrices[i] = avgPrice } return avgPrices }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;640:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;使用JIT计算持仓成本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;@jit def holdingCost_JIT(price, amount){ holding = 0.0 cost = 0.0 avgPrice = 0.0 n = size(price) avgPrices = array(DOUBLE, n, n, 0) for (i in 0..n){ holding += amount[i] if (amount[i] &amp;gt; 0){ cost += amount[i] * price[i] avgPrice = cost/holding } else{ cost += amount[i] * avgPrice } avgPrices[i]=avgPrice } return avgPrices }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;以下为性能对比：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;664:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;n=1000000 id = 1..n price = take(101..109,n) amount =take(1 2 3 -2 -1 -3 4 -1 -2 2 -1,n) trades = table(id, price, amount) timer (10) t = select *, iif(amount &amp;lt; 0, amount*(avgPrice - price), 0) as profit from ( select *, holdingCost_no_JIT(price, amount) as avgPrice from trades ) // 29,509ms timer (10) select *, iif(amount &amp;lt; 0, amount*(avgPrice - price), 0) as profit from ( select *, holdingCost_JIT(price, amount) as avgPrice from trades ) // 148 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;685:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;本例中，使用100万行数据进行计算，JIT版本和非JIT版本在同一台机器各运行10次，耗时分别是148毫秒和29509毫秒。JIT版本比非JIT版本快约200倍。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-未来&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;687:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;687:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;6. 未来&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;687:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;689:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;在后续的版本中，我们计划逐步支持以下功能：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;支持更多的数学和统计类函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;692:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;增强类型推导功能，能够识别更多DolphinDB内置函数返回值的数据类型。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;7. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;696:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/jit.md&#34;&gt;DolphinDB推出了即时编译执行自定义函数的功能，显著提高了for循环，while循环和if-else等语句的运行速度，特别适合于无法使用向量化运算但又对运行速度有极高要求的场景，例如高频因子计算、实时流数据处理等。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/jit.md"/><meta name="wh-out-relpath" content="tutorials/jit.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="即时编译jit" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="即时编译jit"><div class="title"><a href="../tutorials/jit.html">即时编译（JIT）</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem" class="active"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">即时编译（JIT）</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 从 1.01 版本开始支持 JIT，本篇教程将结合实际例子介绍 JIT 的使用和注意事项。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-jit简介"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. JIT简介</h2><div class="- topic/body body"><p class="- topic/p p">即时编译（英文: Just-in-time compilation, 缩写: JIT），又译为及时编译或实时编译，是动态编译的一种形式，可提高程序运行效率。</p><p class="- topic/p p">通常程序有两种运行方式：编译执行和解释执行。编译执行在程序执行前全部翻译为机器码，特点是运行效率较高，以 C/C++ 为代表。解释执行是由解释器对程序逐句解释并执行，灵活性较强，但是执行效率较低，以 Python 为代表。</p><p class="- topic/p p">即时编译融合了两者的优点，在运行时将代码翻译为机器码，可以达到与静态编译语言相近的执行效率。Python 的第三方实现 PyPy 通过 JIT 明显改善了解释器的性能。绝大多数的 Java 实现都依赖 JIT 以提高代码的运行效率。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-jit-在-dolphindb-中的作用"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. JIT 在 DolphinDB 中的作用</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 的编程语言是解释执行，运行程序时首先对程序进行语法分析生成语法树，然后递归执行。在不能使用向量化的情况下，解释成本会比较高。这是由于 DolphinDB 底层由 C++ 实现，脚本中的一次函数调用会转化为多次 C++ 内的虚拟函数调用。for 循环，while 循环和 if-else 等语句中，由于要反复调用函数，十分耗时，在某些场景下不能满足实时性的需求。</p><p class="- topic/p p">DolphinDB 中的即时编译功能显著提高了for循环，while循环和if-else等语句的运行速度，特别适合于无法使用向量化运算但又对运行速度有极高要求的场景，例如高频因子计算、实时流数据处理等。</p><p class="- topic/p p">下面，我们使用一个最简单的例子，对比使用和不使用JIT的情况下，do-while循环计算1到1000000之和100次所需要的时间。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_without_jit(v) {
  s = 0F
  i = 0
  n = size(v)
  do {
    s += v[i]
    i += 1
  } while(i &lt; n)
  return s
}

@jit
def sum_with_jit(v) {
  s = 0F
  i = 0
  n = size(v)
  do {
    s += v[i]
    i += 1
  } while(i &lt; n)
  return s
}

vec = 1..1000000

timer(100) sum_without_jit(vec)     //  91017 ms
timer(100) sum_with_jit(vec)        //    217 ms</code></pre><p class="- topic/p p">不使用 JIT 的耗时是使用 JIT 的 419 倍。</p><p class="- topic/p p">请注意，以上例子仅是为了展示在 do-while 循环中 JIT 的性能优势。实际应用中，类似上例的简单循环计算，一般应当优先使用DolphinDB的内置函数进行向量化运算，这是由于很多内置函数采用了进一步的优化，而且使用内置函数更为方便。上例中，若使用 <code class="+ topic/ph pr-d/codeph ph codeph">sum</code> 函数，耗时是JIT的20%左右。一般来说，循环的操作与计算越复杂，JIT 相对于使用内置函数的优势越大。</p><p class="- topic/p p">在<a class="- topic/xref xref" href="https://zhuanlan.zhihu.com/p/77988657" target="_blank" rel="external noopener">知乎上的一篇专栏</a>中，我们展示了如何使用在 DolphinDB 中使用向量化运算，其中计算交易信号的式子如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>direction = (iif(signal&gt;t1, 1h, iif(signal&lt;t10, 0h, 00h)) - iif(signal&lt;t2, 1h, iif(signal&gt;t20, 0h, 00h))).ffill().nullFill(0h)</code></pre><p class="- topic/p p">对于 DolphinDB 初学者来说，需要了解 <code class="+ topic/ph pr-d/codeph ph codeph">iif</code> 函数才可写出以上语句。使用 for 循环改写以上语句则较为容易：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def calculate_with_jit(signal, n, t1, t10, t20, t2) {
  cur = 0
  idx = 0
  output = array(INT, n, n)
  for (s in signal) {
    if(s &gt; t1) {           // (t1, inf)
      cur = 1
    } else if(s &gt;= t10) {  // [t10, t1]
      if(cur == -1) cur = 0
    } else if(s &gt; t20) {   // [t20, t10)
      cur = 0
    } else if(s &gt;= t2) {   // [t2, t20]
      if(cur == 1) cur = 0
    } else {               // (-inf, t2)
      cur = -1
    }
    output[idx] = cur
    idx += 1
  }
  return output
}</code></pre><p class="- topic/p p">在上述脚本中把@jit去掉，并将函数名改为 <code class="+ topic/ph pr-d/codeph ph codeph">calculate_without_jit</code> ，以产生不使用JIT的自定义函数。对比三种方法的耗时：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 10000000
t1= 60
t10 = 50
t20 = 30
t2 = 20
signal = rand(100.0, n)

timer ffill!(iif(signal&gt;t1, 1h, iif(signal&lt;t10, 0h, 00h)) - iif(signal&lt;t2, 1h, iif(signal&gt;t20, 0h, 00h))).nullFill(0h) // 410.920 ms
timer calculate_with_jit(signal, size(signal), t1, t10, t20, t2)        //    170.7513 ms
timer calculate_without_jit(signal, size(signal), t1, t10, t20, t2)               //  14044.0641 ms</code></pre><p class="- topic/p p">本例中，使用JIT的速度是向量化运算的2.4倍，是不用JIT的82倍。这里JIT的速度比向量化运算还要快，是因为向量化运算中调用了很多次DolphinDB的内置函数，产生了很多中间结果，
涉及到多次内存分配以及虚拟函数调用，而JIT生成的代码则没有这些额外的开销。</p><p class="- topic/p p">某些计算无法使用向量化，比如计算期权隐含波动率(implied volatility)时，需要使用牛顿法，无法使用向量化运算。这种情况下如果需要满足一定的实时性，可以选择使用DolphinDB的插件，亦可使用JIT。两者的区别在于，在任何场景下都可以使用插件，但是需要使用 C++ 编写，比较复杂；JIT的编写相对而言较为容易，但是适用的场景较为有限。JIT的运行速度与使用C++插件的速度非常接近。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3-如何在-dolphindb-中使用-jit"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3. 如何在 DolphinDB 中使用 JIT</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="31-使用方法"><h3 class="- topic/title title topictitle3" id="ariaid-title5">3.1. 使用方法</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 目前仅支持对用户自定义函数进行 JIT。只需在函数定义之前的一行添加 <strong class="+ topic/ph hi-d/b ph b">@jit</strong> 的标识即可：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def myFunc(/* arguments */) {
  /* implementation */
}</code></pre><p class="- topic/p p">用户在调用此函数时，DolphinDB会将函数的代码实时编译为机器码后执行。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="32-支持语句"><h3 class="- topic/title title topictitle3" id="ariaid-title6">3.2. 支持语句</h3><div class="- topic/body body"><p class="- topic/p p">目前 DolphinDB 支持在 JIT 中使用以下几种语句：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">赋值语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def func() {
  y = 1
}</code></pre><p class="- topic/p p">请注意，multiple assign 目前是不支持的，例如：</p><p class="- topic/p p">@jit
def func() {
a, b = 1, 2
}
func()
运行以上语句会抛出异常。</p></li><li class="- topic/li li"><p class="- topic/p p">return 语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def func() {
  return 1
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">if-else 语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def myAbs(x) {
  if(x &gt; 0) return x
  else return -x
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">do-while 语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def mySqrt(x) {
    diff = 0.0000001
    guess = 1.0
    guess = (x / guess + guess) / 2.0
    do {
        guess = (x / guess + guess) / 2.0
    } while(abs(guess * guess - x) &gt;= diff)
    return guess
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">for 语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def mySum(vec) {
  s = 0
  for(i in vec) {
    s += i
  }
  return s
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">break 和 continue语句，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def mySum(vec) {
  s = 0
  for (i in vec) {
    if(i % 2 == 0) continue
    s += i
  }
  return s
}</code></pre></li></ul><p class="- topic/p p">DolphinDB 支持在 JIT 中以上语句的任意嵌套。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="33-支持的运算符和函数"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.3. 支持的运算符和函数</h3><div class="- topic/body body"><p class="- topic/p p">目前DolphinDB支持在JIT中使用以下的运算符：add(+), sub(-), multiply(*), divide(/), and(&amp;&amp;), or(||), bitand(&amp;), bitor(|), bitxor(^), eq(==), neq(!=), ge(&gt;=), gt(&gt;), le(&lt;=), lt(&lt;), neg(-), mod(%), seq(..), at([])，以上运算在所有数据类型下的实现都与非JIT的实现一致。</p><p class="- topic/p p">目前DolphinDB支持在JIT中使用以下的数学函数： <code class="+ topic/ph pr-d/codeph ph codeph">exp</code> , <code class="+ topic/ph pr-d/codeph ph codeph">log</code> , <code class="+ topic/ph pr-d/codeph ph codeph">sin</code> , <code class="+ topic/ph pr-d/codeph ph codeph">asin</code> , <code class="+ topic/ph pr-d/codeph ph codeph">cos</code> , <code class="+ topic/ph pr-d/codeph ph codeph">acos</code> , <code class="+ topic/ph pr-d/codeph ph codeph">tan</code> , <code class="+ topic/ph pr-d/codeph ph codeph">atan</code> , <code class="+ topic/ph pr-d/codeph ph codeph">abs</code> , <code class="+ topic/ph pr-d/codeph ph codeph">ceil</code> , <code class="+ topic/ph pr-d/codeph ph codeph">floor</code> , <code class="+ topic/ph pr-d/codeph ph codeph">sqrt</code>。以上数学函数在JIT中出现时，
如果接受的参数为scalar，那么在最后生成的机器码中会调用glibc中对应的函数或者经过优化的C实现的函数；如果接收的参数为array，那么最后会调用DolphinDB提供的数学函数。这样的好处是通过直接调用C实现的代码提升函数运行效率，减少不必要的虚拟函数调用和内存分配。</p><p class="- topic/p p">目前DolphinDB支持在JIT中使用以下的内置函数：<code class="+ topic/ph pr-d/codeph ph codeph">take</code>, <code class="+ topic/ph pr-d/codeph ph codeph">seq</code> , <code class="+ topic/ph pr-d/codeph ph codeph">array</code>, <code class="+ topic/ph pr-d/codeph ph codeph">size</code>, <code class="+ topic/ph pr-d/codeph ph codeph">isValid</code>, <code class="+ topic/ph pr-d/codeph ph codeph">rand</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfNormal</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfBeta</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfBinomial</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfChiSquare</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfExp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfF</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfGamma</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfKolmogorov</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfcdfLogistic</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfNormal</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfUniform</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfWeibull</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cdfZipf</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invBeta</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invBinomial</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invChiSquare</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invExp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invF</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invGamma</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invLogistic</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invNormal</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invPoisson</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invStudent</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invUniform</code>, <code class="+ topic/ph pr-d/codeph ph codeph">invWeibull</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cbrt</code>, <code class="+ topic/ph pr-d/codeph ph codeph">deg2rad</code>, <code class="+ topic/ph pr-d/codeph ph codeph">rad2deg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">det</code>, <code class="+ topic/ph pr-d/codeph ph codeph">dot</code>, <code class="+ topic/ph pr-d/codeph ph codeph">flatten</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">avg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">count</code>, <code class="+ topic/ph pr-d/codeph ph codeph">size</code>, <code class="+ topic/ph pr-d/codeph ph codeph">min</code>, <code class="+ topic/ph pr-d/codeph ph codeph">max</code>, <code class="+ topic/ph pr-d/codeph ph codeph">iif</code>, <code class="+ topic/ph pr-d/codeph ph codeph">round</code>。</p><p class="- topic/p p">需要注意，<code class="+ topic/ph pr-d/codeph ph codeph">array</code> 函数的第一个参数必须直接指定具体的数据类型，不能通过变量传递指定。这是由于JIT编译时必须知道所有变量的类型，而 <code class="+ topic/ph pr-d/codeph ph codeph">array</code> 函数返回结果的类型由第一个参数指定，因此编译时必须该值必须已知。
此外，<code class="+ topic/ph pr-d/codeph ph codeph">round</code> 函数在使用时必须指定第二个参数，且该参数须大于0。</p><p class="- topic/p p">目前DolphinDB已支持 cum 系列函数，但须注意目前仅支持输入类型为 Vector。
支持的单目函数有：<code class="+ topic/ph pr-d/codeph ph codeph">cummax</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cummin</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cummed</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumfirstNot</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumlastNot</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumrank</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumcount</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumpercentile</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumstd</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumstdp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumvar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumvarp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumsum2</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumsum3</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumsum4</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumavg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumprod</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumPositiveStreak</code>。
支持的双目函数有：<code class="+ topic/ph pr-d/codeph ph codeph">cumbeta</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumwsum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumwavg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumcovar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">cumcorr</code>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="34-空值的处理"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.4. 空值的处理</h3><div class="- topic/body body"><p class="- topic/p p">JIT中所有的函数和运算符处理空值的方法都与原生函数和运算符一致，即每个数据类型都用该类型的最小值来表示该类型的空值，用户不需要专门处理空值。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="35-jit函数之间的调用"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.5. JIT函数之间的调用</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB的JIT函数可以调用另一个JIT函数。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def myfunc1(x) {
  return sqrt(x) + exp(x)
}

@jit
def myfunc2(x) {
  return myfunc1(x)
}

myfunc2(1.5)</code></pre><p class="- topic/p p">在上面的例子中，内部会先编译 <code class="+ topic/ph pr-d/codeph ph codeph">myfunc1</code> , 生成一个签名为 double myfunc1(double) 的native函数， <code class="+ topic/ph pr-d/codeph ph codeph">myfunc2</code> 生成的机器码中直接调用这个函数，而不是在运行时判断 <code class="+ topic/ph pr-d/codeph ph codeph">myfunc1</code> 是否为JIT函数后再执行，从而达到最高的执行效率。</p><p class="- topic/p p">请注意，JIT函数内不可以调用非JIT的用户自定义函数，因为这样无法进行类型推导。关于类型推导下面会提到。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="36-jit-的编译成本以及缓存机制"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.6. JIT 的编译成本以及缓存机制</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 的 JIT 底层依赖<a class="- topic/xref xref" href="https://llvm.org/" target="_blank" rel="external noopener">LLVM</a>实现，每个用户自定义函数在编译时都会生成自己的module，相互独立。编译主要包含以下几个步骤：</p><ol class="- topic/ol ol"><li class="- topic/li li">LLVM相关变量和环境的初始化</li><li class="- topic/li li">根据DolphinDB脚本的语法树生成LLVM的IR</li><li class="- topic/li li">调用LLVM优化第二步生成的IR，然后编译为机器码</li></ol><p class="- topic/p p">以上步骤中第一步耗时一般在5ms以内，后面两步的耗时与实际脚本的复杂度成正比，总体而言编译耗时基本上在50ms以内。</p><p class="- topic/p p">对于一个JIT函数以及一个参数类型组合，DolphinDB只会编译一次。系统会对JIT函数编译的结果进行缓存。系统根据用户调用一个JIT函数时提供的参数的数据类型得到一个对应的字符串，然后在一个哈希表中寻找这个字符串对应的编译结果，如果存在则直接调用；如果不存在则开始编译，并将编译结果保存到此哈希表中，然后执行。</p><p class="- topic/p p">对需要反复执行的任务，或者运行时间远超编译耗时的任务，JIT会显著提高运行速度。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="37-支持函数作为函数参数"><h3 class="- topic/title title topictitle3" id="ariaid-title11">3.7. 支持函数作为函数参数</h3><div class="- topic/body body"><p class="- topic/p p">从1.2.0版本开始，DolphinDB的JIT支持函数以及部分应用（包括嵌套的部分应用）作为函数参数。下面举例说明：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def foo(f, x, y){return f(x,y)}

@jit
def h(x,y){return x+y}

@jit
def g(x,y){return foo(h, x, y)}</code></pre><p class="- topic/p p">上例中，函数<code class="+ topic/ph pr-d/codeph ph codeph">g</code>中引用的函数<code class="+ topic/ph pr-d/codeph ph codeph">foo</code>的第一个参数是函数<code class="+ topic/ph pr-d/codeph ph codeph">h</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def h(a,b,c){return a + b + c}

@jit
def foo(f,x,y){return f(x,y)}

@jit
def g(x,y,z){return foo(h{x}, y, z)}</code></pre><p class="- topic/p p">上例中，将部分应用h作为第一个参数传给foo。其中部分应用的自由参数可以是任意的，可为h{,x}，h{,,x}或者h{x,,y}等等。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def f1(x,y,z){return x + y + z}

@jit
def f2(g2){return g2(1)}

@jit
def f3(g3){return f2(g3{2})}

@jit
def f4(){return f3(f1{,,3})}

f4()</code></pre><p class="- topic/p p">嵌套部分应用也是支持的，在上面的例子中，f4中将f1{,,3}传给f3, 在f3中对这个函数参数又进行了一次部分应用。</p><p class="- topic/p p">需要注意的是，如果同一个函数参数在一个JIT函数中有多种签名，由于编译实现的限制，执行时会报异常。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def foo(x,y){return x + y}

@jit
def f1(f){return f(1,2) + f(1.0,2)}

@jit
def f2(){return f1(foo)}

f2() 
//抛出异常</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="38-对数据形式的拓展支持"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.8. 对数据形式的拓展支持</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 的 JIT 对以下数据形式实现了拓展支持：</p><ul class="- topic/ul ul"><li class="- topic/li li">矩阵</li><li class="- topic/li li">集合</li><li class="- topic/li li">字典</li><li class="- topic/li li">表</li><li class="- topic/li li">元组</li><li class="- topic/li li">数组向量</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="4-类型推导"><h2 class="- topic/title title topictitle2" id="ariaid-title13">4. 类型推导</h2><div class="- topic/body body"><p class="- topic/p p">在使用LLVM生成IR之前，必须知道脚本中所有变量的类型，这个步骤就是类型推导。DolphinDB的JIT使用的类型推导方式是局部推导，比如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def foo() {
  x = 1
  y = 1.1
  z = x + y
  return z
}</code></pre><p class="- topic/p p">通过 x = 1 确定x的类型是int；通过 y = 1.1 确定y的类型是 double；通过 z = x + y 以及上面推得的x和y的类型，确定z的类型也是double；通过 return z 确定 <code class="+ topic/ph pr-d/codeph ph codeph">foo</code> 函数的返回类型是double。</p><p class="- topic/p p">如果函数有参数的话，比如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def foo(x) {
  return x + 1
}</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">foo</code> 函数的返回类型就依赖于输入值x的类型。</p><p class="- topic/p p">上面我们提到了目前JIT支持的数据类型，如果函数内部出现了不支持的类型，或者输入的变量类型不支持，那么就会导致整个函数的变量类型推导失败，在运行时会抛出异常。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def foo(x) {
  return x + 1
}

foo(123)             // 正常执行
foo(1:2)             // 正常执行
foo("abc")           // 抛出异常，因为目前不支持STRING
foo((1 2, 3 4, 5 6)) // 抛出异常，因为目前不支持tuple</code></pre><p class="- topic/p p">因此，为了能够正常使用JIT函数，用户应该避免在函数内或者参数中使用尚不支持的函数。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title14" id="5-实例"><h2 class="- topic/title title topictitle2" id="ariaid-title14">5. 实例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="51-计算隐含波动率-implied-volatility"><h3 class="- topic/title title topictitle3" id="ariaid-title15">5.1. 计算隐含波动率 (implied volatility)</h3><div class="- topic/body body"><p class="- topic/p p">上面提到过某些计算无法进行向量化运算，计算隐含波动率 (implied volatility)就是一个例子：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def GBlackScholes(future_price, strike, input_ttm, risk_rate, b_rate, input_vol, is_call) {
  ttm = input_ttm + 0.000000000000001;
  vol = input_vol + 0.000000000000001;

  d1 = (log(future_price/strike) + (b_rate + vol*vol/2) * ttm) / (vol * sqrt(ttm));
  d2 = d1 - vol * sqrt(ttm);

  if (is_call) {
    return future_price * exp((b_rate - risk_rate) * ttm) * cdfNormal(0, 1, d1) - strike * exp(-risk_rate*ttm) * cdfNormal(0, 1, d2);
  } else {
    return strike * exp(-risk_rate*ttm) * cdfNormal(0, 1, -d2) - future_price * exp((b_rate - risk_rate) * ttm) * cdfNormal(0, 1, -d1);
  }
}

@jit
def ImpliedVolatility(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) {
  high=5.0;
  low = 0.0;

  do {
    if (GBlackScholes(future_price, strike, ttm, risk_rate, b_rate, (high+low)/2, is_call) &gt; option_price) {
      high = (high+low)/2;
    } else {
      low = (high + low) /2;
    }
  } while ((high-low) &gt; 0.00001);

  return (high + low) /2;
}

@jit
def test_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call) {
	n = size(future_price)
	ret = array(DOUBLE, n, n)
	i = 0
	do {
		ret[i] = ImpliedVolatility(future_price[i], strike[i], ttm[i], risk_rate[i], b_rate[i], option_price[i], is_call[i])
		i += 1
	} while(i &lt; n)
	return ret
}

n = 100000
future_price=take(rand(10.0,1)[0], n)
strike_price=take(rand(10.0,1)[0], n)
strike=take(rand(10.0,1)[0], n)
input_ttm=take(rand(10.0,1)[0], n)
risk_rate=take(rand(10.0,1)[0], n)
b_rate=take(rand(10.0,1)[0], n)
vol=take(rand(10.0,1)[0], n)
input_vol=take(rand(10.0,1)[0], n)
multi=take(rand(10.0,1)[0], n)
is_call=take(rand(10.0,1)[0], n)
ttm=take(rand(10.0,1)[0], n)
option_price=take(rand(10.0,1)[0], n)

timer(10) test_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call)          //  2621.73 ms
timer(10) test_non_jit(future_price, strike, ttm, risk_rate, b_rate, option_price, is_call)      //   302714.74 ms
</code></pre><p class="- topic/p p">上面的例子中， <code class="+ topic/ph pr-d/codeph ph codeph">ImpliedVolatility</code> 会调用 <code class="+ topic/ph pr-d/codeph ph codeph">GBlackScholes</code> 函数。函数 <code class="+ topic/ph pr-d/codeph ph codeph">test_non_jit</code> 可通过把 <code class="+ topic/ph pr-d/codeph ph codeph">test_jit</code> 定义之前的@jit去掉以获取。JIT版本 <code class="+ topic/ph pr-d/codeph ph codeph">test_jit</code> 运行速度是非JIT版本 <code class="+ topic/ph pr-d/codeph ph codeph">test_non_jit</code> 的115倍。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="52-计算-greeks"><h3 class="- topic/title title topictitle3" id="ariaid-title16">5.2. 计算 Greeks</h3><div class="- topic/body body"><p class="- topic/p p">量化金融中经常使用<a class="- topic/xref xref" href="https://www.wikiwand.com/en/Greeks_(finance)" target="_blank" rel="external noopener">Greeks</a>进行风险评估，下面以charm(delta衰减)为例展示JIT的使用：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def myMax(a,b){
	if(a&gt;b){
		return a
	}else{
		return b
	}
}

@jit
def NormDist(x) {
  return cdfNormal(0, 1, x);
}

@jit
def ND(x) {
  return (1.0/sqrt(2*pi)) * exp(-(x*x)/2.0)
}

@jit
def CalculateCharm(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) {
  day_year = 245.0;

  d1 = (log(future_price/strike_price) + (b_rate + (vol*vol)/2.0) * input_ttm) / (myMax(vol,0.00001) * sqrt(input_ttm));
  d2 = d1 - vol * sqrt(input_ttm);

  if (is_call) {
    return -exp((b_rate - risk_rate) * input_ttm) * (ND(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) + (b_rate-risk_rate) * NormDist(d1)) * future_price * multi / day_year;
  } else {
    return -exp((b_rate - risk_rate) * input_ttm) * (ND(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) - (b_rate-risk_rate) * NormDist(-d1)) * future_price * multi / day_year;
  }
}

@jit
def test_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) {
	n = size(future_price)
	ret = array(DOUBLE, n, n)
	i = 0
	do {
		ret[i] = CalculateCharm(future_price[i], strike_price[i], input_ttm[i], risk_rate[i], b_rate[i], vol[i], multi[i], is_call[i])
		i += 1
	} while(i &lt; n)
	return ret
}

def ND_validate(x) {
  return (1.0/sqrt(2*pi)) * exp(-(x*x)/2.0)
}

def NormDist_validate(x) {
  return cdfNormal(0, 1, x);
}

def CalculateCharm_vectorized(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call) {
	day_year = 245.0;

	d1 = (log(future_price/strike_price) + (b_rate + pow(vol, 2)/2.0) * input_ttm) / (max(vol, 0.00001) * sqrt(input_ttm));
	d2 = d1 - vol * sqrt(input_ttm);
	return iif(is_call,-exp((b_rate - risk_rate) * input_ttm) * (ND_validate(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) + (b_rate-risk_rate) * NormDist_validate(d1)) * future_price * multi / day_year,-exp((b_rate - risk_rate) * input_ttm) * (ND_validate(d1) * (b_rate/vol/sqrt(input_ttm) - d2/2.0/input_ttm) - (b_rate-risk_rate) * NormDist_validate(-d1)) * future_price * multi / day_year)
}

n = 1000000
future_price=rand(10.0,n)
strike_price=rand(10.0,n)
strike=rand(10.0,n)
input_ttm=rand(10.0,n)
risk_rate=rand(10.0,n)
b_rate=rand(10.0,n)
vol=rand(10.0,n)
input_vol=rand(10.0,n)
multi=rand(10.0,n)
is_call=rand(true false,n)
ttm=rand(10.0,n)
option_price=rand(10.0,n)

timer(10) test_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call)                     //   1834 ms
timer(10) test_none_jit(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call)                // 224099 ms
timer(10) CalculateCharm_vectorized(future_price, strike_price, input_ttm, risk_rate, b_rate, vol, multi, is_call)    //   3118 ms</code></pre><p class="- topic/p p">本例比上一节更加复杂，涉及到更多的函数调用和更复杂的计算。JIT比非JIT快120倍，比向量化版本快70%。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="53-计算止损点-stoploss"><h3 class="- topic/title title topictitle3" id="ariaid-title17">5.3. 计算止损点 (stoploss)</h3><div class="- topic/body body"><p class="- topic/p p">在这篇<a class="- topic/xref xref" href="https://zhuanlan.zhihu.com/p/47236676" target="_blank" rel="external noopener">知乎专栏</a>中，我们展示了如何使用DolphinDB进行技术信号回测，下面我们用JIT来实现其中的stoploss函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def stoploss_JIT(ret, threshold) {
	n = ret.size()
	i = 0
	curRet = 1.0
	curMaxRet = 1.0
	indicator = take(true, n)

	do {
		indicator[i] = false
		curRet *= (1 + ret[i])
		if(curRet &gt; curMaxRet) { curMaxRet = curRet }
		drawDown = 1 - curRet / curMaxRet;
		if(drawDown &gt;= threshold) {
      break
		}
		i += 1
	} while(i &lt; n)

	return indicator
}

def stoploss_no_JIT(ret, threshold) {
	n = ret.size()
	i = 0
	curRet = 1.0
	curMaxRet = 1.0
	indicator = take(true, n)

	do {
		indicator[i] = false
		curRet *= (1 + ret[i])
		if(curRet &gt; curMaxRet) { curMaxRet = curRet }
		drawDown = 1 - curRet / curMaxRet;
		if(drawDown &gt;= threshold) {
      break
		}
		i += 1
	} while(i &lt; n)

	return indicator
}

def stoploss_vectorization(ret, threshold){
	cumret = cumprod(1+ret)
 	drawDown = 1 - cumret / cumret.cummax()
	firstCutIndex = at(drawDown &gt;= threshold).first() + 1
	indicator = take(false, ret.size())
	if(isValid(firstCutIndex) and firstCutIndex &lt; ret.size())
		indicator[firstCutIndex:] = true
	return indicator
}
ret = take(0.0008 -0.0008, 1000000)
threshold = 0.10
timer(10) stoploss_JIT(ret, threshold)              //      59 ms
timer(10) stoploss_no_JIT(ret, threshold)           //   14622 ms
timer(10) stoploss_vectorization(ret, threshold)    //     152 ms</code></pre><p class="- topic/p p">用JIT实现的版本比向量化版本快了 1.5 倍左右，比非 JIT 版本快 248倍左右。</p><p class="- topic/p p">本例中计算止损，只需要找到drawdown大于threshold的第一天，一般不需要使用所有的行。如果数据中最后一天才会达到threshold，那么JIT版本的速度会和向量化计算十分接近。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="54-计算持仓成本"><h3 class="- topic/title title topictitle3" id="ariaid-title18">5.4. 计算持仓成本</h3><div class="- topic/body body"><p class="- topic/p p">若同一个标的的买入卖出交易反复发生，要计算每一笔卖出交易的盈利（或亏损），需要计算平均持仓成本。第一笔买入交易的价格为持仓成本；后续买入交易后，平均持仓成本为之前平均持仓成本与最新交易价格的加权平均；卖出后，平均持仓成本不变；若全部卖出，则重新开始计算持仓成本。这是一个典型的路径依赖问题，不能向量化解决。</p><p class="- topic/p p">下例中 trades 表的字段 price 表示交易价格，amount 表示交易量（正数为买入，负数为卖出）。</p><p class="- topic/p p">不使用JIT计算持仓成本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def holdingCost_no_JIT(price, amount){
	holding = 0.0
	cost = 0.0
	avgPrice = 0.0
	n = size(price)
	avgPrices = array(DOUBLE, n, n, 0)
	for (i in 0:n){
		holding += amount[i]
		if (amount[i] &gt; 0){
			cost += amount[i] * price[i]
			avgPrice = cost/holding
		}
		else{
			cost += amount[i] * avgPrice
		}
	    avgPrices[i] = avgPrice
	}
	return avgPrices
}</code></pre><p class="- topic/p p">使用JIT计算持仓成本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
def holdingCost_JIT(price, amount){
	holding = 0.0
	cost = 0.0
	avgPrice = 0.0
	n = size(price)
	avgPrices = array(DOUBLE, n, n, 0)
	for (i in 0..n){
		holding += amount[i]
		if (amount[i] &gt; 0){
			cost += amount[i] * price[i]
			avgPrice = cost/holding
		}
		else{
			cost += amount[i] * avgPrice
		}
		avgPrices[i]=avgPrice
	}
	return avgPrices
}</code></pre><p class="- topic/p p">以下为性能对比：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n=1000000
id = 1..n
price = take(101..109,n)
amount =take(1 2 3 -2 -1 -3 4 -1 -2 2 -1,n)
trades = table(id, price, amount)

timer (10)
t = select *, iif(amount &lt; 0, amount*(avgPrice - price), 0) as profit
from (
  select *, holdingCost_no_JIT(price, amount) as avgPrice
  from trades
)    // 29,509ms

timer (10)
select *, iif(amount &lt; 0, amount*(avgPrice - price), 0) as profit
from (
  select *, holdingCost_JIT(price, amount) as avgPrice
  from trades
)     // 148 ms</code></pre><p class="- topic/p p">本例中，使用100万行数据进行计算，JIT版本和非JIT版本在同一台机器各运行10次，耗时分别是148毫秒和29509毫秒。JIT版本比非JIT版本快约200倍。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="6-未来"><h2 class="- topic/title title topictitle2" id="ariaid-title19">6. 未来</h2><div class="- topic/body body"><p class="- topic/p p">在后续的版本中，我们计划逐步支持以下功能：</p><ul class="- topic/ul ul"><li class="- topic/li li">支持更多的数学和统计类函数。</li><li class="- topic/li li">增强类型推导功能，能够识别更多DolphinDB内置函数返回值的数据类型。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="7-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title20">7. 总结</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB推出了即时编译执行自定义函数的功能，显著提高了for循环，while循环和if-else等语句的运行速度，特别适合于无法使用向量化运算但又对运行速度有极高要求的场景，例如高频因子计算、实时流数据处理等。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-jit%E7%AE%80%E4%BB%8B" data-tocid="1-jit简介">1. JIT简介</a></li><li class="topic-item"><a href="#2-jit-%E5%9C%A8-dolphindb-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8" data-tocid="2-jit-在-dolphindb-中的作用">2. JIT 在 DolphinDB 中的作用</a></li><li class="topic-item"><a href="#3-%E5%A6%82%E4%BD%95%E5%9C%A8-dolphindb-%E4%B8%AD%E4%BD%BF%E7%94%A8-jit" data-tocid="3-如何在-dolphindb-中使用-jit">3. 如何在 DolphinDB 中使用 JIT</a><ul><li class="topic-item"><a href="#31-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95" data-tocid="31-使用方法">3.1. 使用方法</a></li><li class="topic-item"><a href="#32-%E6%94%AF%E6%8C%81%E8%AF%AD%E5%8F%A5" data-tocid="32-支持语句">3.2. 支持语句</a></li><li class="topic-item"><a href="#33-%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0" data-tocid="33-支持的运算符和函数">3.3. 支持的运算符和函数</a></li><li class="topic-item"><a href="#34-%E7%A9%BA%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86" data-tocid="34-空值的处理">3.4. 空值的处理</a></li><li class="topic-item"><a href="#35-jit%E5%87%BD%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8" data-tocid="35-jit函数之间的调用">3.5. JIT函数之间的调用</a></li><li class="topic-item"><a href="#36-jit-%E7%9A%84%E7%BC%96%E8%AF%91%E6%88%90%E6%9C%AC%E4%BB%A5%E5%8F%8A%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6" data-tocid="36-jit-的编译成本以及缓存机制">3.6. JIT 的编译成本以及缓存机制</a></li><li class="topic-item"><a href="#37-%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0" data-tocid="37-支持函数作为函数参数">3.7. 支持函数作为函数参数</a></li><li class="topic-item"><a href="#38-%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%8B%93%E5%B1%95%E6%94%AF%E6%8C%81" data-tocid="38-对数据形式的拓展支持">3.8. 对数据形式的拓展支持</a></li></ul></li><li class="topic-item"><a href="#4-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC" data-tocid="4-类型推导">4. 类型推导</a></li><li class="topic-item"><a href="#5-%E5%AE%9E%E4%BE%8B" data-tocid="5-实例">5. 实例</a><ul><li class="topic-item"><a href="#51-%E8%AE%A1%E7%AE%97%E9%9A%90%E5%90%AB%E6%B3%A2%E5%8A%A8%E7%8E%87-implied-volatility" data-tocid="51-计算隐含波动率-implied-volatility">5.1. 计算隐含波动率 (implied volatility)</a></li><li class="topic-item"><a href="#52-%E8%AE%A1%E7%AE%97-greeks" data-tocid="52-计算-greeks">5.2. 计算 Greeks</a></li><li class="topic-item"><a href="#53-%E8%AE%A1%E7%AE%97%E6%AD%A2%E6%8D%9F%E7%82%B9-stoploss" data-tocid="53-计算止损点-stoploss">5.3. 计算止损点 (stoploss)</a></li><li class="topic-item"><a href="#54-%E8%AE%A1%E7%AE%97%E6%8C%81%E4%BB%93%E6%88%90%E6%9C%AC" data-tocid="54-计算持仓成本">5.4. 计算持仓成本</a></li></ul></li><li class="topic-item"><a href="#6-%E6%9C%AA%E6%9D%A5" data-tocid="6-未来">6. 未来</a></li><li class="topic-item"><a href="#7-%E6%80%BB%E7%BB%93" data-tocid="7-总结">7. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>