<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="深度学习模型有能力自动发现变量之间的关系，而这些关系通常是不可见的，这使得深度学习可以挖掘新的因子和规律，为量化投资策略提供更多可能性。在传统的量化策略开发流程中，通常会使用 Python ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="ai-dataloader"/><title>AI DataLoader</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;ai-dataloader&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:1;1:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:1;1:1&#34;&gt;AI DataLoader&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:1;1:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:1;3:1&#34;&gt;深度学习模型有能力自动发现变量之间的关系，而这些关系通常是不可见的，这使得深度学习可以挖掘新的因子和规律，为量化投资策略提供更多可能性。在传统的量化策略开发流程中，通常会使用 Python 或第三方工具生成因子，并将其存储为文件。这些因子是构建深度学习模型的基础输入，包括技术指标、波动性指标和市场情绪指标等。随着证券交易规模不断扩大以及因子数据量的激增。传统的文件存储因子作为深度学习模型的输入，面临以下问题：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:1;5:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:1;5:1&#34;&gt;因子数据过大，内存带宽与存储空间瓶颈&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:2;6:1&#34;&gt;因子数据与深度学习模型集成工程化与成本问题&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:2;8:1&#34;&gt;为了应对这些挑战，DolphinDB将数据库与深度学习相结合，开发了AI Dataloader。该工具旨在提高因子数据的效率和管理，并简化与深度学习模型的交互。具体而言，DDBDataLoader类用于因子数据的管理和深度学习模型的集成，达到更贴近功能实现的目的。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;1-总体架构&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:2;10:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:2;10:1&#34;&gt;1. 总体架构&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:2;10:1&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_1.png&#34; width=&#34;550&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;image:1;12:1&#34; dita-ot:image-width=&#34;769&#34; dita-ot:image-height=&#34;302&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:3;14:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:1;14:1&#34;&gt;主要包括以下功能模块:&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:2;16:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:3;16:1&#34;&gt;因子数据存储模块&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:3;17:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:4;17:3&#34;&gt;DolphinDB 存储历史因子数据&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:5;18:1&#34;&gt;因子数据推送模块: 即 AI DataLoader（DDBDataLoader） 队列，其内部维护多个工作线程与消息队列，以提高并发性能，从 DolphinDB 中按照分区机制将因子数据转换为 PyTorch 等深度学习框架等可识别 tensor。策略研发人员可以实时从 DolphinDB 中获取所需的因子数据，并将其推送到深度学习模型中用于训练。这种实时性能帮助策略研发人员在需要时获取最新数据进行模型训练。&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:4;19:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:6;19:3&#34;&gt;第一步，构造 DDBDataLoader 对象，根据 groupCol 参数指定的数据列拆分为若干组查询，每组查询中，再根据 repartitionCol 参数指定的数据列拆分为若干个子查询，此种分割增加了数据的灵活性，使用户能够更精细地选择所需的数据，以满足深度学习模型的训练需求。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:7;20:3&#34;&gt;第二步，DDBDataLoader 对象内部线程根据拆分的数据，会在后台线程中转换以及拼接成 PyTorch 训练所需的数据，再放入预准备队列中，即图中2，通过此种方式，可以减少客户端内存的占用。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:8;21:3&#34;&gt;最后一步涉及从 DDBDataLoader 队列中迭代获取批量数据，并将这些数据返回给客户端，以供 PyTorch 训练使用，即图中5。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:4;23:1&#34;&gt;具体内部详细工作流程将在下一节 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:1;23:17&#34;&gt;工作原理&lt;/i&gt; 中详细介绍。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;2-工作原理&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:3;25:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:3;25:1&#34;&gt;2. 工作原理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:3;25:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:5;27:1&#34;&gt;在构造时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:1;27:6&#34;&gt;DDBDataLoader&lt;/codeph&gt; 接收用户提供的 SQL 查询语句，并将其拆分为多个子查询组。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:2;27:52&#34;&gt;DDBDataLoader &lt;/codeph&gt; 使用后台线程从服务端获取数据，并将其处理为 PyTorch Tensor 格式的批量数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:6;29:1&#34;&gt;DDBDataLoader 提供了 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:2;29:19&#34;&gt;groupCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:3;29:32&#34;&gt;groupScheme&lt;/i&gt; 参数，用于将单个查询 SQL 分成多组查询。其中，每一个组定义了一个时间序列，例如一支股票的交易数据。若不指定，则认为所有的数据定义了一个时间序列。例如，一种典型的情况是表里的数据包含了全部的股票，而我们在训练模型的时候只希望每支股票仅利用自己的历史数据来对未来进行预测。在这种情况下，我们需要将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:4;29:195&#34;&gt;groupCol&lt;/i&gt; 设置为股票标的列，将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:5;29:217&#34;&gt;groupScheme&lt;/i&gt; 设置为所有的股票标的，也即每一个组是一支股票的交易数据。换言之，假如原始的查询 SQL 为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:1;31:1&#34;&gt;select * from loadTable(dbName, tableName)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:7;35:1&#34;&gt;假设 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:6;35:4&#34;&gt;groupScheme&lt;/i&gt; 为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:3;35:20&#34;&gt;stockID&lt;/codeph&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:7;35:32&#34;&gt;groupScheme&lt;/i&gt; 为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:4;35:48&#34;&gt;[&#34;apple&#34;, &#34;google&#34;, &#34;amazon&#34;]&lt;/codeph&gt;，则原始的查询会被拆分成以下三组查询：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:2;37:1&#34;&gt;select * from loadTable(dbName, tableName) where stockID = &#34;apple&#34; select * from loadTable(dbName, tableName) where stockID = &#34;google&#34; select * from loadTable(dbName, tableName) where stockID = &#34;amazon&#34;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:8;43:1&#34;&gt;模型训练的时候，每组训练数据则只会来源于以上三组中的某一组，而不会出现跨组的情况。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:9;45:1&#34;&gt;另一方面，为了避免加载大量数据至内存中，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:5;45:21&#34;&gt;DDBDataLoader&lt;/codeph&gt; 采用分区粒度管理数据。也就是说，每组查询每次只加载一个分区到内存中。通常来说， DolphinDB 的一个分区的大小在 100MB 到 1GB 之间，因此这种设计可以很好地限制内存的使用量。另一方面，基于这种分区粒度的管理方式，使得 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:6;45:154&#34;&gt;DDBDataLoader&lt;/codeph&gt; 实现的 shuffle 和传统的 dataloader 实现的 shuffle 会有一些区别。具体地说，传统的 shuffle 是将数据进行完全随机地打乱，但这样会引入大量的随机 IO，会使得效率偏低。而 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:7;45:273&#34;&gt;DDBDataLoader&lt;/codeph&gt; 使用的 shuffle 方式，则是先随机地选取一个数据的分区并读取，随后在这个分区内部进行 shuffle。使用这种方式，可以最大化地减少随机的 IO，以提升整个训练过程的效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:10;47:1&#34;&gt;另一组要说明的参数是 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:8;47:12&#34;&gt;repartitionCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:9;47:32&#34;&gt;repartitionScheme&lt;/i&gt; 。这组参数主要处理的是单个查询没办法直接拆成多个分区的情况。例如，一种常见的使用 DolphinDB 管理因子数据的方法是使用纵表来对因子数据进行管理（详见 &lt;xref class=&#34;- topic/xref &#34; href=&#34;best_practices_for_multi_factor.md&#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:1;47:131&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;best_practices_for_multi_factor.md&lt;/xref&gt;）。使用这种方法，则在获取可用的训练数据之前，需要先对所有的数据做一个 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:8;47:239&#34;&gt;pivot by&lt;/codeph&gt; 将数据从纵表转化为宽表。然而，用户的数据量可能非常大，例如几百 G 甚至更多，在这种情况下，服务器的内存完全可能不够完成对所有数据的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:9;47:317&#34;&gt;pivot by&lt;/codeph&gt; 。针对这类情况，DDBDataLoader 提供了 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:10;47:354&#34;&gt;repartitionCol&lt;/i&gt; 和&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:11;47:372&#34;&gt;repartitionScheme&lt;/i&gt; 参数这组参数，这组参数的作用是可以对全表的数据做进一步的切分，将全表数据按照 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:12;47:432&#34;&gt;repartitionCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:13;47:451&#34;&gt;repartitionScheme&lt;/i&gt; 拆成多个子表，然后对于每一个子表再做单独的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:10;47:494&#34;&gt;pivot by&lt;/codeph&gt;。换言之，假设原始的查询 SQL 为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:3;49:1&#34;&gt;select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:11;53:1&#34;&gt;假设 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:14;53:4&#34;&gt;repartitionCol&lt;/i&gt; 为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:11;53:23&#34;&gt;date(datetime)&lt;/codeph&gt;，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:15;53:40&#34;&gt;repartitionScheme&lt;/i&gt; 为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:12;53:62&#34;&gt;[&#34;2023.09.05&#34;, &#34;2023.09.06&#34;, &#34;2023.09.07&#34;]&lt;/codeph&gt;，则上述 的查询相当于会被拆成以下几个子查询：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:4;55:1&#34;&gt;select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.05 select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.06 select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.07&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:12;61:1&#34;&gt;可以认为，设置了 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:16;61:10&#34;&gt;repartitionCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:17;61:29&#34;&gt;repartitionScheme&lt;/i&gt; 参数之后，相当于对上述的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:13;61:62&#34;&gt;pivot by&lt;/codeph&gt; 查询语句的结果又做了一个“重分区”，使得每个分区占用的空间不至于特别大。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:13;63:1&#34;&gt;下面介绍 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:14;63:6&#34;&gt;DDBDataLoader&lt;/codeph&gt; 的各个组件。在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:15;63:30&#34;&gt;DDBDataLoader&lt;/codeph&gt; 内部，每组子查询由数据管理器 DataManager 管理，每个 DataManager 又对应一个 DataSource。这里的 DataSource，可视为一个分区的元数据。DataSource 通过传入的 Session 会话从 DolphinDB 服务端获取一个分区的数据，并将该分区的数据放入一个预载队列中。DataManager 则根据选取数据的顺序从 DataSource 产生的预载队列中获取预载的分区粒度数据，并将其根据滑动窗口大小和步长处理为相应的 PyTorch 的 Tensor 格式。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:16;63:301&#34;&gt;DDBDataLoader&lt;/codeph&gt; 维护了一个包含多个数据管理器 DataManager 的数据池，数据池的大小由参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:17;63:359&#34;&gt;groupPoolSize&lt;/codeph&gt; 控制。后台工作线程从这些数据管理器中提取批量数据，并将其组装成用于训练的数据格式和形状，然后放入整个 AI Dataloader 的预准备队列中。最后，迭代时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:18;63:455&#34;&gt;DDBDataLoader&lt;/codeph&gt; 从预准备队列中获取已准备好的批量数据，将其传递给客户端，供神经网络训练使用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;3-ddbdataloader-详细介绍&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:4;65:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:4;65:1&#34;&gt;3. DDBDataLoader 详细介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:4;65:1&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;31-安装步骤&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:5;67:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:5;67:1&#34;&gt;3.1. 安装步骤&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:5;67:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:14;69:1&#34;&gt;DolphinDB Python API 自 1.30.22.2 版本起提供深度学习工具类 DDBDataLoader，提供对 DolphinDB SQL 对应的数据集进行批量拆分和重新洗牌的易用接口，将 DolphinDB 中的数据直接对接到 PyTorch 中。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:5;71:1&#34;&gt;pip install dolphindb-tools &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:15;75:1&#34;&gt;期待输出：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_2.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;image:2;77:1&#34; dita-ot:image-width=&#34;622&#34; dita-ot:image-height=&#34;37&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;alt:1;77:1&#34;&gt;img&lt;/alt&gt;&lt;/image&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;32-dolphindb类型与tensor类型对照表&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:6;79:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:6;79:1&#34;&gt;3.2. DolphinDB类型与Tensor类型对照表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:6;79:1&#34;&gt;&lt;table class=&#34;- topic/table &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;table:1;81:1&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tgroup:1;81:1&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:1;81:1&#34; colnum=&#34;1&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:2;81:1&#34; colnum=&#34;2&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;thead:1;81:1&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:1;81:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:1;81:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:2;81:3&#34;&gt;DolphinDB 类型&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:2;81:33&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:3;81:34&#34;&gt;Tensor 类型&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tbody:1;83:1&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:2;83:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:3;83:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34;&gt;BOOL [不含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:4;83:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34;&gt;torch.bool&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:3;84:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:5;84:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34;&gt;CHAR [不含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:6;84:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34;&gt;torch.int8&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:4;85:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:7;85:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34;&gt;SHORT [不含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:8;85:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34;&gt;torch.int16&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:5;86:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:9;86:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34;&gt;INT [不含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:10;86:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34;&gt;torch.int32&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:6;87:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:11;87:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34;&gt;LONG [不含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:12;87:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34;&gt;torch.int64&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:7;88:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:13;88:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34;&gt;FLOAT&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:14;88:35&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34;&gt;torch.float32&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:8;89:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:15;89:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34;&gt;DOUBLE&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:16;89:35&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34;&gt;torch.float64&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:9;90:1&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:17;90:1&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;9&#34;&gt;CHAR/SHORT/INT/LONG [包含空值]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:18;90:32&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;9&#34;&gt;torch.float64&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:16;92:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:4;92:1&#34;&gt;注意&lt;/b&gt;：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ol:1;94:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:9;94:1&#34;&gt;若 sql 查询的结果表中包含不支持的类型，即便其列名被包含在 targetCol 中，即表示迭代中 y 对应的列名，详细见接口说明，该数据列也不会出现在输入数据和目标数据中。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:10;95:1&#34;&gt;支持上述类型的 ArrayVector 类型。如果使用 ArrayVector 列，需要保证输入数据或目标数据全部为 ArrayVector 类型。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:11;96:1&#34;&gt;torch.bool 不支持布尔型数据的空值，因此获取 BOOL 类型数据前需确保不包含空值。&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;33-接口介绍&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:7;98:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:7;98:1&#34;&gt;3.3. 接口介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:7;98:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:17;100:1&#34;&gt;提供 DDBDataLoader 类来加载和访问数据，接口如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:6;102:1&#34;&gt;DDBDataLoader( ddbSession: Session, sql: str, targetCol: List[str], batchSize: int = 1, shuffle: bool = True, windowSize: Union[List[int], int, None] = None, windowStride: Union[List[int], int, None] = None, *, inputCol: Optional[List[str]] = None, excludeCol: Optional[List[str]] = None, repartitionCol: str = None, repartitionScheme: List[str] = None, groupCol: str = None, groupScheme: List[str] = None, seed: Optional[int] = None, dropLast: bool = False, offset: int = None, device: str = &#34;cpu&#34;, prefetchBatch: int = 1, prepartitionNum: int = 2, groupPoolSize: int = 3, **kwargs )&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;331-必选参数-基础信息&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:8;129:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:8;129:1&#34;&gt;3.3.1. 必选参数 (基础信息)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:8;129:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:5;131:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:12;131:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:5;131:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:18;131:5&#34;&gt;ddbSession&lt;/i&gt;(dolphindb.Session):&lt;/b&gt; 用于获取数据的 Session 连接，包含训练所需的上下文信息。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:13;132:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:6;132:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:19;132:5&#34;&gt;sql&lt;/i&gt;(str):&lt;/b&gt; 表示将数据取出用于训练的 SQL 语句，特别的，该语句必须为查询语句元代码，应尽可能简单，目前不支持 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:19;132:70&#34;&gt;group by&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:20;132:81&#34;&gt;context by&lt;/codeph&gt; 子句。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;332-参数迭代列名类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:9;134:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:9;134:1&#34;&gt;3.3.2. 参数(迭代列名类)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:9;134:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:6;136:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:14;136:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:7;136:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:20;136:5&#34;&gt;targetCol&lt;/i&gt;(List[str]):&lt;/b&gt; 必填参数，字符串或者字符串列表。表示迭代中 y 对应的列名。&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:7;137:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:15;137:3&#34;&gt;如果指定了 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:21;137:11&#34;&gt;inputCol&lt;/i&gt;，x 的数据为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:22;137:29&#34;&gt;inputCol&lt;/i&gt; 对应的列名， y 的数据为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:23;137:54&#34;&gt;targetCol&lt;/i&gt; 对应的列名，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:24;137:72&#34;&gt;excludeCol&lt;/i&gt; 不生效。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:16;138:3&#34;&gt;不指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:25;138:9&#34;&gt;inputCol&lt;/i&gt;，指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:26;138:23&#34;&gt;excludeCol&lt;/i&gt;：x 的数据为 所有列 - &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:27;138:49&#34;&gt;excludeCol&lt;/i&gt; 指定的列名，y 的数据为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:28;138:75&#34;&gt;targetCol&lt;/i&gt; 对应的列名&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:17;139:3&#34;&gt;不指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:29;139:9&#34;&gt;inputCol&lt;/i&gt;，也不指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:30;139:25&#34;&gt;excludeCol&lt;/i&gt;：x 的数据为所有列，y 的数据为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:31;139:55&#34;&gt;targetCol&lt;/i&gt; 对应的列名&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:18;140:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:8;140:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:32;140:5&#34;&gt;inputCol&lt;/i&gt;(Optional[List[str]]):&lt;/b&gt; 可选参数，字符串或者字符串列表。表示迭代中 x 对应的列名，如果不指定则表示所有列，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:21;140:89&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:19;141:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:9;141:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:33;141:5&#34;&gt;excludeCol&lt;/i&gt;(Optional[List[str]]):&lt;/b&gt; 可选参数，字符串或者字符串列表。表示迭代中 x 排除的列名，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:22;141:79&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;333-可选参数取数规则类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:10;143:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:10;143:1&#34;&gt;3.3.3. 可选参数(取数规则类)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:10;143:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:8;145:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:20;145:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:10;145:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:34;145:5&#34;&gt;batchSize&lt;/i&gt;(int):&lt;/b&gt; 批次大小，指定每个批次数据中样本数量。表示每个批次只包含一个样本，默认值为 1。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:21;146:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:11;146:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:35;146:5&#34;&gt;shuffle&lt;/i&gt;(bool):&lt;/b&gt; 是否对数据进行随机打乱，表示不对数据进行打乱，默认值为 False。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:22;147:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:12;147:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:36;147:5&#34;&gt;seed&lt;/i&gt;(Optional[int]):&lt;/b&gt; 随机种子，该种子仅在 DDBDataLoader 对象中生效，与外界隔离。默认值为 None，表示不指定随机种子。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:23;148:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:13;148:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:37;148:5&#34;&gt;dropLast&lt;/i&gt;(bool):&lt;/b&gt; 是否丢弃不足 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:38;148:32&#34;&gt;batchSize&lt;/i&gt; 的数据，其值为 True 时，如果 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:39;148:62&#34;&gt;excludeColl&lt;/i&gt; 无法整除查询结果的大小，则会丢弃最后一组不足 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:40;148:99&#34;&gt;excludeColl&lt;/i&gt; 的数据。默认值为 False，表示不丢弃最后一组不足 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:41;148:140&#34;&gt;excludeColl&lt;/i&gt; 的数据。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;334-可选参数窗口类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:11;150:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:11;150:1&#34;&gt;3.3.4. 可选参数(窗口类)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:11;150:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:9;152:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:24;152:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:14;152:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:42;152:5&#34;&gt;windowSize&lt;/i&gt;(Union[List[int], int, None]):&lt;/b&gt; 用于指定滑动窗口的大小，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:23;152:69&#34;&gt;None&lt;/codeph&gt;。&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:10;153:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:25;153:3&#34;&gt;如果不指定该参数，表示不使用滑动窗口。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:26;154:3&#34;&gt;如果传入一个整数值(int)，例如 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:43;154:23&#34;&gt;windowSize&lt;/i&gt;=3，表示 x 的滑动窗口大小为 3，y 的滑动窗口大小为 1。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:27;155:3&#34;&gt;如果传入两个整数值的列表，例如 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:44;155:21&#34;&gt;windowSize&lt;/i&gt;=[4, 2]，表示 x 的滑动窗口大小为 4，y 的滑动窗口大小为 2。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:28;156:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:15;156:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:45;156:5&#34;&gt;windowStride&lt;/i&gt;(Union[List[int], int, None]):&lt;/b&gt; 用于指定滑动窗口在数据上滑动的步长，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:24;156:78&#34;&gt;None&lt;/codeph&gt;。&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:11;157:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:29;157:3&#34;&gt;不指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:46;157:9&#34;&gt;windowSize&lt;/i&gt; 时，该参数无效。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:30;158:3&#34;&gt;如果传入一个整数值(int)，例如 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:47;158:23&#34;&gt;windowStride&lt;/i&gt;=2，那么表示 x 的滑动窗口步长为 2，而 y 的滑动窗口步长为 1。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:31;159:3&#34;&gt;如果传入两个整数值的列表，例如 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:48;159:21&#34;&gt;windowStride&lt;/i&gt;=[3, 1]，那么表示 x 的滑动窗口步长为 3，而 y 的滑动窗口步长为 1。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:32;160:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:16;160:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:49;160:5&#34;&gt;offset&lt;/i&gt;(Optional[int]):&lt;/b&gt; y 相对于 x 偏移的行数（非负数）。不启用滑动窗口时，表示训练数据都在同一行中。指定滑动窗口时，该参数默认为 x 对应滑动窗口的大小，默认为 0。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;335-可选参数数据切分类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:12;162:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:12;162:1&#34;&gt;3.3.5. 可选参数(数据切分类)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:12;162:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:12;164:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:33;164:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:17;164:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:50;164:5&#34;&gt;repartitionCol&lt;/i&gt;(Optional[str]):&lt;/b&gt; 用于进一步拆分分组查询为子查询的列。默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:25;164:64&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:34;165:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:18;165:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:51;165:5&#34;&gt;repartitionScheme&lt;/i&gt;(Optional[List[str]]):&lt;/b&gt; 分区点值，是一个字符串列表。每个列表元素将和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:52;165:74&#34;&gt;repartitionCol&lt;/i&gt; 指定的列一起使用，以通过条件 where repartitionCol = value 对数据做进一步筛选和分割，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:26;165:153&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:35;166:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:19;166:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:53;166:5&#34;&gt;groupCol&lt;/i&gt;(Optional[str]):&lt;/b&gt; 用于将查询划分成组的列。这个列的值将用于定义分组，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:27;166:65&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:36;167:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:20;167:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:54;167:5&#34;&gt;groupScheme&lt;/i&gt;(Optional[List[str]]):&lt;/b&gt; 分组点值，是一个字符串列表。每个列表元素将与 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:55;167:68&#34;&gt;groupCol&lt;/i&gt; 指定的列一起使用，以通过条件 where groupCol = value 对数据进一步筛选和分组，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:28;167:134&#34;&gt;None&lt;/codeph&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:18;169:2&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:21;169:2&#34;&gt;注&lt;/b&gt;：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ol:2;171:2&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:37;171:2&#34;&gt;其中 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:22;171:8&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:56;171:10&#34;&gt;repartitionCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:57;171:29&#34;&gt;repartitionScheme&lt;/i&gt;&lt;/b&gt; 功能可用于解决单个分区数据较多，无法直接进行全量运算的情况。通过将数据根据 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:58;171:89&#34;&gt;repartitionScheme&lt;/i&gt; 的值进行筛选，可以将数据分割成多个子分区，每个子分区将按照 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:59;171:139&#34;&gt;repartitionScheme&lt;/i&gt; 中的顺序排列。例如，如果 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:60;171:172&#34;&gt;repartitionCol&lt;/i&gt; 为 date(TradeTime)， &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:61;171:208&#34;&gt;repartitionScheme&lt;/i&gt; 为 [&#34;2020.01.01&#34;, &#34;2020.01.02&#34;, &#34;2020.01.03&#34;]，则数据将被细分为三个分区，每个分区对应一个日期值。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:38;172:2&#34;&gt;不同于 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:62;172:9&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:23;172:10&#34;&gt;repartitionCol&lt;/b&gt;&lt;/i&gt;/&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:63;172:30&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:24;172:31&#34;&gt;repartitionScheme&lt;/b&gt;&lt;/i&gt;，其中 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:25;172:57&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:64;172:59&#34;&gt;groupCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:65;172:72&#34;&gt;groupScheme&lt;/i&gt;&lt;/b&gt; 的分组之间不会出现跨分组的数据，例如，如果 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:66;172:110&#34;&gt;groupCol&lt;/i&gt; 为 Code，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:67;172:128&#34;&gt;groupScheme&lt;/i&gt; 为 [“`000001.SH”, “`000002.SH”, “`000003.SH”]，则数据将被划分为三个不相交的分组，每个分组对应一个股票代码。&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;336-其他可选参数不常用类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:13;174:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:13;174:1&#34;&gt;3.3.6. 其他可选参数(不常用类)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:13;174:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:13;176:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:39;176:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:26;176:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:68;176:5&#34;&gt;device&lt;/i&gt;(Optional[str]):&lt;/b&gt; 用于指定张量将被创建在哪个设备上。你可以将其设置为 “cuda“ 或其他支持的设备名称，以便在 GPU 上创建张量。默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:29;176:96&#34;&gt;&#34;cpu&#34;&lt;/codeph&gt; ，表示在 CPU 上创建张量。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:40;177:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:27;177:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:69;177:5&#34;&gt;prefetchBatch&lt;/i&gt;(int):&lt;/b&gt; 表示预加载的批数，用于控制一次性加载多少批次的数据，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:30;177:60&#34;&gt;1&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:41;178:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:28;178:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:70;178:5&#34;&gt;prepartitionNum&lt;/i&gt;(int):&lt;/b&gt; 表示每个数据源预加载的分区数。工作线程将会在后台预加载分区到内存中。如果预载分区过多可能导致内存不足, 默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:31;178:88&#34;&gt;2&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:42;179:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:29;179:3&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:71;179:5&#34;&gt;groupPoolSize&lt;/i&gt;(int):&lt;/b&gt; 如果指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:72;179:34&#34;&gt;groupCol&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:73;179:47&#34;&gt;groupScheme&lt;/i&gt;，所有数据将被划分为若干个数据源，并在其中选择 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:74;179:84&#34;&gt;groupPoolSize&lt;/i&gt; 个数据源准备数据。当有数据源中的数据被全部使用，新的数据源将被加入，直至所有数据源中的数据都被使用，默认值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:32;179:155&#34;&gt;3&lt;/codeph&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;4-简单使用示例&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:14;181:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:14;181:1&#34;&gt;4. 简单使用示例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:14;181:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:19;183:1&#34;&gt;下面将提供一个简单供您快速体验 DDBDataLoader 使用，示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:7;185:1&#34;&gt;import dolphindb as ddb from dolphindb_tools.dataloader import DDBDataLoader sess = ddb.Session() sess.connect(&#34;localhost&#34;, 8848, &#34;admin&#34;, &#34;123456&#34;) sess.run(&#34;&#34;&#34; t = table(1..10 as a, 2..11 as b, 3..12 as c) &#34;&#34;&#34;) sql = 'select * from objByName(&#34;t&#34;)' dataloader = DDBDataLoader(sess, sql, [&#34;c&#34;]) for X, y in dataloader: print(X, y) -------------------------------------------------- tensor([[1, 2, 3]], dtype=torch.int32) tensor([[3]], dtype=torch.int32) tensor([[2, 3, 4]], dtype=torch.int32) tensor([[4]], dtype=torch.int32) tensor([[3, 4, 5]], dtype=torch.int32) tensor([[5]], dtype=torch.int32) tensor([[4, 5, 6]], dtype=torch.int32) tensor([[6]], dtype=torch.int32) tensor([[5, 6, 7]], dtype=torch.int32) tensor([[7]], dtype=torch.int32) tensor([[6, 7, 8]], dtype=torch.int32) tensor([[8]], dtype=torch.int32) tensor([[7, 8, 9]], dtype=torch.int32) tensor([[9]], dtype=torch.int32) tensor([[ 8, 9, 10]], dtype=torch.int32) tensor([[10]], dtype=torch.int32) tensor([[ 9, 10, 11]], dtype=torch.int32) tensor([[11]], dtype=torch.int32) tensor([[10, 11, 12]], dtype=torch.int32) tensor([[12]], dtype=torch.int32)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:20;216:1&#34;&gt;在这个示例中，您使用一个内存表作为待加载的训练数据，并定义了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:33;216:32&#34;&gt;targetCol=[&#34;c&#34;]&lt;/codeph&gt;。这表示将使用同一行的 &#34;a&#34;, &#34;b&#34;, &#34;c&#34; 三列作为训练的输入数据 X，并将 &#34;c&#34; 列作为训练的目标数据 y。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:21;218:1&#34;&gt;如果您指定了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:34;218:8&#34;&gt;offset=5&lt;/codeph&gt;，那么每一份数据都将使用某一行的 &#34;a&#34;, &#34;b&#34;, &#34;c&#34; 作为训练输入数据 X，并且使用距离当前行5行之后的 &#34;c&#34; 列数据作为训练的目标数据 y。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:8;220:1&#34;&gt;dataloader = DDBDataLoader(sess, sql, [&#34;c&#34;], offset=5) for X, y in dataloader: print(X, y)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:22;227:1&#34;&gt;输出如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:9;229:1&#34;&gt;tensor([[1, 2, 3]], dtype=torch.int32) tensor([[8]], dtype=torch.int32) tensor([[2, 3, 4]], dtype=torch.int32) tensor([[9]], dtype=torch.int32) tensor([[3, 4, 5]], dtype=torch.int32) tensor([[10]], dtype=torch.int32) tensor([[4, 5, 6]], dtype=torch.int32) tensor([[11]], dtype=torch.int32) tensor([[5, 6, 7]], dtype=torch.int32) tensor([[12]], dtype=torch.int32)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:23;237:1&#34;&gt;如果指定滑动窗口大小为 3，步长为 1，同时不输入 offset，则表示每份数据使用前三行的 “a“, “b“, “c“ 三列的数据和后一行的 “c“ 列数据，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:10;239:1&#34;&gt;dataloader = DDBDataLoader(sess, sql, [&#34;c&#34;], windowSize=3, windowStride=1) for X, y in dataloader: print(X, y)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:24;246:1&#34;&gt;输出如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:11;248:1&#34;&gt;tensor([[[1, 2, 3], [2, 3, 4], [3, 4, 5]]], dtype=torch.int32) tensor([[[6]]], dtype=torch.int32) tensor([[[2, 3, 4], [3, 4, 5], [4, 5, 6]]], dtype=torch.int32) tensor([[[7]]], dtype=torch.int32) tensor([[[3, 4, 5], [4, 5, 6], [5, 6, 7]]], dtype=torch.int32) tensor([[[8]]], dtype=torch.int32) tensor([[[4, 5, 6], [5, 6, 7], [6, 7, 8]]], dtype=torch.int32) tensor([[[9]]], dtype=torch.int32) ......&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;5-性能对比测试&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:15;264:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:15;264:1&#34;&gt;5. 性能对比测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:15;264:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:25;266:1&#34;&gt;在深度学习中，数据加载和处理的效率对总体训练时长有重要影响。在本节性能测试中，重点关注了传统数据加载方式 (PyTorch DataLoader) 和 DolphinDB 集成 PyTorch (DDBDataLoader) 之间的耗时差异。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:26;268:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:30;268:1&#34;&gt;测试场景&lt;/b&gt;：为前 200 个时间点因子数据来预测下一个时间点 f000001 因子值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:27;270:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:31;270:1&#34;&gt;示例步骤&lt;/b&gt;：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ol:3;272:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:43;272:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:32;272:4&#34;&gt;创建因子数据集&lt;/b&gt;：首先，您需要创建一个因子数据集，这是存储因子数据的地方。这个因子库将用于存储随机生成的数据。接下来，将生成随机数据，并将其写入因子数据集中。这些随机数据将模拟实际因子数据，供后续的训练使用。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:44;273:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:33;273:4&#34;&gt;加载数据&lt;/b&gt;：使用 SQL 查询从 DDBDataLoader中获取所需的因子数据或者 使用 PytorchDataLoader 加载二进制文件数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:45;274:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:34;274:4&#34;&gt;提供给神经网络&lt;/b&gt;：最后，获取的因子数据将被提供给神经网络进行训练。这些数据经过 DDBDataLoader或者 PytorchDataLoader 处理，已准备好供模型使用。&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:28;276:1&#34;&gt;性能测试分为两个部分：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:14;278:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:46;278:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:35;278:3&#34;&gt;PyTorch DataLoader&lt;/b&gt;：使用传统的数据加载方式进行训练数据。这可能包括将数据从文件读取并进行预处理。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:47;279:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:36;279:3&#34;&gt;DDBDataLoader&lt;/b&gt;：使用 DDBDataLoader 准备训练数据。这种方式通过 DolphinDB 和 Session 直接将数据转换为 torch.Tensor，无需保存为文件。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:29;281:1&#34;&gt;在每种数据加载方式下，进行了 2000 次数据批次的迭代。通过比较两种数据加载方式的耗时差异，可以更清楚地了解 DDBDataLoader 性能优势。这种性能测试有助于评估 DDBDataLoader 在数据加载和处理方面的效率，为深度学习模型的训练提供参考和优化的方向。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:30;283:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:37;283:1&#34;&gt;对比测试功能模块代码目录结构&lt;/b&gt;&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_3.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;image:3;285:1&#34; dita-ot:image-width=&#34;559&#34; dita-ot:image-height=&#34;243&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;alt:2;285:1&#34;&gt;img&lt;/alt&gt;&lt;/image&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:15;287:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:48;287:1&#34;&gt;datas：数据存储&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:49;288:1&#34;&gt;dist：&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/dist/dolphindb_tools-0.1a1.whl&#34; format=&#34;whl&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:2;288:8&#34;&gt;&lt;?ditaot usertext?&gt;dolphindb_tools-0.1a1.whl&lt;/xref&gt; 分发包&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:50;289:1&#34;&gt;prepare：数据集准备模块&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:16;290:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:51;290:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/ddb_scripts.dos&#34; format=&#34;dos&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:3;290:5&#34;&gt;&lt;?ditaot usertext?&gt;ddb_scripts.dos&lt;/xref&gt;：DolphinDB 建库建表以及模拟写入脚本&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:52;291:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_data.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:4;291:5&#34;&gt;&lt;?ditaot usertext?&gt;prepare_data.py&lt;/xref&gt;：PytorchDataLoader 测试准备数据&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:53;292:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_index.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:5;292:5&#34;&gt;&lt;?ditaot usertext?&gt;prepare_index.py&lt;/xref&gt;：PytorchDataLoader 测试索引数据&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:54;293:1&#34;&gt;test：&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:17;294:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:55;294:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/net.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:6;294:5&#34;&gt;&lt;?ditaot usertext?&gt;net.py&lt;/xref&gt;：定义神经网络&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:56;295:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/test_wide_new.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:7;295:5&#34;&gt;&lt;?ditaot usertext?&gt;test_wide_new.py&lt;/xref&gt;: DDBDataLoader 方式测试&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:57;296:3&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/test_wide_old.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:8;296:5&#34;&gt;&lt;?ditaot usertext?&gt;test_wide_old.py&lt;/xref&gt;: 传统 PytorchDataLoader 方式测试&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;51-环境准备&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:16;298:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:16;298:1&#34;&gt;5.1. 环境准备&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:16;298:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:31;300:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:38;300:1&#34;&gt;服务端&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:18;302:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:58;302:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:32;302:3&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:39;302:3&#34;&gt;硬件环境&lt;/b&gt;&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;table:2;304:5&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tgroup:2;304:5&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:3;304:5&#34; colnum=&#34;1&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:4;304:5&#34; colnum=&#34;2&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;thead:2;304:5&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:10;304:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:19;304:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:40;304:7&#34;&gt;硬件名称&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:20;304:17&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:41;304:18&#34;&gt;配置信息&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tbody:2;306:5&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:11;306:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:21;306:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34;&gt;主机名&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:22;306:18&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34;&gt;HostName&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:12;307:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:23;307:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34;&gt;外网 IP&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:24;307:19&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34;&gt;xxx.xxx.xxx.218&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:13;308:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:25;308:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34;&gt;操作系统&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:26;308:17&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34;&gt;Linux（内核版本3.10以上）&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:14;309:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:27;309:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34;&gt;内存&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:28;309:19&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34;&gt;500 GB&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:15;310:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:29;310:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34;&gt;CPU&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:30;310:21&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34;&gt;x86_64（64核心）&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:16;311:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:31;311:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34;&gt;GPU&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:32;311:21&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34;&gt;A100&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:17;312:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:33;312:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34;&gt;网络&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:34;312:19&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34;&gt;万兆以太网&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:59;314:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:33;314:3&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:42;314:3&#34;&gt;软件环境&lt;/b&gt;&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;table:3;316:5&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tgroup:3;316:5&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:5;316:5&#34; colnum=&#34;1&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;colspec:6;316:5&#34; colnum=&#34;2&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;thead:3;316:5&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:18;316:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:35;316:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:43;316:7&#34;&gt;软件名称&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:36;316:26&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:44;316:27&#34;&gt;版本信息&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;tbody:3;318:5&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:19;318:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:37;318:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34;&gt;DolphinDB&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:38;318:30&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34;&gt;2.00.10.1&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:20;319:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:39;319:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34;&gt;ddbtools&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:40;319:30&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34;&gt;0.1a1&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:21;320:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:41;320:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34;&gt;python&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:42;320:30&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34;&gt;3.8.17&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:22;321:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:43;321:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34;&gt;dolphindb&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:44;321:30&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34;&gt;1.30.22.2&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;row:23;322:5&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:45;322:5&#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34;&gt;numpy，torch ，pandas&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; align=&#34;left&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;entry:46;322:28&#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34;&gt;1.24.4, 2.0.0+cu118, 1.5.2&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:60;324:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:34;324:3&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:45;324:3&#34;&gt;性能测试工具&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:35;326:5&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:35;326:8&#34;&gt;Python &lt;/codeph&gt; 中的第三方库 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:36;326:25&#34;&gt; line_profiler （4.0.3）&lt;/codeph&gt;，将待测试代码封装为函数后添加 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:37;326:65&#34;&gt;@profile&lt;/codeph&gt; 装饰器，在终端执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:38;326:86&#34;&gt;kernprof -l -v test.py&lt;/codeph&gt; 进行性能测试。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:61;328:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:36;328:3&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:46;328:3&#34;&gt;测试数据&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:37;330:5&#34;&gt;快照 3 秒频因子数据，生成总数据约为 277G，测试数据生成脚本如下：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:38;332:5&#34;&gt;在 DolphinDB 客户端执行，指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:39;332:26&#34;&gt;Datetime &lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:40;332:40&#34;&gt;Symbol &lt;/codeph&gt; 为分区列和排序列，在数据库 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:41;332:64&#34;&gt;dfs://test_ai_dataloader&lt;/codeph&gt; 中创建分区表 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:42;332:98&#34;&gt;wide_factor_table&lt;/codeph&gt;。表中包含 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:43;332:123&#34;&gt;Datetime &lt;/codeph&gt; 时间列和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:44;332:140&#34;&gt;Symbol &lt;/codeph&gt; 股票名称列，以及 1000 列因子列（名称从 f000001 到 f001000）。类型分别为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:45;332:198&#34;&gt;DATETIME &lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:46;332:212&#34;&gt;SYMBOL&lt;/codeph&gt;，因子列类型全部使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:47;332:231&#34;&gt;DOUBLE&lt;/codeph&gt;。详细代码见工程代码中 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:75;332:251&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/ddb_scripts.dos&#34; format=&#34;dos&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:9;332:252&#34;&gt;&lt;?ditaot usertext?&gt;ddb_scripts.dos&lt;/xref&gt;&lt;/i&gt;，核心代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:12;334:5&#34;&gt;dbName = &#34;dfs://test_ai_dataloader&#34; tbName = &#34;wide_factor_table&#34; if (existsDatabase(dbName)) { dropDatabase(dbName) } // 股票数量 numSymbols = 250 // 因子数量 numFactors = 1000 dateBegin = 2020.01.01 dateEnd = 2020.01.31 symbolList = symbol(lpad(string(1..numSymbols), 6, &#34;0&#34;) + &#34;.SH&#34;) factorList = lpad(string(1..numFactors), 7,&#34;f000000&#34;) colNames = [&#34;Datetime&#34;, &#34;Symbol&#34;] join factorList colTypes = [DATETIME, SYMBOL] join take(DOUBLE, numFactors) schema = table(1:0, colNames, colTypes)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:39;357:5&#34;&gt;写入完成后，使用下面的脚本打印 SQL 查询结果，确认已经写入成功。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:13;359:5&#34;&gt;select DateTime, Symbol, f000001 from loadTable(&#34;dfs://test_ai_dataloader&#34;, &#34;wide_factor_table&#34;) where Symbol=`000001.SH, date(DateTime)=2020.01.31&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:40;363:5&#34;&gt;示例数据如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_4.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;image:4;365:5&#34; dita-ot:image-width=&#34;670&#34; dita-ot:image-height=&#34;317&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;alt:3;365:5&#34;&gt;img&lt;/alt&gt;&lt;/image&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;52-pytorch-dataloader-性能测试&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:17;367:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:17;367:1&#34;&gt;5.2. PyTorch DataLoader 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:17;367:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:41;369:1&#34;&gt;在传统深度学习中，通常会采取以下步骤来处理训练数据：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:19;371:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:62;371:1&#34;&gt;生成二进制数据文件&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:63;372:1&#34;&gt;生成索引信息 pkl 文件&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:64;373:1&#34;&gt;使用 PyTorch DataLoader 方式加载数据到模型中&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:42;375:1&#34;&gt;首先使用 numpy 库生成二进制数据文件，此阶段耗时约为 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:47;375:31&#34;&gt;83分钟&lt;/b&gt;，详细见 &lt;xref class=&#34;- topic/xref &#34; href=&#34;script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_data.py&#34; format=&#34;py&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;xref:10;375:44&#34;&gt;&lt;?ditaot usertext?&gt;prepare_data.py&lt;/xref&gt;，核心代码如下:&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:14;377:1&#34;&gt;st = time.time() for symbol in symbols: for t in times: sql_tmp = sql + f&#34;&#34;&#34; where Symbol={symbol}, date(DateTime)={t}&#34;&#34;&#34; data = s.run(sql_tmp, pickleTableToList=True) data = np.array(data[2:]) data.tofile(f&#34;datas/{symbol[1:]}-{t}.bin&#34;) print(f&#34;[{symbol}-{t}] LOAD OVER {data.shape}&#34;) ed = time.time() print(&#34;total time: &#34;, ed-st) # 耗时约 4950s&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:43;390:1&#34;&gt;在数据处理过程中，通常需要计算滑动窗口的大小和步长。这两个参数决定了如何从数据中切割出训练样本。滑动窗口的大小定义了每个训练样本的时间窗口长度，而步长定义了滑动窗口之间的间隔, 一旦确定了滑动窗口的大小和步长，接下来会计算每份数据需要从哪些文件中获取数据。这个计算过程通常涉及到迭代数据并根据滑动窗口的设置来确定数据的切割方式。然后，将这些索引信息保存在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:76;390:179&#34;&gt;index.pkl&lt;/i&gt;, 以供后续使用，此阶段耗时约为 4分钟。核心代码如下，详细见 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:77;390:222&#34;&gt;prepare_index.py&lt;/i&gt; :&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:15;392:1&#34;&gt;with open(&#34;index.pkl&#34;, 'wb') as f: pickle.dump(index_list, f) ed = time.time() print(&#34;total time: &#34;, ed-st) # 约 234s&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:44;399:1&#34;&gt;最后在 Python 代码中，定义一个数据集（DataSet），用于管理和加载训练数据，将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:78;399:47&#34;&gt;index.pkl&lt;/i&gt; 内容读取至内存，使用 mmap 方式打开数据文件，使得能够通过下标访问快速将数据从文件中读取到内存，此阶段耗时约为 4 分钟，核心代码如下，详细见 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:79;399:133&#34;&gt;test_wide_old.py&lt;/i&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:16;401:1&#34;&gt;def main(): torch.set_default_device(&#34;cuda&#34;) torch.set_default_tensor_type(torch.DoubleTensor) model = SimpleNet() model = model.to(&#34;cuda&#34;) loss_fn = nn.MSELoss() loss_fn = loss_fn.to(&#34;cuda&#34;) optimizer = torch.optim.Adam(model.parameters(), lr=0.05) dataset = MyDataset(4802) dataloader = DataLoader( dataset, batch_size=64, shuffle=False, num_workers=3, pin_memory=True, pin_memory_device=&#34;cuda&#34;, prefetch_factor=5, ) epoch = 10 for _ in range(epoch): for x, y in tqdm(dataloader, mininterval=1): x = x.to(&#34;cuda&#34;) y = y.to(&#34;cuda&#34;) y_pred = model(x) loss = loss_fn(y_pred, y) optimizer.zero_grad() loss.backward() optimizer.step() if __name__ == &#34;__main__&#34;: main()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:45;434:1&#34;&gt;至此，基于 PytorchDataLoader 深度学习训练数据流程全部结束，第一阶段生成二进制文件大约为 83 分钟，第二阶段生成索引数据信息为 4分钟，第三阶段迭代训练 2 万次耗时为 25 分钟，总耗时为 112 分钟。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;53-ddbdataloader-性能测试&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:18;436:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:18;436:1&#34;&gt;5.3. DDBDataLoader 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:18;436:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:46;438:1&#34;&gt;在 DDBDataLoader 中，通常会采取以下步骤来处理训练数据：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:20;440:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:65;440:1&#34;&gt;从 DolphinDB 分布式表中加载数据&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:66;441:1&#34;&gt;将加载数据处理成训练所需格式&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:47;443:1&#34;&gt;本次测试中，使用了 DDBDataLoader 来获取训练数据。与传统方法不同，无需将数据保存为文件并在客户端进行处理。相反，通过 Session 将 SQL 查询结果直接转换为 torch.Tensor，这可以减少数据传输和存储成本，在测试代码中，使用 Python 中的第三方库 line_profiler 统计各个部分的执行时间，例如数据加载、模型训练等。测试步骤如下：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ol:4;445:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:67;445:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:48;445:4&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:48;445:4&#34;&gt;定义 DDBDataLoader&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:49;447:5&#34;&gt;在 Python 客户端执行以下代码，使用已建立的数据库表执行 SQL 查询后的结果作为数据集。该数据集指定了目标列为 [&#34;f000001&#34;]，并排除了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:48;447:83&#34;&gt;Symbol &lt;/codeph&gt; 列和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:49;447:96&#34;&gt;DateTime &lt;/codeph&gt; 列的数据。此外，还配置了以下参数：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:21;449:5&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:68;449:5&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:50;449:7&#34;&gt;batchSize=64&lt;/codeph&gt; 表示 一批数据大小为 64。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:69;450:5&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:51;450:7&#34;&gt;windowSize=[200, 1], windowStride=[1, 1], offset=200 &lt;/codeph&gt; 分别表示输入数据和目标数据的滑动窗口大小分别为 200 和 1，滑动窗口步长分别为1和1，offset为200。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:70;451:5&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:52;451:7&#34;&gt;shuffle=True&lt;/codeph&gt; 表示数据打乱设置为 True，使用随机种子 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:53;451:44&#34;&gt;seed=0&lt;/codeph&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:71;452:5&#34;&gt;使用每支股票的时序数据进行训练，指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:54;452:26&#34;&gt; groupCol=&#34;Symbol&#34;&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:55;452:49&#34;&gt;groupScheme=symbols&lt;/codeph&gt;，其中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:56;452:74&#34;&gt;symbols&lt;/codeph&gt; 是包含所有股票名称的字符串列表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:72;453:5&#34;&gt;为了降低数据分块粒度，指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:57;453:21&#34;&gt;repartitionCol=&#34;date(DateTime)&#34;&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:58;453:57&#34;&gt; repartitionScheme=times&lt;/codeph&gt;，其中 times 是包含 2020.01.01到2020.01.31 所有日期的列表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:73;454:5&#34;&gt;训练将在 GPU上进行，指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:59;454:22&#34;&gt;device=&#34;cuda&#34;&lt;/codeph&gt;，将 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:60;454:40&#34;&gt;torch.Tensor&lt;/codeph&gt; 创建到 GPU 上。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:74;455:5&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:61;455:7&#34;&gt;prefetchBatch=5, prepartitionNum=3&lt;/codeph&gt; 表示预准备 5 批数据，配置每组查询预载3个子查询的结果。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:50;457:5&#34;&gt;这些配置将有助于提高训练效果并充分利用 GPU 和后台线程资源。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:17;459:5&#34;&gt;import dolphindb as ddb from dolphindb_tools.dataloader import DDBDataLoader sess = ddb.Session() sess.connect('localhost', 8848, &#34;admin&#34;, &#34;123456&#34;) dbPath = &#34;dfs://test_ai_dataloader&#34; tbName = &#34;wide_factor_table&#34; symbols = [&#34;`&#34; + f&#34;{i}.SH&#34;.zfill(9) for i in range(1, 251)] times = [&#34;2020.01.&#34; + f&#34;{i+1}&#34;.zfill(2) for i in range(31)] sql = f&#34;&#34;&#34;select * from loadTable(&#34;{dbPath}&#34;, &#34;{tbName}&#34;)&#34;&#34;&#34; dataloader = DDBDataLoader( s, sql, targetCol=[&#34;f000001&#34;], batchSize=64, shuffle=True, windowSize=[200, 1], windowStride=[1, 1], repartitionCol=&#34;date(DateTime)&#34;, repartitionScheme=times, groupCol=&#34;Symbol&#34;, groupScheme=symbols, seed=0, offset=200, excludeCol=[&#34;DateTime&#34;, &#34;Symbol&#34;], device=&#34;cuda&#34;, prefetchBatch=5, prepartitionNum=3 )&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:75;487:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:51;487:4&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:49;487:4&#34;&gt;定义网络并训练&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:52;489:5&#34;&gt;下述代码在 Python 客户端执行，它定义了一个简单的 CNN 神经网络结构，并定义了损失函数和优化器。最后像使用 torch 中 DataLoader 一样，迭代 DDBDataLoader 获取数据，输入到网络中进行训练，核心代码如下，详细见 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;i:80;489:130&#34;&gt;test_wide_new.py&lt;/i&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeblock:18;491:5&#34;&gt; model = SimpleNet() model = model.to(&#34;cuda&#34;) loss_fn = nn.MSELoss() loss_fn = loss_fn.to(&#34;cuda&#34;) optimizer = torch.optim.Adam(model.parameters(), lr=0.05) num_epochs = 10 model.train() for epoch in range(num_epochs): for X, y in dataloader: X = X.to(&#34;cuda&#34;) y = y.to(&#34;cuda&#34;) y_pred = model(X) loss = loss_fn(y_pred, y) optimizer.zero_grad() loss.backward() optimizer.step()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:53;512:5&#34;&gt;通过将数据直接转换为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;codeph:62;512:16&#34;&gt;torch.Tensor&lt;/codeph&gt; 并使用 DDBDataLoader 管理数据，可以更高效地获取和使用训练数据，从而提高深度学习模型的训练效率。这种方法减少了数据传输和存储的开销，并使训练过程更加灵活和高效。此种方式总耗时为 25 分钟。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:54;515:1&#34;&gt;从比对结果可以看到，本次测试中，对比了传统方式（PyTorch DataLoader）和 DDBDataLoader，DDBDataLoader 一体化集成 PyTorch 耗时约为 25分钟，内存占用约为 0.8 GB，代码行数约为 70 行， PyTorch DataLoader 总耗时 112 分钟，内存占用约为 4GB，代码行数约为 200 多行。考虑两种方式的特点，原因大概如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:22;517:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:76;517:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:50;517:3&#34;&gt;性能提升&lt;/b&gt;：在数据准备以及迭代取数耗时方面，DDBDataLoader 耗时明显低于传统方式。这主要是因为 DDBDataLoader 可以直接从 DolphinDB 中直接获得数据，将每个分区（数据源）的数据整体打乱后提供给客户端进行处理。传统方式通常将数据集和 DataLoader 处理逻辑分开，需要先将数据导出成磁盘上的文件，然后再提供给客户端使用，这会对性能产生较大影响。所以，DDBDataLoader 最终相比传统方法有显著性能提升。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:77;518:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:51;518:3&#34;&gt;灵活性增加&lt;/b&gt;：在灵活性上，DDBDataLoader 使用 SQL 的方式来初始化，这提供了很高的灵活性。例如，用户可以直接用 SQL 实现新的因子，新实现的因子可以直接应用到 PyTorch 的训练中，而不需要再像传统的方式那样需要将数据再导出成磁盘上的文件。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:78;519:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:52;519:3&#34;&gt;内存占用减少&lt;/b&gt;：在内存方面，DolphinDB 内部并行线程以及多消息队列机制，迭代数据集，使用完内存，及时回收，返还给操作系统，减少内存在进程中常驻时间，而传统的数据集和 DataLoader 方式，为直接加载全量数据到内存中，导致内存长时间占用，当涉及数据集过大时，容易产生 OOM 现象。这样 DDBDataLoader 内存使用减少为原来的 1/5。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:79;520:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;b:53;520:3&#34;&gt;代码行数减少&lt;/b&gt;：在代码简洁性方面，DolphinDB 封装了一个 DataLoader 接口，用户使用无感知，只需调用接口，将数据传输到 PyTorch 中，仅仅只需代码 70 行，而 传统的数据集和 DataLoader 需要重新构造一个接口用于数据集与 PyTorch 的对接，代码需 200 多行行。极大的减低了开发运维成本。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:55;522:1&#34;&gt;综上，DDBDataLoader 可以提升性能以及大幅降低 DolphinDB 内数据用于 PyTorch 训练的开发运维成本。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;6-总结&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;topic:19;524:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;title:19;524:1&#34;&gt;6. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;body:19;524:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:56;526:1&#34;&gt;DDBDataLoader 是 DolphinDB 在深度学习和数据库结合方面的一次探索。它旨在解决以下问题:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;ul:23;528:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:80;528:1&#34;&gt;充分利用了 DolphinDB 的特性，将 SQL 查询拆分为多个查询，从而减少了数据在客户端的内存占用&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;li:81;529:1&#34;&gt;DDBDataLoader 采用即时查询的方式直接从数据库获取数据，可以灵活得操作数据、提高效率且降低开发运维成本。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ai_dataloader_ml.md&#34; xtrc=&#34;p:57;531:1&#34;&gt;综上所述，将 DolphinDB 和 DDBDataLoader 集成到因子数据管理流程中，有助于更好地满足量化投资策略的需求，充分发挥深度学习模型的潜力。这种集成方式能够提高效率，降低成本，并提供更强大的因子数据管理和应用能力。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/ai_dataloader_ml.md"/><meta name="wh-out-relpath" content="tutorials/ai_dataloader_ml.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="ai-dataloader" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                    
                    <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="wh_topic_body">
                        
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">AI DataLoader</h1><div class="- topic/body body"><p class="- topic/p p">深度学习模型有能力自动发现变量之间的关系，而这些关系通常是不可见的，这使得深度学习可以挖掘新的因子和规律，为量化投资策略提供更多可能性。在传统的量化策略开发流程中，通常会使用 Python 或第三方工具生成因子，并将其存储为文件。这些因子是构建深度学习模型的基础输入，包括技术指标、波动性指标和市场情绪指标等。随着证券交易规模不断扩大以及因子数据量的激增。传统的文件存储因子作为深度学习模型的输入，面临以下问题：</p><ul class="- topic/ul ul"><li class="- topic/li li">因子数据过大，内存带宽与存储空间瓶颈</li><li class="- topic/li li">因子数据与深度学习模型集成工程化与成本问题</li></ul><p class="- topic/p p">为了应对这些挑战，DolphinDB将数据库与深度学习相结合，开发了AI Dataloader。该工具旨在提高因子数据的效率和管理，并简化与深度学习模型的交互。具体而言，DDBDataLoader类用于因子数据的管理和深度学习模型的集成，达到更贴近功能实现的目的。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-总体架构"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 总体架构</h2><div class="- topic/body body"><img class="- topic/image image" src="images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_1.png" width="550"/><br/><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">主要包括以下功能模块:</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">因子数据存储模块<ul class="- topic/ul ul"><li class="- topic/li li">DolphinDB 存储历史因子数据</li></ul></li><li class="- topic/li li">因子数据推送模块: 即 AI DataLoader（DDBDataLoader） 队列，其内部维护多个工作线程与消息队列，以提高并发性能，从 DolphinDB 中按照分区机制将因子数据转换为 PyTorch 等深度学习框架等可识别 tensor。策略研发人员可以实时从 DolphinDB 中获取所需的因子数据，并将其推送到深度学习模型中用于训练。这种实时性能帮助策略研发人员在需要时获取最新数据进行模型训练。<ul class="- topic/ul ul"><li class="- topic/li li">第一步，构造 DDBDataLoader 对象，根据 groupCol 参数指定的数据列拆分为若干组查询，每组查询中，再根据 repartitionCol 参数指定的数据列拆分为若干个子查询，此种分割增加了数据的灵活性，使用户能够更精细地选择所需的数据，以满足深度学习模型的训练需求。</li><li class="- topic/li li">第二步，DDBDataLoader 对象内部线程根据拆分的数据，会在后台线程中转换以及拼接成 PyTorch 训练所需的数据，再放入预准备队列中，即图中2，通过此种方式，可以减少客户端内存的占用。</li><li class="- topic/li li">最后一步涉及从 DDBDataLoader 队列中迭代获取批量数据，并将这些数据返回给客户端，以供 PyTorch 训练使用，即图中5。</li></ul></li></ul><p class="- topic/p p">具体内部详细工作流程将在下一节 <em class="+ topic/ph hi-d/i ph i">工作原理</em> 中详细介绍。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-工作原理"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 工作原理</h2><div class="- topic/body body"><p class="- topic/p p">在构造时，<code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 接收用户提供的 SQL 查询语句，并将其拆分为多个子查询组。<code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader </code> 使用后台线程从服务端获取数据，并将其处理为 PyTorch Tensor 格式的批量数据。</p><p class="- topic/p p">DDBDataLoader 提供了 <em class="+ topic/ph hi-d/i ph i">groupCol</em> 和 <em class="+ topic/ph hi-d/i ph i">groupScheme</em> 参数，用于将单个查询 SQL 分成多组查询。其中，每一个组定义了一个时间序列，例如一支股票的交易数据。若不指定，则认为所有的数据定义了一个时间序列。例如，一种典型的情况是表里的数据包含了全部的股票，而我们在训练模型的时候只希望每支股票仅利用自己的历史数据来对未来进行预测。在这种情况下，我们需要将 <em class="+ topic/ph hi-d/i ph i">groupCol</em> 设置为股票标的列，将 <em class="+ topic/ph hi-d/i ph i">groupScheme</em> 设置为所有的股票标的，也即每一个组是一支股票的交易数据。换言之，假如原始的查询 SQL 为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable(dbName, tableName)</code></pre><p class="- topic/p p">假设 <em class="+ topic/ph hi-d/i ph i">groupScheme</em> 为 <code class="+ topic/ph pr-d/codeph ph codeph">stockID</code>,  <em class="+ topic/ph hi-d/i ph i">groupScheme</em> 为 <code class="+ topic/ph pr-d/codeph ph codeph">["apple", "google", "amazon"]</code>，则原始的查询会被拆分成以下三组查询：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable(dbName, tableName) where stockID = "apple"
select * from loadTable(dbName, tableName) where stockID = "google"
select * from loadTable(dbName, tableName) where stockID = "amazon"</code></pre><p class="- topic/p p">模型训练的时候，每组训练数据则只会来源于以上三组中的某一组，而不会出现跨组的情况。</p><p class="- topic/p p">另一方面，为了避免加载大量数据至内存中，<code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 采用分区粒度管理数据。也就是说，每组查询每次只加载一个分区到内存中。通常来说， DolphinDB 的一个分区的大小在 100MB 到 1GB 之间，因此这种设计可以很好地限制内存的使用量。另一方面，基于这种分区粒度的管理方式，使得 <code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 实现的 shuffle 和传统的 dataloader 实现的 shuffle 会有一些区别。具体地说，传统的 shuffle 是将数据进行完全随机地打乱，但这样会引入大量的随机 IO，会使得效率偏低。而 <code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 使用的 shuffle 方式，则是先随机地选取一个数据的分区并读取，随后在这个分区内部进行 shuffle。使用这种方式，可以最大化地减少随机的 IO，以提升整个训练过程的效率。</p><p class="- topic/p p">另一组要说明的参数是 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em>  和 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 。这组参数主要处理的是单个查询没办法直接拆成多个分区的情况。例如，一种常见的使用 DolphinDB 管理因子数据的方法是使用纵表来对因子数据进行管理（详见 <a class="- topic/xref xref" href="best_practices_for_multi_factor.html">best_practices_for_multi_factor.md</a>）。使用这种方法，则在获取可用的训练数据之前，需要先对所有的数据做一个 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 将数据从纵表转化为宽表。然而，用户的数据量可能非常大，例如几百 G 甚至更多，在这种情况下，服务器的内存完全可能不够完成对所有数据的 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 。针对这类情况，DDBDataLoader 提供了 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 和<em class="+ topic/ph hi-d/i ph i">repartitionScheme</em>  参数这组参数，这组参数的作用是可以对全表的数据做进一步的切分，将全表数据按照 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 和 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em>  拆成多个子表，然后对于每一个子表再做单独的 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code>。换言之，假设原始的查询 SQL 为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName</code></pre><p class="- topic/p p">假设 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 为 <code class="+ topic/ph pr-d/codeph ph codeph">date(datetime)</code>，<em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 为 <code class="+ topic/ph pr-d/codeph ph codeph">["2023.09.05", "2023.09.06", "2023.09.07"]</code>，则上述 的查询相当于会被拆成以下几个子查询：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.05
select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.06
select val from loadTable(dbName, tableName) pivot by datetime, stockID, factorName where date(datetime) = 2023.09.07</code></pre><p class="- topic/p p">可以认为，设置了 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 和 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 参数之后，相当于对上述的 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 查询语句的结果又做了一个“重分区”，使得每个分区占用的空间不至于特别大。</p><p class="- topic/p p">下面介绍 <code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 的各个组件。在 <code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 内部，每组子查询由数据管理器 DataManager 管理，每个 DataManager 又对应一个 DataSource。这里的 DataSource，可视为一个分区的元数据。DataSource 通过传入的 Session 会话从 DolphinDB 服务端获取一个分区的数据，并将该分区的数据放入一个预载队列中。DataManager 则根据选取数据的顺序从 DataSource 产生的预载队列中获取预载的分区粒度数据，并将其根据滑动窗口大小和步长处理为相应的 PyTorch 的 Tensor 格式。<code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 维护了一个包含多个数据管理器 DataManager 的数据池，数据池的大小由参数 <code class="+ topic/ph pr-d/codeph ph codeph">groupPoolSize</code> 控制。后台工作线程从这些数据管理器中提取批量数据，并将其组装成用于训练的数据格式和形状，然后放入整个 AI Dataloader 的预准备队列中。最后，迭代时，<code class="+ topic/ph pr-d/codeph ph codeph">DDBDataLoader</code> 从预准备队列中获取已准备好的批量数据，将其传递给客户端，供神经网络训练使用。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3-ddbdataloader-详细介绍"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3. DDBDataLoader 详细介绍</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="31-安装步骤"><h3 class="- topic/title title topictitle3" id="ariaid-title5">3.1. 安装步骤</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB Python API 自 1.30.22.2 版本起提供深度学习工具类 DDBDataLoader，提供对 DolphinDB SQL 对应的数据集进行批量拆分和重新洗牌的易用接口，将 DolphinDB 中的数据直接对接到 PyTorch 中。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">pip install dolphindb-tools </pre><p class="- topic/p p">期待输出：</p><br/><img class="- topic/image image" src="images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_2.png" alt="img"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="32-dolphindb类型与tensor类型对照表"><h3 class="- topic/title title topictitle3" id="ariaid-title6">3.2. DolphinDB类型与Tensor类型对照表</h3><div class="- topic/body body"><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="32-dolphindb类型与tensor类型对照表__entry__1"><strong class="+ topic/ph hi-d/b ph b">DolphinDB 类型</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="32-dolphindb类型与tensor类型对照表__entry__2"><strong class="+ topic/ph hi-d/b ph b">Tensor 类型</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">BOOL [不含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.bool</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">CHAR [不含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.int8</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">SHORT [不含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.int16</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">INT [不含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.int32</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">LONG [不含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.int64</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">FLOAT</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.float32</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">DOUBLE</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.float64</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__1">CHAR/SHORT/INT/LONG [包含空值]</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="32-dolphindb类型与tensor类型对照表__entry__2">torch.float64</td></tr></tbody></table></div><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：</p><ol class="- topic/ol ol"><li class="- topic/li li">若 sql 查询的结果表中包含不支持的类型，即便其列名被包含在 targetCol 中，即表示迭代中 y 对应的列名，详细见接口说明，该数据列也不会出现在输入数据和目标数据中。</li><li class="- topic/li li">支持上述类型的 ArrayVector 类型。如果使用 ArrayVector 列，需要保证输入数据或目标数据全部为 ArrayVector 类型。</li><li class="- topic/li li">torch.bool 不支持布尔型数据的空值，因此获取 BOOL 类型数据前需确保不包含空值。</li></ol></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="33-接口介绍"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.3. 接口介绍</h3><div class="- topic/body body"><p class="- topic/p p">提供 DDBDataLoader 类来加载和访问数据，接口如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>DDBDataLoader(
    ddbSession: Session,
    sql: str,
    targetCol: List[str],
    batchSize: int = 1,
    shuffle: bool = True,
    windowSize: Union[List[int], int, None] = None,
    windowStride: Union[List[int], int, None] = None,
    *,
    inputCol: Optional[List[str]] = None,
    excludeCol: Optional[List[str]] = None,
    repartitionCol: str = None,
    repartitionScheme: List[str] = None,
    groupCol: str = None,   
    groupScheme: List[str] = None,
    seed: Optional[int] = None,
    dropLast: bool = False,
    offset: int = None,
    device: str = "cpu",
    prefetchBatch: int = 1,
    prepartitionNum: int = 2,
    groupPoolSize: int = 3,
    **kwargs
)</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="331-必选参数-基础信息"><h4 class="- topic/title title topictitle4" id="ariaid-title8">3.3.1. 必选参数 (基础信息)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">ddbSession</em>(dolphindb.Session):</strong> 用于获取数据的 Session 连接，包含训练所需的上下文信息。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">sql</em>(str):</strong> 表示将数据取出用于训练的 SQL 语句，特别的，该语句必须为查询语句元代码，应尽可能简单，目前不支持 <code class="+ topic/ph pr-d/codeph ph codeph">group by</code>/<code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 子句。</li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="332-参数迭代列名类"><h4 class="- topic/title title topictitle4" id="ariaid-title9">3.3.2. 参数(迭代列名类)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">targetCol</em>(List[str]):</strong> 必填参数，字符串或者字符串列表。表示迭代中 y 对应的列名。<ul class="- topic/ul ul"><li class="- topic/li li">如果指定了 <em class="+ topic/ph hi-d/i ph i">inputCol</em>，x 的数据为 <em class="+ topic/ph hi-d/i ph i">inputCol</em> 对应的列名， y 的数据为 <em class="+ topic/ph hi-d/i ph i">targetCol</em> 对应的列名，<em class="+ topic/ph hi-d/i ph i">excludeCol</em> 不生效。</li><li class="- topic/li li">不指定 <em class="+ topic/ph hi-d/i ph i">inputCol</em>，指定 <em class="+ topic/ph hi-d/i ph i">excludeCol</em>：x 的数据为 所有列 - <em class="+ topic/ph hi-d/i ph i">excludeCol</em> 指定的列名，y 的数据为 <em class="+ topic/ph hi-d/i ph i">targetCol</em> 对应的列名</li><li class="- topic/li li">不指定 <em class="+ topic/ph hi-d/i ph i">inputCol</em>，也不指定 <em class="+ topic/ph hi-d/i ph i">excludeCol</em>：x 的数据为所有列，y 的数据为 <em class="+ topic/ph hi-d/i ph i">targetCol</em> 对应的列名</li></ul></li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">inputCol</em>(Optional[List[str]]):</strong> 可选参数，字符串或者字符串列表。表示迭代中 x 对应的列名，如果不指定则表示所有列，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">excludeCol</em>(Optional[List[str]]):</strong> 可选参数，字符串或者字符串列表。表示迭代中 x 排除的列名，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="333-可选参数取数规则类"><h4 class="- topic/title title topictitle4" id="ariaid-title10">3.3.3. 可选参数(取数规则类)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">batchSize</em>(int):</strong> 批次大小，指定每个批次数据中样本数量。表示每个批次只包含一个样本，默认值为 1。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">shuffle</em>(bool):</strong> 是否对数据进行随机打乱，表示不对数据进行打乱，默认值为 False。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">seed</em>(Optional[int]):</strong> 随机种子，该种子仅在 DDBDataLoader 对象中生效，与外界隔离。默认值为 None，表示不指定随机种子。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">dropLast</em>(bool):</strong> 是否丢弃不足 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 的数据，其值为 True 时，如果 <em class="+ topic/ph hi-d/i ph i">excludeColl</em> 无法整除查询结果的大小，则会丢弃最后一组不足 <em class="+ topic/ph hi-d/i ph i">excludeColl</em> 的数据。默认值为 False，表示不丢弃最后一组不足 <em class="+ topic/ph hi-d/i ph i">excludeColl</em> 的数据。</li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="334-可选参数窗口类"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.3.4. 可选参数(窗口类)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">windowSize</em>(Union[List[int], int, None]):</strong> 用于指定滑动窗口的大小，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。<ul class="- topic/ul ul"><li class="- topic/li li">如果不指定该参数，表示不使用滑动窗口。</li><li class="- topic/li li">如果传入一个整数值(int)，例如 <em class="+ topic/ph hi-d/i ph i">windowSize</em>=3，表示 x 的滑动窗口大小为 3，y 的滑动窗口大小为 1。</li><li class="- topic/li li">如果传入两个整数值的列表，例如 <em class="+ topic/ph hi-d/i ph i">windowSize</em>=[4, 2]，表示 x 的滑动窗口大小为 4，y 的滑动窗口大小为 2。</li></ul></li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">windowStride</em>(Union[List[int], int, None]):</strong>  用于指定滑动窗口在数据上滑动的步长，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。<ul class="- topic/ul ul"><li class="- topic/li li">不指定 <em class="+ topic/ph hi-d/i ph i">windowSize</em> 时，该参数无效。</li><li class="- topic/li li">如果传入一个整数值(int)，例如 <em class="+ topic/ph hi-d/i ph i">windowStride</em>=2，那么表示 x 的滑动窗口步长为 2，而 y 的滑动窗口步长为 1。</li><li class="- topic/li li">如果传入两个整数值的列表，例如 <em class="+ topic/ph hi-d/i ph i">windowStride</em>=[3, 1]，那么表示 x 的滑动窗口步长为 3，而 y 的滑动窗口步长为 1。</li></ul></li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">offset</em>(Optional[int]):</strong>  y 相对于 x 偏移的行数（非负数）。不启用滑动窗口时，表示训练数据都在同一行中。指定滑动窗口时，该参数默认为 x 对应滑动窗口的大小，默认为 0。</li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="335-可选参数数据切分类"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.3.5. 可选参数(数据切分类)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">repartitionCol</em>(Optional[str]):</strong> 用于进一步拆分分组查询为子查询的列。默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">repartitionScheme</em>(Optional[List[str]]):</strong> 分区点值，是一个字符串列表。每个列表元素将和 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 指定的列一起使用，以通过条件 where repartitionCol = value 对数据做进一步筛选和分割，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">groupCol</em>(Optional[str]):</strong> 用于将查询划分成组的列。这个列的值将用于定义分组，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">groupScheme</em>(Optional[List[str]]):</strong> 分组点值，是一个字符串列表。每个列表元素将与 <em class="+ topic/ph hi-d/i ph i">groupCol</em> 指定的列一起使用，以通过条件 where groupCol = value 对数据进一步筛选和分组，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">None</code>。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注</strong>：</p><ol class="- topic/ol ol"><li class="- topic/li li">其中 <strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 和 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em></strong> 功能可用于解决单个分区数据较多，无法直接进行全量运算的情况。通过将数据根据 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 的值进行筛选，可以将数据分割成多个子分区，每个子分区将按照 <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 中的顺序排列。例如，如果 <em class="+ topic/ph hi-d/i ph i">repartitionCol</em> 为 date(TradeTime)， <em class="+ topic/ph hi-d/i ph i">repartitionScheme</em> 为 ["2020.01.01", "2020.01.02", "2020.01.03"]，则数据将被细分为三个分区，每个分区对应一个日期值。</li><li class="- topic/li li">不同于 <em class="+ topic/ph hi-d/i ph i"><strong class="+ topic/ph hi-d/b ph b">repartitionCol</strong></em>/<em class="+ topic/ph hi-d/i ph i"><strong class="+ topic/ph hi-d/b ph b">repartitionScheme</strong></em>，其中 <strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">groupCol</em> 和 <em class="+ topic/ph hi-d/i ph i">groupScheme</em></strong> 的分组之间不会出现跨分组的数据，例如，如果 <em class="+ topic/ph hi-d/i ph i">groupCol</em> 为 Code，<em class="+ topic/ph hi-d/i ph i">groupScheme</em> 为 [“`000001.SH”, “`000002.SH”, “`000003.SH”]，则数据将被划分为三个不相交的分组，每个分组对应一个股票代码。</li></ol></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="336-其他可选参数不常用类"><h4 class="- topic/title title topictitle4" id="ariaid-title13">3.3.6. 其他可选参数(不常用类)</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">device</em>(Optional[str]):</strong> 用于指定张量将被创建在哪个设备上。你可以将其设置为 “cuda“ 或其他支持的设备名称，以便在 GPU 上创建张量。默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">"cpu"</code> ，表示在 CPU 上创建张量。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">prefetchBatch</em>(int):</strong> 表示预加载的批数，用于控制一次性加载多少批次的数据，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">1</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">prepartitionNum</em>(int):</strong> 表示每个数据源预加载的分区数。工作线程将会在后台预加载分区到内存中。如果预载分区过多可能导致内存不足, 默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">2</code>。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b"><em class="+ topic/ph hi-d/i ph i">groupPoolSize</em>(int):</strong> 如果指定 <em class="+ topic/ph hi-d/i ph i">groupCol</em> 和 <em class="+ topic/ph hi-d/i ph i">groupScheme</em>，所有数据将被划分为若干个数据源，并在其中选择 <em class="+ topic/ph hi-d/i ph i">groupPoolSize</em> 个数据源准备数据。当有数据源中的数据被全部使用，新的数据源将被加入，直至所有数据源中的数据都被使用，默认值为 <code class="+ topic/ph pr-d/codeph ph codeph">3</code>。</li></ul></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title14" id="4-简单使用示例"><h2 class="- topic/title title topictitle2" id="ariaid-title14">4. 简单使用示例</h2><div class="- topic/body body"><p class="- topic/p p">下面将提供一个简单供您快速体验 DDBDataLoader 使用，示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import dolphindb as ddb
from dolphindb_tools.dataloader import DDBDataLoader

sess = ddb.Session()
sess.connect("localhost", 8848, "admin", "123456")

sess.run("""
    t = table(1..10 as a, 2..11 as b, 3..12 as c)
""")

sql = 'select * from objByName("t")'
         
dataloader = DDBDataLoader(sess, sql, ["c"])

for X, y in dataloader:
    print(X, y)

--------------------------------------------------
tensor([[1, 2, 3]], dtype=torch.int32) tensor([[3]], dtype=torch.int32)
tensor([[2, 3, 4]], dtype=torch.int32) tensor([[4]], dtype=torch.int32)
tensor([[3, 4, 5]], dtype=torch.int32) tensor([[5]], dtype=torch.int32)
tensor([[4, 5, 6]], dtype=torch.int32) tensor([[6]], dtype=torch.int32)
tensor([[5, 6, 7]], dtype=torch.int32) tensor([[7]], dtype=torch.int32)
tensor([[6, 7, 8]], dtype=torch.int32) tensor([[8]], dtype=torch.int32)
tensor([[7, 8, 9]], dtype=torch.int32) tensor([[9]], dtype=torch.int32)
tensor([[ 8,  9, 10]], dtype=torch.int32) tensor([[10]], dtype=torch.int32)
tensor([[ 9, 10, 11]], dtype=torch.int32) tensor([[11]], dtype=torch.int32)
tensor([[10, 11, 12]], dtype=torch.int32) tensor([[12]], dtype=torch.int32)</code></pre><p class="- topic/p p">在这个示例中，您使用一个内存表作为待加载的训练数据，并定义了 <code class="+ topic/ph pr-d/codeph ph codeph">targetCol=["c"]</code>。这表示将使用同一行的 "a", "b", "c" 三列作为训练的输入数据 X，并将 "c" 列作为训练的目标数据 y。</p><p class="- topic/p p">如果您指定了 <code class="+ topic/ph pr-d/codeph ph codeph">offset=5</code>，那么每一份数据都将使用某一行的 "a", "b", "c" 作为训练输入数据 X，并且使用距离当前行5行之后的 "c" 列数据作为训练的目标数据 y。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dataloader = DDBDataLoader(sess, sql, ["c"], offset=5)

for X, y in dataloader:
    print(X, y)</code></pre><p class="- topic/p p">输出如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tensor([[1, 2, 3]], dtype=torch.int32) tensor([[8]], dtype=torch.int32)
tensor([[2, 3, 4]], dtype=torch.int32) tensor([[9]], dtype=torch.int32)
tensor([[3, 4, 5]], dtype=torch.int32) tensor([[10]], dtype=torch.int32)
tensor([[4, 5, 6]], dtype=torch.int32) tensor([[11]], dtype=torch.int32)
tensor([[5, 6, 7]], dtype=torch.int32) tensor([[12]], dtype=torch.int32)</code></pre><p class="- topic/p p">如果指定滑动窗口大小为 3，步长为 1，同时不输入 offset，则表示每份数据使用前三行的 “a“, “b“, “c“ 三列的数据和后一行的 “c“ 列数据，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dataloader = DDBDataLoader(sess, sql, ["c"], windowSize=3, windowStride=1)

for X, y in dataloader:
    print(X, y)</code></pre><p class="- topic/p p">输出如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tensor([[[1, 2, 3],
         [2, 3, 4],
         [3, 4, 5]]], dtype=torch.int32) tensor([[[6]]], dtype=torch.int32)
tensor([[[2, 3, 4],
         [3, 4, 5],
         [4, 5, 6]]], dtype=torch.int32) tensor([[[7]]], dtype=torch.int32)
tensor([[[3, 4, 5],
         [4, 5, 6],
         [5, 6, 7]]], dtype=torch.int32) tensor([[[8]]], dtype=torch.int32)
tensor([[[4, 5, 6],
         [5, 6, 7],
         [6, 7, 8]]], dtype=torch.int32) tensor([[[9]]], dtype=torch.int32)
......</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title15" id="5-性能对比测试"><h2 class="- topic/title title topictitle2" id="ariaid-title15">5. 性能对比测试</h2><div class="- topic/body body"><p class="- topic/p p">在深度学习中，数据加载和处理的效率对总体训练时长有重要影响。在本节性能测试中，重点关注了传统数据加载方式 (PyTorch DataLoader)  和 DolphinDB 集成 PyTorch (DDBDataLoader) 之间的耗时差异。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试场景</strong>：为前 200 个时间点因子数据来预测下一个时间点 f000001 因子值。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">示例步骤</strong>：</p><ol class="- topic/ol ol"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">创建因子数据集</strong>：首先，您需要创建一个因子数据集，这是存储因子数据的地方。这个因子库将用于存储随机生成的数据。接下来，将生成随机数据，并将其写入因子数据集中。这些随机数据将模拟实际因子数据，供后续的训练使用。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">加载数据</strong>：使用 SQL 查询从 DDBDataLoader中获取所需的因子数据或者 使用 PytorchDataLoader 加载二进制文件数据。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">提供给神经网络</strong>：最后，获取的因子数据将被提供给神经网络进行训练。这些数据经过 DDBDataLoader或者 PytorchDataLoader 处理，已准备好供模型使用。</li></ol><p class="- topic/p p">性能测试分为两个部分：</p><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">PyTorch DataLoader</strong>：使用传统的数据加载方式进行训练数据。这可能包括将数据从文件读取并进行预处理。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">DDBDataLoader</strong>：使用 DDBDataLoader 准备训练数据。这种方式通过 DolphinDB 和 Session 直接将数据转换为 torch.Tensor，无需保存为文件。</li></ul><p class="- topic/p p">在每种数据加载方式下，进行了 2000 次数据批次的迭代。通过比较两种数据加载方式的耗时差异，可以更清楚地了解 DDBDataLoader 性能优势。这种性能测试有助于评估 DDBDataLoader 在数据加载和处理方面的效率，为深度学习模型的训练提供参考和优化的方向。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">对比测试功能模块代码目录结构</strong></p><br/><img class="- topic/image image" src="images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_3.png" alt="img"/><br/><ul class="- topic/ul ul"><li class="- topic/li li">datas：数据存储</li><li class="- topic/li li">dist：<a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/dist/dolphindb_tools-0.1a1.whl">dolphindb_tools-0.1a1.whl</a> 分发包</li><li class="- topic/li li">prepare：数据集准备模块<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/ddb_scripts.dos">ddb_scripts.dos</a>：DolphinDB 建库建表以及模拟写入脚本</li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_data.py">prepare_data.py</a>：PytorchDataLoader 测试准备数据</li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_index.py">prepare_index.py</a>：PytorchDataLoader 测试索引数据</li></ul></li><li class="- topic/li li">test：<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/net.py">net.py</a>：定义神经网络</li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/test_wide_new.py">test_wide_new.py</a>: DDBDataLoader 方式测试</li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/test/test_wide_old.py">test_wide_old.py</a>: 传统 PytorchDataLoader 方式测试</li></ul></li></ul></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="51-环境准备"><h3 class="- topic/title title topictitle3" id="ariaid-title16">5.1. 环境准备</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">服务端</strong></p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">硬件环境</strong></p><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="51-环境准备__entry__1"><strong class="+ topic/ph hi-d/b ph b">硬件名称</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="51-环境准备__entry__2"><strong class="+ topic/ph hi-d/b ph b">配置信息</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">主机名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">HostName</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">外网 IP</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">xxx.xxx.xxx.218</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">操作系统</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">Linux（内核版本3.10以上）</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">内存</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">500 GB</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">CPU</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">x86_64（64核心）</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">GPU</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">A100</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__1">网络</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__2">万兆以太网</td></tr></tbody></table></div></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">软件环境</strong></p><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="51-环境准备__entry__17"><strong class="+ topic/ph hi-d/b ph b">软件名称</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="51-环境准备__entry__18"><strong class="+ topic/ph hi-d/b ph b">版本信息</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__17">DolphinDB</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__18">2.00.10.1</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__17">ddbtools</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__18">0.1a1</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__17">python</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__18">3.8.17</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__17">dolphindb</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__18">1.30.22.2</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__17">numpy，torch ，pandas</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="51-环境准备__entry__18">1.24.4, 2.0.0+cu118, 1.5.2</td></tr></tbody></table></div></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">性能测试工具</strong></p><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">Python </code> 中的第三方库 <code class="+ topic/ph pr-d/codeph ph codeph"> line_profiler （4.0.3）</code>，将待测试代码封装为函数后添加 <code class="+ topic/ph pr-d/codeph ph codeph">@profile</code> 装饰器，在终端执行 <code class="+ topic/ph pr-d/codeph ph codeph">kernprof -l -v test.py</code> 进行性能测试。</p></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试数据</strong></p><p class="- topic/p p">快照 3 秒频因子数据，生成总数据约为 277G，测试数据生成脚本如下：</p><p class="- topic/p p">在 DolphinDB 客户端执行，指定 <code class="+ topic/ph pr-d/codeph ph codeph">Datetime </code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">Symbol </code> 为分区列和排序列，在数据库 <code class="+ topic/ph pr-d/codeph ph codeph">dfs://test_ai_dataloader</code> 中创建分区表 <code class="+ topic/ph pr-d/codeph ph codeph">wide_factor_table</code>。表中包含 <code class="+ topic/ph pr-d/codeph ph codeph">Datetime </code> 时间列和 <code class="+ topic/ph pr-d/codeph ph codeph">Symbol </code> 股票名称列，以及 1000 列因子列（名称从 f000001 到 f001000）。类型分别为 <code class="+ topic/ph pr-d/codeph ph codeph">DATETIME </code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">SYMBOL</code>，因子列类型全部使用 <code class="+ topic/ph pr-d/codeph ph codeph">DOUBLE</code>。详细代码见工程代码中 <em class="+ topic/ph hi-d/i ph i"><a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/ddb_scripts.dos">ddb_scripts.dos</a></em>，核心代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbName = "dfs://test_ai_dataloader"
tbName = "wide_factor_table"

if (existsDatabase(dbName)) {
    dropDatabase(dbName)
}

// 股票数量
numSymbols = 250
// 因子数量
numFactors = 1000

dateBegin = 2020.01.01
dateEnd = 2020.01.31
symbolList = symbol(lpad(string(1..numSymbols), 6, "0") + ".SH")
factorList = lpad(string(1..numFactors), 7,"f000000")

colNames = ["Datetime", "Symbol"] join factorList
colTypes = [DATETIME, SYMBOL] join take(DOUBLE, numFactors)
schema = table(1:0, colNames, colTypes)</code></pre><p class="- topic/p p">写入完成后，使用下面的脚本打印 SQL 查询结果，确认已经写入成功。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select DateTime, Symbol, f000001 from loadTable("dfs://test_ai_dataloader", "wide_factor_table") where Symbol=`000001.SH, date(DateTime)=2020.01.31</code></pre><p class="- topic/p p">示例数据如下：</p><br/><img class="- topic/image image" src="images/DolphinDB_AI_DataLoader_for_Deep_Learning/DolphinDB_AI_DataLoader_for_Deep_Learning_4.png" alt="img"/><br/></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="52-pytorch-dataloader-性能测试"><h3 class="- topic/title title topictitle3" id="ariaid-title17">5.2. PyTorch DataLoader 性能测试</h3><div class="- topic/body body"><p class="- topic/p p">在传统深度学习中，通常会采取以下步骤来处理训练数据：</p><ul class="- topic/ul ul"><li class="- topic/li li">生成二进制数据文件</li><li class="- topic/li li">生成索引信息 pkl 文件</li><li class="- topic/li li">使用 PyTorch DataLoader 方式加载数据到模型中</li></ul><p class="- topic/p p">首先使用 numpy 库生成二进制数据文件，此阶段耗时约为 <strong class="+ topic/ph hi-d/b ph b">83分钟</strong>，详细见 <a class="- topic/xref xref" href="script/DolphinDB_AI_DataLoader_for_Deep_Learning/prepare/prepare_data.py">prepare_data.py</a>，核心代码如下:</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>st = time.time()
for symbol in symbols:
    for t in times:
        sql_tmp = sql + f""" where Symbol={symbol}, date(DateTime)={t}"""
        data = s.run(sql_tmp, pickleTableToList=True)
        data = np.array(data[2:])
        data.tofile(f"datas/{symbol[1:]}-{t}.bin")
        print(f"[{symbol}-{t}] LOAD OVER {data.shape}")
ed = time.time()
print("total time: ", ed-st)   # 耗时约 4950s</code></pre><p class="- topic/p p">在数据处理过程中，通常需要计算滑动窗口的大小和步长。这两个参数决定了如何从数据中切割出训练样本。滑动窗口的大小定义了每个训练样本的时间窗口长度，而步长定义了滑动窗口之间的间隔, 一旦确定了滑动窗口的大小和步长，接下来会计算每份数据需要从哪些文件中获取数据。这个计算过程通常涉及到迭代数据并根据滑动窗口的设置来确定数据的切割方式。然后，将这些索引信息保存在 <em class="+ topic/ph hi-d/i ph i">index.pkl</em>, 以供后续使用，此阶段耗时约为 4分钟。核心代码如下，详细见 <em class="+ topic/ph hi-d/i ph i">prepare_index.py</em> :</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>with open("index.pkl", 'wb') as f:
    pickle.dump(index_list, f)
ed = time.time()
print("total time: ", ed-st)    # 约 234s</code></pre><p class="- topic/p p">最后在 Python 代码中，定义一个数据集（DataSet），用于管理和加载训练数据，将 <em class="+ topic/ph hi-d/i ph i">index.pkl</em> 内容读取至内存，使用 mmap 方式打开数据文件，使得能够通过下标访问快速将数据从文件中读取到内存，此阶段耗时约为 4 分钟，核心代码如下，详细见 <em class="+ topic/ph hi-d/i ph i">test_wide_old.py</em>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def main():
    torch.set_default_device("cuda")
    torch.set_default_tensor_type(torch.DoubleTensor)

    model = SimpleNet()
    model = model.to("cuda")

    loss_fn = nn.MSELoss()
    loss_fn = loss_fn.to("cuda")
    optimizer = torch.optim.Adam(model.parameters(), lr=0.05)
    dataset = MyDataset(4802)
    dataloader = DataLoader(
        dataset, batch_size=64, shuffle=False, num_workers=3,
        pin_memory=True, pin_memory_device="cuda",
        prefetch_factor=5,
    )

    epoch = 10
    for _ in range(epoch):
        for x, y in tqdm(dataloader, mininterval=1):
            x = x.to("cuda")
            y = y.to("cuda")
            y_pred = model(x)
            loss = loss_fn(y_pred, y)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            
if __name__ == "__main__":
    main()</code></pre><p class="- topic/p p">至此，基于 PytorchDataLoader 深度学习训练数据流程全部结束，第一阶段生成二进制文件大约为 83 分钟，第二阶段生成索引数据信息为 4分钟，第三阶段迭代训练 2 万次耗时为 25 分钟，总耗时为 112 分钟。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="53-ddbdataloader-性能测试"><h3 class="- topic/title title topictitle3" id="ariaid-title18">5.3. DDBDataLoader 性能测试</h3><div class="- topic/body body"><p class="- topic/p p">在 DDBDataLoader 中，通常会采取以下步骤来处理训练数据：</p><ul class="- topic/ul ul"><li class="- topic/li li">从 DolphinDB 分布式表中加载数据</li><li class="- topic/li li">将加载数据处理成训练所需格式</li></ul><p class="- topic/p p">本次测试中，使用了 DDBDataLoader 来获取训练数据。与传统方法不同，无需将数据保存为文件并在客户端进行处理。相反，通过 Session 将 SQL 查询结果直接转换为 torch.Tensor，这可以减少数据传输和存储成本，在测试代码中，使用 Python 中的第三方库 line_profiler 统计各个部分的执行时间，例如数据加载、模型训练等。测试步骤如下：</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">定义 DDBDataLoader</strong></p><p class="- topic/p p">在 Python 客户端执行以下代码，使用已建立的数据库表执行 SQL 查询后的结果作为数据集。该数据集指定了目标列为 ["f000001"]，并排除了 <code class="+ topic/ph pr-d/codeph ph codeph">Symbol </code> 列和 <code class="+ topic/ph pr-d/codeph ph codeph">DateTime </code> 列的数据。此外，还配置了以下参数：</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">batchSize=64</code> 表示 一批数据大小为 64。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">windowSize=[200, 1], windowStride=[1, 1], offset=200 </code> 分别表示输入数据和目标数据的滑动窗口大小分别为 200 和 1，滑动窗口步长分别为1和1，offset为200。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">shuffle=True</code> 表示数据打乱设置为 True，使用随机种子 <code class="+ topic/ph pr-d/codeph ph codeph">seed=0</code>。</li><li class="- topic/li li">使用每支股票的时序数据进行训练，指定 <code class="+ topic/ph pr-d/codeph ph codeph"> groupCol="Symbol"</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">groupScheme=symbols</code>，其中 <code class="+ topic/ph pr-d/codeph ph codeph">symbols</code> 是包含所有股票名称的字符串列表。</li><li class="- topic/li li">为了降低数据分块粒度，指定 <code class="+ topic/ph pr-d/codeph ph codeph">repartitionCol="date(DateTime)"</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph"> repartitionScheme=times</code>，其中 times 是包含 2020.01.01到2020.01.31 所有日期的列表。</li><li class="- topic/li li">训练将在 GPU上进行，指定 <code class="+ topic/ph pr-d/codeph ph codeph">device="cuda"</code>，将 <code class="+ topic/ph pr-d/codeph ph codeph">torch.Tensor</code> 创建到 GPU 上。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">prefetchBatch=5, prepartitionNum=3</code> 表示预准备 5 批数据，配置每组查询预载3个子查询的结果。</li></ul><p class="- topic/p p">这些配置将有助于提高训练效果并充分利用 GPU 和后台线程资源。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import dolphindb as ddb
from dolphindb_tools.dataloader import DDBDataLoader

sess = ddb.Session()
sess.connect('localhost', 8848, "admin", "123456")

dbPath = "dfs://test_ai_dataloader"
tbName = "wide_factor_table"

symbols = ["`" + f"{i}.SH".zfill(9) for i in range(1, 251)]
times = ["2020.01." + f"{i+1}".zfill(2) for i in range(31)]

sql = f"""select * from loadTable("{dbPath}", "{tbName}")"""

dataloader = DDBDataLoader(
    s, sql, targetCol=["f000001"], batchSize=64, shuffle=True,
    windowSize=[200, 1], windowStride=[1, 1],
    repartitionCol="date(DateTime)", repartitionScheme=times,
    groupCol="Symbol", groupScheme=symbols,
    seed=0,
    offset=200, excludeCol=["DateTime", "Symbol"], device="cuda",
    prefetchBatch=5, prepartitionNum=3
)</code></pre></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">定义网络并训练</strong></p><p class="- topic/p p">下述代码在 Python 客户端执行，它定义了一个简单的 CNN 神经网络结构，并定义了损失函数和优化器。最后像使用 torch 中 DataLoader 一样，迭代 DDBDataLoader 获取数据，输入到网络中进行训练，核心代码如下，详细见 <em class="+ topic/ph hi-d/i ph i">test_wide_new.py</em>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>
model = SimpleNet()
model = model.to("cuda")
loss_fn = nn.MSELoss()
loss_fn = loss_fn.to("cuda")
optimizer = torch.optim.Adam(model.parameters(), lr=0.05)
num_epochs = 10

model.train()
for epoch in range(num_epochs):
    for X, y in dataloader:
        X = X.to("cuda")
        y = y.to("cuda")
        y_pred = model(X)
        loss = loss_fn(y_pred, y)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()</code></pre><p class="- topic/p p">通过将数据直接转换为 <code class="+ topic/ph pr-d/codeph ph codeph">torch.Tensor</code> 并使用 DDBDataLoader 管理数据，可以更高效地获取和使用训练数据，从而提高深度学习模型的训练效率。这种方法减少了数据传输和存储的开销，并使训练过程更加灵活和高效。此种方式总耗时为 25 分钟。</p></li></ol><p class="- topic/p p">从比对结果可以看到，本次测试中，对比了传统方式（PyTorch DataLoader）和 DDBDataLoader，DDBDataLoader 一体化集成 PyTorch 耗时约为 25分钟，内存占用约为 0.8 GB，代码行数约为 70 行， PyTorch DataLoader 总耗时 112 分钟，内存占用约为 4GB，代码行数约为 200 多行。考虑两种方式的特点，原因大概如下：</p><ul class="- topic/ul ul"><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">性能提升</strong>：在数据准备以及迭代取数耗时方面，DDBDataLoader 耗时明显低于传统方式。这主要是因为 DDBDataLoader 可以直接从 DolphinDB 中直接获得数据，将每个分区（数据源）的数据整体打乱后提供给客户端进行处理。传统方式通常将数据集和 DataLoader 处理逻辑分开，需要先将数据导出成磁盘上的文件，然后再提供给客户端使用，这会对性能产生较大影响。所以，DDBDataLoader 最终相比传统方法有显著性能提升。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">灵活性增加</strong>：在灵活性上，DDBDataLoader 使用 SQL 的方式来初始化，这提供了很高的灵活性。例如，用户可以直接用 SQL 实现新的因子，新实现的因子可以直接应用到 PyTorch 的训练中，而不需要再像传统的方式那样需要将数据再导出成磁盘上的文件。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">内存占用减少</strong>：在内存方面，DolphinDB 内部并行线程以及多消息队列机制，迭代数据集，使用完内存，及时回收，返还给操作系统，减少内存在进程中常驻时间，而传统的数据集和 DataLoader 方式，为直接加载全量数据到内存中，导致内存长时间占用，当涉及数据集过大时，容易产生 OOM 现象。这样 DDBDataLoader 内存使用减少为原来的 1/5。</li><li class="- topic/li li"><strong class="+ topic/ph hi-d/b ph b">代码行数减少</strong>：在代码简洁性方面，DolphinDB 封装了一个 DataLoader 接口，用户使用无感知，只需调用接口，将数据传输到 PyTorch 中，仅仅只需代码 70 行，而 传统的数据集和 DataLoader 需要重新构造一个接口用于数据集与 PyTorch 的对接，代码需 200 多行行。极大的减低了开发运维成本。</li></ul><p class="- topic/p p">综上，DDBDataLoader 可以提升性能以及大幅降低 DolphinDB 内数据用于 PyTorch 训练的开发运维成本。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="6-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title19">6. 总结</h2><div class="- topic/body body"><p class="- topic/p p">DDBDataLoader 是 DolphinDB 在深度学习和数据库结合方面的一次探索。它旨在解决以下问题:</p><ul class="- topic/ul ul"><li class="- topic/li li">充分利用了 DolphinDB 的特性，将 SQL 查询拆分为多个查询，从而减少了数据在客户端的内存占用</li><li class="- topic/li li">DDBDataLoader 采用即时查询的方式直接从数据库获取数据，可以灵活得操作数据、提高效率且降低开发运维成本。</li></ul><p class="- topic/p p">综上所述，将 DolphinDB 和 DDBDataLoader 集成到因子数据管理流程中，有助于更好地满足量化投资策略的需求，充分发挥深度学习模型的潜力。这种集成方式能够提高效率，降低成本，并提供更强大的因子数据管理和应用能力。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84" data-tocid="1-总体架构">1. 总体架构</a></li><li class="topic-item"><a href="#2-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" data-tocid="2-工作原理">2. 工作原理</a></li><li class="topic-item"><a href="#3-ddbdataloader-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D" data-tocid="3-ddbdataloader-详细介绍">3. DDBDataLoader 详细介绍</a><ul><li class="topic-item"><a href="#31-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4" data-tocid="31-安装步骤">3.1. 安装步骤</a></li><li class="topic-item"><a href="#32-dolphindb%E7%B1%BB%E5%9E%8B%E4%B8%8Etensor%E7%B1%BB%E5%9E%8B%E5%AF%B9%E7%85%A7%E8%A1%A8" data-tocid="32-dolphindb类型与tensor类型对照表">3.2. DolphinDB类型与Tensor类型对照表</a></li><li class="topic-item"><a href="#33-%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D" data-tocid="33-接口介绍">3.3. 接口介绍</a><ul><li class="topic-item"><a href="#331-%E5%BF%85%E9%80%89%E5%8F%82%E6%95%B0-%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF" data-tocid="331-必选参数-基础信息">3.3.1. 必选参数 (基础信息)</a></li><li class="topic-item"><a href="#332-%E5%8F%82%E6%95%B0%E8%BF%AD%E4%BB%A3%E5%88%97%E5%90%8D%E7%B1%BB" data-tocid="332-参数迭代列名类">3.3.2. 参数(迭代列名类)</a></li><li class="topic-item"><a href="#333-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%8F%96%E6%95%B0%E8%A7%84%E5%88%99%E7%B1%BB" data-tocid="333-可选参数取数规则类">3.3.3. 可选参数(取数规则类)</a></li><li class="topic-item"><a href="#334-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E7%AA%97%E5%8F%A3%E7%B1%BB" data-tocid="334-可选参数窗口类">3.3.4. 可选参数(窗口类)</a></li><li class="topic-item"><a href="#335-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E6%95%B0%E6%8D%AE%E5%88%87%E5%88%86%E7%B1%BB" data-tocid="335-可选参数数据切分类">3.3.5. 可选参数(数据切分类)</a></li><li class="topic-item"><a href="#336-%E5%85%B6%E4%BB%96%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%B1%BB" data-tocid="336-其他可选参数不常用类">3.3.6. 其他可选参数(不常用类)</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B" data-tocid="4-简单使用示例">4. 简单使用示例</a></li><li class="topic-item"><a href="#5-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95" data-tocid="5-性能对比测试">5. 性能对比测试</a><ul><li class="topic-item"><a href="#51-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87" data-tocid="51-环境准备">5.1. 环境准备</a></li><li class="topic-item"><a href="#52-pytorch-dataloader-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="52-pytorch-dataloader-性能测试">5.2. PyTorch DataLoader 性能测试</a></li><li class="topic-item"><a href="#53-ddbdataloader-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="53-ddbdataloader-性能测试">5.3. DDBDataLoader 性能测试</a></li></ul></li><li class="topic-item"><a href="#6-%E6%80%BB%E7%BB%93" data-tocid="6-总结">6. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>