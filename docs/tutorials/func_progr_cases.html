<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="DolphinDB 支持函数化编程：函数对象可以作为高阶函数的参数。这提高了代码表达能力，简化了代码，复杂的任务可以通过一行或几行代码完成。 本教程介绍了一些常见场景下的函数化编程案例，重点介绍 DolphinDB 的高阶函数及其使用场景。 CSV 数据文件中常用整数表示时间，如“93100000”表示“9:31:00.000”。为了便于查询分析，建议将这类数据转换为时间类型，再存储到 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="函数化编程案例"/><title>函数化编程案例</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;函数化编程案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;函数化编程案例&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;DolphinDB 支持函数化编程：函数对象可以作为高阶函数的参数。这提高了代码表达能力，简化了代码，复杂的任务可以通过一行或几行代码完成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;本教程介绍了一些常见场景下的函数化编程案例，重点介绍 DolphinDB 的高阶函数及其使用场景。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:38;56:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-数据导入&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;1. 数据导入&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;11-整型时间转化为-time-格式并导入&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;1.1. 整型时间转化为 TIME 格式并导入&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;CSV 数据文件中常用整数表示时间，如“93100000”表示“9:31:00.000”。为了便于查询分析，建议将这类数据转换为时间类型，再存储到 DolphinDB 数据库中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;针对这种场景，可通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;13:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loadTextEx&lt;/codeph&gt; 函数的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;13:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;transform&lt;/codeph&gt; 参数将文本文件中待转化的时间列指定为相应的数据类型。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;本例中会用到 CSV 文件 &lt;xref class=&#34;- topic/xref &#34; format=&#34;csv&#34; href=&#34;data/candle_201801.csv&#34; xtrc=&#34;xref:1;15:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;candle_201801.csv&lt;/xref&gt;，数据样本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;csv&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;symbol,exchange,cycle,tradingDay,date,time,open,high,low,close,volume,turnover,unixTime 000001,SZSE,1,20180102,20180102,93100000,13.35,13.39,13.35,13.38,2003635,26785576.72,1514856660000 000001,SZSE,1,20180102,20180102,93200000,13.37,13.38,13.33,13.33,867181 ......&lt;/codeblock&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;24:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;建库&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;26:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;用脚本创建如下分布式数据库（按天进行值分区）：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;28:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;login(`admin,`123456) dataFilePath=&#34;/home/data/candle_201801.csv&#34; dbPath=&#34;dfs://DolphinDBdatabase&#34; db=database(dbPath,VALUE,2018.01.02..2018.01.30)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;35:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;建表&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;37:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下面先通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;37:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;extractTextSchema&lt;/codeph&gt; 函数获取数据文件的表结构。csv 文件中的 time 字段被识别为整型。若要将其存为 TIME 类型，可以通过 update 语句更新表结构将其转换为 TIME 类型，然后用更新后的表结构来创建分布式表。该分布式表的分区列是 date 列。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;39:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;schemaTB=extractTextSchema(dataFilePath) update schemaTB set type=&#34;TIME&#34; where name=&#34;time&#34; tb=table(1:0, schemaTB.name, schemaTB.type) tb=db.createPartitionedTable(tb, `tb1, `date);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;46:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这里通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;46:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;extractTextSchema&lt;/codeph&gt; 获取表结构。用户也可以自定义表结构。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;48:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;48:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;导入数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;50:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;可以通过自定义函数 i2t 对时间列 time 进行预处理，将其转换为 TIME 类型，并返回处理后的数据表。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;52:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def i2t(mutable t){ return t.replaceColumn!(`time, t.time.format(&#34;000000000&#34;).temporalParse(&#34;HHmmssSSS&#34;)) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;58:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;请注意：在自定义函数体内对数据进行处理时，请尽量使用本地的修改（以！结尾的函数）来提升性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;60:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;60:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loadTextEx&lt;/codeph&gt; 函数导入 csv 文件的数据到分布式表，这里指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;60:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;transform&lt;/codeph&gt; 参数为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;60:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;i2t&lt;/codeph&gt; 函数，导入时会自动应用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;60:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;i2t&lt;/codeph&gt; 函数处理数据。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;62:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;tmpTB=loadTextEx(dbHandle=db, tableName=`tb1, partitionColumns=`date, filename=dataFilePath, transform=i2t);&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;66:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;查询数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;68:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;查看表内前 2 行数据，可以看到结果符合预期。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;70:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select top 2 * from loadTable(dbPath,`tb1); symbol exchange cycle tradingDay date time open high low close volume turnover unixTime ------ -------- ----- ---------- ---------- -------------- ----- ----- ----- ----- ------- ---------- ------------- 000001 SZSE 1 2018.01.02 2018.01.02 09:31:00.000 13.35 13.39 13.35 13.38 2003635 2.678558E7 1514856660000 000001 SZSE 1 2018.01.02 2018.01.02 09:32:00.000 13.37 13.38 13.33 13.33 867181 1.158757E7 1514856720000&lt;/codeblock&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;79:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;login(`admin,`123456) dataFilePath=&#34;/home/data/candle_201801.csv&#34; dbPath=&#34;dfs://DolphinDBdatabase&#34; db=database(dbPath,VALUE,2018.01.02..2018.01.30) schemaTB=extractTextSchema(dataFilePath) update schemaTB set type=&#34;TIME&#34; where name=&#34;time&#34; tb=table(1:0,schemaTB.name,schemaTB.type) tb=db.createPartitionedTable(tb,`tb1,`date); def i2t(mutable t){ return t.replaceColumn!(`time,t.time.format(&#34;000000000&#34;).temporalParse(&#34;HHmmssSSS&#34;)) } tmpTB=loadTextEx(dbHandle=db,tableName=`tb1,partitionColumns=`date,filename=dataFilePath,transform=i2t);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注&lt;/b&gt;：关于文本导入的相关函数和案例，可以参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;import_data.md&#34; xtrc=&#34;xref:2;98:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;数据导入教程&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;12-有纳秒时间戳的文本导入&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;1.2. 有纳秒时间戳的文本导入&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;本例将以整数类型存储的纳秒级数据导入为 NANOTIMESTAMP 类型。本例使用文本文件 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;data/nx.txt&#34; xtrc=&#34;xref:3;102:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;nx.txt&lt;/xref&gt;，数据样本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;SendingTimeInNano#securityID#origSendingTimeInNano#bidSize 1579510735948574000#27522#1575277200049000000#1 1579510735948606000#27522#1575277200049000000#2 ...&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;每一行记录通过字符'#'来分隔列，SendingTimeInNano 和 origSendingTimeInNano 用于存储纳秒时间戳。&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:2;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;113:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;建库建表&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;115:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;首先定义分布式数据库和表，脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;117:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dbSendingTimeInNano = database(, VALUE, 2020.01.20..2020.02.22); dbSecurityIDRange = database(, RANGE, 0..10001); db = database(&#34;dfs://testdb&#34;, COMPO, [dbSendingTimeInNano, dbSecurityIDRange]); nameCol = `SendingTimeInNano`securityID`origSendingTimeInNano`bidSize; typeCol = [`NANOTIMESTAMP,`INT,`NANOTIMESTAMP,`INT]; schemaTb = table(1:0,nameCol,typeCol); db = database(&#34;dfs://testdb&#34;); nx = db.createPartitionedTable(schemaTb, `nx, `SendingTimeInNano`securityID);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;130:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上述脚本创建了一个 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;database.md&#34; xtrc=&#34;xref:4;130:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;组合分区&lt;/xref&gt; 的数据库，然后根据文本的字段和类型创建了表 nx。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;132:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;导入数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;134:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;导入数据时，使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;134:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;nanotimestamp&lt;/codeph&gt;，将文本中的整型转化为 NANOTIMESTAMP 类型：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;136:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def dataTransform(mutable t){ return t.replaceColumn!(`SendingTimeInNano, nanotimestamp(t.SendingTimeInNano)).replaceColumn!(`origSendingTimeInNano, nanotimestamp(t.origSendingTimeInNano)) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;142:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最终通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;142:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loadTextEx&lt;/codeph&gt; 导入数据。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dbSendingTimeInNano = database(, VALUE, 2020.01.20..2020.02.22); dbSecurityIDRange = database(, RANGE, 0..10001); db = database(&#34;dfs://testdb&#34;, COMPO, [dbSendingTimeInNano, dbSecurityIDRange]); nameCol = `SendingTimeInNano`securityID`origSendingTimeInNano`bidSize; typeCol = [`NANOTIMESTAMP,`INT,`NANOTIMESTAMP,`INT]; schemaTb = table(1:0,nameCol,typeCol); db = database(&#34;dfs://testdb&#34;); nx = db.createPartitionedTable(schemaTb, `nx, `SendingTimeInNano`securityID); def dataTransform(mutable t){ return t.replaceColumn!(`SendingTimeInNano, nanotimestamp(t.SendingTimeInNano)).replaceColumn!(`origSendingTimeInNano, nanotimestamp(t.origSendingTimeInNano)) } pt=loadTextEx(dbHandle=db,tableName=`nx , partitionColumns=`SendingTimeInNano`securityID,filename=&#34;nx.txt&#34;,delimiter='#',transform=dataTransform);&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-lambda-表达式&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;2. Lambda 表达式&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在 DolphinDB 中可以使用命名函数或匿名函数（通常为 lambda 表达式）来创建自定义函数。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;x = 1..10 each(x -&amp;gt; x + 1, [1, 2, 3])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在这个例子中使用了一个 lambda 表达式（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;174:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;x -&amp;gt; x + 1, [1, 2, 3]&lt;/codeph&gt;）作为高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;174:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 的参数，其中，该 lambda 表达式接受一个输入 x 并返回 x + 1。它与 each 函数一起使用的结果是，将 1 添加到数组 [1, 2, 3] 中的每个元素。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;后续章节将介绍其他 lambda 函数案例。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-高阶函数使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3. 高阶函数使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-cross-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.1. cross 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;311-将两个向量或矩阵两两组合作为参数来调用函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.1.1. 将两个向量或矩阵，两两组合作为参数来调用函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cross&lt;/codeph&gt; 函数的伪代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;for(i:0~(size(X)-1)){ for(j:0~(size(Y)-1)){ result[i,j]=&amp;lt;function&amp;gt;(X[i], Y[j]); } } return result;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;以计算协方差矩阵为例，一般需要使用两个 for 循环计算。代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def matlab_cov(mutable matt){ nullFill!(matt,0.0) rowss,colss=matt.shape() msize = min(rowss, colss) df=matrix(float,msize,msize) for (r in 0..(msize-1)){ for (c in 0..(msize-1)){ df[r,c]=covar(matt[:,r],matt[:,c]) } } return df }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;212:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;以上代码虽然逻辑简单，但是冗长，表达能力较差，且易出错。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在 DolphinDB 中可以使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;214:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cross&lt;/codeph&gt; 或 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;214:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;pcross&lt;/codeph&gt; 计算协方差矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cross(covar, matt)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;312-计算股票两两之间的相关性&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.1.2. 计算股票两两之间的相关性&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;222:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;本例中，我们使用金融大数据开放社区 Tushare 的沪深股票 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://tushare.pro/document/2?doc_id=27&#34; scope=&#34;external&#34; xtrc=&#34;xref:5;222:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;日线行情&lt;/xref&gt; 数据，来计算股票间的两两相关性。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;首先我们定义一个数据库和表，来存储沪深股票日线行情数据。相关语句如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;login(&#34;admin&#34;,&#34;123456&#34;) dbPath=&#34;dfs://tushare&#34; yearRange=date(2008.01M + 12*0..22) if(existsDatabase(dbPath)){ dropDatabase(dbPath) } columns1=`ts_code`trade_date`open`high`low`close`pre_close`change`pct_chg`vol`amount type1=`SYMBOL`NANOTIMESTAMP`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE db=database(dbPath,RANGE,yearRange) hushen_daily_line=db.createPartitionedTable(table(100000000:0,columns1,type1),`hushen_daily_line,`trade_date)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注：上面的表是按照 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://tushare.pro/document/2?doc_id=27&#34; scope=&#34;external&#34; xtrc=&#34;xref:6;239:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;日线行情&lt;/xref&gt; 里的结构说明定义的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;定义好表结构后，如需获取对应的数据，可前往 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://tushare.pro/document/1?doc_id=39&#34; scope=&#34;external&#34; xtrc=&#34;xref:7;241:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;Tushare&lt;/xref&gt; 平台注册账户，获取 TOKEN，并参考 &lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/getTushareDailyLine.py&#34; xtrc=&#34;xref:8;241:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;案例脚本&lt;/xref&gt; 进行数据导入操作。本案例使用 DolphinDB 的 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/pydoc/py.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:9;241:162&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;Python API&lt;/xref&gt;获取数据，用户也可参考 Tushare 的说明文档使用其它语言或库。本例使用 2008 年到 2017 年的日线行情进行说明。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在计算两两相关性时，首先使用 exec + pivot by 生成股票回报率矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;retMatrix=exec pct_chg/100 as ret from daily_line pivot by trade_date, ts_code&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;exec&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;249:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;pivot by&lt;/codeph&gt; 是 DolphinDB 编程语言的特点之一。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;249:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;exec&lt;/codeph&gt; 与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;249:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select&lt;/codeph&gt; 的用法相同，但 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;249:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select&lt;/codeph&gt;语句仅可生成表，, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;249:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;exec&lt;/codeph&gt; 语句可以生成向量。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;249:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;pivot by&lt;/codeph&gt; 用于重整维度，与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;249:123&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;exec&lt;/codeph&gt; 一起使用时会生成一个矩阵。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;调用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;251:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cross&lt;/codeph&gt; 生成股票两两相关性矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;corrMatrix=cross(corr,retMatrix)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;查询和每只股票相关性最高的 10 只股票：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;syms=(exec count(*) from daily_line group by ts_code).ts_code syms=&#34;C&#34;+strReplace(syms, &#34;.&#34;, &#34;_&#34;) mostCorrelated=select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms).rename!(`ts_code`corr_ts_code`corr) context by ts_code having rank(corr,false) between 1:10&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上面代码中，corrMatrix 是一个矩阵，需要转化为表做进一步处理，同时新增一列表示股票代码。使用 table 函数转化成表后，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;265:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rename!&lt;/codeph&gt; 函数去修改表的列名。由于表的列名不能以数字开头，故此例中，在 syms 前拼接了字符 &#34;C&#34;，并将 syms 中的字符'.'转化成'_'。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;之后，对表做 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;267:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;unpivot&lt;/codeph&gt; 操作，把多列的数据转化成一列。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;为了说明中间过程，我们将以上代码拆解出一个中间步骤：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;275:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这一步生成结果如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;277:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;ts_code valueType value --------- ---------- ----------------- 000001.SZ C600539_SH 1 000002.SZ C600539_SH 0.581235290880416 000004.SZ C600539_SH 0.277978963095669 000005.SZ C600539_SH 0.352580116619933 000006.SZ C600539_SH 0.5056164472398 ......&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这样就得到了每只股票与其它股票的相关系数。之后又使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;288:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rename!&lt;/codeph&gt; 来修改列名，然后通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;288:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;context by&lt;/codeph&gt; 来按照 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;288:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;ts_code&lt;/codeph&gt; （股票代码）分组计算。每组中，查询相关性最高的 10 只股票。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最终完整代码为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;login(&#34;admin&#34;,&#34;123456&#34;) daily_line= loadTable(&#34;dfs://tushare&#34;,&#34;hushen_daily_line&#34;) retMatrix=exec pct_chg/100 as ret from daily_line pivot by trade_date,ts_code corrMatrix=cross(corr,retMatrix) syms=(exec count(*) from daily_line group by ts_code).ts_code syms=&#34;C&#34;+strReplace(syms, &#34;.&#34;, &#34;_&#34;) mostCorrelated=select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms).rename!(`ts_code`corr_ts_code`corr) context by ts_code having rank(corr,false) between 1:10&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-each-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.2. each 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;306:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;某些场景需要把函数应用到指定参数中的每个元素。若不使用函数化编程，需要使用 for 循环。DolphinDB 提供的高阶函数，例如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;306:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;306:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;peach&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;306:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;306:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;ploop&lt;/codeph&gt; 等，可以简化代码。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;321-获取数据表各个列的-null-值个数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;308:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;308:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.2.1. 获取数据表各个列的 NULL 值个数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;308:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;310:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;计算表 t 各列的 NULL 值个数，可以使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;310:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(x-&amp;gt;x.size() - x.count(), t.values())&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注：在 DolphinDB 中，对于向量或矩阵，size 返回所有元素的个数，而 count 返回的是非 NULL 元素的个数。因此可以通过 size 和 count 的差值获得 NULL 元素的个数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;其中，t.values() 返回一个 tuple，每个元素为表 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;318:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t&lt;/codeph&gt; 其中的一列。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;322-去除表中存在-null-值的行&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.2.2. 去除表中存在 NULL 值的行&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;先通过如下代码生成表 t：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;sym = take(`a`b`c, 110) id = 1..100 join take(int(),10) id2 = take(int(),10) join 1..100 t = table(sym, id,id2)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;可用以下两种方法实现。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;第一种是直接按行处理，检查每一行是否存在 NULL 值，若存在就去除该行。解决方案如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;335:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t[each(x -&amp;gt; !(x.id == NULL || x.id2 == NULL), t)]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;339:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;需要注意的是，按行处理表时，表的每一行是一个字典对象。这里定义了一个 lambda 表达式来检查空值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;341:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若列数较多，不便枚举时，可以采用以下写法：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;343:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t[each(x -&amp;gt; all(isValid(x.values())), t)]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;347:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上面代码中，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;347:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;x.values&lt;/codeph&gt; 获取了该字典所有的值，然后通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;347:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;isValid&lt;/codeph&gt; 检查 NULL 值，最后通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;347:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;all&lt;/codeph&gt; 将结果汇总，判断该行是否包含 NULL 值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;349:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;当数据量较大时，上述脚本运行效率较低。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;DolphinDB 采用列式存储，列操作较行操作具有更佳的性能。我们可以调用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;351:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 对表的每一列分别应用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;351:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;isValid&lt;/codeph&gt; 函数，返回一个结果矩阵。通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;351:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rowAnd&lt;/codeph&gt; 判断矩阵的每一行是否存在 0 值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;355:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t[each(isValid, t.values()).rowAnd()]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;359:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;当数据量很大时，可能会产生如下报错：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;361:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;The number of cells in a matrix can't exceed 2 billions.&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;365:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这是因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;365:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(isValid, t.values())&lt;/codeph&gt; 生成的矩阵过大。为解决该问题，可以调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;365:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;reduce&lt;/codeph&gt; 进行迭代计算，遍历检查每一列是否存在 NULL 值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;367:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t[reduce(def(x,y) -&amp;gt; x and isValid(y), t.values(), true)]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;323-按行处理与按列处理性能比较案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.2.3. 按行处理与按列处理性能比较案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;373:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例对表的某个字段进行如下处理：&#34;aaaa_bbbb&#34; 替换为 &#34;bbbb_aaaa&#34;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;先创建一个表 t：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t=table(take(&#34;aaaa_bbbb&#34;, 1000000) as str);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;有两种处理思路，可以按行处理或按列处理。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;按行处理：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;可以调用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;385:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 遍历每一行数据，切分后拼接。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:31;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(x -&amp;gt; split(x, '_').reverse().concat('_'), t[`str])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;按列处理：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:32;393:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;pos = strpos(t[`str], &#34;_&#34;) substr(t[`str], pos+1)+&#34;_&#34;+t[`str].left(pos)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;对比两种方式的性能，可以看到使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;398:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 按行遍历的时间在 2s300ms 左右，而按列处理的时间在 100ms 左右。因此按列处理性能更高。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;400:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码和测试结果如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:33;402:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t=table(take(&#34;aaaa_bbbb&#34;, 1000000) as str); timer r = each(x -&amp;gt; split(x, '_').reverse().concat('_'), t[`str]) timer { pos = strpos(t[`str], &#34;_&#34;) r = substr(t[`str], pos+1)+&#34;_&#34;+t[`str].left(pos) }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;324-判断两张表内容是否相同&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;413:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;413:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.2.4. 判断两张表内容是否相同&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;413:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;415:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;判断两张表 t1 和 t2 的数据是否完全相同，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;415:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 高阶函数，对表的每列进行比较。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:34;417:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;all(each(eqObj, t1.values(), t2.values()))&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-loop-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.3. loop 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;331-loop-与-each-的区别&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.3.1. loop 与 each 的区别&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;425:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;425:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt; 与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;425:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt;相似，区别在于函数返回值的格式和类型。。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 高阶函数根据每个子任务计算结果的数据类型和形式，决定返回值的数据形式：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若单个任务返回一个 scalar，则 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;429:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 返回一个 vector；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若单个任务返回 vector，那么 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;430:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 返回一个 matrix；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;431:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若单个任务返回字典，那么 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;431:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 返回一个 table。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;433:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若所有子任务的数据类型和形式都相同，则返回 Vector 或 Matrix，否则返回 Tuple。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:35;435:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;m=1..12$4:3; m; each(add{1 2 3 4}, m);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;441:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;得到以下结果：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;3&#34; xtrc=&#34;tgroup:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;col1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;443:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;col2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;443:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;col3&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:4;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:5;445:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;6&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;445:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;10&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:7;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;4&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:8;446:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;8&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:9;446:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;12&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:10;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;6&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:11;447:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;10&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:12;447:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;14&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;448:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:13;448:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;8&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:14;448:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;12&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:15;448:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;16&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;450:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;而 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;450:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt; 总是返回 Tuple。例如，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;450:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt; 计算每一列的最大值：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:36;452:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name); t; loop(max, t.values());&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;458:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;得到以下结果：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:2;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:4;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:5;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:6;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:7;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:16;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;offset&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:17;460:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;0&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:18;460:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:19;460:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;2&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:20;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;0&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:21;462:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:22;462:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;6&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:23;462:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;MSFT&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;332-导入多个文件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.3.2. 导入多个文件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;假设在一个目录下，有多个结构相同的 csv 文件，需将其导入到同一个 DolphinDB 内存表中。可以调用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;466:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt; 来实现：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:37;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop(loadText, fileDir + &#34;/&#34; + files(fileDir).filename).unionAll(false)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-movingrolling-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.4. moving/rolling 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;341-moving-案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.4.1. moving 案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;476:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;以当前记录的 UpAvgPrice 和 DownAvgPrice 字段值确定一个区间，取 close 字段的前 20 个数计算其是否在区间 [DownAvgPrice, UpAvgPrice] 范围内，并统计范围内数据的百分比。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;478:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;数据如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/functional_programming/moving1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;480:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; dita-ot:image-width=&#34;1195&#34; dita-ot:image-height=&#34;394&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;480:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;482:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;以 trade_date 为 2019.06.17 的记录的 UpAvgPrice 和 DownAvgPrice 字段确定一个区间 [11.5886533, 12.8061868]，检查该记录的前 20 行 close 数据（即图中标 1 这列）是否在对应区间中，若其中有 75% 的数据落在区间内，则 signal（图中标 4）的值设为 true，否则为 false。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;484:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;解决方案：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;486:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;486:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;moving&lt;/codeph&gt;。下例编写自定义函数 rangeTest 对每个窗口的数据进行上述区间判断，返回 true 或 false。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:38;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;defg rangeTest(close, downlimit, uplimit){ size = close.size() - 1 return between(close.subarray(0:size), downlimit.last():uplimit.last()).sum() &amp;gt;= size*0.75 } update t set signal = moving(rangeTest, [close, downAvgPrice, upAvgPrice], 21)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;497:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注：本例中，因为是计算前 20 行作为当期行的列数值，因而窗口需要包含前 20 条记录和本条记录，故窗口大小为 21 行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;499:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注：上例调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;499:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;between&lt;/codeph&gt; 函数，来检查每个元素是否在 a 和 b 之间（边界包含在内）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;501:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例模拟行情数据，创建一个测试表 t：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:39;503:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t=table(rand(&#34;d&#34;+string(1..n),n) as ts_code, nanotimestamp(2008.01.10+1..n) as trade_date, rand(n,n) as open, rand(n,n) as high, rand(n,n) as low, rand(n,n) as close, rand(n,n) as pre_close, rand(n,n) as change, rand(n,n) as pct_chg, rand(n,n) as vol, rand(n,n) as amount, rand(n,n) as downAvgPrice, rand(n,n) as upAvgPrice, rand(1 0,n) as singna)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;507:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rolling 和 moving 类似，都将函数运算符应用到滑动窗口，进行窗口计算。两者也有细微区别： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;507:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rolling&lt;/codeph&gt; 可以指定步长 step，moving 的步长为 1；且两者对空值的处理也不相同。详情可参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;window_cal.md&#34; xtrc=&#34;xref:10;507:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;rolling 的空值处理&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;342-movingsum-和-msum-性能差距&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.4.2. moving(sum) 和 msum 性能差距&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;509:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;511:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;虽然 DolphinDB 提供了高阶函数 moving，但是如果所要进行的计算可以用 m 系列函数（例如&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;511:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;msum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;511:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mcount&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;511:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mavg&lt;/codeph&gt;等）实现，请避免使用 moving 实现，这是因为 m 系列函数进行了优化，性能远超 moving。下面以 moving(sum) 和 msum 为例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:40;513:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;x=1..1000000 timer moving(sum, x, 10) timer msum(x, 10)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;519:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;根据数据量的不同，msum 比 moving(sum) 计算耗时缩短 50 至 200 倍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;性能差距的主要原因如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;取数方式不同：msum 是一次性将数据读入内存，无需为每次计算任务单独分配内存；moving(sum) 每次计算都会生成一个子对象，每次计算都需要为子对象申请内存，计算完成后还需要进行内存回收。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;msum 为增量计算，每次窗口计算都使用上一个窗口计算的结果。即直接加上当前窗口新合入的数据，并减去上一个窗口的第一条数据；而 moving(sum) 为全量计算，即每次计算都会累加窗口内的所有数据。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-eachpre-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.5. eachPre 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;528:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;创建一个表 t，包含 sym 和 BidPrice 两列：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:41;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t = table(take(`a`b`c`d`e ,100) as sym, rand(100.0,100) as bidPrice)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;534:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;需要进行如下计算：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;536:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;536:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:3;536:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;536:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;生成新的一列 ln 用于存储以下因子的计算结果：先计算当前的 bidPrice 值除以前 3 行 bidPrice 均值的结果（不包括当前行），然后取自然对数。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;538:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:4;538:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;538:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;基于列 ln，生成新列 clean 用于存储以下因子的计算结果：计算 ln 的绝对值，若该值大于波动范围阈值 F，则取上一条记录的 ln 值，反之则认为当前报价正常，并保留当前的 ln 值。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;540:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;根据 ln 列的因子计算规则，可以分析出该问题涉及到滑动窗口计算，窗口的大小为 3。参考 3.4.1 的 moving 案例，具体脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:42;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t2 = select *, log(bidPrice / prev(moving(avg, bidPrice,3))) as ln from t&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;546:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;由于内置函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;546:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;msum&lt;/codeph&gt;,&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;546:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mcount&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:64;546:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mavg&lt;/codeph&gt; 比 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:65;546:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;moving&lt;/codeph&gt; 高阶函数有更好的性能，可以将上述脚本改写如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:43;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;//method 1 t2 = select *, log(bidPrice / prev(mavg(bidPrice,3))) as ln from t //method 2 t22 = select *, log(bidPrice / mavg(prev(bidPrice),3)) as ln from t&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;556:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;此处调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:66;556:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;prev&lt;/codeph&gt; 函数获取前一行的数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;“先计算均值再移动结果”和“先移动列再计算均值”效果等价的。唯一的区别是：表 t22 第三行会产生一个结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;对于第二个数据处理要求，我们假设波动返回 F 为 0.02, 然后实现一个自定义函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:67;560:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cleanFun&lt;/codeph&gt;来实现其取值逻辑，如下：:&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:44;562:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;F = 0.02 def cleanFun(F, x, y): iif(abs(x) &amp;gt; F, y, x)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;567:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这里的参数 x 表示当前值，y 表示前一个值。然后调用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:68;567:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;eachPre&lt;/codeph&gt;来对相邻元素两两计算，该函数等价于实现：F(X[0], pre), F(X[1], X[0]), ..., F(X[n], X[n-1])。对应脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:45;569:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t2[`clean] = eachPre(cleanFun{F}, t2[`ln])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;573:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:46;575:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;F = 0.02 t = table(take(`a`b`c`d`e ,100) as sym, rand(100.0,100) as bidPrice) t2 = select *, log(bidPrice / prev(mavg(bidPrice,3))) as ln from t def cleanFun(F,x,y) : iif(abs(x) &amp;gt; F, y,x) t2[`clean] = eachPre(cleanFun{F}, t2[`ln])&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;36-byrow-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;583:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;583:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.6. byRow 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;583:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:101;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;计算矩阵每行最大值的下标。下例生成一个矩阵 m：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:47;587:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;a1=2 3 4 a2=1 2 3 a3=1 4 5 a4=5 3 2 m = matrix(a1,a2,a3,a4)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:102;595:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;一种思路是，对每行分别计算最大值的下标，可以直接调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:69;595:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;imax&lt;/codeph&gt; 函数实现。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:70;595:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;imax&lt;/codeph&gt; 在矩阵每列单独计算，返回一个向量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:103;597:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;为求每行的计算结果，可以先对矩阵进行转置操作，然后调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:71;597:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;imax&lt;/codeph&gt; 函数进行计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:48;599:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;imax(m.transpose())&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:104;603:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;此外，DolphinDB 还提供了一个高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:72;603:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;byRow&lt;/codeph&gt;，对矩阵的每一行应用指定函数进行计算。使用该函数可以避免转置操作。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:49;605:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;byRow(imax, m)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:105;609:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;以上操作亦可用行计算函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:73;609:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rowImax&lt;/codeph&gt; 来实现：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:50;611:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;print rowImax(m)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;37-segmentby-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;615:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;615:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.7. segmentby 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;615:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:106;617:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:74;617:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;segmentby&lt;/codeph&gt;。其语法如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:51;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;segmentby(func, funcArgs, segment)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:107;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;根据 segment 参数取值确定分组方案，连续的相同值分为一组，进行分组计算。返回的结果与 segment 参数的长度相同。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:52;625:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;x=1 2 3 0 3 2 1 4 5 y=1 1 1 -1 -1 -1 1 1 1 segmentby(cumsum,x,y);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:108;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上例中，根据 y 确定了 3 个分组：1 1 1, -1 -1 -1 和 1 1 1，由此把 x 也分为 3 组：1 2 3, 0 3 2 和 1 4 5，并将 cumsum 函数应用到 x 的每个分组，计算每个分组的累计和。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:109;633:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;DolphinDB 还提供了内置函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:75;633:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;segment&lt;/codeph&gt;用于在 SQL 语句中进行分组。与 segmentby 不同，它只返回分组信息，而不对分组进行计算。。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:110;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例中，将表的某列数据按照给定阈值进行分组，连续小于或大于该阈值的数据被划分为一组。连续大于该阈值的分组将保留组内最大值对应的记录并输出（若有重复值则输出第一条）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:111;637:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;表内容如下图所示，当阈值为 0.3 时，希望结果保留箭头所指记录：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/functional_programming/segment-case1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:2;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; dita-ot:image-width=&#34;213&#34; dita-ot:image-height=&#34;268&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:2;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:112;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;表定义如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:53;643:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dated = 2021.09.01..2021.09.12 v = 0 0 0.3 0.3 0 0.5 0.3 0.7 0 0 0.3 0 t = table(dated as date, v)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:113;649:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;将数据按照是否连续大于 minV 来分组时，可以使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:76;649:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;segment&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:54;651:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;segment(v&amp;gt;= minV)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:114;655:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在 SQL 中配合 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:77;655:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;context by&lt;/codeph&gt; 语句进行分组计算，通过 having 子句过滤分组的最大值。过滤结果可能存在多行，根据需求只保留第一行满足结果的数据，此时可以通过指定 limit 子句限定输出的记录数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:115;657:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整的 SQL 查询语句如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:55;659:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select * from t context by segment(v&amp;gt;= minV) having (v=max(v) and v&amp;gt;=minV) limit 1&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;38-pivot-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.8. pivot 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:116;665:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:78;665:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;pivot&lt;/codeph&gt; 可以在指定的二维维度上重组数据，结果为一个矩阵。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:117;667:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;现有包含 4 列数据的表 t1:&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:56;669:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;syms=`600300`600400`600500$SYMBOL sym=syms[0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2] time=09:40:00+1 30 65 90 130 185 195 10 40 90 140 160 190 200 5 45 80 140 170 190 210 price=172.12 170.32 172.25 172.55 175.1 174.85 174.5 36.45 36.15 36.3 35.9 36.5 37.15 36.9 40.1 40.2 40.25 40.15 40.1 40.05 39.95 volume=100 * 10 3 7 8 25 6 10 4 5 1 2 8 6 10 2 2 5 5 4 4 3 t1=table(sym, time, price, volume); t1;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:118;679:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;将 t1 的数据依据 time 和 sym 维度进行数据重组，并且计算每分钟股价的加权平均值，以交易量为权重。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:57;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;stockprice=pivot(wavg, [t1.price, t1.volume], minute(t1.time), t1.sym) stockprice.round(2)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;39-contextby-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.9. contextby 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:119;688:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:79;688:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;contextby&lt;/codeph&gt; 可以将数据根据列字段分组，并在组内调用指定函数进行计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:58;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;sym=`IBM`IBM`IBM`MS`MS`MS price=172.12 170.32 175.25 26.46 31.45 29.43 qty=5800 700 9000 6300 2100 5300 trade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07; contextby(avg, price, sym);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:120;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:80;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;contextby&lt;/codeph&gt; 亦可搭配 SQL 语句使用。下例调用 contextby 筛选出价格高于组内平均价的交易记录：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:59;700:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t1=table(trade_date,sym,qty,price); select trade_date, sym, qty, price from t1 where price &amp;gt; contextby(avg, price,sym);&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;310-callunifiedcall-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.10. call/unifiedCall 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;705:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:121;707:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;对需要批量调用不同函数进行计算的场景，可以通过高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:81;707:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;call&lt;/codeph&gt; 或者 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:82;707:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;unifiedCall&lt;/codeph&gt; 配合高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:83;707:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:84;707:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;loop&lt;/codeph&gt; 实现。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:122;709:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:85;709:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;call&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:86;709:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;unifiedCall&lt;/codeph&gt; 功能相同，但参数形式不同，详情可参考用户手册。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:123;711:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例中在部分应用中调用了函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:87;711:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;call&lt;/codeph&gt; 函数，该部分应用将向量 [1, 2, 3] 作为固定参数，在高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:88;711:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 中调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:89;711:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;sin&lt;/codeph&gt; 与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:90;711:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;log&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:60;713:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(call{, 1..3},(sin,log));&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:124;717:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;此外，还可通过元编程方式调用函数。这里会用到&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:91;717:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;funcByName&lt;/codeph&gt;。上述例子可改写为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:61;719:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(call{, 1..3},(funcByName('sin'),funcByName('log')));&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:125;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;或者，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:92;723:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;makeCall&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:93;723:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;makeUnifiedCall&lt;/codeph&gt; 生成元代码，后续通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:94;723:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;eval&lt;/codeph&gt; 来执行：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:62;725:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each(eval, each(makeCall{,1..3},(sin,log)))&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;311-accumulate-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;729:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;729:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.11. accumulate 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;729:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:126;731:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;已知分钟线数据如下，将某只股票每成交约 150 万股进行一次时间切分，最后得到时间窗口长度不等的若干条数据。具体的切分规则为：若某点的数据合入分组，可以缩小数据量和阈值（150 万）间的差值，则加入该点，否则当前分组不合入该点的数据。示意图如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/functional_programming/accumulcate.jpeg&#34; placement=&#34;break&#34; xtrc=&#34;image:3;733:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; dita-ot:image-width=&#34;1098&#34; dita-ot:image-height=&#34;747&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:3;733:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:127;735:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;构造测试数据如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:63;737:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;timex = 13:03:00+(0..27)*60 volume = 288658 234804 182714 371986 265882 174778 153657 201388 175937 138388 169086 203013 261230 398871 692212 494300 581400 348160 250354 220064 218116 458865 673619 477386 454563 622870 458177 880992 t = table(timex as time, volume)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:128;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这里自定义一个分组计算函数，将 volume 的累加，按上述切分规则，以 150 万为阈值进行分组。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:129;745:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;先定义一个分组函数，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:64;747:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def caclCumVol(target, preResult, x){ result = preResult + x if(result - target&amp;gt; target - preResult) return x else return result } accumulate(caclCumVol{1500000}, volume)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:130;756:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上述脚本通过自定义函数 caclCumVol 计算 volume 的累加值，结果最接近 150 万时划分分组。新的分组将从下一个 volume 值开始重新累加。对应脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:65;758:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;iif(accumulate(caclCumVol{1500000}, volume) ==volume, timex, NULL).ffill()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:131;762:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;通过和 volume 比较，筛选出了每组的起始记录。若中间结果存在空值，则调用 ffill 函数进行前值填充。将获得的结果配合 group by 语句进行分组计算，查询时，注意替换以上脚本的 timex 为表的 time 字段。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:66;764:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;output = select sum(volume) as sum_volume, last(time) as endTime from t group by iif(accumulate(caclCumVol{1500000}, volume) ==volume, time, NULL).ffill() as startTime&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:132;768:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:67;770:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;timex = 13:03:00+(0..27)*60 volume = 288658 234804 182714 371986 265882 174778 153657 201388 175937 138388 169086 203013 261230 398871 692212 494300 581400 348160 250354 220064 218116 458865 673619 477386 454563 622870 458177 880992 t = table(timex as time, volume) def caclCumVol(target, preResult, x){ result = preResult + x if(result - target&amp;gt; target - preResult) return x else return result } output = select sum(volume) as sum_volume, last(time) as endTime from t group by iif(accumulate(caclCumVol{1500000}, volume)==volume, time, NULL).ffill() as startTime&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;312-window-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;783:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;783:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.12. window 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;783:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:133;785:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;对表中的某列数据进行以下计算，如果当前数值是前 5 个数据的最低值 (包括当前值)，也是后 5 个最低值 (包括当前值)，那么标记是 1，否则是 0。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:134;787:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;创建测试表 t：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:68;789:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t = table(rand(1..100,20) as id)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:135;793:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;可以通过应用窗口函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:95;793:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;window&lt;/codeph&gt;，指定一个前后都为 5 的数据窗口，在该窗口内通过调用 min 函数计算最小值。注意：函数 window 的窗口边界包含在窗口中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:136;795:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;实现脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:69;797:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select *, iif(id==window(min, id, -4:4), 1, 0) as mid from t&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;313-reduce-使用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;801:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;801:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;3.13. reduce 使用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;801:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:137;803:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上面的一些案例中，也有用到高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:96;803:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;reduce&lt;/codeph&gt;。伪代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:70;805:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;result=&amp;lt;function&amp;gt;(init,X[0]); for(i:1~size(X)){ result=&amp;lt;function&amp;gt;(result, X[i]); } return result;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:138;813:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:97;813:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;accumulate&lt;/codeph&gt; 返回中间结果不同，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:98;813:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;reduce&lt;/codeph&gt; 只返回最后一个结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:139;815:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;例如下面的计算阶乘的例子：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:71;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;r1 = reduce(mul, 1..10); r2 = accumulate(mul, 1..10)[9];&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:140;822:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最终 r1 和 r2 的结果是一样的。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-部分应用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;824:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;824:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;4. 部分应用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;824:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:141;826:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;部分应用是指固定一个函数的部分参数，产生一个参数较少的函数。部分应用通常应用在对参数个数有特定要求的高阶函数中。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-提交带有参数的作业&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;4.1. 提交带有参数的作业&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:142;830:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;假设需要一个 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;scheduledJob.md&#34; xtrc=&#34;xref:11;830:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;定时任务&lt;/xref&gt;，每日 0 点执行，用于计算某设备前一日温度指标的最大值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:143;832:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;假设设备的温度信息存储在分布式库 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:99;832:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dfs://dolphindb&lt;/codeph&gt; 下的表 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:100;832:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;sensor&lt;/codeph&gt; 中，其时间字段为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:101;832:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;ts&lt;/codeph&gt;，类型为 DATETIME。下例定义一个 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:102;832:83&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;getMaxTemperature&lt;/codeph&gt; 函数来实现计算过程，脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:72;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def getMaxTemperature(deviceID){ maxTemp=exec max(temperature) from loadTable(&#34;dfs://dolphindb&#34;,&#34;sensor&#34;) where ID=deviceID ,date(ts) = today()-1 return maxTemp }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:144;842:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;定义计算函数后，可通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:103;842:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;scheduleJob&lt;/codeph&gt; 提交定时任务。由于函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:104;842:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;scheduleJob&lt;/codeph&gt; 不提供接口供任务函数进行传参，而自定义函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:105;842:77&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;getMaxTemperature&lt;/codeph&gt; 以设备 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:106;842:101&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;deviceID&lt;/codeph&gt; 作为参数，这里可以通过部分应用来固定参数，从而产生一个没有参数的函数。脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:73;844:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;scheduleJob(`testJob, &#34;getMaxTemperature&#34;, getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:145;848:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;上例只查询了设备号为 1 的设备。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:146;850:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最终，完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:74;852:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def getMaxTemperature(deviceID){ maxTemp=exec max(temperature) from loadTable(&#34;dfs://dolphindb&#34;,&#34;sensor&#34;) where ID=deviceID ,date(ts) = today()-1 return maxTemp } scheduleJob(`testJob, &#34;getMaxTemperature&#34;, getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-获取集群其它节点作业信息&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;862:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;862:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;4.2. 获取集群其它节点作业信息&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;862:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:147;864:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在 DolphinDB 中提交定时作业后，可通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:107;864:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;getRecentJobs&lt;/codeph&gt; 来取得本地节点上最近几个批处理作业的状态。如查看本地节点最近 3 个批处理作业状态，可以用如下所示脚本实现：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:75;866:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;getRecentJobs(3);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:148;870:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;若想获取集群上其它节点的作业信息，需通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:108;870:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc&lt;/codeph&gt; 来在指定的远程节点上调用内置函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:109;870:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;getRecentJobs&lt;/codeph&gt;。如获取节点别名为 P1-node1 的作业信息，可以如下实现：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:76;872:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc(&#34;P1-node1&#34;,getRecentJobs)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:149;876:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;如需获取节点 P1-node1 上最近 3 个作业的信息，通过如下脚本实现会报错：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:77;878:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc(&#34;P1-node1&#34;,getRecentJobs(3))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:150;882:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:110;882:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc&lt;/codeph&gt; 函数第二个参数需要为函数（内置函数或用户自定义函数）。这里可以通过 DolphinDB 的部分应用，固定函数参数，来生成一个新的函数给 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:111;882:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc&lt;/codeph&gt; 使用，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:78;884:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;rpc(&#34;P1-node1&#34;,getRecentJobs{3})&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;43-带状态的流计算消息处理函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:33;888:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:33;888:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;4.3. 带“状态”的流计算消息处理函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:33;888:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:151;890:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在流计算中，用户通常需要给定一个消息处理函数，接受到消息后进行处理。这个处理函数是一元函数或数据表。若为函数，用于处理订阅数据，其唯一的参数是订阅的数据，即不能包含状态信息。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:152;892:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例通过部分应用定义消息处理函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:112;892:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cumulativeAverage&lt;/codeph&gt;，用于计算数据的累计均值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:153;894:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;定义流数据表 trades，对于其 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:113;894:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;price&lt;/codeph&gt; 字段，每接受一条消息，计算一次 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:114;894:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;price&lt;/codeph&gt; 的均值，并输出到结果表 avgTable 中。脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:79;896:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;share streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,DOUBLE]) as trades avgT=table(10000:0,[`avg_price],[DOUBLE]) def cumulativeAverage(mutable avgTable, mutable stat, trade){ newVals = exec price from trade; for(val in newVals) { stat[0] = (stat[0] * stat[1] + val )/(stat[1] + 1) stat[1] += 1 insert into avgTable values(stat[0]) } } subscribeTable(tableName=&#34;trades&#34;, actionName=&#34;action30&#34;, handler=cumulativeAverage{avgT,0.0 0.0}, msgAsTable=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:154;913:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;自定义函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:115;913:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;cumulativeAverage&lt;/codeph&gt; 的参数 avgTable 为计算结果的存储表。stat 是一个向量，包含了两个值：其中，stat[0] 用来表示当前的所有数据的平均值，stat[1] 表示数据个数。函数体的计算实现为：遍历数据更新 stat 的值，并将新的计算结果插入表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:155;915:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;订阅流数据表时，通过在 handler 中固定前两个参数，实现带“状态”的消息处理函数。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-金融场景相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:34;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:34;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;5. 金融场景相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:34;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-使用-map-reduce对-tick-数据降精度&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:35;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:35;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;5.1. 使用 map reduce，对 tick 数据降精度&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:35;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:156;921:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例中，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:116;921:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mr&lt;/codeph&gt; 函数（map reduce）将 tick 数据转化为分钟级数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:157;923:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;在 DolphinDB 中，可以使用 SQL 语句基于 tick 数据计算分钟级数据：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:80;925:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;minuteQuotes=select avg(bid) as bid, avg(ofr) as ofr from t group by symbol,date,minute(time) as minute&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:158;929:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;但在数据量较大时，该实现效率低，耗时长。为提升性能，可以使用 DolphinDB 的分布式计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:159;931:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;Map-Reduce 函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:117;931:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mr&lt;/codeph&gt; 是 DolphinDB 通用分布式计算框架的核心功能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:160;933:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:81;935:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;login(`admin, `123456) db = database(&#34;dfs://TAQ&#34;) quotes = db.loadTable(&#34;quotes&#34;) //create a new table quotes_minute model=select top 1 symbol,date, minute(time) as minute,bid,ofr from quotes where date=2007.08.01,symbol=`EBAY if(existsTable(&#34;dfs://TAQ&#34;, &#34;quotes_minute&#34;)) db.dropTable(&#34;quotes_minute&#34;) db.createPartitionedTable(model, &#34;quotes_minute&#34;, `date`symbol) //populate data for table quotes_minute def saveMinuteQuote(t){ minuteQuotes=select avg(bid) as bid, avg(ofr) as ofr from t group by symbol,date,minute(time) as minute loadTable(&#34;dfs://TAQ&#34;, &#34;quotes_minute&#34;).append!(minuteQuotes) return minuteQuotes.size() } ds = sqlDS(&amp;lt;select symbol,date,time,bid,ofr from quotes where date between 2007.08.01 : 2007.08.31&amp;gt;) timer mr(ds, saveMinuteQuote, +) &lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-数据回放和高频因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:36;958:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:36;958:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;5.2. 数据回放和高频因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:36;958:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:161;960:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;有状态的因子，即因子的计算不仅用到当前数据，还会用到历史数据。实现状态因子的计算，一般包括这几个步骤：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;962:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;962:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:5;962:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;962:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;保存本批次的消息数据到历史记录；&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;963:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:6;963:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;963:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;根据更新后的历史记录，计算因子&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;964:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:7;964:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;964:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;将因子计算结果写入输出表中。如有必要，删除未来不再需要的的历史记录。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:162;966:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;DolphinDB 的消息处理函数必须是单目函数，其唯一的参数就是当前的消息。要保存历史状态并在消息处理函数中计算历史数据，可以通过部分应用实现：对于多参数的消息处理函数，保留一个参数用于接收消息，固化其它所有的参数，用于保存历史状态。这些固化参数只对消息处理函数可见，不受其他应用的影响。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:163;968:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;历史状态可保存在内存表，字典或分区内存表中。本例将使用 DolphinDB&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;streaming_tutorial.md&#34; xtrc=&#34;xref:12;968:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;流计算引擎&lt;/xref&gt; 来处理 &lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;https://www.dolphindb.cn/downloads/tutorial/hfFactorsSampleData.zip&#34; scope=&#34;external&#34; xtrc=&#34;xref:13;968:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;?ditaot usertext?&gt;报价数据&lt;/xref&gt; 通过字典保存历史状态并计算因子。如需通过内存表或分布式内存表保存历史状态，可以参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;hf_factor_streaming.md&#34; xtrc=&#34;xref:14;968:193&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;实时计算高频因子&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:164;970:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;定义状态因子：计算当前第一档卖价 (askPrice1) 与 30 个报价前的第一档卖价的比值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:165;972:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;对应的因子计算函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:118;972:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;factorAskPriceRatio&lt;/codeph&gt;实现如下：:&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:82;974:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;defg factorAskPriceRatio(x){ cnt = x.size() if(cnt &amp;lt; 31) return double() else return x[cnt - 1]/x[cnt - 31] }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:166;982:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;导入数据创建对应的流数据表后，可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:119;982:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;replay&lt;/codeph&gt; 函数回放数据，模拟实时流计算的场景。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:83;984:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;quotesData = loadText(&#34;/data/ddb/data/sampleQuotes.csv&#34;) x=quotesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as quotes1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:167;991:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;由于这里使用字典保存历史状态，可以定义如下字典：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:84;993:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;history = dict(STRING, ANY)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:168;997:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;该字典的键值为 STRING 类型，存储股票字段，值为元组（tuple）类型，存储卖价的历史数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:169;999:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:120;999:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dictUpdate!&lt;/codeph&gt; 函数更新字典，然后循环计算每只股票的因子，并通过表存储因子的计算结果。然后订阅流表，通过数据回放向流表注入数据，每到来一条新数据都将触发因子的计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:170;1001:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;消息处理函数定义如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:85;1003:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def factorHandler(mutable historyDict, mutable factors, msg){ historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&amp;gt;array(x.type(), 0, 512).append!(x)) syms = msg.symbol.distinct() cnt = syms.size() v = array(DOUBLE, cnt) for(i in 0:cnt){ v[i] = factorAskPriceRatio(historyDict[syms[i]]) } factors.tableInsert([take(now(), cnt), syms, v]) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:171;1016:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;参数 historyDict 为保存历史状态的字典，factors 是存储计算结果的表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:172;1018:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:86;1020:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;quotesData = loadText(&#34;/data/ddb/data/sampleQuotes.csv&#34;) defg factorAskPriceRatio(x){ cnt = x.size() if(cnt &amp;lt; 31) return double() else return x[cnt - 1]/x[cnt - 31] } def factorHandler(mutable historyDict, mutable factors, msg){ historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&amp;gt;array(x.type(), 0, 512).append!(x)) syms = msg.symbol.distinct() cnt = syms.size() v = array(DOUBLE, cnt) for(i in 0:cnt){ v[i] = factorAskPriceRatio(historyDict[syms[i]]) } factors.tableInsert([take(now(), cnt), syms, v]) } x=quotesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as quotes1 history = dict(STRING, ANY) share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors subscribeTable(tableName = &#34;quotes1&#34;, offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize=3000, throttle=0.005) replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:173;1048:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;查看结果&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:87;1050:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;select top 10 * from factors where isValid(factor)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;53-基于字典的计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:37;1054:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:37;1054:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;5.3. 基于字典的计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:37;1054:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:174;1056:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;下例创建表 orders，该表包含了一些简单的股票信息：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:88;1058:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;orders = table(`IBM`IBM`IBM`GOOG as SecID, 1 2 3 4 as Value, 4 5 6 7 as Vol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:175;1062:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;创建一个字典。键为股票代码，值为从 orders 表中筛选出来的只包含该股票信息的子表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:176;1064:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;字典定义如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:89;1066:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;historyDict = dict(STRING, ANY)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:177;1070:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;然后通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:121;1070:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dictUpdate!&lt;/codeph&gt;，来更新每个键的值，实现如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:90;1072:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;historyDict.dictUpdate!(function=def(x,y){tableInsert(x,y);return x}, keys=orders.SecID, parameters=orders, initFunc=def(x){t = table(100:0, x.keys(), each(type, x.values())); tableInsert(t, x); return t})&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:178;1076:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;可以把 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:122;1076:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;dictUpdate!&lt;/codeph&gt; 的执行过程理解成，针对参数 parameters 遍历，每个 parameters 作为参数，通过 function 去更新字典 (字典的 key 由 keys 指定的)。当字典中不存在对应的 key 时，会调用 initFunc 去初始化 key 对应的值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:179;1078:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这个例子中，字典的 key 是股票代码，value 是 orders 的子表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:180;1080:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;这里，我们使用 orders.SecID 作为 keys，在更新的函数参数中，我们定义了一个 lamda 函数将当前记录插入到表中，如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:91;1082:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def(x,y){tableInsert(x,y);return x}&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:181;1086:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;注意此处使用 lamda 函数封装了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:123;1086:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;tableInsert&lt;/codeph&gt;，而非指定 function=tableInsert。这是因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:124;1086:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;tableInsert&lt;/codeph&gt; 的返回值不是一个 table，而是插入的条数，如果直接调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:125;1086:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;tableInsert&lt;/codeph&gt;，在写入第二条 IBM 对应的记录时，会将字典中的值更新成插入的条数；写入第三条 IBM 对应的记录时，系统会抛出异常。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:182;1088:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;初始条件下，historyDict 未赋值，可以通过指定 initFunc 参数对字典进行初始化赋值：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:92;1090:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def(x){ t = table(100:0, x.keys(), each(type, x.values())); tableInsert(t, x); return t }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:183;1098:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最终，完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:93;1100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;orders = table(`IBM`IBM`IBM`GOOG as SecID, 1 2 3 4 as Value, 4 5 6 7 as Vol) historyDict = dict(STRING, ANY) historyDict.dictUpdate!(function=def(x,y){tableInsert(x,y);return x}, keys=orders.SecID, parameters=orders, initFunc=def(x){t = table(100:0, x.keys(), each(type, x.values())); tableInsert(t, x); return t})&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:184;1107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;执行后 historyDict 结果如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:94;1109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;GOOG-&amp;gt; Vol Value SecID --- ----- ----- 7 4 GOOG IBM-&amp;gt; Vol Value SecID --- ----- ----- 4 1 IBM 5 2 IBM 6 3 IBM&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-机器学习相关案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:38;1123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:38;1123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;6. 机器学习相关案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:38;1123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-ols-残差&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:39;1125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:39;1125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;6.1. ols 残差&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:39;1125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:185;1127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;创建样本表 t 如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:95;1129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t=table(2020.11.01 2020.11.02 as date, `IBM`MSFT as ticker, 1.0 2 as past1, 2.0 2.5 as past3, 3.5 7 as past5, 4.2 2.4 as past10, 5.0 3.7 as past20, 5.5 6.2 as past30, 7.0 8.0 as past60)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:186;1133:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;计算每行数据和一个向量 benchX 的回归残差，并将结果保存到新列中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:187;1135:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;向量 benchX 如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:96;1137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;benchX = 10 15 7 8 9 1 2.0&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:188;1141:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;DolphinDB 提供了最小二乘回归函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:126;1141:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;ols&lt;/codeph&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:189;1143:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;先将表中参与计算的以下列转化成矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:97;1145:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;mt = matrix(t[`past1`past3`past5`past10`past20`past30`past60]).transpose()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:190;1149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;然后定义残差计算函数如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:98;1151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;def(y, x) { return ols(y, x, true, 2).ANOVA.SS[1] }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:191;1157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;最后使用高阶函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:127;1157:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;each&lt;/codeph&gt; 与部分应用，对每行数据应用残差计算函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:99;1159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t[`residual] = each(def(y, x){ return ols(y, x, true, 2).ANOVA.SS[1]}{,benchX}, mt)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:192;1163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;完整代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;shell&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:100;1165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;t=table(2020.11.01 2020.11.02 as date, `IBM`MSFT as ticker, 1.0 2 as past1, 2.0 2.5 as past3, 3.5 7 as past5, 4.2 2.4 as past10, 5.0 3.7 as past20, 5.5 6.2 as past30, 7.0 8.0 as past60) mt = matrix(t[`past1`past3`past5`past10`past20`past30`past60]).transpose() t[`residual] = each(def(y, x){ return ols(y, x, true, 2).ANOVA.SS[1]}{,benchX}, mt)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:40;1172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:40;1172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;7. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:40;1172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:193;1174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/func_progr_cases.md&#34;&gt;除了上面提到的一些函数与高阶函数。DolphinDB 还提供了丰富的函数库，包括数学函数、统计函数、分布相关函数、假设检验函数、机器学习函数、逻辑函数、字符串函数、时间函数、数据操作函数、窗口函数、高阶函数、元编程、分布式计算函数、流计算函数、定时任务函数、性能监控函数、用户权限管理函数等。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/func_progr_cases.md"/><meta name="wh-out-relpath" content="tutorials/func_progr_cases.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="函数化编程案例" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="函数化编程案例"><div class="title"><a href="../tutorials/func_progr_cases.html">函数化编程案例</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem" class="active"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">函数化编程案例</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 支持函数化编程：函数对象可以作为高阶函数的参数。这提高了代码表达能力，简化了代码，复杂的任务可以通过一行或几行代码完成。</p><p class="- topic/p p">本教程介绍了一些常见场景下的函数化编程案例，重点介绍 DolphinDB 的高阶函数及其使用场景。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-数据导入"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 数据导入</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-整型时间转化为-time-格式并导入"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1. 整型时间转化为 TIME 格式并导入</h3><div class="- topic/body body"><p class="- topic/p p">CSV 数据文件中常用整数表示时间，如“93100000”表示“9:31:00.000”。为了便于查询分析，建议将这类数据转换为时间类型，再存储到 DolphinDB 数据库中。</p><p class="- topic/p p">针对这种场景，可通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTextEx</code> 函数的 <code class="+ topic/ph pr-d/codeph ph codeph">transform</code> 参数将文本文件中待转化的时间列指定为相应的数据类型。</p><p class="- topic/p p">本例中会用到 CSV 文件 <a class="- topic/xref xref" href="data/candle_201801.csv">candle_201801.csv</a>，数据样本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock csv"><code>symbol,exchange,cycle,tradingDay,date,time,open,high,low,close,volume,turnover,unixTime
000001,SZSE,1,20180102,20180102,93100000,13.35,13.39,13.35,13.38,2003635,26785576.72,1514856660000
000001,SZSE,1,20180102,20180102,93200000,13.37,13.38,13.33,13.33,867181
......</code></pre><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">建库</p><p class="- topic/p p">用脚本创建如下分布式数据库（按天进行值分区）：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>login(`admin,`123456)
dataFilePath="/home/data/candle_201801.csv"
dbPath="dfs://DolphinDBdatabase"
db=database(dbPath,VALUE,2018.01.02..2018.01.30)</code></pre></li><li class="- topic/li li"><p class="- topic/p p">建表</p><p class="- topic/p p">下面先通过 <code class="+ topic/ph pr-d/codeph ph codeph">extractTextSchema</code> 函数获取数据文件的表结构。csv 文件中的 time 字段被识别为整型。若要将其存为 TIME 类型，可以通过 update 语句更新表结构将其转换为 TIME 类型，然后用更新后的表结构来创建分布式表。该分布式表的分区列是 date 列。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>schemaTB=extractTextSchema(dataFilePath)
update schemaTB set type="TIME" where name="time"
tb=table(1:0, schemaTB.name, schemaTB.type)
tb=db.createPartitionedTable(tb, `tb1, `date);</code></pre><p class="- topic/p p">这里通过 <code class="+ topic/ph pr-d/codeph ph codeph">extractTextSchema</code> 获取表结构。用户也可以自定义表结构。</p></li><li class="- topic/li li"><p class="- topic/p p">导入数据</p><p class="- topic/p p">可以通过自定义函数 i2t 对时间列 time 进行预处理，将其转换为 TIME 类型，并返回处理后的数据表。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def i2t(mutable t){
    return t.replaceColumn!(`time, t.time.format("000000000").temporalParse("HHmmssSSS"))
}</code></pre><p class="- topic/p p">请注意：在自定义函数体内对数据进行处理时，请尽量使用本地的修改（以！结尾的函数）来提升性能。</p><p class="- topic/p p">调用 <code class="+ topic/ph pr-d/codeph ph codeph">loadTextEx</code> 函数导入 csv 文件的数据到分布式表，这里指定 <code class="+ topic/ph pr-d/codeph ph codeph">transform</code> 参数为 <code class="+ topic/ph pr-d/codeph ph codeph">i2t</code> 函数，导入时会自动应用 <code class="+ topic/ph pr-d/codeph ph codeph">i2t</code> 函数处理数据。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tmpTB=loadTextEx(dbHandle=db, tableName=`tb1, partitionColumns=`date, filename=dataFilePath, transform=i2t);</code></pre></li><li class="- topic/li li"><p class="- topic/p p">查询数据</p><p class="- topic/p p">查看表内前 2 行数据，可以看到结果符合预期。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 2 * from loadTable(dbPath,`tb1);

symbol exchange cycle tradingDay date       time               open  high  low   close volume  turnover   unixTime
------ -------- ----- ---------- ---------- --------------     ----- ----- ----- ----- ------- ---------- -------------
000001 SZSE     1     2018.01.02 2018.01.02 09:31:00.000       13.35 13.39 13.35 13.38 2003635 2.678558E7 1514856660000
000001 SZSE     1     2018.01.02 2018.01.02 09:32:00.000       13.37 13.38 13.33 13.33 867181  1.158757E7 1514856720000</code></pre></li></ol><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>login(`admin,`123456)
dataFilePath="/home/data/candle_201801.csv"
dbPath="dfs://DolphinDBdatabase"
db=database(dbPath,VALUE,2018.01.02..2018.01.30)
schemaTB=extractTextSchema(dataFilePath)
update schemaTB set type="TIME" where name="time"
tb=table(1:0,schemaTB.name,schemaTB.type)
tb=db.createPartitionedTable(tb,`tb1,`date);

def i2t(mutable t){
    return t.replaceColumn!(`time,t.time.format("000000000").temporalParse("HHmmssSSS"))
}

tmpTB=loadTextEx(dbHandle=db,tableName=`tb1,partitionColumns=`date,filename=dataFilePath,transform=i2t);</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注</strong>：关于文本导入的相关函数和案例，可以参考 <a class="- topic/xref xref" href="import_data.html">数据导入教程</a></p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-有纳秒时间戳的文本导入"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2. 有纳秒时间戳的文本导入</h3><div class="- topic/body body"><p class="- topic/p p">本例将以整数类型存储的纳秒级数据导入为 NANOTIMESTAMP 类型。本例使用文本文件 <a class="- topic/xref xref" href="data/nx.txt">nx.txt</a>，数据样本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>SendingTimeInNano#securityID#origSendingTimeInNano#bidSize
1579510735948574000#27522#1575277200049000000#1
1579510735948606000#27522#1575277200049000000#2
...</code></pre><p class="- topic/p p">每一行记录通过字符'#'来分隔列，SendingTimeInNano 和 origSendingTimeInNano 用于存储纳秒时间戳。</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">建库建表</p><p class="- topic/p p">首先定义分布式数据库和表，脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>dbSendingTimeInNano = database(, VALUE, 2020.01.20..2020.02.22);
dbSecurityIDRange = database(, RANGE,  0..10001);
db = database("dfs://testdb", COMPO, [dbSendingTimeInNano, dbSecurityIDRange]);

nameCol = `SendingTimeInNano`securityID`origSendingTimeInNano`bidSize;
typeCol = [`NANOTIMESTAMP,`INT,`NANOTIMESTAMP,`INT];
schemaTb = table(1:0,nameCol,typeCol);

db = database("dfs://testdb");
nx = db.createPartitionedTable(schemaTb, `nx, `SendingTimeInNano`securityID);</code></pre><p class="- topic/p p">上述脚本创建了一个 <a class="- topic/xref xref" href="database.html">组合分区</a> 的数据库，然后根据文本的字段和类型创建了表 nx。</p></li><li class="- topic/li li"><p class="- topic/p p">导入数据</p><p class="- topic/p p">导入数据时，使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">nanotimestamp</code>，将文本中的整型转化为 NANOTIMESTAMP 类型：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def dataTransform(mutable t){
  return t.replaceColumn!(`SendingTimeInNano, nanotimestamp(t.SendingTimeInNano)).replaceColumn!(`origSendingTimeInNano, nanotimestamp(t.origSendingTimeInNano))
}</code></pre><p class="- topic/p p">最终通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTextEx</code> 导入数据。</p></li></ol><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>dbSendingTimeInNano = database(, VALUE, 2020.01.20..2020.02.22);
dbSecurityIDRange = database(, RANGE,  0..10001);
db = database("dfs://testdb", COMPO, [dbSendingTimeInNano, dbSecurityIDRange]);

nameCol = `SendingTimeInNano`securityID`origSendingTimeInNano`bidSize;
typeCol = [`NANOTIMESTAMP,`INT,`NANOTIMESTAMP,`INT];
schemaTb = table(1:0,nameCol,typeCol);

db = database("dfs://testdb");
nx = db.createPartitionedTable(schemaTb, `nx, `SendingTimeInNano`securityID);

def dataTransform(mutable t){
  return t.replaceColumn!(`SendingTimeInNano, nanotimestamp(t.SendingTimeInNano)).replaceColumn!(`origSendingTimeInNano, nanotimestamp(t.origSendingTimeInNano))
}

pt=loadTextEx(dbHandle=db,tableName=`nx , partitionColumns=`SendingTimeInNano`securityID,filename="nx.txt",delimiter='#',transform=dataTransform);</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="2-lambda-表达式"><h2 class="- topic/title title topictitle2" id="ariaid-title5">2. Lambda 表达式</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中可以使用命名函数或匿名函数（通常为 lambda 表达式）来创建自定义函数。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>x = 1..10
each(x -&gt; x + 1, [1, 2, 3])</code></pre><p class="- topic/p p">在这个例子中使用了一个 lambda 表达式（<code class="+ topic/ph pr-d/codeph ph codeph">x -&gt; x + 1, [1, 2, 3]</code>）作为高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 的参数，其中，该 lambda 表达式接受一个输入 x 并返回 x + 1。它与 each 函数一起使用的结果是，将 1 添加到数组 [1, 2, 3] 中的每个元素。</p><p class="- topic/p p">后续章节将介绍其他 lambda 函数案例。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title6" id="3-高阶函数使用案例"><h2 class="- topic/title title topictitle2" id="ariaid-title6">3. 高阶函数使用案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="31-cross-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.1. cross 使用案例</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="311-将两个向量或矩阵两两组合作为参数来调用函数"><h4 class="- topic/title title topictitle4" id="ariaid-title8">3.1.1. 将两个向量或矩阵，两两组合作为参数来调用函数</h4><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">cross</code> 函数的伪代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>for(i:0~(size(X)-1)){
   for(j:0~(size(Y)-1)){
       result[i,j]=&lt;function&gt;(X[i], Y[j]);
   }
}
return result;</code></pre><p class="- topic/p p">以计算协方差矩阵为例，一般需要使用两个 for 循环计算。代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def matlab_cov(mutable matt){
 nullFill!(matt,0.0)
 rowss,colss=matt.shape()
 msize = min(rowss, colss)
 df=matrix(float,msize,msize)
 for (r in 0..(msize-1)){
  for (c in 0..(msize-1)){
   df[r,c]=covar(matt[:,r],matt[:,c])
  }
 }
 return df
}</code></pre><p class="- topic/p p">以上代码虽然逻辑简单，但是冗长，表达能力较差，且易出错。</p><p class="- topic/p p">在 DolphinDB 中可以使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">cross</code> 或 <code class="+ topic/ph pr-d/codeph ph codeph">pcross</code> 计算协方差矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>cross(covar, matt)</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="312-计算股票两两之间的相关性"><h4 class="- topic/title title topictitle4" id="ariaid-title9">3.1.2. 计算股票两两之间的相关性</h4><div class="- topic/body body"><p class="- topic/p p">本例中，我们使用金融大数据开放社区 Tushare 的沪深股票 <a class="- topic/xref xref" href="https://tushare.pro/document/2?doc_id=27" target="_blank" rel="external noopener">日线行情</a> 数据，来计算股票间的两两相关性。</p><p class="- topic/p p">首先我们定义一个数据库和表，来存储沪深股票日线行情数据。相关语句如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>login("admin","123456")
dbPath="dfs://tushare"
yearRange=date(2008.01M + 12*0..22)
if(existsDatabase(dbPath)){
 dropDatabase(dbPath)
}
columns1=`ts_code`trade_date`open`high`low`close`pre_close`change`pct_chg`vol`amount
type1=`SYMBOL`NANOTIMESTAMP`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE`DOUBLE
db=database(dbPath,RANGE,yearRange)
hushen_daily_line=db.createPartitionedTable(table(100000000:0,columns1,type1),`hushen_daily_line,`trade_date)</code></pre><p class="- topic/p p">注：上面的表是按照 <a class="- topic/xref xref" href="https://tushare.pro/document/2?doc_id=27" target="_blank" rel="external noopener">日线行情</a> 里的结构说明定义的。</p><p class="- topic/p p">定义好表结构后，如需获取对应的数据，可前往 <a class="- topic/xref xref" href="https://tushare.pro/document/1?doc_id=39" target="_blank" rel="external noopener">Tushare</a> 平台注册账户，获取 TOKEN，并参考 <a class="- topic/xref xref" href="script/getTushareDailyLine.py">案例脚本</a> 进行数据导入操作。本案例使用 DolphinDB 的 <a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/pydoc/py.html" target="_blank" rel="external noopener">Python API</a>获取数据，用户也可参考 Tushare 的说明文档使用其它语言或库。本例使用 2008 年到 2017 年的日线行情进行说明。</p><p class="- topic/p p">在计算两两相关性时，首先使用 exec + pivot by 生成股票回报率矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>retMatrix=exec pct_chg/100 as ret from daily_line pivot by trade_date, ts_code</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">exec</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 是 DolphinDB 编程语言的特点之一。<code class="+ topic/ph pr-d/codeph ph codeph">exec</code> 与 <code class="+ topic/ph pr-d/codeph ph codeph">select</code> 的用法相同，但 <code class="+ topic/ph pr-d/codeph ph codeph">select</code>语句仅可生成表，, <code class="+ topic/ph pr-d/codeph ph codeph">exec</code> 语句可以生成向量。<code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 用于重整维度，与 <code class="+ topic/ph pr-d/codeph ph codeph">exec</code> 一起使用时会生成一个矩阵。</p><p class="- topic/p p">调用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">cross</code> 生成股票两两相关性矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>corrMatrix=cross(corr,retMatrix)</code></pre><p class="- topic/p p">查询和每只股票相关性最高的 10 只股票：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>syms=(exec count(*) from daily_line group by ts_code).ts_code
syms="C"+strReplace(syms, ".", "_")
mostCorrelated=select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms).rename!(`ts_code`corr_ts_code`corr) context by ts_code having rank(corr,false) between 1:10</code></pre><p class="- topic/p p">上面代码中，corrMatrix 是一个矩阵，需要转化为表做进一步处理，同时新增一列表示股票代码。使用 table 函数转化成表后，通过 <code class="+ topic/ph pr-d/codeph ph codeph">rename!</code> 函数去修改表的列名。由于表的列名不能以数字开头，故此例中，在 syms 前拼接了字符 "C"，并将 syms 中的字符'.'转化成'_'。</p><p class="- topic/p p">之后，对表做 <code class="+ topic/ph pr-d/codeph ph codeph">unpivot</code> 操作，把多列的数据转化成一列。</p><p class="- topic/p p">为了说明中间过程，我们将以上代码拆解出一个中间步骤：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms)</code></pre><p class="- topic/p p">这一步生成结果如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>ts_code   valueType  value
--------- ---------- -----------------
000001.SZ C600539_SH 1
000002.SZ C600539_SH 0.581235290880416
000004.SZ C600539_SH 0.277978963095669
000005.SZ C600539_SH 0.352580116619933
000006.SZ C600539_SH 0.5056164472398
......</code></pre><p class="- topic/p p">这样就得到了每只股票与其它股票的相关系数。之后又使用 <code class="+ topic/ph pr-d/codeph ph codeph">rename!</code> 来修改列名，然后通过 <code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 来按照 <code class="+ topic/ph pr-d/codeph ph codeph">ts_code</code> （股票代码）分组计算。每组中，查询相关性最高的 10 只股票。</p><p class="- topic/p p">最终完整代码为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>login("admin","123456")
daily_line= loadTable("dfs://tushare","hushen_daily_line")

retMatrix=exec pct_chg/100 as ret from daily_line pivot by trade_date,ts_code
corrMatrix=cross(corr,retMatrix)

syms=(exec count(*) from daily_line group by ts_code).ts_code
syms="C"+strReplace(syms, ".", "_")
mostCorrelated=select * from table(corrMatrix.columnNames() as ts_code, corrMatrix).rename!([`ts_code].append!(syms)).unpivot(`ts_code, syms).rename!(`ts_code`corr_ts_code`corr) context by ts_code having rank(corr,false) between 1:10</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="32-each-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.2. each 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">某些场景需要把函数应用到指定参数中的每个元素。若不使用函数化编程，需要使用 for 循环。DolphinDB 提供的高阶函数，例如 <code class="+ topic/ph pr-d/codeph ph codeph">each</code>, <code class="+ topic/ph pr-d/codeph ph codeph">peach</code>, <code class="+ topic/ph pr-d/codeph ph codeph">loop</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ploop</code> 等，可以简化代码。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="321-获取数据表各个列的-null-值个数"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.2.1. 获取数据表各个列的 NULL 值个数</h4><div class="- topic/body body"><p class="- topic/p p">计算表 t 各列的 NULL 值个数，可以使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>each(x-&gt;x.size() - x.count(), t.values())</code></pre><p class="- topic/p p">注：在 DolphinDB 中，对于向量或矩阵，size 返回所有元素的个数，而 count 返回的是非 NULL 元素的个数。因此可以通过 size 和 count 的差值获得 NULL 元素的个数。</p><p class="- topic/p p">其中，t.values() 返回一个 tuple，每个元素为表 <code class="+ topic/ph pr-d/codeph ph codeph">t</code> 其中的一列。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="322-去除表中存在-null-值的行"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.2.2. 去除表中存在 NULL 值的行</h4><div class="- topic/body body"><p class="- topic/p p">先通过如下代码生成表 t：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>sym = take(`a`b`c, 110)
id = 1..100 join take(int(),10)
id2 =  take(int(),10) join 1..100
t = table(sym, id,id2)</code></pre><p class="- topic/p p">可用以下两种方法实现。</p><p class="- topic/p p">第一种是直接按行处理，检查每一行是否存在 NULL 值，若存在就去除该行。解决方案如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t[each(x -&gt; !(x.id == NULL || x.id2 == NULL), t)]</code></pre><p class="- topic/p p">需要注意的是，按行处理表时，表的每一行是一个字典对象。这里定义了一个 lambda 表达式来检查空值。</p><p class="- topic/p p">若列数较多，不便枚举时，可以采用以下写法：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t[each(x -&gt; all(isValid(x.values())), t)]</code></pre><p class="- topic/p p">上面代码中，<code class="+ topic/ph pr-d/codeph ph codeph">x.values</code> 获取了该字典所有的值，然后通过 <code class="+ topic/ph pr-d/codeph ph codeph">isValid</code> 检查 NULL 值，最后通过 <code class="+ topic/ph pr-d/codeph ph codeph">all</code> 将结果汇总，判断该行是否包含 NULL 值。</p><p class="- topic/p p">当数据量较大时，上述脚本运行效率较低。</p><p class="- topic/p p">DolphinDB 采用列式存储，列操作较行操作具有更佳的性能。我们可以调用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 对表的每一列分别应用 <code class="+ topic/ph pr-d/codeph ph codeph">isValid</code> 函数，返回一个结果矩阵。通过 <code class="+ topic/ph pr-d/codeph ph codeph">rowAnd</code> 判断矩阵的每一行是否存在 0 值。</p><p class="- topic/p p">代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t[each(isValid, t.values()).rowAnd()]</code></pre><p class="- topic/p p">当数据量很大时，可能会产生如下报错：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>The number of cells in a matrix can't exceed 2 billions.</code></pre><p class="- topic/p p">这是因为 <code class="+ topic/ph pr-d/codeph ph codeph">each(isValid, t.values())</code> 生成的矩阵过大。为解决该问题，可以调用 <code class="+ topic/ph pr-d/codeph ph codeph">reduce</code> 进行迭代计算，遍历检查每一列是否存在 NULL 值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t[reduce(def(x,y) -&gt; x and isValid(y), t.values(), true)]</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="323-按行处理与按列处理性能比较案例"><h4 class="- topic/title title topictitle4" id="ariaid-title13">3.2.3. 按行处理与按列处理性能比较案例</h4><div class="- topic/body body"><p class="- topic/p p">下例对表的某个字段进行如下处理："aaaa_bbbb" 替换为 "bbbb_aaaa"。</p><p class="- topic/p p">先创建一个表 t：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t=table(take("aaaa_bbbb", 1000000) as str);</code></pre><p class="- topic/p p">有两种处理思路，可以按行处理或按列处理。</p><p class="- topic/p p">按行处理：</p><p class="- topic/p p">可以调用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 遍历每一行数据，切分后拼接。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>each(x -&gt; split(x, '_').reverse().concat('_'), t[`str])</code></pre><p class="- topic/p p">按列处理：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>pos = strpos(t[`str], "_")
substr(t[`str], pos+1)+"_"+t[`str].left(pos)</code></pre><p class="- topic/p p">对比两种方式的性能，可以看到使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 按行遍历的时间在 2s300ms 左右，而按列处理的时间在 100ms 左右。因此按列处理性能更高。</p><p class="- topic/p p">完整代码和测试结果如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t=table(take("aaaa_bbbb", 1000000) as str);

timer r = each(x -&gt; split(x, '_').reverse().concat('_'), t[`str])

timer {
 pos = strpos(t[`str], "_")
 r = substr(t[`str], pos+1)+"_"+t[`str].left(pos)
}</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="324-判断两张表内容是否相同"><h4 class="- topic/title title topictitle4" id="ariaid-title14">3.2.4. 判断两张表内容是否相同</h4><div class="- topic/body body"><p class="- topic/p p">判断两张表 t1 和 t2 的数据是否完全相同，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 高阶函数，对表的每列进行比较。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>all(each(eqObj, t1.values(), t2.values()))</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="33-loop-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title15">3.3. loop 使用案例</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="331-loop-与-each-的区别"><h4 class="- topic/title title topictitle4" id="ariaid-title16">3.3.1. loop 与 each 的区别</h4><div class="- topic/body body"><p class="- topic/p p">高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">loop</code> 与 <code class="+ topic/ph pr-d/codeph ph codeph">each</code>相似，区别在于函数返回值的格式和类型。。</p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">each</code> 高阶函数根据每个子任务计算结果的数据类型和形式，决定返回值的数据形式：</p><ul class="- topic/ul ul"><li class="- topic/li li">若单个任务返回一个 scalar，则 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 返回一个 vector；</li><li class="- topic/li li">若单个任务返回 vector，那么 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 返回一个 matrix；</li><li class="- topic/li li">若单个任务返回字典，那么 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 返回一个 table。</li></ul><p class="- topic/p p">若所有子任务的数据类型和形式都相同，则返回 Vector 或 Matrix，否则返回 Tuple。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>m=1..12$4:3;
m;
each(add{1 2 3 4}, m);</code></pre><p class="- topic/p p">得到以下结果：</p><div class="table-container"><table class="- topic/table table" data-cols="3"><caption></caption><colgroup><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__1">col1</th><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__2">col2</th><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__3">col3</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__1">2</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__2">6</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__3">10</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__1">4</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__2">8</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__3">12</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__1">6</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__2">10</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__3">14</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__1">8</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__2">12</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__3">16</td></tr></tbody></table></div><p class="- topic/p p">而 <code class="+ topic/ph pr-d/codeph ph codeph">loop</code> 总是返回 Tuple。例如，使用 <code class="+ topic/ph pr-d/codeph ph codeph">loop</code> 计算每一列的最大值：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t = table(1 2 3 as id, 4 5 6 as value, `IBM`MSFT`GOOG as name);
t;
loop(max, t.values());</code></pre><p class="- topic/p p">得到以下结果：</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__16">offset</th><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__17">0</th><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__18">1</th><th class="- topic/entry entry colsep-0 rowsep-0" id="331-loop-与-each-的区别__entry__19">2</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__16">0</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__17">3</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__18">6</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="331-loop-与-each-的区别__entry__19">MSFT</td></tr></tbody></table></div></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title17" id="332-导入多个文件"><h4 class="- topic/title title topictitle4" id="ariaid-title17">3.3.2. 导入多个文件</h4><div class="- topic/body body"><p class="- topic/p p">假设在一个目录下，有多个结构相同的 csv 文件，需将其导入到同一个 DolphinDB 内存表中。可以调用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">loop</code> 来实现：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>loop(loadText, fileDir + "/" + files(fileDir).filename).unionAll(false)</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="34-movingrolling-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title18">3.4. moving/rolling 使用案例</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title19" id="341-moving-案例"><h4 class="- topic/title title topictitle4" id="ariaid-title19">3.4.1. moving 案例</h4><div class="- topic/body body"><p class="- topic/p p">以当前记录的 UpAvgPrice 和 DownAvgPrice 字段值确定一个区间，取 close 字段的前 20 个数计算其是否在区间 [DownAvgPrice, UpAvgPrice] 范围内，并统计范围内数据的百分比。</p><p class="- topic/p p">数据如下：</p><br/><img class="- topic/image image" src="images/functional_programming/moving1.png" alt="image"/><br/><p class="- topic/p p">以 trade_date 为 2019.06.17 的记录的 UpAvgPrice 和 DownAvgPrice 字段确定一个区间 [11.5886533, 12.8061868]，检查该记录的前 20 行 close 数据（即图中标 1 这列）是否在对应区间中，若其中有 75% 的数据落在区间内，则 signal（图中标 4）的值设为 true，否则为 false。</p><p class="- topic/p p">解决方案：</p><p class="- topic/p p">使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">moving</code>。下例编写自定义函数 rangeTest 对每个窗口的数据进行上述区间判断，返回 true 或 false。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg rangeTest(close, downlimit, uplimit){
  size = close.size() - 1
  return between(close.subarray(0:size), downlimit.last():uplimit.last()).sum() &gt;= size*0.75
}

update t set signal = moving(rangeTest, [close, downAvgPrice, upAvgPrice], 21)</code></pre><p class="- topic/p p">注：本例中，因为是计算前 20 行作为当期行的列数值，因而窗口需要包含前 20 条记录和本条记录，故窗口大小为 21 行。</p><p class="- topic/p p">注：上例调用 <code class="+ topic/ph pr-d/codeph ph codeph">between</code> 函数，来检查每个元素是否在 a 和 b 之间（边界包含在内）。</p><p class="- topic/p p">下例模拟行情数据，创建一个测试表 t：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t=table(rand("d"+string(1..n),n) as ts_code, nanotimestamp(2008.01.10+1..n) as trade_date, rand(n,n) as open, rand(n,n) as high, rand(n,n) as low, rand(n,n) as close, rand(n,n) as pre_close, rand(n,n) as change, rand(n,n) as pct_chg, rand(n,n) as vol, rand(n,n) as amount, rand(n,n) as downAvgPrice, rand(n,n) as upAvgPrice, rand(1 0,n) as singna)</code></pre><p class="- topic/p p">rolling 和 moving 类似，都将函数运算符应用到滑动窗口，进行窗口计算。两者也有细微区别： <code class="+ topic/ph pr-d/codeph ph codeph">rolling</code> 可以指定步长 step，moving 的步长为 1；且两者对空值的处理也不相同。详情可参考 <a class="- topic/xref xref" href="window_cal.html">rolling 的空值处理</a>。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title20" id="342-movingsum-和-msum-性能差距"><h4 class="- topic/title title topictitle4" id="ariaid-title20">3.4.2. moving(sum) 和 msum 性能差距</h4><div class="- topic/body body"><p class="- topic/p p">虽然 DolphinDB 提供了高阶函数 moving，但是如果所要进行的计算可以用 m 系列函数（例如<code class="+ topic/ph pr-d/codeph ph codeph">msum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mcount</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mavg</code>等）实现，请避免使用 moving 实现，这是因为 m 系列函数进行了优化，性能远超 moving。下面以 moving(sum) 和 msum 为例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>x=1..1000000
timer moving(sum, x, 10)
timer msum(x, 10)</code></pre><p class="- topic/p p">根据数据量的不同，msum 比 moving(sum) 计算耗时缩短 50 至 200 倍。</p><p class="- topic/p p">性能差距的主要原因如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">取数方式不同：msum 是一次性将数据读入内存，无需为每次计算任务单独分配内存；moving(sum) 每次计算都会生成一个子对象，每次计算都需要为子对象申请内存，计算完成后还需要进行内存回收。</li><li class="- topic/li li">msum 为增量计算，每次窗口计算都使用上一个窗口计算的结果。即直接加上当前窗口新合入的数据，并减去上一个窗口的第一条数据；而 moving(sum) 为全量计算，即每次计算都会累加窗口内的所有数据。</li></ul></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="35-eachpre-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title21">3.5. eachPre 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">创建一个表 t，包含 sym 和 BidPrice 两列：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t = table(take(`a`b`c`d`e ,100) as sym, rand(100.0,100) as bidPrice)</code></pre><p class="- topic/p p">需要进行如下计算：</p><ul class="- topic/ul ul"><li class="- topic/li li"><ol class="- topic/ol ol"><li class="- topic/li li">生成新的一列 ln 用于存储以下因子的计算结果：先计算当前的 bidPrice 值除以前 3 行 bidPrice 均值的结果（不包括当前行），然后取自然对数。</li></ol></li><li class="- topic/li li"><ol class="- topic/ol ol"><li class="- topic/li li">基于列 ln，生成新列 clean 用于存储以下因子的计算结果：计算 ln 的绝对值，若该值大于波动范围阈值 F，则取上一条记录的 ln 值，反之则认为当前报价正常，并保留当前的 ln 值。</li></ol></li></ul><p class="- topic/p p">根据 ln 列的因子计算规则，可以分析出该问题涉及到滑动窗口计算，窗口的大小为 3。参考 3.4.1 的 moving 案例，具体脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t2 = select *, log(bidPrice / prev(moving(avg, bidPrice,3))) as ln from t</code></pre><p class="- topic/p p">由于内置函数 <code class="+ topic/ph pr-d/codeph ph codeph">msum</code>,<code class="+ topic/ph pr-d/codeph ph codeph">mcount</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">mavg</code> 比 <code class="+ topic/ph pr-d/codeph ph codeph">moving</code> 高阶函数有更好的性能，可以将上述脚本改写如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>//method 1
t2 = select *, log(bidPrice / prev(mavg(bidPrice,3))) as ln from t

//method 2
t22 = select *, log(bidPrice / mavg(prev(bidPrice),3)) as ln from t</code></pre><p class="- topic/p p">此处调用 <code class="+ topic/ph pr-d/codeph ph codeph">prev</code> 函数获取前一行的数据。</p><p class="- topic/p p">“先计算均值再移动结果”和“先移动列再计算均值”效果等价的。唯一的区别是：表 t22 第三行会产生一个结果。</p><p class="- topic/p p">对于第二个数据处理要求，我们假设波动返回 F 为 0.02, 然后实现一个自定义函数 <code class="+ topic/ph pr-d/codeph ph codeph">cleanFun</code>来实现其取值逻辑，如下：:</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>F = 0.02
def cleanFun(F, x, y): iif(abs(x) &gt; F, y, x)</code></pre><p class="- topic/p p">这里的参数 x 表示当前值，y 表示前一个值。然后调用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">eachPre</code>来对相邻元素两两计算，该函数等价于实现：F(X[0], pre), F(X[1], X[0]), ..., F(X[n], X[n-1])。对应脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t2[`clean] = eachPre(cleanFun{F}, t2[`ln])</code></pre><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>F = 0.02
t = table(take(`a`b`c`d`e ,100) as sym, rand(100.0,100) as bidPrice)
t2 = select *, log(bidPrice / prev(mavg(bidPrice,3))) as ln from t
def cleanFun(F,x,y) : iif(abs(x) &gt; F, y,x)
t2[`clean] = eachPre(cleanFun{F}, t2[`ln])</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title22" id="36-byrow-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title22">3.6. byRow 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">计算矩阵每行最大值的下标。下例生成一个矩阵 m：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>a1=2 3 4
a2=1 2 3
a3=1 4 5
a4=5 3 2
m = matrix(a1,a2,a3,a4)</code></pre><p class="- topic/p p">一种思路是，对每行分别计算最大值的下标，可以直接调用 <code class="+ topic/ph pr-d/codeph ph codeph">imax</code> 函数实现。<code class="+ topic/ph pr-d/codeph ph codeph">imax</code> 在矩阵每列单独计算，返回一个向量。</p><p class="- topic/p p">为求每行的计算结果，可以先对矩阵进行转置操作，然后调用 <code class="+ topic/ph pr-d/codeph ph codeph">imax</code> 函数进行计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>imax(m.transpose())</code></pre><p class="- topic/p p">此外，DolphinDB 还提供了一个高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">byRow</code>，对矩阵的每一行应用指定函数进行计算。使用该函数可以避免转置操作。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>byRow(imax, m)</code></pre><p class="- topic/p p">以上操作亦可用行计算函数 <code class="+ topic/ph pr-d/codeph ph codeph">rowImax</code> 来实现：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>print rowImax(m)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title23" id="37-segmentby-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title23">3.7. segmentby 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">segmentby</code>。其语法如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>segmentby(func, funcArgs, segment)</code></pre><p class="- topic/p p">根据 segment 参数取值确定分组方案，连续的相同值分为一组，进行分组计算。返回的结果与 segment 参数的长度相同。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>x=1 2 3 0 3 2 1 4 5
y=1 1 1 -1 -1 -1 1 1 1
segmentby(cumsum,x,y);</code></pre><p class="- topic/p p">上例中，根据 y 确定了 3 个分组：1 1 1, -1 -1 -1 和 1 1 1，由此把 x 也分为 3 组：1 2 3, 0 3 2 和 1 4 5，并将 cumsum 函数应用到 x 的每个分组，计算每个分组的累计和。</p><p class="- topic/p p">DolphinDB 还提供了内置函数 <code class="+ topic/ph pr-d/codeph ph codeph">segment</code>用于在 SQL 语句中进行分组。与 segmentby 不同，它只返回分组信息，而不对分组进行计算。。</p><p class="- topic/p p">下例中，将表的某列数据按照给定阈值进行分组，连续小于或大于该阈值的数据被划分为一组。连续大于该阈值的分组将保留组内最大值对应的记录并输出（若有重复值则输出第一条）。</p><p class="- topic/p p">表内容如下图所示，当阈值为 0.3 时，希望结果保留箭头所指记录：</p><br/><img class="- topic/image image" src="images/functional_programming/segment-case1.png" alt="image"/><br/><p class="- topic/p p">表定义如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>dated = 2021.09.01..2021.09.12
v = 0 0 0.3 0.3 0 0.5 0.3 0.7 0 0 0.3 0
t = table(dated as date, v)</code></pre><p class="- topic/p p">将数据按照是否连续大于 minV 来分组时，可以使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">segment</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>segment(v&gt;= minV)</code></pre><p class="- topic/p p">在 SQL 中配合 <code class="+ topic/ph pr-d/codeph ph codeph">context by</code> 语句进行分组计算，通过 having 子句过滤分组的最大值。过滤结果可能存在多行，根据需求只保留第一行满足结果的数据，此时可以通过指定 limit 子句限定输出的记录数。</p><p class="- topic/p p">完整的 SQL 查询语句如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>select * from t context by segment(v&gt;= minV) having (v=max(v) and v&gt;=minV) limit 1</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="38-pivot-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title24">3.8. pivot 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">pivot</code> 可以在指定的二维维度上重组数据，结果为一个矩阵。</p><p class="- topic/p p">现有包含 4 列数据的表 t1:</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>syms=`600300`600400`600500$SYMBOL
sym=syms[0 0 0 0 0 0 0 1 1 1 1 1 1 1 2 2 2 2 2 2 2]
time=09:40:00+1 30 65 90 130 185 195 10 40 90 140 160 190 200 5 45 80 140 170 190 210
price=172.12 170.32 172.25 172.55 175.1 174.85 174.5 36.45 36.15 36.3 35.9 36.5 37.15 36.9 40.1 40.2 40.25 40.15 40.1 40.05 39.95
volume=100 * 10 3 7 8 25 6 10 4 5 1 2 8 6 10 2 2 5 5 4 4 3
t1=table(sym, time, price, volume);
t1;</code></pre><p class="- topic/p p">将 t1 的数据依据 time 和 sym 维度进行数据重组，并且计算每分钟股价的加权平均值，以交易量为权重。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>stockprice=pivot(wavg, [t1.price, t1.volume], minute(t1.time), t1.sym)
stockprice.round(2)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title25" id="39-contextby-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title25">3.9. contextby 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">contextby</code> 可以将数据根据列字段分组，并在组内调用指定函数进行计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>sym=`IBM`IBM`IBM`MS`MS`MS
price=172.12 170.32 175.25 26.46 31.45 29.43
qty=5800 700 9000 6300 2100 5300
trade_date=2013.05.08 2013.05.06 2013.05.07 2013.05.08 2013.05.06 2013.05.07;
contextby(avg, price, sym);</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">contextby</code> 亦可搭配 SQL 语句使用。下例调用 contextby 筛选出价格高于组内平均价的交易记录：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t1=table(trade_date,sym,qty,price);
select trade_date, sym, qty, price from t1 where price &gt; contextby(avg, price,sym);</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title26" id="310-callunifiedcall-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title26">3.10. call/unifiedCall 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">对需要批量调用不同函数进行计算的场景，可以通过高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">call</code> 或者 <code class="+ topic/ph pr-d/codeph ph codeph">unifiedCall</code> 配合高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code>/<code class="+ topic/ph pr-d/codeph ph codeph">loop</code> 实现。</p><p class="- topic/p p">注：<code class="+ topic/ph pr-d/codeph ph codeph">call</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">unifiedCall</code> 功能相同，但参数形式不同，详情可参考用户手册。</p><p class="- topic/p p">下例中在部分应用中调用了函数 <code class="+ topic/ph pr-d/codeph ph codeph">call</code> 函数，该部分应用将向量 [1, 2, 3] 作为固定参数，在高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 中调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">sin</code> 与 <code class="+ topic/ph pr-d/codeph ph codeph">log</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>each(call{, 1..3},(sin,log));</code></pre><p class="- topic/p p">此外，还可通过元编程方式调用函数。这里会用到<code class="+ topic/ph pr-d/codeph ph codeph">funcByName</code>。上述例子可改写为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>each(call{, 1..3},(funcByName('sin'),funcByName('log')));</code></pre><p class="- topic/p p">或者，使用 <code class="+ topic/ph pr-d/codeph ph codeph">makeCall</code>/<code class="+ topic/ph pr-d/codeph ph codeph">makeUnifiedCall</code> 生成元代码，后续通过 <code class="+ topic/ph pr-d/codeph ph codeph">eval</code> 来执行：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>each(eval, each(makeCall{,1..3},(sin,log)))</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title27" id="311-accumulate-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title27">3.11. accumulate 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">已知分钟线数据如下，将某只股票每成交约 150 万股进行一次时间切分，最后得到时间窗口长度不等的若干条数据。具体的切分规则为：若某点的数据合入分组，可以缩小数据量和阈值（150 万）间的差值，则加入该点，否则当前分组不合入该点的数据。示意图如下：</p><br/><img class="- topic/image image" src="images/functional_programming/accumulcate.jpeg" alt="image"/><br/><p class="- topic/p p">构造测试数据如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>timex = 13:03:00+(0..27)*60
volume = 288658 234804 182714 371986 265882 174778 153657 201388 175937 138388 169086 203013 261230 398871 692212 494300 581400 348160 250354 220064 218116 458865 673619 477386 454563 622870 458177 880992
t = table(timex as time, volume)</code></pre><p class="- topic/p p">这里自定义一个分组计算函数，将 volume 的累加，按上述切分规则，以 150 万为阈值进行分组。</p><p class="- topic/p p">先定义一个分组函数，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def caclCumVol(target, preResult, x){
 result = preResult + x
 if(result - target&gt; target - preResult) return x
 else return result
}
accumulate(caclCumVol{1500000}, volume)</code></pre><p class="- topic/p p">上述脚本通过自定义函数 caclCumVol 计算 volume 的累加值，结果最接近 150 万时划分分组。新的分组将从下一个 volume 值开始重新累加。对应脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>iif(accumulate(caclCumVol{1500000}, volume) ==volume, timex, NULL).ffill()</code></pre><p class="- topic/p p">通过和 volume 比较，筛选出了每组的起始记录。若中间结果存在空值，则调用 ffill 函数进行前值填充。将获得的结果配合 group by 语句进行分组计算，查询时，注意替换以上脚本的 timex 为表的 time 字段。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>output = select sum(volume) as sum_volume, last(time) as endTime from t group by iif(accumulate(caclCumVol{1500000}, volume) ==volume, time, NULL).ffill() as startTime</code></pre><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>timex = 13:03:00+(0..27)*60
volume = 288658 234804 182714 371986 265882 174778 153657 201388 175937 138388 169086 203013 261230 398871 692212 494300 581400 348160 250354 220064 218116 458865 673619 477386 454563 622870 458177 880992
t = table(timex as time, volume)

def caclCumVol(target, preResult, x){
 result = preResult + x
 if(result - target&gt; target - preResult) return x
 else return result
}
output = select sum(volume) as sum_volume, last(time) as endTime from t group by iif(accumulate(caclCumVol{1500000}, volume)==volume, time, NULL).ffill() as startTime</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title28" id="312-window-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title28">3.12. window 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">对表中的某列数据进行以下计算，如果当前数值是前 5 个数据的最低值 (包括当前值)，也是后 5 个最低值 (包括当前值)，那么标记是 1，否则是 0。</p><p class="- topic/p p">创建测试表 t：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t = table(rand(1..100,20) as id)</code></pre><p class="- topic/p p">可以通过应用窗口函数 <code class="+ topic/ph pr-d/codeph ph codeph">window</code>，指定一个前后都为 5 的数据窗口，在该窗口内通过调用 min 函数计算最小值。注意：函数 window 的窗口边界包含在窗口中。</p><p class="- topic/p p">实现脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>select *, iif(id==window(min, id, -4:4), 1, 0) as mid from t</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="313-reduce-使用案例"><h3 class="- topic/title title topictitle3" id="ariaid-title29">3.13. reduce 使用案例</h3><div class="- topic/body body"><p class="- topic/p p">上面的一些案例中，也有用到高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">reduce</code>。伪代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>result=&lt;function&gt;(init,X[0]);
for(i:1~size(X)){
  result=&lt;function&gt;(result, X[i]);
}
return result;</code></pre><p class="- topic/p p">与 <code class="+ topic/ph pr-d/codeph ph codeph">accumulate</code> 返回中间结果不同，<code class="+ topic/ph pr-d/codeph ph codeph">reduce</code> 只返回最后一个结果。</p><p class="- topic/p p">例如下面的计算阶乘的例子：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>r1 = reduce(mul, 1..10);
r2 = accumulate(mul, 1..10)[9];</code></pre><p class="- topic/p p">最终 r1 和 r2 的结果是一样的。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title30" id="4-部分应用案例"><h2 class="- topic/title title topictitle2" id="ariaid-title30">4. 部分应用案例</h2><div class="- topic/body body"><p class="- topic/p p">部分应用是指固定一个函数的部分参数，产生一个参数较少的函数。部分应用通常应用在对参数个数有特定要求的高阶函数中。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title31" id="41-提交带有参数的作业"><h3 class="- topic/title title topictitle3" id="ariaid-title31">4.1. 提交带有参数的作业</h3><div class="- topic/body body"><p class="- topic/p p">假设需要一个 <a class="- topic/xref xref" href="scheduledJob.html">定时任务</a>，每日 0 点执行，用于计算某设备前一日温度指标的最大值。</p><p class="- topic/p p">假设设备的温度信息存储在分布式库 <code class="+ topic/ph pr-d/codeph ph codeph">dfs://dolphindb</code> 下的表 <code class="+ topic/ph pr-d/codeph ph codeph">sensor</code> 中，其时间字段为 <code class="+ topic/ph pr-d/codeph ph codeph">ts</code>，类型为 DATETIME。下例定义一个 <code class="+ topic/ph pr-d/codeph ph codeph">getMaxTemperature</code> 函数来实现计算过程，脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def getMaxTemperature(deviceID){
    maxTemp=exec max(temperature) from loadTable("dfs://dolphindb","sensor")
            where ID=deviceID ,date(ts) = today()-1
    return  maxTemp
}</code></pre><p class="- topic/p p">定义计算函数后，可通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">scheduleJob</code> 提交定时任务。由于函数 <code class="+ topic/ph pr-d/codeph ph codeph">scheduleJob</code> 不提供接口供任务函数进行传参，而自定义函数 <code class="+ topic/ph pr-d/codeph ph codeph">getMaxTemperature</code> 以设备 <code class="+ topic/ph pr-d/codeph ph codeph">deviceID</code> 作为参数，这里可以通过部分应用来固定参数，从而产生一个没有参数的函数。脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>scheduleJob(`testJob, "getMaxTemperature", getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');</code></pre><p class="- topic/p p">上例只查询了设备号为 1 的设备。</p><p class="- topic/p p">最终，完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def getMaxTemperature(deviceID){
    maxTemp=exec max(temperature) from loadTable("dfs://dolphindb","sensor")
            where ID=deviceID ,date(ts) = today()-1
    return  maxTemp
}

scheduleJob(`testJob, "getMaxTemperature", getMaxTemperature{1}, 00:00m, today(), today()+30, 'D');</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title32" id="42-获取集群其它节点作业信息"><h3 class="- topic/title title topictitle3" id="ariaid-title32">4.2. 获取集群其它节点作业信息</h3><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中提交定时作业后，可通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs</code> 来取得本地节点上最近几个批处理作业的状态。如查看本地节点最近 3 个批处理作业状态，可以用如下所示脚本实现：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>getRecentJobs(3);</code></pre><p class="- topic/p p">若想获取集群上其它节点的作业信息，需通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">rpc</code> 来在指定的远程节点上调用内置函数 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs</code>。如获取节点别名为 P1-node1 的作业信息，可以如下实现：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>rpc("P1-node1",getRecentJobs)</code></pre><p class="- topic/p p">如需获取节点 P1-node1 上最近 3 个作业的信息，通过如下脚本实现会报错：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>rpc("P1-node1",getRecentJobs(3))</code></pre><p class="- topic/p p">因为 <code class="+ topic/ph pr-d/codeph ph codeph">rpc</code> 函数第二个参数需要为函数（内置函数或用户自定义函数）。这里可以通过 DolphinDB 的部分应用，固定函数参数，来生成一个新的函数给 <code class="+ topic/ph pr-d/codeph ph codeph">rpc</code> 使用，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>rpc("P1-node1",getRecentJobs{3})</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title33" id="43-带状态的流计算消息处理函数"><h3 class="- topic/title title topictitle3" id="ariaid-title33">4.3. 带“状态”的流计算消息处理函数</h3><div class="- topic/body body"><p class="- topic/p p">在流计算中，用户通常需要给定一个消息处理函数，接受到消息后进行处理。这个处理函数是一元函数或数据表。若为函数，用于处理订阅数据，其唯一的参数是订阅的数据，即不能包含状态信息。</p><p class="- topic/p p">下例通过部分应用定义消息处理函数 <code class="+ topic/ph pr-d/codeph ph codeph">cumulativeAverage</code>，用于计算数据的累计均值。</p><p class="- topic/p p">定义流数据表 trades，对于其 <code class="+ topic/ph pr-d/codeph ph codeph">price</code> 字段，每接受一条消息，计算一次 <code class="+ topic/ph pr-d/codeph ph codeph">price</code> 的均值，并输出到结果表 avgTable 中。脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>share streamTable(10000:0,`time`symbol`price, [TIMESTAMP,SYMBOL,DOUBLE]) as trades
avgT=table(10000:0,[`avg_price],[DOUBLE])

def cumulativeAverage(mutable avgTable, mutable stat, trade){
   newVals = exec price from trade;

   for(val in newVals) {
      stat[0] = (stat[0] * stat[1] + val )/(stat[1] + 1)
      stat[1] += 1
      insert into avgTable values(stat[0])
   }
}

subscribeTable(tableName="trades", actionName="action30", handler=cumulativeAverage{avgT,0.0 0.0}, msgAsTable=true)</code></pre><p class="- topic/p p">自定义函数 <code class="+ topic/ph pr-d/codeph ph codeph">cumulativeAverage</code> 的参数 avgTable 为计算结果的存储表。stat 是一个向量，包含了两个值：其中，stat[0] 用来表示当前的所有数据的平均值，stat[1] 表示数据个数。函数体的计算实现为：遍历数据更新 stat 的值，并将新的计算结果插入表。</p><p class="- topic/p p">订阅流数据表时，通过在 handler 中固定前两个参数，实现带“状态”的消息处理函数。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title34" id="5-金融场景相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title34">5. 金融场景相关案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title35" id="51-使用-map-reduce对-tick-数据降精度"><h3 class="- topic/title title topictitle3" id="ariaid-title35">5.1. 使用 map reduce，对 tick 数据降精度</h3><div class="- topic/body body"><p class="- topic/p p">下例中，使用 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 函数（map reduce）将 tick 数据转化为分钟级数据。</p><p class="- topic/p p">在 DolphinDB 中，可以使用 SQL 语句基于 tick 数据计算分钟级数据：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>minuteQuotes=select avg(bid) as bid, avg(ofr) as ofr from t group by symbol,date,minute(time) as minute</code></pre><p class="- topic/p p">但在数据量较大时，该实现效率低，耗时长。为提升性能，可以使用 DolphinDB 的分布式计算。</p><p class="- topic/p p">Map-Reduce 函数 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 是 DolphinDB 通用分布式计算框架的核心功能。</p><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>login(`admin, `123456)
db = database("dfs://TAQ")
quotes = db.loadTable("quotes")

//create a new table quotes_minute
model=select  top 1 symbol,date, minute(time) as minute,bid,ofr from quotes where date=2007.08.01,symbol=`EBAY
if(existsTable("dfs://TAQ", "quotes_minute"))
db.dropTable("quotes_minute")
db.createPartitionedTable(model, "quotes_minute", `date`symbol)

//populate data for table quotes_minute
def saveMinuteQuote(t){
minuteQuotes=select avg(bid) as bid, avg(ofr) as ofr from t group by symbol,date,minute(time) as minute
loadTable("dfs://TAQ", "quotes_minute").append!(minuteQuotes)
return minuteQuotes.size()
}

ds = sqlDS(&lt;select symbol,date,time,bid,ofr from quotes where date between 2007.08.01 : 2007.08.31&gt;)
timer mr(ds, saveMinuteQuote, +)
</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title36" id="52-数据回放和高频因子计算"><h3 class="- topic/title title topictitle3" id="ariaid-title36">5.2. 数据回放和高频因子计算</h3><div class="- topic/body body"><p class="- topic/p p">有状态的因子，即因子的计算不仅用到当前数据，还会用到历史数据。实现状态因子的计算，一般包括这几个步骤：</p><ul class="- topic/ul ul"><li class="- topic/li li"><ol class="- topic/ol ol"><li class="- topic/li li">保存本批次的消息数据到历史记录；</li></ol></li><li class="- topic/li li"><ol class="- topic/ol ol"><li class="- topic/li li">根据更新后的历史记录，计算因子</li></ol></li><li class="- topic/li li"><ol class="- topic/ol ol"><li class="- topic/li li">将因子计算结果写入输出表中。如有必要，删除未来不再需要的的历史记录。</li></ol></li></ul><p class="- topic/p p">DolphinDB 的消息处理函数必须是单目函数，其唯一的参数就是当前的消息。要保存历史状态并在消息处理函数中计算历史数据，可以通过部分应用实现：对于多参数的消息处理函数，保留一个参数用于接收消息，固化其它所有的参数，用于保存历史状态。这些固化参数只对消息处理函数可见，不受其他应用的影响。</p><p class="- topic/p p">历史状态可保存在内存表，字典或分区内存表中。本例将使用 DolphinDB<a class="- topic/xref xref" href="streaming_tutorial.html">流计算引擎</a> 来处理 <a class="- topic/xref xref" href="https://www.dolphindb.cn/downloads/tutorial/hfFactorsSampleData.zip" target="_blank" rel="external noopener">报价数据</a> 通过字典保存历史状态并计算因子。如需通过内存表或分布式内存表保存历史状态，可以参考 <a class="- topic/xref xref" href="hf_factor_streaming.html">实时计算高频因子</a>。</p><p class="- topic/p p">定义状态因子：计算当前第一档卖价 (askPrice1) 与 30 个报价前的第一档卖价的比值。</p><p class="- topic/p p">对应的因子计算函数 <code class="+ topic/ph pr-d/codeph ph codeph">factorAskPriceRatio</code>实现如下：:</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>defg factorAskPriceRatio(x){
 cnt = x.size()
 if(cnt &lt; 31) return double()
 else return x[cnt - 1]/x[cnt - 31]
}</code></pre><p class="- topic/p p">导入数据创建对应的流数据表后，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">replay</code> 函数回放数据，模拟实时流计算的场景。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>quotesData = loadText("/data/ddb/data/sampleQuotes.csv")

x=quotesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as quotes1</code></pre><p class="- topic/p p">由于这里使用字典保存历史状态，可以定义如下字典：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>history = dict(STRING, ANY)</code></pre><p class="- topic/p p">该字典的键值为 STRING 类型，存储股票字段，值为元组（tuple）类型，存储卖价的历史数据。</p><p class="- topic/p p">下例调用 <code class="+ topic/ph pr-d/codeph ph codeph">dictUpdate!</code> 函数更新字典，然后循环计算每只股票的因子，并通过表存储因子的计算结果。然后订阅流表，通过数据回放向流表注入数据，每到来一条新数据都将触发因子的计算。</p><p class="- topic/p p">消息处理函数定义如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def factorHandler(mutable historyDict, mutable factors, msg){
 historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&gt;array(x.type(), 0, 512).append!(x))
 syms = msg.symbol.distinct()
 cnt = syms.size()
 v = array(DOUBLE, cnt)
 for(i in 0:cnt){
     v[i] = factorAskPriceRatio(historyDict[syms[i]])
 }
 factors.tableInsert([take(now(), cnt), syms, v])
}</code></pre><p class="- topic/p p">参数 historyDict 为保存历史状态的字典，factors 是存储计算结果的表。</p><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>quotesData = loadText("/data/ddb/data/sampleQuotes.csv")

defg factorAskPriceRatio(x){
 cnt = x.size()
 if(cnt &lt; 31) return double()
 else return x[cnt - 1]/x[cnt - 31]
}
def factorHandler(mutable historyDict, mutable factors, msg){
 historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&gt;array(x.type(), 0, 512).append!(x))
 syms = msg.symbol.distinct()
 cnt = syms.size()
 v = array(DOUBLE, cnt)
 for(i in 0:cnt){
     v[i] = factorAskPriceRatio(historyDict[syms[i]])
 }
 factors.tableInsert([take(now(), cnt), syms, v])
}

x=quotesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as quotes1
history = dict(STRING, ANY)
share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors
subscribeTable(tableName = "quotes1", offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize=3000, throttle=0.005)

replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)</code></pre><p class="- topic/p p">查看结果</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>select top 10 * from factors where isValid(factor)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title37" id="53-基于字典的计算"><h3 class="- topic/title title topictitle3" id="ariaid-title37">5.3. 基于字典的计算</h3><div class="- topic/body body"><p class="- topic/p p">下例创建表 orders，该表包含了一些简单的股票信息：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>orders = table(`IBM`IBM`IBM`GOOG as SecID, 1 2 3 4 as Value, 4 5 6 7 as Vol)</code></pre><p class="- topic/p p">创建一个字典。键为股票代码，值为从 orders 表中筛选出来的只包含该股票信息的子表。</p><p class="- topic/p p">字典定义如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>historyDict = dict(STRING, ANY)</code></pre><p class="- topic/p p">然后通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">dictUpdate!</code>，来更新每个键的值，实现如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>historyDict.dictUpdate!(function=def(x,y){tableInsert(x,y);return x}, keys=orders.SecID, parameters=orders, initFunc=def(x){t = table(100:0, x.keys(), each(type, x.values())); tableInsert(t, x); return t})</code></pre><p class="- topic/p p">可以把 <code class="+ topic/ph pr-d/codeph ph codeph">dictUpdate!</code> 的执行过程理解成，针对参数 parameters 遍历，每个 parameters 作为参数，通过 function 去更新字典 (字典的 key 由 keys 指定的)。当字典中不存在对应的 key 时，会调用 initFunc 去初始化 key 对应的值。</p><p class="- topic/p p">这个例子中，字典的 key 是股票代码，value 是 orders 的子表。</p><p class="- topic/p p">这里，我们使用 orders.SecID 作为 keys，在更新的函数参数中，我们定义了一个 lamda 函数将当前记录插入到表中，如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def(x,y){tableInsert(x,y);return x}</code></pre><p class="- topic/p p">注意此处使用 lamda 函数封装了 <code class="+ topic/ph pr-d/codeph ph codeph">tableInsert</code>，而非指定 function=tableInsert。这是因为 <code class="+ topic/ph pr-d/codeph ph codeph">tableInsert</code> 的返回值不是一个 table，而是插入的条数，如果直接调用 <code class="+ topic/ph pr-d/codeph ph codeph">tableInsert</code>，在写入第二条 IBM 对应的记录时，会将字典中的值更新成插入的条数；写入第三条 IBM 对应的记录时，系统会抛出异常。</p><p class="- topic/p p">初始条件下，historyDict 未赋值，可以通过指定 initFunc 参数对字典进行初始化赋值：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>def(x){
  t = table(100:0, x.keys(), each(type, x.values()));
  tableInsert(t, x);
  return t
}</code></pre><p class="- topic/p p">最终，完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>orders = table(`IBM`IBM`IBM`GOOG as SecID, 1 2 3 4 as Value, 4 5 6 7 as Vol)
historyDict = dict(STRING, ANY)
historyDict.dictUpdate!(function=def(x,y){tableInsert(x,y);return x}, keys=orders.SecID, parameters=orders,
            initFunc=def(x){t = table(100:0, x.keys(), each(type, x.values())); tableInsert(t, x); return t})</code></pre><p class="- topic/p p">执行后 historyDict 结果如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>GOOG-&gt;
Vol Value SecID
--- ----- -----
7   4     GOOG

IBM-&gt;
Vol Value SecID
--- ----- -----
4   1     IBM
5   2     IBM
6   3     IBM</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title38" id="6-机器学习相关案例"><h2 class="- topic/title title topictitle2" id="ariaid-title38">6. 机器学习相关案例</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title39" id="61-ols-残差"><h3 class="- topic/title title topictitle3" id="ariaid-title39">6.1. ols 残差</h3><div class="- topic/body body"><p class="- topic/p p">创建样本表 t 如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t=table(2020.11.01 2020.11.02 as date, `IBM`MSFT as ticker, 1.0 2 as past1, 2.0 2.5 as past3, 3.5 7 as past5, 4.2 2.4 as past10, 5.0 3.7 as past20, 5.5 6.2 as past30, 7.0 8.0 as past60)</code></pre><p class="- topic/p p">计算每行数据和一个向量 benchX 的回归残差，并将结果保存到新列中。</p><p class="- topic/p p">向量 benchX 如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>benchX = 10 15 7 8 9 1 2.0</code></pre><p class="- topic/p p">DolphinDB 提供了最小二乘回归函数 <code class="+ topic/ph pr-d/codeph ph codeph">ols</code>。</p><p class="- topic/p p">先将表中参与计算的以下列转化成矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>mt = matrix(t[`past1`past3`past5`past10`past20`past30`past60]).transpose()</code></pre><p class="- topic/p p">然后定义残差计算函数如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def(y, x) {
    return ols(y, x, true, 2).ANOVA.SS[1]
}</code></pre><p class="- topic/p p">最后使用高阶函数 <code class="+ topic/ph pr-d/codeph ph codeph">each</code> 与部分应用，对每行数据应用残差计算函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t[`residual] = each(def(y, x){ return ols(y, x, true, 2).ANOVA.SS[1]}{,benchX}, mt)</code></pre><p class="- topic/p p">完整代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock shell"><code>t=table(2020.11.01 2020.11.02 as date, `IBM`MSFT as ticker, 1.0 2 as past1, 2.0 2.5 as past3, 3.5 7 as past5, 4.2 2.4 as past10, 5.0 3.7 as past20, 5.5 6.2 as past30, 7.0 8.0 as past60)

mt = matrix(t[`past1`past3`past5`past10`past20`past30`past60]).transpose()
t[`residual] = each(def(y, x){ return ols(y, x, true, 2).ANOVA.SS[1]}{,benchX}, mt)</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title40" id="7-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title40">7. 总结</h2><div class="- topic/body body"><p class="- topic/p p">除了上面提到的一些函数与高阶函数。DolphinDB 还提供了丰富的函数库，包括数学函数、统计函数、分布相关函数、假设检验函数、机器学习函数、逻辑函数、字符串函数、时间函数、数据操作函数、窗口函数、高阶函数、元编程、分布式计算函数、流计算函数、定时任务函数、性能监控函数、用户权限管理函数等。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5" data-tocid="1-数据导入">1. 数据导入</a><ul><li class="topic-item"><a href="#11-%E6%95%B4%E5%9E%8B%E6%97%B6%E9%97%B4%E8%BD%AC%E5%8C%96%E4%B8%BA-time-%E6%A0%BC%E5%BC%8F%E5%B9%B6%E5%AF%BC%E5%85%A5" data-tocid="11-整型时间转化为-time-格式并导入">1.1. 整型时间转化为 TIME 格式并导入</a></li><li class="topic-item"><a href="#12-%E6%9C%89%E7%BA%B3%E7%A7%92%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%96%87%E6%9C%AC%E5%AF%BC%E5%85%A5" data-tocid="12-有纳秒时间戳的文本导入">1.2. 有纳秒时间戳的文本导入</a></li></ul></li><li class="topic-item"><a href="#2-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F" data-tocid="2-lambda-表达式">2. Lambda 表达式</a></li><li class="topic-item"><a href="#3-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="3-高阶函数使用案例">3. 高阶函数使用案例</a><ul><li class="topic-item"><a href="#31-cross-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="31-cross-使用案例">3.1. cross 使用案例</a><ul><li class="topic-item"><a href="#311-%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%90%91%E9%87%8F%E6%88%96%E7%9F%A9%E9%98%B5%E4%B8%A4%E4%B8%A4%E7%BB%84%E5%90%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%9D%A5%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0" data-tocid="311-将两个向量或矩阵两两组合作为参数来调用函数">3.1.1. 将两个向量或矩阵，两两组合作为参数来调用函数</a></li><li class="topic-item"><a href="#312-%E8%AE%A1%E7%AE%97%E8%82%A1%E7%A5%A8%E4%B8%A4%E4%B8%A4%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7" data-tocid="312-计算股票两两之间的相关性">3.1.2. 计算股票两两之间的相关性</a></li></ul></li><li class="topic-item"><a href="#32-each-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="32-each-使用案例">3.2. each 使用案例</a><ul><li class="topic-item"><a href="#321-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E8%A1%A8%E5%90%84%E4%B8%AA%E5%88%97%E7%9A%84-null-%E5%80%BC%E4%B8%AA%E6%95%B0" data-tocid="321-获取数据表各个列的-null-值个数">3.2.1. 获取数据表各个列的 NULL 值个数</a></li><li class="topic-item"><a href="#322-%E5%8E%BB%E9%99%A4%E8%A1%A8%E4%B8%AD%E5%AD%98%E5%9C%A8-null-%E5%80%BC%E7%9A%84%E8%A1%8C" data-tocid="322-去除表中存在-null-值的行">3.2.2. 去除表中存在 NULL 值的行</a></li><li class="topic-item"><a href="#323-%E6%8C%89%E8%A1%8C%E5%A4%84%E7%90%86%E4%B8%8E%E6%8C%89%E5%88%97%E5%A4%84%E7%90%86%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E6%A1%88%E4%BE%8B" data-tocid="323-按行处理与按列处理性能比较案例">3.2.3. 按行处理与按列处理性能比较案例</a></li><li class="topic-item"><a href="#324-%E5%88%A4%E6%96%AD%E4%B8%A4%E5%BC%A0%E8%A1%A8%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C" data-tocid="324-判断两张表内容是否相同">3.2.4. 判断两张表内容是否相同</a></li></ul></li><li class="topic-item"><a href="#33-loop-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="33-loop-使用案例">3.3. loop 使用案例</a><ul><li class="topic-item"><a href="#331-loop-%E4%B8%8E-each-%E7%9A%84%E5%8C%BA%E5%88%AB" data-tocid="331-loop-与-each-的区别">3.3.1. loop 与 each 的区别</a></li><li class="topic-item"><a href="#332-%E5%AF%BC%E5%85%A5%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6" data-tocid="332-导入多个文件">3.3.2. 导入多个文件</a></li></ul></li><li class="topic-item"><a href="#34-movingrolling-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="34-movingrolling-使用案例">3.4. moving/rolling 使用案例</a><ul><li class="topic-item"><a href="#341-moving-%E6%A1%88%E4%BE%8B" data-tocid="341-moving-案例">3.4.1. moving 案例</a></li><li class="topic-item"><a href="#342-movingsum-%E5%92%8C-msum-%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D" data-tocid="342-movingsum-和-msum-性能差距">3.4.2. moving(sum) 和 msum 性能差距</a></li></ul></li><li class="topic-item"><a href="#35-eachpre-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="35-eachpre-使用案例">3.5. eachPre 使用案例</a></li><li class="topic-item"><a href="#36-byrow-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="36-byrow-使用案例">3.6. byRow 使用案例</a></li><li class="topic-item"><a href="#37-segmentby-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="37-segmentby-使用案例">3.7. segmentby 使用案例</a></li><li class="topic-item"><a href="#38-pivot-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="38-pivot-使用案例">3.8. pivot 使用案例</a></li><li class="topic-item"><a href="#39-contextby-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="39-contextby-使用案例">3.9. contextby 使用案例</a></li><li class="topic-item"><a href="#310-callunifiedcall-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="310-callunifiedcall-使用案例">3.10. call/unifiedCall 使用案例</a></li><li class="topic-item"><a href="#311-accumulate-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="311-accumulate-使用案例">3.11. accumulate 使用案例</a></li><li class="topic-item"><a href="#312-window-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="312-window-使用案例">3.12. window 使用案例</a></li><li class="topic-item"><a href="#313-reduce-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="313-reduce-使用案例">3.13. reduce 使用案例</a></li></ul></li><li class="topic-item"><a href="#4-%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="4-部分应用案例">4. 部分应用案例</a><ul><li class="topic-item"><a href="#41-%E6%8F%90%E4%BA%A4%E5%B8%A6%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E4%B8%9A" data-tocid="41-提交带有参数的作业">4.1. 提交带有参数的作业</a></li><li class="topic-item"><a href="#42-%E8%8E%B7%E5%8F%96%E9%9B%86%E7%BE%A4%E5%85%B6%E5%AE%83%E8%8A%82%E7%82%B9%E4%BD%9C%E4%B8%9A%E4%BF%A1%E6%81%AF" data-tocid="42-获取集群其它节点作业信息">4.2. 获取集群其它节点作业信息</a></li><li class="topic-item"><a href="#43-%E5%B8%A6%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%81%E8%AE%A1%E7%AE%97%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" data-tocid="43-带状态的流计算消息处理函数">4.3. 带“状态”的流计算消息处理函数</a></li></ul></li><li class="topic-item"><a href="#5-%E9%87%91%E8%9E%8D%E5%9C%BA%E6%99%AF%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="5-金融场景相关案例">5. 金融场景相关案例</a><ul><li class="topic-item"><a href="#51-%E4%BD%BF%E7%94%A8-map-reduce%E5%AF%B9-tick-%E6%95%B0%E6%8D%AE%E9%99%8D%E7%B2%BE%E5%BA%A6" data-tocid="51-使用-map-reduce对-tick-数据降精度">5.1. 使用 map reduce，对 tick 数据降精度</a></li><li class="topic-item"><a href="#52-%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%BE%E5%92%8C%E9%AB%98%E9%A2%91%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="52-数据回放和高频因子计算">5.2. 数据回放和高频因子计算</a></li><li class="topic-item"><a href="#53-%E5%9F%BA%E4%BA%8E%E5%AD%97%E5%85%B8%E7%9A%84%E8%AE%A1%E7%AE%97" data-tocid="53-基于字典的计算">5.3. 基于字典的计算</a></li></ul></li><li class="topic-item"><a href="#6-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E6%A1%88%E4%BE%8B" data-tocid="6-机器学习相关案例">6. 机器学习相关案例</a><ul><li class="topic-item"><a href="#61-ols-%E6%AE%8B%E5%B7%AE" data-tocid="61-ols-残差">6.1. ols 残差</a></li></ul></li><li class="topic-item"><a href="#7-%E6%80%BB%E7%BB%93" data-tocid="7-总结">7. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>