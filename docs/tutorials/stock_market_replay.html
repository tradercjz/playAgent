<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="一个量化策略在生产（交易）环境中运行时，实时数据的处理通常是由事件驱动的。为确保研发和生产使用同一套代码，通常在研发阶段需将历史数据，严格按照事件发生的时间顺序进行回放，以此模拟交易环境。一个交易所的行情数据通常包括逐笔委托、逐笔成交、快照等多种类型的数据。DolphinDB 提供了严格按照时间顺序将多个不同数据源同时进行回放的功能。 首先简要介绍 DolphinDB ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../stream/str_intro.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="股票行情回放"/><title>股票行情回放</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;股票行情回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;股票行情回放&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;一个量化策略在生产（交易）环境中运行时，实时数据的处理通常是由事件驱动的。为确保研发和生产使用同一套代码，通常在研发阶段需将历史数据，严格按照事件发生的时间顺序进行回放，以此模拟交易环境。一个交易所的行情数据通常包括逐笔委托、逐笔成交、快照等多种类型的数据。DolphinDB 提供了严格按照时间顺序将多个不同数据源同时进行回放的功能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;首先简要介绍 DolphinDB 数据回放功能和原理，之后介绍股票行情回放的应用方案和代码实现。关于如何基于 DolphinDB 搭建行情数据回放服务，请参阅：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;appendices_market_replay_bp.md&#34; xtrc=&#34;xref:1;5:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;搭建行情回放服务的最佳实践&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:63;101:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../stream/str_intro.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;流数据&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 流数据引擎及流数据计算的基本概念&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-单表回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;1. 单表回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB 历史数据回放功能通过 replay 函数实现。replay 函数的作用是将内存表或数据库表中的记录以一定的速率写入到目标表中，以模拟实时注入的数据流。根据输入表的数量，回放分为单表回放和多表回放，其中单表回放是最基础的回放模式，即将一个输入表回放至一个相同表结构的目标表中，以下是不包括建表语句的单表回放示例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;tradeDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://trade&#34;, &#34;trade&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) replay(inputTables=tradeDS, outputTables=tradeStream, dateColumn=`Date, timeColumn=`Time, replayRate=10000, absoluteRate=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;以上脚本将数据库 &#34;dfs://trade&#34; 中的 &#34;trade&#34; 表中 2020 年 12 月 31 日的数据以每秒 1 万条的速度注入目标表 tradeStream 中。更多关于 replay、replayDS 函数的介绍可以参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;data_replay.md&#34; xtrc=&#34;xref:2;16:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 历史数据回放教程&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;但是，单表回放并不能满足所有的回放要求。因为在实践中，一个领域问题往往需要多个不同类型的消息协作，例如金融领域的行情数据包括逐笔委托、逐笔成交、快照等，为了更好地模拟实际交易中的实时数据流，通常需要将以上三类数据同时进行回放，这时便提出了多表回放的需求。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-多表回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;2. 多表回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB不断优化拓展多表回放的功能，既支持N个输入表一对一回放至N个输出表的N对N回放，又在1.30.17/2.00.5及之后的版本中支持了N个不同结构的输入表同时回放至同一个输出表的N对一异构回放，异构回放能够保证多个数据源的严格时序回放和消费。本小节将对多表回放面临的难点、相应的 DolphinDB 技术解决方案和原理展开介绍。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-n-对-n回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;2.1. N 对 N回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;类似单表回放的原理，replay 函数提供了N 对 N模式的多表回放，即将多个输入表回放至多个目标表，输入表与目标表一一对应。以下是N 对 N模式的多表回放的示例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;orderDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://order&#34;, &#34;order&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) tradeDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://trade&#34;, &#34;trade&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) snapshotDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://snapshot&#34;, &#34;snapshot&#34;) where Date =2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) replay(inputTables=[orderDS, tradeDS, snapshotDS], outputTables=[orderStream, tradeStream, snapshotStream], dateColumn=`Date, timeColumn=`Time, replayRate=10000, absoluteRate=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;以上脚本将三个数据库表中的历史数据分别注入三个目标表中。在N 对 N的模式中，不同表的在同一秒内的两条数据写入目标表的顺序可能和数据中的时间字段的先后关系不一致。此外，下游如果由三个处理线程分别对三个目标表进行订阅与消费，也很难保证表与表之间的数据被处理的顺序关系。因此，N 对 N回放不能保证整体上最严格的时序。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在实践中，一个领域中不同类型的消息是有先后顺序的，比如股票的逐笔成交和逐笔委托，所以在对多个数据源回放时要求每条数据都严格按照时间顺序注入目标表，为此我们需要解决以下问题：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;不同结构的数据如何统一进行排序和注入以保证整体的顺序？&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;如何保证对多表回放结果的实时消费也是严格按照时序进行的？&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-n-对-1-异构回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;2.2. N 对 1 异构回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;面对上述多表回放的难点，DolphinDB 进一步增加了异构模式的多表回放，支持将多个不同表结构的数据表写入到同一张异构流数据表中，从而实现了严格按时间顺序的多表回放。以下是异构模式的多表回放示例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;orderDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://order&#34;, &#34;order&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) tradeDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://trade&#34;, &#34;trade&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) snapshotDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://snapshot&#34;, &#34;snapshot&#34;) where Date =2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time) inputDict = dict([&#34;order&#34;, &#34;trade&#34;, &#34;snapshot&#34;], [orderDS, tradeDS, snapshotDS]) replay(inputTables=inputDict, outputTables=messageStream, dateColumn=`Date, timeColumn=`Time, replayRate=10000, absoluteRate=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;异构回放时将 replay 函数的 inputTables 参数指定为字典，outputTables 参数指定为异构流数据表。inputTables 参数指定多个结构不同的数据源，字典的 key 是用户自定义的字符串，是数据源的唯一标识，将会对应 outputTables 参数指定的表的第二列，字典的 value 是通过 replayDS 定义的数据源或者表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;以上脚本中的输出表 messageStream 为异构流数据表，其表结构如下：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;3&#34; xtrc=&#34;tgroup:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;name&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;57:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;typeString&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;57:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;comment&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:4;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;msgTime&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:5;59:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;TIMESTAMP&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;59:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;消息时间&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:7;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;msgType&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:8;60:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;SYMBOL&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:9;60:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;数据源标识：&#34;order&#34;、&#34;trade&#34;、&#34;snapshot&#34;&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:10;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;msgBody&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:11;61:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;BLOB&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:12;61:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;消息内容，以二进制格式存储&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;异构回放时 outputTables 参数指定的表至少需要包含以上三列，此外，还可以指定各输入表的公共列（列名和类型一致的列）。回放完成后，表 messageStream 的数据预览如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stock_market_replay/messageStream.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; dita-ot:image-width=&#34;768&#34; dita-ot:image-height=&#34;295&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;messageStream&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;表中每行记录对应输入表中的一行记录，msgTime 字段是输入表中的时间列，msgType 字段用来区分来自哪张输入表，msgBody 字段以二进制格式存储了输入表中的记录内容。在回放的过程中，通过异构流数据表这样的数据结构可以对多个数据源进行全局排序，因而保证了多个数据源之间的严格时间顺序。同时，异构流数据表和普通流数据表一样可以被订阅，即多种类型的数据存储在同一张表中被发布并被同一个线程实时处理，因而也保证了消费的严格时序性。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;69:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;若要对异构流数据表进行数据处理操作，如指标计算等，则需要将二进制格式的消息内容反序列化为原始结构的一行记录。DolphinDB 在脚本语言以及在 API 中均支持了对异构流数据表的解析功能。脚本支持流数据分发引擎 streamFilter 对异构流数据表进行反序列化以及反序列后结果的数据处理；同时，各类 API 在支持流数据订阅功能的基础上，扩展支持了在订阅时对异构流数据表进行反序列化。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-多表回放应用股票行情回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3. 多表回放应用：股票行情回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;基于上文提到的异构回放、异构流数据表解析以及 DolphinDB 流处理框架中的其他特性等，本章将结合股票行情回放展示 DolphinDB 异构模式的多表回放功能在实际场景中的应用，包括数据回放以及三种具体的回放结果消费方案：使用内置流计算引擎实时处理数据、实时推送外部消息中间件、外部程序订阅与实时消费。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-行情回放与消费方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.1. 行情回放与消费方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;77:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;行情多表回放方案的数据处理流程图如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;../stream/images/stock_market_replay_1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:2;79:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; dita-ot:image-width=&#34;1487&#34; dita-ot:image-height=&#34;1630&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;处理流程图说明：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;回放与消费流程围绕异构流数据表 messageStream 展开。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;图中异构流数据表模块以上，为异构模式的多表回放的示意图，由数据回放工具即 replay 和 replayDS 函数，将存储在多个数据库中的原始数据回放至异构流数据表中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;图中异构流数据表模块以下，分为三条支路，分别对应对回放结果的三种不同的处理方式，从左至右依次是：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在 DolphinDB 的订阅中，通过内置的流计算引擎实时计算指标，本文将使用 asof join 引擎实时关联逐笔成交与快照数据，计算个股交易成本并写入结果流数据表；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在 DolphinDB 的订阅中，通过 Kafka 插件将回放结果实时写入外部的消息中间件 Kafka；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在外部程序中，通过 DolphinDB 的流数据 API 来实时订阅和消费回放结果，本文将使用 C++API。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-测试数据集&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.2. 测试数据集&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本教程基于上交所某日的股票行情数据进行回放，包括逐笔委托、逐笔成交、Level2 快照三种行情数据，分别存放在分布式数据库 &#34;dfs://order&#34;、&#34;dfs://trade&#34;、&#34;dfs://snapshot&#34; 中，均使用 TSDB 存储引擎，数据概览如下：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;7&#34; xtrc=&#34;tgroup:2;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:4;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:5;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:6;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:7;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:8;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:9;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:10;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:13;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;数据集&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:14;97:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;字段数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:15;97:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;总行数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:16;97:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;数据大小&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:17;97:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;简称&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:18;97:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;分区机制&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:19;97:77&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;排序列&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;99:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;99:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:20;99:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;逐笔委托&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:21;99:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:22;99:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;49018552&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:23;99:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;6.8G&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:24;99:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;order&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:25;99:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;VALUE: 交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:26;99:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;股票, 交易时间&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:27;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;逐笔成交&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:28;100:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;15&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:29;100:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;43652718&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:30;100:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3G&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:31;100:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;trade&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:32;100:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;VALUE: 交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:33;100:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;股票, 交易时间&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:34;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Level2 行情快照&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:35;101:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;55&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:36;101:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;8410359&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:37;101:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;4.1G&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:38;101:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;snapshot&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:39;101:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;VALUE: 交易日, HASH: [SYMBOL, 20]&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:40;101:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;股票, 交易时间&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;103:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;后文也将提供部分原始数据的 csv 文件以及对应的数据导入脚本，以便快速体验回放功能。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-代码实现&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3. 代码实现&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本教程脚本开发工具采用 DolphinDB GUI，相关环境配置见后文&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#开发环境配置&#34; xtrc=&#34;xref:3;107:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;开发环境配置&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;331-股票行情回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3.1. 股票行情回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本小节脚本将三个数据库中的不同结构的数据回放至同一个异构流数据表中。完整脚本见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/01.stockMarketReplay.txt&#34; xtrc=&#34;xref:4;111:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;股票行情回放. txt&lt;/xref&gt;。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;创建异构流数据表 messageStream&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;115:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;colName = `msgTime`msgType`msgBody colType = [TIMESTAMP,SYMBOL, BLOB] messageTemp = streamTable(1000000:0, colName, colType) enableTableShareAndPersistence(table=messageTemp, tableName=&#34;messageStream&#34;, asynWrite=true, compress=true, cacheSize=1000000, retentionMinutes=1440, flushMode=0, preCache=10000) messageTemp = NULL&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;messageStream 是共享的异步持久化异构流数据表。为了之后能够对该表进行订阅，必须将其定义为共享的流数据表，共享意味着在当前节点的所有会话中可见。同时此处对流数据表进行持久化，其主要目的是控制该表的最大内存占用，enableTableShareAndPersistence 函数中的 cacheSize 参数规定了该表在内存中最多保留 100 万行。流数据持久化也保障了流数据的备份和恢复，当节点异常关闭后，持久化的数据会在重启时自动载入流数据表以继续流数据消费。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;三个数据源异构回放至流数据表 messageStream&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;timeRS = cutPoints(09:15:00.000..15:00:00.000, 100) orderDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://order&#34;, &#34;order&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS) tradeDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://trade&#34;, &#34;trade&#34;) where Date = 2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS) snapshotDS = replayDS(sqlObj=&amp;lt;select * from loadTable(&#34;dfs://snapshot&#34;, &#34;snapshot&#34;) where Date =2020.12.31&amp;gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS) inputDict = dict([&#34;order&#34;, &#34;trade&#34;, &#34;snapshot&#34;], [orderDS, tradeDS, snapshotDS]) submitJob(&#34;replay&#34;, &#34;replay stock market&#34;, replay, inputDict, messageStream, `Date, `Time, , , 3)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;上述脚本读取三个数据库中的结构不同的数据表进行全速的异构回放，回放通过 submitJob 函数提交后台作业来执行。下面讲解对于回放进行调优的相关参数和原理：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;replayDS 函数中的 timeRepartitionSchema 参数：replayDS 函数将输入的 SQL 查询转化为数据源，其会根据输入表的分区以及 timeRepartitionSchema 参数，将原始的 SQL 查询按照时间顺序拆分成若干小的 SQL 查询。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;141:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;replay 函数中的 parallelLevel 参数：parallelLevel 表示从数据库加载数据到内存的工作线程数量，即同时查询经过划分之后的小数据源的并行度，默认为 1，上述脚本中通过 submitjob 的参数设置为 3。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;143:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;对数据库表的回放过程分为两步，其一是通过 SQL 查询历史数据至内存，查询包括对数据的排序，其二是将内存中的数据写入输出表，两步以流水线的方式执行。若将某日数据全部导入内存并排序，会占用大量内存甚至导致内存不足，同时由于全部数据的查询耗时比较长，会导致第二步写入输出表的时刻也相应推迟。以 orderDS 为例，若不设置 timeRepartitionSchema 参数，则相应的 SQL 查询为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;145:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;select * from loadTable(&#34;dfs://order&#34;, &#34;order&#34;) where Date = 2020.12.31 order by Time&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;因此针对大数据量的场景，本教程先对 replayDS 函数指定 timeRepartitionSchema 参数，将数据按照时间戳分为 100 个小数据源，则每次查询的最小单位为其中一个小数据源，同时提高 parallelLevel 参数来帮助提升查询速度。以 orderDS 为例，若设置上述 timeRepartitionSchema 参数，则相应的其中一个 SQL 查询为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;select * from loadTable(&#34;dfs://order&#34;, &#34;order&#34;) where Date = 2020.12.31, 09:15:00.000 &amp;lt;= Time &amp;lt; 09:18:27.001 order by Time&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;后文的 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#性能测试&#34; xtrc=&#34;xref:5;155:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;性能测试&lt;/xref&gt; 章节利用本节的脚本进行了性能测试，最终总耗时 4m18s，内存占用峰值 4.7GB。内存主要由回放过程中的 SQL 查询和输出表等占用，通过对数据源进行切割以及对输出表进行持久化能有效控制内存使用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;作业运维：在 submitJob 函数提交后，通过 getRecentJobs 函数可以查看后台作业的状态，如果 endTime 和 errorMsg 为空，说明任务正在正常运行中。也可以用 cancelJob 函数取消回放，其输入参数 jobId 通过 getRecentJobs 获取。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;若没有可作为数据源的数据库，也可以通过加载 csv 文件至内存中进行回放来快速体验本教程，附录中的数据文件提供了 100 支股票的某日完整行情数据，全部数据在内存中约占 700M。以下脚本需要修改 loadText 的路径为实际的 csv 文本数据存储路径。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;orderDS = select * from loadText(&#34;/yourDataPath/replayData/order.csv&#34;) order by Time tradeDS = select * from loadText(&#34;/yourDataPath/replayData/trade.csv&#34;) order by Time snapshotDS = select * from loadText(&#34;/yourDataPath/replayData/snapshot.csv&#34;) order by Time inputDict = dict([&#34;order&#34;, &#34;trade&#34;, &#34;snapshot&#34;], [orderDS, tradeDS, snapshotDS]) submitJob(&#34;replay&#34;, &#34;replay text&#34;, replay, inputDict, messageStream, `Date, `Time, , , 1)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;332-消费场景-1在-dolphindb-订阅中实时计算个股交易成本&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3.2. 消费场景 1：在 DolphinDB 订阅中实时计算个股交易成本&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本小节脚本将实时消费小节创建的流数据表 messageStream，使用 asof join 引擎实时关联逐笔成交与快照数据，并计算个股交易成本，完整脚本见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/02.calTradeCost_asofJoin.txt&#34; xtrc=&#34;xref:6;172:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景 1: 计算个股交易成本_asofJoin 实现. txt&lt;/xref&gt;。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;创建计算结果输出表 prevailingQuotes&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;colName = `TradeTime`SecurityID`Price`TradeQty`BidPX1`OfferPX1`Spread`SnapshotTime colType = [TIME, SYMBOL, DOUBLE, INT, DOUBLE, DOUBLE, DOUBLE, TIME] prevailingQuotesTemp = streamTable(1000000:0, colName, colType) enableTableShareAndPersistence(table=prevailingQuotesTemp, tableName=&#34;prevailingQuotes&#34;, asynWrite=true, compress=true, cacheSize=1000000, retentionMinutes=1440, flushMode=0, preCache=10000) prevailingQuotesTemp = NULL&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;prevailingQuotes 被定义为共享流数据表，之后可以对其进行订阅和进一步的处理。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;创建流计算 asof join 引擎&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;def createSchemaTable(dbName, tableName){ schema = loadTable(dbName, tableName).schema().colDefs return table(1:0, schema.name, schema.typeString) } tradeSchema = createSchemaTable(&#34;dfs://trade&#34;, &#34;trade&#34;) snapshotSchema = createSchemaTable(&#34;dfs://snapshot&#34;, &#34;snapshot&#34;) joinEngine=createAsofJoinEngine(name=&#34;tradeJoinSnapshot&#34;, leftTable=tradeSchema, rightTable=snapshotSchema, outputTable=prevailingQuotes, metrics=&amp;lt;[Price, TradeQty, BidPX1, OfferPX1, abs(Price-(BidPX1+OfferPX1)/2), snapshotSchema.Time]&amp;gt;, matchingColumn=`SecurityID, timeColumn=`Time, useSystemTime=false, delayedTime=1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;使用 asof join 引擎实现在对股票分组的基础上，对于每条输入的 trade 记录，实时关联与之在时间列上最接近的一条 snapshot 记录，并使用 trade 中的价格字段和 snapshot 中的报价字段进行指标计算。最终，以上配置的 asof join 引擎会输出和左表行数相同的结果。asof join 引擎更多介绍请参考第八章 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;199:174&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;createAsofJoinEngine&lt;/codeph&gt;的相关介绍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;考虑到实际的业务含义，此例中 asof join 引擎在用于两个数据流的实时关联时，配置参数 useSystemTime=false 以按照数据中的时间列进行关联计算。使用数据中的时间列，相较于使用数据注入引擎时的系统时间作为时间列，可以避免在实时场景中两个数据流到达引擎的时刻乱序而带来的问题。但是，在此处，因为异构回放能够严格保证两个数据流的处理顺序，因此也可以使用数据注入引擎的系统时间进行关联计算。除了在使用 asof join 引擎时配置参数 useSystemTime=true 外，使用 look up join 引擎也能够实现按系统时间进行实时关联，即当每一条 trade 表中的记录注入引擎时，总是立刻去关联已经注入引擎的最新的一条相应股票的 snapshot 记录，得到的计算结果会同上文中的 asof join 引擎实现完全一致，而由于 look up join 引擎在内部实现上更简单，所以在计算性能上会有稍好的表现，完成脚本见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/03.calTradeCost_lookUpJoin.txt&#34; xtrc=&#34;xref:7;201:430&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景 1: 计算个股交易成本_lookUpJoin 实现. txt&lt;/xref&gt;。look up join 引擎更多介绍请参考第八章中&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;201:553&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;createLookUpJoinEngine&lt;/codeph&gt;的相关介绍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;自定义函数 createSchemaTable，用于获取数据库表的表结构，以做为创建引擎时的参数传入。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;创建流计算过滤与分发引擎&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;def appendLeftStream(msg){ tempMsg = select * from msg where Price &amp;gt; 0 and Time&amp;gt;=09:30:00.000 getLeftStream(getStreamEngine(`tradeJoinSnapshot)).tableInsert(tempMsg) } filter1 = dict(STRING,ANY) filter1[&#34;condition&#34;] = &#34;trade&#34; filter1[&#34;handler&#34;] = appendLeftStream filter2 = dict(STRING,ANY) filter2[&#34;condition&#34;] = &#34;snapshot&#34; filter2[&#34;handler&#34;] = getRightStream(getStreamEngine(`tradeJoinSnapshot)) schema = dict([&#34;trade&#34;, &#34;snapshot&#34;], [tradeSchema, snapshotSchema]) engine = streamFilter(name=&#34;streamFilter&#34;, dummyTable=messageStream, filter=[filter1, filter2], msgSchema=schema)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;222:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;streamFilter 函数通过设置 msgSchema 参数，会对异构流数据表进行反序列，并根据 filter 参数中设置的 handler 来处理订阅的数据。当订阅数据到来时，handler 之间是串行执行的，这样就保证了对数据的处理严格按照时序进行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;handler 参数是一元函数或数据表，用于处理订阅的数据。当它是函数时，其唯一的参数是经过解析和过滤后的数据表。这里对于 trade 数据其 handler 设置为函数 appendLeftStream，该函数对订阅到的数据首先做过滤，再将符合条件的数据作为左表写入到 asof join 引擎。对于 snapshot 数据其 handler 设置为 asof join 引擎的右表，表示对于订阅到的 snapshot 数据直接作为右表写入 asof join 引擎。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;订阅异构流数据表&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;subscribeTable(tableName=&#34;messageStream&#34;, actionName=&#34;tradeJoinSnapshot&#34;, offset=-1, handler=engine, msgAsTable=true, reconnect=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;设置参数 offset 为 -1，订阅将会从提交订阅时流数据表的当前行开始。为了消费到完整的数据，建议先执行此处脚本以提交订阅，再提交后台回放作业，参考 3.3.1 小节。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;234:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;234:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;查看计算结果&lt;/li&gt;&lt;/ul&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stock_market_replay/prevailingQuotes.png&#34; placement=&#34;break&#34; xtrc=&#34;image:3;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; dita-ot:image-width=&#34;503&#34; dita-ot:image-height=&#34;276&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;238:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;asof join 引擎在 matchingColumn 的分组内输出表数据与输入时的顺序一致。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;333-消费场景-2在-dolphindb-订阅中将回放结果实时推送-kafka&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3.3. 消费场景 2：在 DolphinDB 订阅中将回放结果实时推送 Kafka&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;242:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本小节脚本将前文中创建的流数据表 messageStream 实时发送至消息中间件 Kafka。执行以下脚本，需要有可以写入的 Kafka server，并且安装 DolphinDB Kafka 插件，插件配置见后文&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#开发环境配置&#34; xtrc=&#34;xref:8;242:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;开发环境配置&lt;/xref&gt;。完整脚本见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/04.publishToKafka.txt&#34; xtrc=&#34;xref:9;242:135&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景 2: 实时推送 Kafka.txt&lt;/xref&gt;。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;加载 Kafka 插件并创建 Kafka producer&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;loadPlugin(&#34;/DolphinDB/server/plugins/kafka/PluginKafka.txt&#34;) go producerCfg = dict(STRING, ANY) producerCfg[&#34;metadata.broker.list&#34;] = &#34;localhost&#34; producer = kafka::producer(producerCfg)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;loadPlugin 的路径和 producer 配置请按需修改。本教程涉及的 Kafka server 和 DolphinDB server 在同一台服务器上，故 metadata.broker.list 参数为 localhost。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:11;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;定义推送数据至 Kafka topic 的函数&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;def sendMsgToKafkaFunc(dataType, producer, msg){ startTime = now() try { kafka::produce(producer, &#34;topic-message&#34;, 1, msg, true) cost = now() - startTime writeLog(&#34;[Kafka Plugin] Successed to send&#34; + dataType + &#34;:&#34; + msg.size() + &#34;rows,&#34; + cost + &#34;ms.&#34;) } catch(ex) {writeLog(&#34;[Kafka Plugin] Failed to send msg to kafka with error:&#34; +ex)} }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;kafka::produce 函数会将任意表结构的 msg 以 json 格式发送至指定的 Kafka topic。此处的 writeLog 函数在日志中打印每批推送的情况来方便运维观察。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:12;272:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;272:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;注册流数据过滤与分发引擎&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;274:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;filter1 = dict(STRING,ANY) filter1[&#34;condition&#34;] = &#34;order&#34; filter1[&#34;handler&#34;] = sendMsgToKafkaFunc{&#34;order&#34;, producer} filter2 = dict(STRING,ANY) filter2[&#34;condition&#34;] = &#34;trade&#34; filter2[&#34;handler&#34;] = sendMsgToKafkaFunc{&#34;trade&#34;, producer} filter3 = dict(STRING,ANY) filter3[&#34;condition&#34;] = &#34;snapshot&#34; filter3[&#34;handler&#34;] = sendMsgToKafkaFunc{&#34;snapshot&#34;, producer} schema = dict([&#34;order&#34;,&#34;trade&#34;, &#34;snapshot&#34;], [loadTable(&#34;dfs://order&#34;, &#34;order&#34;), loadTable(&#34;dfs://trade&#34;, &#34;trade&#34;), loadTable(&#34;dfs://snapshot&#34;, &#34;snapshot&#34;)]) engine = streamFilter(name=&#34;streamFilter&#34;, dummyTable=messageStream, filter=[filter1, filter2, filter3], msgSchema=schema)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;streamFilter 函数通过设置 msgSchema 参数，会对异构流数据表进行反序列，并根据 filter 参数中设置的 handler 来处理订阅的数据。当订阅数据到来时，handler 之间是串行执行的，这样就保证了对数据的处理严格按照时序进行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;handler 参数是一元函数或数据表，用于处理订阅的数据。当它是函数时，其唯一的参数是经过解析和过滤后的数据表。sendMsgToKafka{&#34;order&#34;, producer} 的写法是函数化编程中的部分应用，即指定函数 sendMsgToKafka 的部分参数，产生一个参数较少的新函数。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:13;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;订阅异构流数据表&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;subscribeTable(tableName=&#34;messageStream&#34;, actionName=&#34;sendMsgToKafka&#34;, offset=-1, handler=engine, msgAsTable=true, reconnect=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;设置参数 offset 为 -1，订阅将会从提交订阅时流数据表的当前行开始。为了消费到完整的数据，建议先执行此处脚本以提交订阅，再提交后台回放作业，参考 3.3.1 小节。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:14;302:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;302:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在终端查看发送结果&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在命令行开启消费者进程，从第一条开始消费名为 topic-message 的 topic&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic topic-message&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;311:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;返回：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stock_market_replay/KafkaToipic.png&#34; placement=&#34;break&#34; xtrc=&#34;image:4;313:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; dita-ot:image-width=&#34;1582&#34; dita-ot:image-height=&#34;277&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;334-消费场景-3在外部程序中通过-capi-实时订阅与处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3.4. 消费场景 3：在外部程序中通过 C++API 实时订阅与处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本小节代码为 C++ 程序，程序会订阅前文创建的异构流数据表 messageStream，并实时打印每条数据。以下代码依赖DolphinDB C++ API，API安装见后文&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#开发环境配置&#34; xtrc=&#34;xref:10;317:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;开发环境配置&lt;/xref&gt;。完整代码见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;cpp&#34; href=&#34;script/stock_market_replay/05.subscribe.cpp&#34; xtrc=&#34;xref:11;317:114&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景 3:C++API 实时订阅. cpp&lt;/xref&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;c++&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;int main(int argc, char *argv[]){ DBConnection conn; string hostName = &#34;127.0.0.1&#34;; int port = 8848; bool ret = conn.connect(hostName, port); conn.run(&#34;login(\&#34;admin\&#34;, \&#34;123456\&#34;)&#34;); DictionarySP t1schema = conn.run(&#34;loadTable(\&#34;dfs://snapshotL2\&#34;, \&#34;snapshotL2\&#34;).schema()&#34;); DictionarySP t2schema = conn.run(&#34;loadTable(\&#34;dfs://trade\&#34;, \&#34;trade\&#34;).schema()&#34;); DictionarySP t3schema = conn.run(&#34;loadTable(\&#34;dfs://order\&#34;, \&#34;order\&#34;).schema()&#34;); unordered_map&amp;lt;string, DictionarySP&amp;gt; sym2schema; sym2schema[&#34;snapshot&#34;] = t1schema; sym2schema[&#34;trade&#34;] = t2schema; sym2schema[&#34;order&#34;] = t3schema; StreamDeserializerSP sdsp = new StreamDeserializer(sym2schema); auto myHandler = [&amp;amp;](Message msg) { const string &amp;amp;symbol = msg.getSymbol(); cout &amp;lt;&amp;lt; symbol &amp;lt;&amp;lt; &#34;:&#34;; size_t len = msg-&amp;gt;size(); for (int i = 0; i &amp;lt; len; i++) { cout &amp;lt;&amp;lt;msg-&amp;gt;get(i)-&amp;gt;getString() &amp;lt;&amp;lt; &#34;,&#34;; } cout &amp;lt;&amp;lt; endl; }; int listenport = 10260; ThreadedClient threadedClient(listenport); auto thread = threadedClient.subscribe(hostName, port, myHandler, &#34;messageStream&#34;, &#34;printMessageStream&#34;, -1, true, nullptr, false, false, sdsp); cout&amp;lt;&amp;lt;&#34;Successed to subscribe messageStream&#34;&amp;lt;&amp;lt;endl; thread-&amp;gt;join(); return 0; }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;调用订阅函数 ThreadedClient::subscribe 订阅异构流数据表时，在最后一个参数指定相应的流数据反序列化实例 StreamDeserializerSP，则在订阅时会对收到的数据进行反序列化再传递给用户自定义的回调函数 myHandler。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;listenport 参数为单线程客户端的订阅端口号，设置 C++ 程序所在服务器的任意空闲端口即可。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:15;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;在终端查看程序实时打印的内容：&lt;/li&gt;&lt;/ul&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stock_market_replay/C++API.png&#34; placement=&#34;break&#34; xtrc=&#34;image:5;362:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; dita-ot:image-width=&#34;1574&#34; dita-ot:image-height=&#34;502&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;335-清理环境&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;3.3.5. 清理环境&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;366:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;如果反复执行上述脚本，可能需要清理流数据表、取消订阅、注销流计算引擎等操作，建议在运行回放与消费脚本前先清理环境。本教程的清理环境脚本见附录 &lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/06.cleanEnvironment.txt&#34; xtrc=&#34;xref:12;366:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;清理环境. txt&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-性能测试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;4. 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;本教程对异构模式下的多表回放功能进行了性能测试。以第三章提及的测试数据集作为回放的输入，以第三章第三小节的回放脚本作为测试脚本，该脚本不设定回放速率（即以最快的速率回放），并且输出表没有任何订阅，最终回放了 101,081,629 条数据至输出表中，总耗时 4m18s，每秒回放约 39 万条数据，内存占用峰值 4.7GB。测试使用的服务器的 CPU 为 Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz，更详细的服务器及DolphinDB server配置信息见后文&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#开发环境配置&#34; xtrc=&#34;xref:13;370:253&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;开发环境配置&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-开发环境配置&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;5. 开发环境配置&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;374:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;374:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;服务器环境&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:16;376:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;376:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;CPU 类型：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;逻辑 CPU 总数：8&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;378:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;内存：64GB&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;379:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;OS：64 位 CentOS Linux 7 (Core)&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB server 部署&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:17;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;server 版本：2.00.6&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;384:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;server 部署模式：单节点&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;配置文件：dolphindb.cfg&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;localSite=localhost:8848:local8848 mode=single maxMemSize=32 maxConnections=512 workerNum=8 maxConnectionPerSite=15 newValuePartitionPolicy=add webWorkerNum=2 dataSync=1 persistenceDir=/DolphinDB/server/persistenceDir maxPubConnections=64 subExecutors=16 subPort=8849 subThrottle=1 persistenceWorkerNum=1 lanCluster=0&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;406:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;406:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;注意&lt;/b&gt;： 配置参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;406:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;persistenceDir&lt;/codeph&gt; 需要开发人员根据实际环境配置。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;408:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;单节点部署教程：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;standalone_server.md&#34; xtrc=&#34;xref:14;408:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;单节点部署&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;410:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;410:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB client 开发环境&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:18;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;CPU 类型：Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz 3.60 GHz&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;413:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;逻辑 CPU 总数：8&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;内存：32GB&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;415:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;OS：Windows 10 专业版&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB GUI 版本：1.30.15&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB Kafka 插件安装&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:19;420:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:31;420:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Kafka 插件版本：release200&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;422:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;422:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;注意&lt;/b&gt;： Kafka 插件版本建议按 DolphinDB server 版本选择，如 2.00.6 版本的 server 安装 release200 分支的插件&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;424:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Kafka 插件教程：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;../plugins/kafka/kafka.md&#34; xtrc=&#34;xref:15;424:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;Kafka 插件教程&lt;/xref&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Kafka server 部署&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:20;428:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:32;428:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;zookeeper 版本：3.4.6&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:33;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Kafka 版本：2.12-2.6.2&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:34;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;Kafka 部署模式：单节点&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:35;431:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;创建 Kafka topic&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;433:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 4 --topic topic-message&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;437:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;437:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;DolphinDB C++ API 安装&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:21;439:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:36;439:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;C++ API 版本：release200&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;441:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:9;441:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;注意&lt;/b&gt;： C++API 版本建议按 DolphinDB server 版本选择，如 2.00.6 版本的 server 安装 release200 分支的 API。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/cppdoc/cpp_api.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:16;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;C++ API教程&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-附录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;6. 附录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:22;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:37;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/01.stockMarketReplay.txt&#34; xtrc=&#34;xref:17;449:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;股票行情回放.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:38;450:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/02.calTradeCost_asofJoin.txt&#34; xtrc=&#34;xref:18;450:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景1：计算个股交易成本 _asofJoin 实现.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:39;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/03.calTradeCost_lookUpJoin.txt&#34; xtrc=&#34;xref:19;451:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景1：计算个股交易成本 _lookUpJoin 实现.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:40;452:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/04.publishToKafka.txt&#34; xtrc=&#34;xref:20;452:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景2：实时推送 Kafka.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:41;453:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;cpp&#34; href=&#34;script/stock_market_replay/05.subscribe.cpp&#34; xtrc=&#34;xref:21;453:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;消费场景3：C++API 实时订阅.cpp&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:42;454:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/stock_market_replay/06.cleanEnvironment.txt&#34; xtrc=&#34;xref:22;454:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;清理环境.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:43;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;https://www.dolphindb.cn/downloads/docs/stock_market_replay.zip&#34; scope=&#34;external&#34; xtrc=&#34;xref:23;455:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stock_market_replay.md&#34;&gt;&lt;?ditaot usertext?&gt;样例数据：order.csv, trade.csv与snapshot.csv&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/stock_market_replay.md"/><meta name="wh-out-relpath" content="tutorials/stock_market_replay.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="股票行情回放" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="chap7_tutorials_streaming"><div class="title"><a href="../stream/str_intro.html"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming_auto_sub.html">金融场景应用案例</a></div></div></li><li class="active"><div class="topicref" data-id="股票行情回放"><div class="title"><a href="../tutorials/stock_market_replay.html">股票行情回放</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="streamfunctions-d9713e3813" class="topicref" data-id="streamfunctions" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamfunctions-d9713e3813-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_funcs.html" id="streamfunctions-d9713e3813-link">功能简介</a></div></div></li><li role="treeitem"><div data-tocid="入门示例-01实时计算买卖价差-d9713e4044" class="topicref" data-id="入门示例-01实时计算买卖价差" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/try_example1.html" id="入门示例-01实时计算买卖价差-d9713e4044-link">入门示例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="内置流式计算算子-d9713e4090" class="topicref" data-id="内置流式计算算子" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 内置流式计算算子-d9713e4090-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_operator.html" id="内置流式计算算子-d9713e4090-link"><span class="keyword label">流式计算算子</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="streamingEngineTopic-d9713e4229" class="topicref" data-id="streamingEngineTopic" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamingEngineTopic-d9713e4229-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/themes/streamingEngine.html" id="streamingEngineTopic-d9713e4229-link"><span class="keyword label">流计算引擎</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e4506" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e4506-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_join_engine.html" id="chap7_tutorials_streaming-d9713e4506-link"><span class="keyword label">内置多数据源流式关联引擎</span></a></div></div></li><li role="treeitem"><div data-tocid="streamha-d9713e4783" class="topicref" data-id="streamha" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_ha.html" id="streamha-d9713e4783-link"><span class="keyword label">流数据高可用</span></a></div></div></li><li role="treeitem"><div data-tocid="流计算状态监控-d9713e4830" class="topicref" data-id="流计算状态监控" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_monitor.html" id="流计算状态监控-d9713e4830-link">流计算状态监控</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="replay-d9713e4876" class="topicref" data-id="replay" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action replay-d9713e4876-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_replay.html" id="replay-d9713e4876-link"><span class="keyword label">历史数据回放</span></a></div></div></li><li role="treeitem"><div data-tocid="流批一体功能-d9713e5061" class="topicref" data-id="流批一体功能" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_batch.html" id="流批一体功能-d9713e5061-link"><span class="keyword label">流批一体</span></a></div></div></li><li role="treeitem"><div data-tocid="streamengineparser-解析原理介绍-d9713e5108" class="topicref" data-id="streamengineparser-解析原理介绍" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_eng_parser.html" id="streamengineparser-解析原理介绍-d9713e5108-link">StreamEngineParser 解析原理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="realtime_data_acces-d9713e5155" class="topicref" data-id="realtime_data_acces" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action realtime_data_acces-d9713e5155-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/realtime_data_acces.html" id="realtime_data_acces-d9713e5155-link">实时流数据接入</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="cep-d9713e5617" class="topicref" data-id="cep" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action cep-d9713e5617-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/cep.html" id="cep-d9713e5617-link">复杂事件处理（CEP）引擎</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6123" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6123-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/local_sub.html" id="tocId-d9713e6123-link">流处理结果交互方式</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6312" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6312-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_altair.html" id="tocId-d9713e6312-link">数据可视化工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e6405" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e6405-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="tocId-d9713e6405-link">金融场景应用案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e6406" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="节点启动时的流计算自动订阅-d9713e6406-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="k-线计算-d9713e6452" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC.html" id="k-线计算-d9713e6452-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e6498" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant.html" id="金融因子流式实现-d9713e6498-link">金融因子流式实现</a></div></div></li><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e6544" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing.html" id="多数据源流式实时关联处理-d9713e6544-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="实时计算高频因子-d9713e6590" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming.html" id="实时计算高频因子-d9713e6590-link">实时计算高频因子</a></div></div></li><li role="treeitem" class="active"><div data-tocid="股票行情回放-d9713e6636" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay.html" id="股票行情回放-d9713e6636-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e6682" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility.html" id="金融实时实际波动率预测-d9713e6682-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e6728" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e6728-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e6774" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily.html" id="实时计算日累计逐单资金流-d9713e6774-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e6820" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order.html" id="实时计算分钟资金流-d9713e6820-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e6866" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e6866-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e6959" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc.html" id="处理-level-2-行情数据实例-d9713e6959-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e7005" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc.html" id="实时计算涨幅榜-d9713e7005-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e7051" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV.html" id="基金份额参考价值-iopv-计算-d9713e7051-link">基金份额参考价值 IOPV 计算</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7097" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7097-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_str_app_iot.html" id="tocId-d9713e7097-link">物联网场景应用案例</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">股票行情回放</h1><div class="- topic/body body"><p class="- topic/p p">一个量化策略在生产（交易）环境中运行时，实时数据的处理通常是由事件驱动的。为确保研发和生产使用同一套代码，通常在研发阶段需将历史数据，严格按照事件发生的时间顺序进行回放，以此模拟交易环境。一个交易所的行情数据通常包括逐笔委托、逐笔成交、快照等多种类型的数据。DolphinDB 提供了严格按照时间顺序将多个不同数据源同时进行回放的功能。</p><p class="- topic/p p">首先简要介绍 DolphinDB 数据回放功能和原理，之后介绍股票行情回放的应用方案和代码实现。关于如何基于 DolphinDB 搭建行情数据回放服务，请参阅：<a class="- topic/xref xref" href="appendices_market_replay_bp.html">搭建行情回放服务的最佳实践</a>。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-单表回放"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 单表回放</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 历史数据回放功能通过 replay 函数实现。replay 函数的作用是将内存表或数据库表中的记录以一定的速率写入到目标表中，以模拟实时注入的数据流。根据输入表的数量，回放分为单表回放和多表回放，其中单表回放是最基础的回放模式，即将一个输入表回放至一个相同表结构的目标表中，以下是不包括建表语句的单表回放示例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">tradeDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
replay(inputTables=tradeDS, outputTables=tradeStream, dateColumn=`Date, timeColumn=`Time, replayRate=<span class="hl-number">10000</span>, absoluteRate=true)</pre><p class="- topic/p p">以上脚本将数据库 "dfs://trade" 中的 "trade" 表中 2020 年 12 月 31 日的数据以每秒 1 万条的速度注入目标表 tradeStream 中。更多关于 replay、replayDS 函数的介绍可以参考 <a class="- topic/xref xref" href="data_replay.html">DolphinDB 历史数据回放教程</a>。</p><p class="- topic/p p">但是，单表回放并不能满足所有的回放要求。因为在实践中，一个领域问题往往需要多个不同类型的消息协作，例如金融领域的行情数据包括逐笔委托、逐笔成交、快照等，为了更好地模拟实际交易中的实时数据流，通常需要将以上三类数据同时进行回放，这时便提出了多表回放的需求。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-多表回放"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 多表回放</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB不断优化拓展多表回放的功能，既支持N个输入表一对一回放至N个输出表的N对N回放，又在1.30.17/2.00.5及之后的版本中支持了N个不同结构的输入表同时回放至同一个输出表的N对一异构回放，异构回放能够保证多个数据源的严格时序回放和消费。本小节将对多表回放面临的难点、相应的 DolphinDB 技术解决方案和原理展开介绍。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-n-对-n回放"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1. N 对 N回放</h3><div class="- topic/body body"><p class="- topic/p p">类似单表回放的原理，replay 函数提供了N 对 N模式的多表回放，即将多个输入表回放至多个目标表，输入表与目标表一一对应。以下是N 对 N模式的多表回放的示例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">orderDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
tradeDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
snapshotDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://snapshot"</span>, <span class="hl-string">"snapshot"</span>) where Date =<span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
replay(inputTables=[orderDS, tradeDS, snapshotDS], outputTables=[orderStream, tradeStream, snapshotStream], dateColumn=`Date, timeColumn=`Time, replayRate=<span class="hl-number">10000</span>, absoluteRate=true)</pre><p class="- topic/p p">以上脚本将三个数据库表中的历史数据分别注入三个目标表中。在N 对 N的模式中，不同表的在同一秒内的两条数据写入目标表的顺序可能和数据中的时间字段的先后关系不一致。此外，下游如果由三个处理线程分别对三个目标表进行订阅与消费，也很难保证表与表之间的数据被处理的顺序关系。因此，N 对 N回放不能保证整体上最严格的时序。</p><p class="- topic/p p">在实践中，一个领域中不同类型的消息是有先后顺序的，比如股票的逐笔成交和逐笔委托，所以在对多个数据源回放时要求每条数据都严格按照时间顺序注入目标表，为此我们需要解决以下问题：</p><ul class="- topic/ul ul"><li class="- topic/li li">不同结构的数据如何统一进行排序和注入以保证整体的顺序？</li><li class="- topic/li li">如何保证对多表回放结果的实时消费也是严格按照时序进行的？</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="22-n-对-1-异构回放"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.2. N 对 1 异构回放</h3><div class="- topic/body body"><p class="- topic/p p">面对上述多表回放的难点，DolphinDB 进一步增加了异构模式的多表回放，支持将多个不同表结构的数据表写入到同一张异构流数据表中，从而实现了严格按时间顺序的多表回放。以下是异构模式的多表回放示例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">orderDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
tradeDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
snapshotDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://snapshot"</span>, <span class="hl-string">"snapshot"</span>) where Date =<span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time)
inputDict = dict([<span class="hl-string">"order"</span>, <span class="hl-string">"trade"</span>, <span class="hl-string">"snapshot"</span>], [orderDS, tradeDS, snapshotDS])
replay(inputTables=inputDict, outputTables=messageStream, dateColumn=`Date, timeColumn=`Time, replayRate=<span class="hl-number">10000</span>, absoluteRate=true)</pre><p class="- topic/p p">异构回放时将 replay 函数的 inputTables 参数指定为字典，outputTables 参数指定为异构流数据表。inputTables 参数指定多个结构不同的数据源，字典的 key 是用户自定义的字符串，是数据源的唯一标识，将会对应 outputTables 参数指定的表的第二列，字典的 value 是通过 replayDS 定义的数据源或者表。</p><p class="- topic/p p">以上脚本中的输出表 messageStream 为异构流数据表，其表结构如下：</p><div class="table-container"><table class="- topic/table table" data-cols="3"><caption></caption><colgroup><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="22-n-对-1-异构回放__entry__1">name</th><th class="- topic/entry entry colsep-0 rowsep-0" id="22-n-对-1-异构回放__entry__2">typeString</th><th class="- topic/entry entry colsep-0 rowsep-0" id="22-n-对-1-异构回放__entry__3">comment</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__1">msgTime</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__2">TIMESTAMP</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__3">消息时间</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__1">msgType</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__2">SYMBOL</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__3">数据源标识："order"、"trade"、"snapshot"</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__1">msgBody</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__2">BLOB</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="22-n-对-1-异构回放__entry__3">消息内容，以二进制格式存储</td></tr></tbody></table></div><p class="- topic/p p">异构回放时 outputTables 参数指定的表至少需要包含以上三列，此外，还可以指定各输入表的公共列（列名和类型一致的列）。回放完成后，表 messageStream 的数据预览如下：</p><br/><img class="- topic/image image" src="images/stock_market_replay/messageStream.png" alt="messageStream"/><br/><p class="- topic/p p">表中每行记录对应输入表中的一行记录，msgTime 字段是输入表中的时间列，msgType 字段用来区分来自哪张输入表，msgBody 字段以二进制格式存储了输入表中的记录内容。在回放的过程中，通过异构流数据表这样的数据结构可以对多个数据源进行全局排序，因而保证了多个数据源之间的严格时间顺序。同时，异构流数据表和普通流数据表一样可以被订阅，即多种类型的数据存储在同一张表中被发布并被同一个线程实时处理，因而也保证了消费的严格时序性。</p><p class="- topic/p p">若要对异构流数据表进行数据处理操作，如指标计算等，则需要将二进制格式的消息内容反序列化为原始结构的一行记录。DolphinDB 在脚本语言以及在 API 中均支持了对异构流数据表的解析功能。脚本支持流数据分发引擎 streamFilter 对异构流数据表进行反序列化以及反序列后结果的数据处理；同时，各类 API 在支持流数据订阅功能的基础上，扩展支持了在订阅时对异构流数据表进行反序列化。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title6" id="3-多表回放应用股票行情回放"><h2 class="- topic/title title topictitle2" id="ariaid-title6">3. 多表回放应用：股票行情回放</h2><div class="- topic/body body"><p class="- topic/p p">基于上文提到的异构回放、异构流数据表解析以及 DolphinDB 流处理框架中的其他特性等，本章将结合股票行情回放展示 DolphinDB 异构模式的多表回放功能在实际场景中的应用，包括数据回放以及三种具体的回放结果消费方案：使用内置流计算引擎实时处理数据、实时推送外部消息中间件、外部程序订阅与实时消费。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="31-行情回放与消费方案"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.1. 行情回放与消费方案</h3><div class="- topic/body body"><p class="- topic/p p">行情多表回放方案的数据处理流程图如下：</p><br/><img class="- topic/image image" src="../stream/images/stock_market_replay_1.png"/><br/><p class="- topic/p p">处理流程图说明：</p><p class="- topic/p p">回放与消费流程围绕异构流数据表 messageStream 展开。</p><p class="- topic/p p">图中异构流数据表模块以上，为异构模式的多表回放的示意图，由数据回放工具即 replay 和 replayDS 函数，将存储在多个数据库中的原始数据回放至异构流数据表中。</p><p class="- topic/p p">图中异构流数据表模块以下，分为三条支路，分别对应对回放结果的三种不同的处理方式，从左至右依次是：</p><ul class="- topic/ul ul"><li class="- topic/li li">在 DolphinDB 的订阅中，通过内置的流计算引擎实时计算指标，本文将使用 asof join 引擎实时关联逐笔成交与快照数据，计算个股交易成本并写入结果流数据表；</li><li class="- topic/li li">在 DolphinDB 的订阅中，通过 Kafka 插件将回放结果实时写入外部的消息中间件 Kafka；</li><li class="- topic/li li">在外部程序中，通过 DolphinDB 的流数据 API 来实时订阅和消费回放结果，本文将使用 C++API。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="32-测试数据集"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.2. 测试数据集</h3><div class="- topic/body body"><p class="- topic/p p">本教程基于上交所某日的股票行情数据进行回放，包括逐笔委托、逐笔成交、Level2 快照三种行情数据，分别存放在分布式数据库 "dfs://order"、"dfs://trade"、"dfs://snapshot" 中，均使用 TSDB 存储引擎，数据概览如下：</p><div class="table-container"><table class="- topic/table table" data-cols="7"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__1">数据集</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__2">字段数</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__3">总行数</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__4">数据大小</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__5">简称</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__6">分区机制</th><th class="- topic/entry entry colsep-0 rowsep-0" id="32-测试数据集__entry__7">排序列</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__1">逐笔委托</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__2">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__3">49018552</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__4">6.8G</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__5">order</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__6">VALUE: 交易日, HASH: [SYMBOL, 20]</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__7">股票, 交易时间</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__1">逐笔成交</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__2">15</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__3">43652718</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__4">3.3G</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__5">trade</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__6">VALUE: 交易日, HASH: [SYMBOL, 20]</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__7">股票, 交易时间</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__1">Level2 行情快照</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__2">55</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__3">8410359</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__4">4.1G</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__5">snapshot</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__6">VALUE: 交易日, HASH: [SYMBOL, 20]</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="32-测试数据集__entry__7">股票, 交易时间</td></tr></tbody></table></div><p class="- topic/p p">后文也将提供部分原始数据的 csv 文件以及对应的数据导入脚本，以便快速体验回放功能。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="33-代码实现"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.3. 代码实现</h3><div class="- topic/body body"><p class="- topic/p p">本教程脚本开发工具采用 DolphinDB GUI，相关环境配置见后文<a class="- topic/xref xref" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">开发环境配置</a>。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="331-股票行情回放"><h4 class="- topic/title title topictitle4" id="ariaid-title10">3.3.1. 股票行情回放</h4><div class="- topic/body body"><p class="- topic/p p">本小节脚本将三个数据库中的不同结构的数据回放至同一个异构流数据表中。完整脚本见附录 <a class="- topic/xref xref" href="script/stock_market_replay/01.stockMarketReplay.txt">股票行情回放. txt</a>。</p><ul class="- topic/ul ul"><li class="- topic/li li">创建异构流数据表 messageStream</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">colName = `msgTime`msgType`msgBody
colType = [TIMESTAMP,SYMBOL, BLOB]
messageTemp = streamTable(<span class="hl-number">1000000</span>:<span class="hl-number">0</span>, colName, colType)
enableTableShareAndPersistence(table=messageTemp, tableName=<span class="hl-string">"messageStream"</span>, asynWrite=true, compress=true, cacheSize=<span class="hl-number">1000000</span>, retentionMinutes=<span class="hl-number">1440</span>, flushMode=<span class="hl-number">0</span>, preCache=<span class="hl-number">10000</span>)
messageTemp = NULL</pre><p class="- topic/p p">messageStream 是共享的异步持久化异构流数据表。为了之后能够对该表进行订阅，必须将其定义为共享的流数据表，共享意味着在当前节点的所有会话中可见。同时此处对流数据表进行持久化，其主要目的是控制该表的最大内存占用，enableTableShareAndPersistence 函数中的 cacheSize 参数规定了该表在内存中最多保留 100 万行。流数据持久化也保障了流数据的备份和恢复，当节点异常关闭后，持久化的数据会在重启时自动载入流数据表以继续流数据消费。</p><ul class="- topic/ul ul"><li class="- topic/li li">三个数据源异构回放至流数据表 messageStream</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">timeRS = cutPoints(<span class="hl-number">09</span>:<span class="hl-number">15</span>:<span class="hl-number">00.000</span>.<span class="hl-number">.15</span>:<span class="hl-number">00</span>:<span class="hl-number">00.000</span>, <span class="hl-number">100</span>)
orderDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS)
tradeDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS)
snapshotDS = replayDS(sqlObj=&lt;select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://snapshot"</span>, <span class="hl-string">"snapshot"</span>) where Date =<span class="hl-number">2020.12</span>.<span class="hl-number">31</span>&gt;, dateColumn=`Date, timeColumn=`Time, timeRepartitionSchema=timeRS)
inputDict = dict([<span class="hl-string">"order"</span>, <span class="hl-string">"trade"</span>, <span class="hl-string">"snapshot"</span>], [orderDS, tradeDS, snapshotDS])

submitJob(<span class="hl-string">"replay"</span>, <span class="hl-string">"replay stock market"</span>, replay, inputDict, messageStream, `Date, `Time, , , <span class="hl-number">3</span>)</pre><p class="- topic/p p">上述脚本读取三个数据库中的结构不同的数据表进行全速的异构回放，回放通过 submitJob 函数提交后台作业来执行。下面讲解对于回放进行调优的相关参数和原理：</p><p class="- topic/p p">replayDS 函数中的 timeRepartitionSchema 参数：replayDS 函数将输入的 SQL 查询转化为数据源，其会根据输入表的分区以及 timeRepartitionSchema 参数，将原始的 SQL 查询按照时间顺序拆分成若干小的 SQL 查询。</p><p class="- topic/p p">replay 函数中的 parallelLevel 参数：parallelLevel 表示从数据库加载数据到内存的工作线程数量，即同时查询经过划分之后的小数据源的并行度，默认为 1，上述脚本中通过 submitjob 的参数设置为 3。</p><p class="- topic/p p">对数据库表的回放过程分为两步，其一是通过 SQL 查询历史数据至内存，查询包括对数据的排序，其二是将内存中的数据写入输出表，两步以流水线的方式执行。若将某日数据全部导入内存并排序，会占用大量内存甚至导致内存不足，同时由于全部数据的查询耗时比较长，会导致第二步写入输出表的时刻也相应推迟。以 orderDS 为例，若不设置 timeRepartitionSchema 参数，则相应的 SQL 查询为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span> order by Time</pre><p class="- topic/p p">因此针对大数据量的场景，本教程先对 replayDS 函数指定 timeRepartitionSchema 参数，将数据按照时间戳分为 100 个小数据源，则每次查询的最小单位为其中一个小数据源，同时提高 parallelLevel 参数来帮助提升查询速度。以 orderDS 为例，若设置上述 timeRepartitionSchema 参数，则相应的其中一个 SQL 查询为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">select * <strong class="hl-keyword">from</strong> loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>) where Date = <span class="hl-number">2020.12</span>.<span class="hl-number">31</span>, <span class="hl-number">09</span>:<span class="hl-number">15</span>:<span class="hl-number">00.000</span> &lt;= Time &lt; <span class="hl-number">09</span>:<span class="hl-number">18</span>:<span class="hl-number">27.001</span> order by Time</pre><p class="- topic/p p">后文的 <a class="- topic/xref xref" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95">性能测试</a> 章节利用本节的脚本进行了性能测试，最终总耗时 4m18s，内存占用峰值 4.7GB。内存主要由回放过程中的 SQL 查询和输出表等占用，通过对数据源进行切割以及对输出表进行持久化能有效控制内存使用。</p><p class="- topic/p p">作业运维：在 submitJob 函数提交后，通过 getRecentJobs 函数可以查看后台作业的状态，如果 endTime 和 errorMsg 为空，说明任务正在正常运行中。也可以用 cancelJob 函数取消回放，其输入参数 jobId 通过 getRecentJobs 获取。</p><p class="- topic/p p">若没有可作为数据源的数据库，也可以通过加载 csv 文件至内存中进行回放来快速体验本教程，附录中的数据文件提供了 100 支股票的某日完整行情数据，全部数据在内存中约占 700M。以下脚本需要修改 loadText 的路径为实际的 csv 文本数据存储路径。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">orderDS = select * <strong class="hl-keyword">from</strong> loadText(<span class="hl-string">"/yourDataPath/replayData/order.csv"</span>) order by Time
tradeDS = select * <strong class="hl-keyword">from</strong> loadText(<span class="hl-string">"/yourDataPath/replayData/trade.csv"</span>) order by Time
snapshotDS = select * <strong class="hl-keyword">from</strong> loadText(<span class="hl-string">"/yourDataPath/replayData/snapshot.csv"</span>) order by Time
inputDict = dict([<span class="hl-string">"order"</span>, <span class="hl-string">"trade"</span>, <span class="hl-string">"snapshot"</span>], [orderDS, tradeDS, snapshotDS])

submitJob(<span class="hl-string">"replay"</span>, <span class="hl-string">"replay text"</span>, replay, inputDict, messageStream, `Date, `Time, , , <span class="hl-number">1</span>)</pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="332-消费场景-1在-dolphindb-订阅中实时计算个股交易成本"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.3.2. 消费场景 1：在 DolphinDB 订阅中实时计算个股交易成本</h4><div class="- topic/body body"><p class="- topic/p p">本小节脚本将实时消费小节创建的流数据表 messageStream，使用 asof join 引擎实时关联逐笔成交与快照数据，并计算个股交易成本，完整脚本见附录 <a class="- topic/xref xref" href="script/stock_market_replay/02.calTradeCost_asofJoin.txt">消费场景 1: 计算个股交易成本_asofJoin 实现. txt</a>。</p><ul class="- topic/ul ul"><li class="- topic/li li">创建计算结果输出表 prevailingQuotes</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">colName = `TradeTime`SecurityID`Price`TradeQty`BidPX1`OfferPX1`Spread`SnapshotTime
colType = [TIME, SYMBOL, DOUBLE, INT, DOUBLE, DOUBLE, DOUBLE, TIME]
prevailingQuotesTemp = streamTable(<span class="hl-number">1000000</span>:<span class="hl-number">0</span>, colName, colType)
enableTableShareAndPersistence(table=prevailingQuotesTemp, tableName=<span class="hl-string">"prevailingQuotes"</span>, asynWrite=true, compress=true, cacheSize=<span class="hl-number">1000000</span>, retentionMinutes=<span class="hl-number">1440</span>, flushMode=<span class="hl-number">0</span>, preCache=<span class="hl-number">10000</span>)
prevailingQuotesTemp = NULL</pre><p class="- topic/p p">prevailingQuotes 被定义为共享流数据表，之后可以对其进行订阅和进一步的处理。</p><ul class="- topic/ul ul"><li class="- topic/li li">创建流计算 asof join 引擎</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">def</strong> createSchemaTable(dbName, tableName){
	schema = loadTable(dbName, tableName).schema().colDefs
	<strong class="hl-keyword">return</strong> table(<span class="hl-number">1</span>:<span class="hl-number">0</span>, schema.name, schema.typeString)
}
tradeSchema = createSchemaTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>)
snapshotSchema = createSchemaTable(<span class="hl-string">"dfs://snapshot"</span>, <span class="hl-string">"snapshot"</span>)

joinEngine=createAsofJoinEngine(name=<span class="hl-string">"tradeJoinSnapshot"</span>, leftTable=tradeSchema, rightTable=snapshotSchema, outputTable=prevailingQuotes, metrics=&lt;[Price, TradeQty, BidPX1, OfferPX1, abs(Price-(BidPX1+OfferPX1)/<span class="hl-number">2</span>), snapshotSchema.Time]&gt;, matchingColumn=`SecurityID, timeColumn=`Time, useSystemTime=false, delayedTime=<span class="hl-number">1</span>)</pre><p class="- topic/p p">使用 asof join 引擎实现在对股票分组的基础上，对于每条输入的 trade 记录，实时关联与之在时间列上最接近的一条 snapshot 记录，并使用 trade 中的价格字段和 snapshot 中的报价字段进行指标计算。最终，以上配置的 asof join 引擎会输出和左表行数相同的结果。asof join 引擎更多介绍请参考第八章 <code class="+ topic/ph pr-d/codeph ph codeph">createAsofJoinEngine</code>的相关介绍。</p><p class="- topic/p p">考虑到实际的业务含义，此例中 asof join 引擎在用于两个数据流的实时关联时，配置参数 useSystemTime=false 以按照数据中的时间列进行关联计算。使用数据中的时间列，相较于使用数据注入引擎时的系统时间作为时间列，可以避免在实时场景中两个数据流到达引擎的时刻乱序而带来的问题。但是，在此处，因为异构回放能够严格保证两个数据流的处理顺序，因此也可以使用数据注入引擎的系统时间进行关联计算。除了在使用 asof join 引擎时配置参数 useSystemTime=true 外，使用 look up join 引擎也能够实现按系统时间进行实时关联，即当每一条 trade 表中的记录注入引擎时，总是立刻去关联已经注入引擎的最新的一条相应股票的 snapshot 记录，得到的计算结果会同上文中的 asof join 引擎实现完全一致，而由于 look up join 引擎在内部实现上更简单，所以在计算性能上会有稍好的表现，完成脚本见附录 <a class="- topic/xref xref" href="script/stock_market_replay/03.calTradeCost_lookUpJoin.txt">消费场景 1: 计算个股交易成本_lookUpJoin 实现. txt</a>。look up join 引擎更多介绍请参考第八章中<code class="+ topic/ph pr-d/codeph ph codeph">createLookUpJoinEngine</code>的相关介绍。</p><p class="- topic/p p">自定义函数 createSchemaTable，用于获取数据库表的表结构，以做为创建引擎时的参数传入。</p><ul class="- topic/ul ul"><li class="- topic/li li">创建流计算过滤与分发引擎</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">def</strong> appendLeftStream(msg){
	tempMsg = select * <strong class="hl-keyword">from</strong> msg where Price &gt; <span class="hl-number">0</span> <strong class="hl-keyword">and</strong> Time&gt;=<span class="hl-number">09</span>:<span class="hl-number">30</span>:<span class="hl-number">00.000</span>
	getLeftStream(getStreamEngine(`tradeJoinSnapshot)).tableInsert(tempMsg)
}
filter1 = dict(STRING,ANY)
filter1[<span class="hl-string">"condition"</span>] = <span class="hl-string">"trade"</span>
filter1[<span class="hl-string">"handler"</span>] = appendLeftStream
filter2 = dict(STRING,ANY)
filter2[<span class="hl-string">"condition"</span>] = <span class="hl-string">"snapshot"</span>
filter2[<span class="hl-string">"handler"</span>] = getRightStream(getStreamEngine(`tradeJoinSnapshot))
schema = dict([<span class="hl-string">"trade"</span>, <span class="hl-string">"snapshot"</span>], [tradeSchema, snapshotSchema])
engine = streamFilter(name=<span class="hl-string">"streamFilter"</span>, dummyTable=messageStream, filter=[filter1, filter2], msgSchema=schema)</pre><p class="- topic/p p">streamFilter 函数通过设置 msgSchema 参数，会对异构流数据表进行反序列，并根据 filter 参数中设置的 handler 来处理订阅的数据。当订阅数据到来时，handler 之间是串行执行的，这样就保证了对数据的处理严格按照时序进行。</p><p class="- topic/p p">handler 参数是一元函数或数据表，用于处理订阅的数据。当它是函数时，其唯一的参数是经过解析和过滤后的数据表。这里对于 trade 数据其 handler 设置为函数 appendLeftStream，该函数对订阅到的数据首先做过滤，再将符合条件的数据作为左表写入到 asof join 引擎。对于 snapshot 数据其 handler 设置为 asof join 引擎的右表，表示对于订阅到的 snapshot 数据直接作为右表写入 asof join 引擎。</p><ul class="- topic/ul ul"><li class="- topic/li li">订阅异构流数据表</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">subscribeTable(tableName=<span class="hl-string">"messageStream"</span>, actionName=<span class="hl-string">"tradeJoinSnapshot"</span>, offset=-<span class="hl-number">1</span>, handler=engine, msgAsTable=true, reconnect=true)</pre><p class="- topic/p p">设置参数 offset 为 -1，订阅将会从提交订阅时流数据表的当前行开始。为了消费到完整的数据，建议先执行此处脚本以提交订阅，再提交后台回放作业，参考 3.3.1 小节。</p><ul class="- topic/ul ul"><li class="- topic/li li">查看计算结果</li></ul><br/><img class="- topic/image image" src="images/stock_market_replay/prevailingQuotes.png"/><br/><p class="- topic/p p">asof join 引擎在 matchingColumn 的分组内输出表数据与输入时的顺序一致。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="333-消费场景-2在-dolphindb-订阅中将回放结果实时推送-kafka"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.3.3. 消费场景 2：在 DolphinDB 订阅中将回放结果实时推送 Kafka</h4><div class="- topic/body body"><p class="- topic/p p">本小节脚本将前文中创建的流数据表 messageStream 实时发送至消息中间件 Kafka。执行以下脚本，需要有可以写入的 Kafka server，并且安装 DolphinDB Kafka 插件，插件配置见后文<a class="- topic/xref xref" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">开发环境配置</a>。完整脚本见附录 <a class="- topic/xref xref" href="script/stock_market_replay/04.publishToKafka.txt">消费场景 2: 实时推送 Kafka.txt</a>。</p><ul class="- topic/ul ul"><li class="- topic/li li">加载 Kafka 插件并创建 Kafka producer</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">loadPlugin(<span class="hl-string">"/DolphinDB/server/plugins/kafka/PluginKafka.txt"</span>)
go
producerCfg = dict(STRING, ANY)
producerCfg[<span class="hl-string">"metadata.broker.list"</span>] = <span class="hl-string">"localhost"</span>
producer = kafka::producer(producerCfg)</pre><p class="- topic/p p">loadPlugin 的路径和 producer 配置请按需修改。本教程涉及的 Kafka server 和 DolphinDB server 在同一台服务器上，故 metadata.broker.list 参数为 localhost。</p><ul class="- topic/ul ul"><li class="- topic/li li">定义推送数据至 Kafka topic 的函数</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">def</strong> sendMsgToKafkaFunc(dataType, producer, msg){
	startTime = now()
	<strong class="hl-keyword">try</strong> {
		kafka::produce(producer, <span class="hl-string">"topic-message"</span>, <span class="hl-number">1</span>, msg, true)
		cost = now() - startTime
		writeLog(<span class="hl-string">"[Kafka Plugin] Successed to send"</span> + dataType + <span class="hl-string">":"</span> + msg.size() + <span class="hl-string">"rows,"</span> + cost + <span class="hl-string">"ms."</span>)
	}
	catch(ex) {writeLog(<span class="hl-string">"[Kafka Plugin] Failed to send msg to kafka with error:"</span> +ex)}
}</pre><p class="- topic/p p">kafka::produce 函数会将任意表结构的 msg 以 json 格式发送至指定的 Kafka topic。此处的 writeLog 函数在日志中打印每批推送的情况来方便运维观察。</p><ul class="- topic/ul ul"><li class="- topic/li li">注册流数据过滤与分发引擎</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">filter1 = dict(STRING,ANY)
filter1[<span class="hl-string">"condition"</span>] =  <span class="hl-string">"order"</span>
filter1[<span class="hl-string">"handler"</span>] = sendMsgToKafkaFunc{<span class="hl-string">"order"</span>, producer}
filter2 = dict(STRING,ANY)
filter2[<span class="hl-string">"condition"</span>] = <span class="hl-string">"trade"</span>
filter2[<span class="hl-string">"handler"</span>] = sendMsgToKafkaFunc{<span class="hl-string">"trade"</span>, producer}
filter3 = dict(STRING,ANY)
filter3[<span class="hl-string">"condition"</span>] = <span class="hl-string">"snapshot"</span>
filter3[<span class="hl-string">"handler"</span>] = sendMsgToKafkaFunc{<span class="hl-string">"snapshot"</span>, producer}

schema = dict([<span class="hl-string">"order"</span>,<span class="hl-string">"trade"</span>, <span class="hl-string">"snapshot"</span>], [loadTable(<span class="hl-string">"dfs://order"</span>, <span class="hl-string">"order"</span>), loadTable(<span class="hl-string">"dfs://trade"</span>, <span class="hl-string">"trade"</span>), loadTable(<span class="hl-string">"dfs://snapshot"</span>, <span class="hl-string">"snapshot"</span>)])

engine = streamFilter(name=<span class="hl-string">"streamFilter"</span>, dummyTable=messageStream, filter=[filter1, filter2, filter3], msgSchema=schema)</pre><p class="- topic/p p">streamFilter 函数通过设置 msgSchema 参数，会对异构流数据表进行反序列，并根据 filter 参数中设置的 handler 来处理订阅的数据。当订阅数据到来时，handler 之间是串行执行的，这样就保证了对数据的处理严格按照时序进行。</p><p class="- topic/p p">handler 参数是一元函数或数据表，用于处理订阅的数据。当它是函数时，其唯一的参数是经过解析和过滤后的数据表。sendMsgToKafka{"order", producer} 的写法是函数化编程中的部分应用，即指定函数 sendMsgToKafka 的部分参数，产生一个参数较少的新函数。</p><ul class="- topic/ul ul"><li class="- topic/li li">订阅异构流数据表</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock python">subscribeTable(tableName=<span class="hl-string">"messageStream"</span>, actionName=<span class="hl-string">"sendMsgToKafka"</span>, offset=-<span class="hl-number">1</span>, handler=engine, msgAsTable=true, reconnect=true)</pre><p class="- topic/p p">设置参数 offset 为 -1，订阅将会从提交订阅时流数据表的当前行开始。为了消费到完整的数据，建议先执行此处脚本以提交订阅，再提交后台回放作业，参考 3.3.1 小节。</p><ul class="- topic/ul ul"><li class="- topic/li li">在终端查看发送结果</li></ul><p class="- topic/p p">在命令行开启消费者进程，从第一条开始消费名为 topic-message 的 topic</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --from-beginning --topic topic-message</code></pre><p class="- topic/p p">返回：</p><br/><img class="- topic/image image" src="images/stock_market_replay/KafkaToipic.png"/><br/></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="334-消费场景-3在外部程序中通过-capi-实时订阅与处理"><h4 class="- topic/title title topictitle4" id="ariaid-title13">3.3.4. 消费场景 3：在外部程序中通过 C++API 实时订阅与处理</h4><div class="- topic/body body"><p class="- topic/p p">本小节代码为 C++ 程序，程序会订阅前文创建的异构流数据表 messageStream，并实时打印每条数据。以下代码依赖DolphinDB C++ API，API安装见后文<a class="- topic/xref xref" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">开发环境配置</a>。完整代码见附录 <a class="- topic/xref xref" href="script/stock_market_replay/05.subscribe.cpp">消费场景 3:C++API 实时订阅. cpp</a>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock c++"><code>int main(int argc, char *argv[]){
    DBConnection conn;
    string hostName = "127.0.0.1";
    int port = 8848;
    bool ret = conn.connect(hostName, port);

    conn.run("login(\"admin\", \"123456\")");
    DictionarySP t1schema = conn.run("loadTable(\"dfs://snapshotL2\", \"snapshotL2\").schema()");
    DictionarySP t2schema = conn.run("loadTable(\"dfs://trade\", \"trade\").schema()");
    DictionarySP t3schema = conn.run("loadTable(\"dfs://order\", \"order\").schema()");

    unordered_map&lt;string, DictionarySP&gt; sym2schema;
    sym2schema["snapshot"] = t1schema;
    sym2schema["trade"] = t2schema;
    sym2schema["order"] = t3schema;
    StreamDeserializerSP sdsp = new StreamDeserializer(sym2schema);
    auto myHandler = [&amp;](Message msg) {
            const string &amp;symbol = msg.getSymbol();
            cout &lt;&lt; symbol &lt;&lt; ":";
            size_t len = msg-&gt;size();
            for (int i = 0; i &lt; len; i++) {
                    cout &lt;&lt;msg-&gt;get(i)-&gt;getString() &lt;&lt; ",";
            }
            cout &lt;&lt; endl;
    };

    int listenport = 10260;
    ThreadedClient threadedClient(listenport);
    auto thread = threadedClient.subscribe(hostName, port, myHandler, "messageStream", "printMessageStream", -1, true, nullptr, false, false, sdsp);
    cout&lt;&lt;"Successed to subscribe messageStream"&lt;&lt;endl;
    thread-&gt;join();

    return 0;
}</code></pre><p class="- topic/p p">调用订阅函数 ThreadedClient::subscribe 订阅异构流数据表时，在最后一个参数指定相应的流数据反序列化实例 StreamDeserializerSP，则在订阅时会对收到的数据进行反序列化再传递给用户自定义的回调函数 myHandler。</p><p class="- topic/p p">listenport 参数为单线程客户端的订阅端口号，设置 C++ 程序所在服务器的任意空闲端口即可。</p><ul class="- topic/ul ul"><li class="- topic/li li">在终端查看程序实时打印的内容：</li></ul><br/><img class="- topic/image image" src="images/stock_market_replay/C++API.png"/><br/></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="335-清理环境"><h4 class="- topic/title title topictitle4" id="ariaid-title14">3.3.5. 清理环境</h4><div class="- topic/body body"><p class="- topic/p p">如果反复执行上述脚本，可能需要清理流数据表、取消订阅、注销流计算引擎等操作，建议在运行回放与消费脚本前先清理环境。本教程的清理环境脚本见附录 <a class="- topic/xref xref" href="script/stock_market_replay/06.cleanEnvironment.txt">清理环境. txt</a>。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title15" id="4-性能测试"><h2 class="- topic/title title topictitle2" id="ariaid-title15">4. 性能测试</h2><div class="- topic/body body"><p class="- topic/p p">本教程对异构模式下的多表回放功能进行了性能测试。以第三章提及的测试数据集作为回放的输入，以第三章第三小节的回放脚本作为测试脚本，该脚本不设定回放速率（即以最快的速率回放），并且输出表没有任何订阅，最终回放了 101,081,629 条数据至输出表中，总耗时 4m18s，每秒回放约 39 万条数据，内存占用峰值 4.7GB。测试使用的服务器的 CPU 为 Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz，更详细的服务器及DolphinDB server配置信息见后文<a class="- topic/xref xref" href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">开发环境配置</a>。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title16" id="5-开发环境配置"><h2 class="- topic/title title topictitle2" id="ariaid-title16">5. 开发环境配置</h2><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">服务器环境</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">CPU 类型：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz</li><li class="- topic/li li">逻辑 CPU 总数：8</li><li class="- topic/li li">内存：64GB</li><li class="- topic/li li">OS：64 位 CentOS Linux 7 (Core)</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">DolphinDB server 部署</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">server 版本：2.00.6</li><li class="- topic/li li">server 部署模式：单节点</li><li class="- topic/li li">配置文件：dolphindb.cfg</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>localSite=localhost:8848:local8848
mode=single
maxMemSize=32
maxConnections=512
workerNum=8
maxConnectionPerSite=15
newValuePartitionPolicy=add
webWorkerNum=2
dataSync=1
persistenceDir=/DolphinDB/server/persistenceDir
maxPubConnections=64
subExecutors=16
subPort=8849
subThrottle=1
persistenceWorkerNum=1
lanCluster=0</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>： 配置参数 <code class="+ topic/ph pr-d/codeph ph codeph">persistenceDir</code> 需要开发人员根据实际环境配置。</p><p class="- topic/p p">单节点部署教程：<a class="- topic/xref xref" href="standalone_server.html">单节点部署</a></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">DolphinDB client 开发环境</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">CPU 类型：Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz   3.60 GHz</li><li class="- topic/li li">逻辑 CPU 总数：8</li><li class="- topic/li li">内存：32GB</li><li class="- topic/li li">OS：Windows 10 专业版</li><li class="- topic/li li">DolphinDB GUI 版本：1.30.15</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">DolphinDB Kafka 插件安装</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">Kafka 插件版本：release200</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>： Kafka 插件版本建议按 DolphinDB server 版本选择，如 2.00.6 版本的 server 安装 release200 分支的插件</p><p class="- topic/p p">Kafka 插件教程：<a class="- topic/xref xref" href="../plugins/kafka/kafka.html">Kafka 插件教程</a></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">Kafka server 部署</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">zookeeper 版本：3.4.6</li><li class="- topic/li li">Kafka 版本：2.12-2.6.2</li><li class="- topic/li li">Kafka 部署模式：单节点</li><li class="- topic/li li">创建 Kafka topic</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 4 --topic topic-message</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">DolphinDB C++ API 安装</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">C++ API 版本：release200</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>： C++API 版本建议按 DolphinDB server 版本选择，如 2.00.6 版本的 server 安装 release200 分支的 API。</p><p class="- topic/p p"><a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/cppdoc/cpp_api.html" target="_blank" rel="external noopener">C++ API教程</a></p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="6-附录"><h2 class="- topic/title title topictitle2" id="ariaid-title17">6. 附录</h2><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/01.stockMarketReplay.txt">股票行情回放.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/02.calTradeCost_asofJoin.txt">消费场景1：计算个股交易成本 _asofJoin 实现.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/03.calTradeCost_lookUpJoin.txt">消费场景1：计算个股交易成本 _lookUpJoin 实现.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/04.publishToKafka.txt">消费场景2：实时推送 Kafka.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/05.subscribe.cpp">消费场景3：C++API 实时订阅.cpp</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/stock_market_replay/06.cleanEnvironment.txt">清理环境.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="https://www.dolphindb.cn/downloads/docs/stock_market_replay.zip" target="_blank" rel="external noopener">样例数据：order.csv, trade.csv与snapshot.csv</a></li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E5%8D%95%E8%A1%A8%E5%9B%9E%E6%94%BE" data-tocid="1-单表回放">1. 单表回放</a></li><li class="topic-item"><a href="#2-%E5%A4%9A%E8%A1%A8%E5%9B%9E%E6%94%BE" data-tocid="2-多表回放">2. 多表回放</a><ul><li class="topic-item"><a href="#21-n-%E5%AF%B9-n%E5%9B%9E%E6%94%BE" data-tocid="21-n-对-n回放">2.1. N 对 N回放</a></li><li class="topic-item"><a href="#22-n-%E5%AF%B9-1-%E5%BC%82%E6%9E%84%E5%9B%9E%E6%94%BE" data-tocid="22-n-对-1-异构回放">2.2. N 对 1 异构回放</a></li></ul></li><li class="topic-item"><a href="#3-%E5%A4%9A%E8%A1%A8%E5%9B%9E%E6%94%BE%E5%BA%94%E7%94%A8%E8%82%A1%E7%A5%A8%E8%A1%8C%E6%83%85%E5%9B%9E%E6%94%BE" data-tocid="3-多表回放应用股票行情回放">3. 多表回放应用：股票行情回放</a><ul><li class="topic-item"><a href="#31-%E8%A1%8C%E6%83%85%E5%9B%9E%E6%94%BE%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%96%B9%E6%A1%88" data-tocid="31-行情回放与消费方案">3.1. 行情回放与消费方案</a></li><li class="topic-item"><a href="#32-%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E9%9B%86" data-tocid="32-测试数据集">3.2. 测试数据集</a></li><li class="topic-item"><a href="#33-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" data-tocid="33-代码实现">3.3. 代码实现</a><ul><li class="topic-item"><a href="#331-%E8%82%A1%E7%A5%A8%E8%A1%8C%E6%83%85%E5%9B%9E%E6%94%BE" data-tocid="331-股票行情回放">3.3.1. 股票行情回放</a></li><li class="topic-item"><a href="#332-%E6%B6%88%E8%B4%B9%E5%9C%BA%E6%99%AF-1%E5%9C%A8-dolphindb-%E8%AE%A2%E9%98%85%E4%B8%AD%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97%E4%B8%AA%E8%82%A1%E4%BA%A4%E6%98%93%E6%88%90%E6%9C%AC" data-tocid="332-消费场景-1在-dolphindb-订阅中实时计算个股交易成本">3.3.2. 消费场景 1：在 DolphinDB 订阅中实时计算个股交易成本</a></li><li class="topic-item"><a href="#333-%E6%B6%88%E8%B4%B9%E5%9C%BA%E6%99%AF-2%E5%9C%A8-dolphindb-%E8%AE%A2%E9%98%85%E4%B8%AD%E5%B0%86%E5%9B%9E%E6%94%BE%E7%BB%93%E6%9E%9C%E5%AE%9E%E6%97%B6%E6%8E%A8%E9%80%81-kafka" data-tocid="333-消费场景-2在-dolphindb-订阅中将回放结果实时推送-kafka">3.3.3. 消费场景 2：在 DolphinDB 订阅中将回放结果实时推送 Kafka</a></li><li class="topic-item"><a href="#334-%E6%B6%88%E8%B4%B9%E5%9C%BA%E6%99%AF-3%E5%9C%A8%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%80%9A%E8%BF%87-capi-%E5%AE%9E%E6%97%B6%E8%AE%A2%E9%98%85%E4%B8%8E%E5%A4%84%E7%90%86" data-tocid="334-消费场景-3在外部程序中通过-capi-实时订阅与处理">3.3.4. 消费场景 3：在外部程序中通过 C++API 实时订阅与处理</a></li><li class="topic-item"><a href="#335-%E6%B8%85%E7%90%86%E7%8E%AF%E5%A2%83" data-tocid="335-清理环境">3.3.5. 清理环境</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="4-性能测试">4. 性能测试</a></li><li class="topic-item"><a href="#5-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE" data-tocid="5-开发环境配置">5. 开发环境配置</a></li><li class="topic-item"><a href="#6-%E9%99%84%E5%BD%95" data-tocid="6-附录">6. 附录</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>