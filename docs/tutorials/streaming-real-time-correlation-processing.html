<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在进行数据分析时经常需要对多个不同的数据源进行关联操作，因此在各类数据库的 SQL 语言中均包含了丰富的 join 语句，以支持批计算中的多种关联操作。DolphinDB 不仅通过 join ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../stream/str_intro.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="多数据源流式实时关联处理"/><title>多数据源流式实时关联处理</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;多数据源流式实时关联处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;多数据源流式实时关联处理&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在进行数据分析时经常需要对多个不同的数据源进行关联操作，因此在各类数据库的 SQL 语言中均包含了丰富的 join 语句，以支持批计算中的多种关联操作。DolphinDB 不仅通过 join 语法支持了对于全量历史数据的关联处理，而且在要求低延时的实时计算场景中，也提供了多种流数据连接引擎来支持对不断增长的数据流进行实时的关联处理。流数据连接引擎在内部实现上以增量计算为原则，在大数据流量下依然能够保持毫秒级的时延性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;本教程将系统地介绍 DolphinDB 中的 5 种不同的流数据连接引擎，从实时数据流关联、DolphinDB 连接引擎分类、用连接引擎实现金融应用场景等方面层层递进，帮助用户深入理解 DolphinDB 的流计算连接引擎和快速上手多数据源实时关联处理。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;DolphinDB 2.00.8 及以上版本支持本篇所有代码。此外，1.30.20 及以上版本支持除 3.2 小节外的所有代码，细节会在该小节内详细说明。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:61;99:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../stream/str_intro.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;流数据&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 流数据引擎及流数据计算的基本概念&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-流数据实时关联&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;1. 流数据实时关联&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;本章从 DolphinDB 中批计算的表关联语法 join 讲起，介绍实时数据流关联面临的挑战。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;11-dolphindb-批计算表关联&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;1.1. DolphinDB 批计算表关联&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在批计算场景中，DolphinDB SQL 语句中不仅提供了与传统关系型数据库类似的 equi join, full join, left join, prefix join, cross join 等表连接方式，还提供了两种专门为时序数据设计的连接方式：asof join 和 window join。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以下是一个简单的 asof join 批计算的示例，更详细应用介绍请参考：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://ask.dolphindb.cn/blog/9&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;17:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;应用教程：使用 Asof Join, Window Join 快速估计个股交易成本&lt;/xref&gt;。我们将通过它进一步分析实时连接中的挑战。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// data t1 = table(take(`A, 4) as Sym, 10:10:03.000+(10 2100 2890 6030) as Time, 12.5 12.5 12.6 12.6 as Price) t2 = table(take(`A, 4) as Sym, 10:10:00.000+(0 3000 6000 9000) as Time, 12.6 12.5 12.7 12.6 as BidPrice) // asof join calculation select * from aj(t1, t2, `Time)&lt;/codeblock&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/1_1.png&#34; width=&#34;70%&#34; xtrc=&#34;image:1;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;624&#34; dita-ot:image-height=&#34;142&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;asof join 能够关联当前时刻或距离当前时刻最近时刻的数据。指定连接列为 Time 字段后，如上图所示，t1 表的每行记录总是关联 t2 表中 Time 值小于它的 Time 值的那一行 t2 记录。关联后的结果如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/1_2.png&#34; width=&#34;50%&#34; xtrc=&#34;image:2;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;369&#34; dita-ot:image-height=&#34;106&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;12-实时数据流关联面临的挑战&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;1.2. 实时数据流关联面临的挑战&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;批计算的关联操作，作为计算输入的 t1 表和 t2 表的数据是有界的，关联操作作用在全量输入数据上，计算结果一次性全量输出。现在考虑一下实时关联的场景，首先在输入上，t1, t2 的记录数会不断增长，表现为数据无界且无法预知下一条记录何时到来，比如股票市场中的交易数据、行情快照数据，而对于关联结果，我们会希望在每一条输入到来后尽快且尽可能正确地输出结果记录，这时计算是不断增量进行的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;那么，对于流式的实时关联场景，我们需要解决以下两个问题：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;何时触发计算并输出：以上面的 asof join 为例，数据流 t1 中第一条记录（Time 值为 10:10:03:010）到达系统时，假设 t2 数据流中也有一条记录（Time 为 10:10:00.000），此时实时计算模块是决定关联目前 t2 中最近的一条记录并输出，还是等待某个触发条件再关联输出，这是技术实现上要解决的问题。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;如何管理内存：为了能够正确地关联到两个数据流，实时计算模块需要缓存历史的数据流，而输入是源源不断的，则需要历史数据的清理机制。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-流数据连接引擎&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2. 流数据连接引擎&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;DolphinDB 提供了 createAsofJoinEngine, createWindowJoinEngine, createEquiJoinEngine, createLeftSemiJoinEngine, createLookupJoinEngine 等 5 种不同的流计算连接引擎函数，不同连接引擎的关联规则基本上与批计算中相应的 join 类似，差异将在后续小节中详细说明。本章首先概述 DolphinDB 流计算引擎，之后依次介绍各个引擎的原理和效果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;流计算连接引擎是 DolphinDB 中对数据流进行实时关联的计算模块，可以理解为一个设置了关联规则的计算黑盒，输入为 2 条数据流，输出为 1 条数据流，引擎内部会自动维护计算状态。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_1.png&#34; width=&#34;60%&#34; xtrc=&#34;image:3;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;530&#34; dita-ot:image-height=&#34;146&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;51:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以下代码是 1.1 小节中的 asof join SQL 的流计算实现的脚本，首先创建 2 个流数据表作为输入、1 个流数据表作为输出，然后通过函数 createAsofJoinEngine 创建流计算引擎，之后通过函数 subscribeTable 分别订阅 2 个流数据表并将数据实时注入流计算引擎的左、右表。之后当数据不断写入两个流数据表时，输出结果表 output 中的记录数会相应地增加。流数据订阅功能更详细的介绍见 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;streaming_tutorial.md&#34; xtrc=&#34;xref:2;51:215&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;流数据订阅&lt;/xref&gt; 。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`Time`Price, [SYMBOL, TIME, DOUBLE]) as trade share streamTable(1:0, `Sym`Time`BidPrice, [SYMBOL, TIME, DOUBLE]) as snapshot share table(1:0, `Time`Sym`Price`t2_Time`BidPrice, [TIME, SYMBOL, DOUBLE, TIME, DOUBLE]) as output // create engine ajEngine = createAsofJoinEngine(name=&#34;asofJoin&#34;, leftTable=trade, rightTable=snapshot, outputTable=output, metrics=&amp;lt;[Price, snapshot.Time, BidPrice]&amp;gt;, matchingColumn=`Sym, timeColumn=`Time, useSystemTime=false, delayedTime=1000) // subscribe topic subscribeTable(tableName=&#34;trade&#34;, actionName=&#34;joinLeft&#34;, offset=0, handler=getLeftStream(ajEngine), msgAsTable=true) subscribeTable(tableName=&#34;snapshot&#34;, actionName=&#34;joinRight&#34;, offset=0, handler=getRightStream(ajEngine), msgAsTable=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以下代码构造输入数据并写入 2 个流数据表，查看结果表 output 将看到引擎计算的结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;69:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data t1 = table(take(`A, 4) as Sym, 10:10:03.000+(10 2100 2890 6030) as Time, 12.5 12.5 12.6 12.6 as Price) t2 = table(take(`A, 4) as Sym, 10:10:00.000+(0 3000 6000 9000) as Time, 12.6 12.5 12.7 12.6 as BidPrice) // input data snapshot.append!(t2) trade.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;流计算连接引擎通过内置实现和简单的参数接口来解决上一章提到的实时数据流关联的问题。对于内存管理，每个引擎都提供了 garbageSize 参数来清理不再需要的历史数据。对于触发计算的机制，不同的引擎会稍有不同，可以大致分为以下几类：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;若关联计算依赖数据的时间顺序，则处理的方式有：&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:2;81:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;81:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以数据注入引擎时的系统时间为时序标准&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;82:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以数据中的时间列为时序标准，这种情况下因为无法预知后续将到达的数据的时间戳，则时序判断以最新的时间戳为依据，认为时间戳早于它的全部数据都已经到齐，同时辅以超时强制触发的规则&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联计算不依赖数据的时间顺序，则处理的方式有：&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:3;84:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;84:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在数据注入引擎时立即计算输出&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;85:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;等待到匹配数据后才计算输出，同时辅以超时强制触发的规则&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联规则和触发规则决定了引擎的计算结果，下面我们详细介绍每一个连接引擎的原理和关联效果。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-asof-join-引擎createasofjoinengine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2.1. Asof Join 引擎（createAsofJoinEngine）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Asof Join 引擎的连接机制类似于 SQL 中的 asof join，按连接列分组，在每个分组内按时间邻近度关联左右表。引擎默认左右表是有序的，在连接列分组内，对于左表的每一条记录，当引擎判断邻近的时刻到来后，在右表缓存中选取在该条左表记录的时刻之前且最接近的一条记录，不论是否找到，引擎都将输出一条结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Asof join 引擎在创建时通过参数 useSystemTime 指定以下两种规则中的一种，用于判断临近时刻是否到来：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;规则一：以数据注入引擎时的系统时间为时序标准，则每一条左表记录注入引擎时立刻关联并输出；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;96:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;规则二：以数据中的时间列为时序标准，当右表数据的最新时刻大于左表数据的时刻时触发关联并输出。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在规则二的基础上，还可以通过参数 delayedTime 设置超时强制触发规则。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示在一个分组中，以非系统时间触发输出的 Asof Join 引擎效果（未设置超时强制触发），触发输出的时刻由右表到来新数据决定。后文将介绍一个 Asof Join 引擎的实际应用场景：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-asof-join-引擎计算个股交易成本&#34; xtrc=&#34;xref:3;100:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;计算个股交易成本&lt;/xref&gt;。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_2.png&#34; width=&#34;60%&#34; xtrc=&#34;image:4;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;649&#34; dita-ot:image-height=&#34;152&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-window-join-引擎createwindowjoinengine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2.2. Window Join 引擎（createWindowJoinEngine）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;106:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Window Join 引擎的连接机制类似于 SQL 中的 window join，上一小节的 Asof Join 引擎可以看做是 Window Join 引擎的一个特例。按连接列分组，在每个分组内按时间邻近关联右表一个时间窗口内的数据，这个窗口由左表的每一条记录的时刻和创建引擎时指定的窗口（参数 window）决定。引擎默认左右表是有序的，在连接列分组内，对于左表中的每一条记录，会在右表缓存中选取由左表的时刻确定的窗口范围内的记录，可能会找到 0 至多条记录，引擎将输出一条结果，这条结果由多条右表记录聚合为一条后与左表拼接而成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Window Join 引擎在创建时通过参数 useSystemTime 指定以下两种规则中的一种，用于判断临近时刻是否到来：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;规则一：以数据注入引擎时的系统时间为时序标准，则系统时间达到窗口下边界时立刻关联并输出；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;规则二：以数据中的时间列为时序标准，当右表数据的最新时刻大于窗口下边界时触发关联并输出。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在规则二的基础上，还可以通过参数 maxDelayedTime 设置超时强制触发规则。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;115:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示在一个分组中，以非系统时间触发输出的普通窗口（参数 window=-1:2）连接的效果，由每一条左表记录基于其时间戳往前 1 个时间刻度、往后 2 个时间刻度划定窗口的上下边界，输出由大于窗口下边界的第一条右表记录触发，窗口计算不包含这条触发记录。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_3.png&#34; width=&#34;60%&#34; xtrc=&#34;image:5;117:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;649&#34; dita-ot:image-height=&#34;152&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;119:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示在一个分组中，以非系统时间触发输出的特殊窗口（参数 window=0:0）连接的效果，窗口范围由相邻两条左表记录划定，输出由等于或大于左表时间戳的第一条右表记录触发，窗口计算不包含这条触发记录。后文将介绍一个基于特殊窗口的窗口关联引擎的实际应用场景：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-window-join-引擎将行情快照与逐笔成交数据融合&#34; xtrc=&#34;xref:4;119:130&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;对行情快照融合逐笔成交数据&lt;/xref&gt;。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_4.png&#34; width=&#34;60%&#34; xtrc=&#34;image:6;121:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;629&#34; dita-ot:image-height=&#34;133&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-equi-join-引擎createequijoinengine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2.3. Equi Join 引擎（createEquiJoinEngine）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;注：自 1.30.21/2.00.9 版本起，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;125:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEqualJoinEngine&lt;/codeph&gt; 更名为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;125:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEquiJoinEngine&lt;/codeph&gt;，原函数名可继续使用。&lt;/i&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Equi Join 引擎的连接机制类似于 SQL 中的 equi join，按连接列和时间列等值关联左右表，对于左表（或右表）中的每一条记录，当它成功匹配上右表（或左表）中连接列一致的一条记录时，引擎将输出一条结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;与 SQL 中的 equi join 不同的是，因为引擎内部并不缓存所有历史数据，所以可能出现左表（或右表）中的某条记录到来后无法关联到已经从引擎缓存中清除的历史右表（或左表）记录，进而不会输出结果。这是由 Equi Join 引擎的设计初衷和内部实现决定的，该引擎是为以连接列和时间列为键值的输入数据设计的，比如每支股票在每分钟有一条记录。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示字段结构为（连接列，时间列，指标）的输入数据注入等值关联引擎的效果。后文 3.3 小节将介绍一个等值关联引擎的实际应用场景：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-equi-join-引擎拼接不同数据源的实时分钟指标&#34; xtrc=&#34;xref:5;131:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;拼接不同数据源的实时分钟指标&lt;/xref&gt;。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_5.png&#34; width=&#34;60%&#34; xtrc=&#34;image:7;133:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;629&#34; dita-ot:image-height=&#34;133&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;135:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;建议按推荐场景使用 Equi Join 引擎，即对连接列和时间列唯一的数据使用本引擎。若非推荐场景，为了理解输出效果，可以参考如下设计原理：Equi Join 引擎内部分别为左右表数据维护两个以连接列和时间列作为键值的键值表作为缓存，并对每条记录标识是否关联过。下面以左表为例介绍，右表同理。当一条左表记录注入引擎，则查找右表缓存，若能成功匹配则输出一条结果，并在右表缓存中标识对应记录为已关联，这时左表缓存中不会保存这条立刻关联输出的左表记录（此原理会导致上图中后续的灰色数据 (A,t1,4) 无法匹配而不输出），若未能匹配成功，则将该条左表记录加入左表缓存，并标识为未关联。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;需要注意，对于缓存中的已关联、未关联的数据，Equi Join 引擎都会进行过期清理，清理原理可参考用户手册。若遵循推荐场景使用此引擎，但是引擎输出结果与 SQL equi join 结果仍不完全一致，则是设置的清理规则导致的差异。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;24-lookup-join-引擎createlookupjoinengine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2.4. Lookup Join 引擎（createLookupJoinEngine）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;141:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Lookup Join 引擎的连接机制类似于 SQL 中的 left join，按连接列等值关联左右表，左表中的每一条记录注入引擎时便立刻关联当前时刻的右表，不论是否在右表中匹配到连接列一致的记录，引擎都会立刻输出一条结果，若未能匹配上则结果中右表相关的字段为空。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;143:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;与 SQL 中的 left join 不同的是，引擎在内部缓存右表的记录时，对于相同连接列的数据总是只保留最新一条，因此对于左表的每一条记录至多只会匹配一条右表记录并输出一次。引擎的右表可以是数据流或者数据集。对于数据流，引擎通过数据流不断地注入引擎来更新内部的右表缓存；对于数据集，引擎通过对数据集的定时查询来更新内部的右表缓存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;145:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示字段结构为（连接列，指标）的输入数据，注入右表保留最新一条记录的 Lookup Join 引擎的效果，左表数据总是在达到后立刻输出。后文将介绍一个 Lookup Join 引擎的实际应用场景：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-lookup-join-引擎将实时行情与历史日频指标关联&#34; xtrc=&#34;xref:6;145:101&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;对实时行情关联历史日频指标&lt;/xref&gt;。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_6.png&#34; width=&#34;60%&#34; xtrc=&#34;image:8;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;629&#34; dita-ot:image-height=&#34;132&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;25-left-semi-join-引擎createleftsemijoinengine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;2.5. Left Semi Join 引擎（createLeftSemiJoinEngine）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Left Semi Join 引擎的连接机制类似于 SQL 中的 equi join，按连接列等值关联左右表，对于左表中的每一条记录，当它成功匹配上右表中连接列一致的一条记录时，引擎将输出一条结果。未成功匹配的左表的记录将一直由引擎缓存，等待与右表中更新的记录匹配。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;153:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;与 SQL 中的 equi join 不同的是，引擎在内部缓存右表的记录时，对于相同连接列的数据总是只保留第一条或者最新一条，因此对于左表的每一条记录至多只会匹配一条右表记录并输出一次。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;下图展示字段结构为（连接列，指标）的输入数据，注入右表保留最新一条记录的 Left Semi Join 引擎的效果，左表数据总是等到匹配成功才输出。后文将分别介绍两个 Left Semi Join 引擎的实际应用场景：一是&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-left-semi-join-引擎对逐笔成交数据补充原始委托信息&#34; xtrc=&#34;xref:7;155:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;对逐笔成交数据补充原始委托信息&lt;/xref&gt;，二是&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-left-semi-join-引擎关联股票与指数行情并计算相关性&#34; xtrc=&#34;xref:8;155:169&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;关联股票和指数行情并计算相关性&lt;/xref&gt;。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/2_7.png&#34; width=&#34;60%&#34; xtrc=&#34;image:9;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;629&#34; dita-ot:image-height=&#34;132&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-实时关联应用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3. 实时关联应用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;DolphinDB 中流计算连接引擎是结合各类实际业务场景而设计的，本章将从 6 个实际应用案例出发介绍各个连接引擎适用的具体场景。为了便于解释关联效果，下文案例中均以少量的模拟数据依次注入右表、左表来模拟数据流输入。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;流计算脚本开发和调试过程中推荐使用 getStreamingStat 函数监控流订阅的状态，getStreamEngineStat 函数监控流数据引擎的状态。此外，文末&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#附录&#34; xtrc=&#34;xref:9;163:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;附录&lt;/xref&gt;中提供了清理流数据环境的通用脚本，用于一键清理所有的流数据表、取消所有的订阅、释放所有的流引擎。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-用-asof-join-引擎计算个股交易成本&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.1. 用 Asof Join 引擎计算个股交易成本&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;因为逐笔成交数据和报价数据的发生时间不可能完全一致而不能使用常用的等值连接，往往需要以成交时间为基准找到交易发生前的最近一次报价数据，因此需要以邻近匹配的方式关联两个数据流。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，每条成交记录匹配一条时刻早于自己的报价记录，输出与原始的每一条成交记录一一对应。以下脚本用 Asof Join 引擎来实现此场景：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;171:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`TradeTime`TradePrice, [SYMBOL, TIME, DOUBLE]) as trades share streamTable(1:0, `Sym`Time`Bid1Price`Ask1Price, [SYMBOL, TIME, DOUBLE, DOUBLE]) as snapshot share streamTable(1:0, `TradeTime`Sym`TradePrice`TradeCost`SnapshotTime, [TIME, SYMBOL, DOUBLE, DOUBLE, TIME]) as output // create engine ajEngine = createAsofJoinEngine(name=&#34;asofJoin&#34;, leftTable=trades, rightTable=snapshot, outputTable=output, metrics=&amp;lt;[TradePrice, abs(TradePrice-(Bid1Price+Ask1Price)/2), snapshot.Time]&amp;gt;, matchingColumn=`Sym, timeColumn=`TradeTime`Time, useSystemTime=false, delayedTime=1000) // subscribe topic subscribeTable(tableName=&#34;trades&#34;, actionName=&#34;appendLeftStream&#34;, handler=getLeftStream(ajEngine), msgAsTable=true, offset=-1, hash=0) subscribeTable(tableName=&#34;snapshot&#34;, actionName=&#34;appendRightStream&#34;, handler=getRightStream(ajEngine), msgAsTable=true, offset=-1, hash=1)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;逐笔成交数据 trades 注入引擎的左表，报价数据 snapshot 注入引擎的右表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 useSystemTime=false 表示通过数据中的时间列（左表为 TradeTime 字段，右表为 Time 字段）来判断左右表中记录的时序关系。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 delayedTime 是对默认触发机制的补充，以超时强制触发的方式保证左表及时匹配并输出。若未设置 delayedTime 是默认触发机制，对于任意一条左表记录，它必须等到右表出现一条时间戳大于它的记录才输出。但考虑到实际的应用场景中，某条右表记录可能迟迟未能到达或者始终不可能出现一条大于某些左表数据的右表记录，同时期望左表中每条记录都能匹配并输出，那么建议设置 dalayTime，在这种情况下将以左表出现更新的数据或者系统时间超时来强制触发计算。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 metrics 中 snapshot.Time 表示取右表 snapshot 中的 Time 字段，因为左表 trades 中也具有 Time 字段，若不加前缀、直接写 Time，则默认取左表的 Time 字段。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;上例中创建引擎时未显式指定 garbageSize，则使用默认值，garbageSize 不论大小均不改变计算结果，只影响引擎的内存占用。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为原始输入的 2 个流数据表，先写入右表，再写入左表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: trade t1 = table(`A`A`B`A`B`B as Sym, 10:00:02.000+(1..6)*700 as TradeTime, (3.4 3.5 7.7 3.5 7.5 7.6) as TradePrice) // generate data: snapshot t2 = table(`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6)*1000 as Time, (3.5 7.6 3.5 7.6) as Bid1Price, (3.5 7.6 3.6 7.6) as Ask1Price) // input data snapshot.append!(t2) trades.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;输入数据与关联关系如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_1.png&#34; width=&#34;70%&#34; xtrc=&#34;image:10;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;675&#34; dita-ot:image-height=&#34;210&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联得到的结果表 output 如下，左表中全部 7 条数据都有对应的输出。本例中，在创建引擎时指定了 delayedTime 参数，因此对于分组 B，即使右表 snapshot 中没有比 10:00:06.200 更大的时间戳，左表 trades 中最后一条数据 (B,10:00:06.200, 7.6) 仍然能够在注入引擎 2s 后强制输出。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_2.png&#34; width=&#34;50%&#34; xtrc=&#34;image:11;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;358&#34; dita-ot:image-height=&#34;149&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-用-window-join-引擎将行情快照与逐笔成交数据融合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.2. 用 Window Join 引擎将行情快照与逐笔成交数据融合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;行情快照和逐笔成交数据包含着不同的信息，很多高频因子的计算同时依赖行情快照和成交数据，本例在行情快照数据的基础上融合前后两个快照之间的逐笔成交数据，融合后的数据可以更方便地作为后续复杂因子的计算的输入。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，每条行情快照记录匹配一个时间窗口内的全部逐笔成交记录的聚合值，这个时间窗口的上下界由两条行情快照数据的时刻决定，输出与原始的每一条行情快照记录一一对应。对于一个窗口中的逐笔成交记录，既需要计算交易量总和这样的聚合值，也希望以一个字段保留窗口内的全部逐笔成交明细。以下脚本用 Window Join 引擎的特殊窗口来实现此场景。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;注意，1.30 版本的 DolphinDB 不支持 array vector 数据形式，以下脚本包含 array vector 功能，因此仅支持 2.00 版本。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;219:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`TradeTime`Side`TradeQty, [SYMBOL, TIME, INT, LONG]) as trades share streamTable(1:0, `Sym`Time`Open`High`Low`Close, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as snapshot share streamTable(1:0, `Time`Sym`Open`High`Low`Close`BuyQty`SellQty`TradeQtyList`TradeTimeList, [TIME, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG[], TIME[]]) as output // create engine wjMetrics = &amp;lt;[Open, High, Low, Close, sum(iif(Side==1, TradeQty, 0)), sum(iif(Side==2, TradeQty, 0)), TradeQty, TradeTime]&amp;gt; fillArray = [00:00:00.000, &#34;&#34;, 0, 0, 0, 0, 0, 0, [], []] wjEngine = createWindowJoinEngine(name=&#34;windowJoin&#34;, leftTable=snapshot, rightTable=trades, outputTable=output, window=0:0, metrics=wjMetrics, matchingColumn=`Sym, timeColumn=`Time`TradeTime, useSystemTime=false, nullFill=fillArray) // subscribe topic subscribeTable(tableName=&#34;snapshot&#34;, actionName=&#34;appendLeftStream&#34;, handler=getLeftStream(wjEngine), msgAsTable=true, offset=-1, hash=0) subscribeTable(tableName=&#34;trades&#34;, actionName=&#34;appendRightStream&#34;, handler=getRightStream(wjEngine), msgAsTable=true, offset=-1, hash=1)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;行情快照数据 snapshot 注入引擎的左表，逐笔成交数据 trades 注入引擎的右表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 useSystemTime=false 表示通过数据中的时间列（左表为 Time 字段，右表为 TradeTime 字段）来判断左右表中记录的时序关系。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 window=0:0 表示右表 trades 的计算窗口将由左表 snapshot 当前和其上一条数据的时间戳划定。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;238:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 metrics 表示计算指标，如 Open 表示取左表 snapshot 中 Open 字段，sum(iif(Side==1, TradeQty, 0)) 表示对右表 trades 在窗口内的数据做聚合计算。注意，TradeQty 是右表 trades 中的字段，且此处对 TradeQty 没有使用聚合函数，则表示对右表 trades 在窗口内的全部 TradeQty 值保留明细，对应的输出为一个数据类型为 array vector 的字段。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎参数 nullFill 为可选参数，表示如何填充输出表中的空值，本例中结合实际场景，对于表示价格的字段如 Open 等都指定将空值填充为 0。注意，nullFill 为元组，必须和输出表列字段等长且类型一一对应。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为原始输入的 2 个流数据表，先写入右表，再写入左表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: snapshot t1 = table(`A`B`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6 9 9)*1000 as Time, (NULL NULL 3.5 7.6 3.5 7.6) as Open, (3.5 7.6 3.6 7.6 3.6 7.6) as High, (3.5 7.6 3.5 7.6 3.4 7.5) as Low, (3.5 7.6 3.5 7.6 3.6 7.5) as Close) // generate data: trade t2 = table(`A`A`B`A`B`B`A`B`A`A as Sym, 10:00:02.000+(1..10)*700 as TradeTime, (1 2 1 1 1 1 2 1 2 2) as Side, (1..10) * 10 as TradeQty) // input data trades.append!(t2) snapshot.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;输入数据与关联关系如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_3.png&#34; width=&#34;80%&#34; xtrc=&#34;image:12;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;749&#34; dita-ot:image-height=&#34;265&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联得到的结果表 output 如下，其中最后两列为 array vector 类型数据，记录了窗口中全部成交记录的 TradeQty 字段明细、TradeTime 字段明细。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;注意，输出表比左表 snapshot 少一条数据，即左表 sanpshot 中分组 B 内时间戳为 10:00:09.000 的数据没有输出，这是因为右表 trades 中分组 B 内没有等于或大于 10:00:09.000 的数据来关闭窗口。在实际生产中，当接入实时数据时，若需要左表 snapshot 一旦达到引擎便立即输出，则建议选择 useSystemTime=true，即用系统时间作为时间戳，这时，对于任意一条左表记录，右表窗口是从前一条左表记录到达到本条记录到达之间进入引擎的全部右表数据。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_4.png&#34; width=&#34;70%&#34; xtrc=&#34;image:13;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;675&#34; dita-ot:image-height=&#34;130&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-用-equi-join-引擎拼接不同数据源的实时分钟指标&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.3. 用 Equi Join 引擎拼接不同数据源的实时分钟指标&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在量化金融的实盘中往往会对原始的行情快照、逐笔成交等进行降采样形成分钟指标，以作为输入提供给进一步的交易策略，这时则需要将多个不同数据源计算出的指标关联到同一张表中。本例将对快照和成交数据分别做实时的 1 分钟聚合，并将快照指标和成交指标关联后输出到同一张宽表中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，每支股票的行情快照分钟指标在每一分钟只有一条记录，逐笔成交分钟指标同样有这样的唯一性，并且在某一分钟的输出上，期望总是在两类指标都计算完成后再将关联输出。以下脚本用 Equi Join 引擎来实现此场景。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;注意：如您使用的 DolphinDB 版本早于 1.30.21/2.00.9，请将脚本中的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;269:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEquiJoinEngine&lt;/codeph&gt; 替换为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;269:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEqualJoinEngine&lt;/codeph&gt;。自 1.30.21/2.00.9 版本起，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;269:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEqualJoinEngine&lt;/codeph&gt; 更名为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;269:148&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;createEquiJoinEngine&lt;/codeph&gt;，原函数名可继续使用。&lt;/i&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`TradeTime`Side`TradeQty, [SYMBOL, TIME, INT, LONG]) as trades share streamTable(1:0, `UpdateTime`Sym`BuyTradeQty`SellTradeQty, [TIME, SYMBOL, LONG, LONG]) as tradesMin share streamTable(1:0, `Sym`Time`Bid1Price`Bid1Qty, [SYMBOL, TIME, DOUBLE, LONG]) as snapshot share streamTable(1:0, `UpdateTime`Sym`AvgBid1Amt, [TIME, SYMBOL, DOUBLE]) as snapshotMin share streamTable(1:0, `UpdateTime`Sym`AvgBid1Amt`BuyTradeQty`SellTradeQty, [TIME, SYMBOL, DOUBLE, LONG, LONG]) as output // create engine: eqJoinEngine = createEquiJoinEngine(name=&#34;EquiJoin&#34;, leftTable=tradesMin, rightTable=snapshotMin, outputTable=output, metrics=&amp;lt;[AvgBid1Amt, BuyTradeQty, SellTradeQty]&amp;gt;, matchingColumn=`Sym, timeColumn=`UpdateTime) // create engine: tsEngine1 = createTimeSeriesEngine(name=&#34;tradesAggr&#34;, windowSize=60000, step=60000, metrics=&amp;lt;[sum(iif(Side==1, 0, TradeQty)), sum(iif(Side==2, 0, TradeQty))]&amp;gt;, dummyTable=trades, outputTable=getLeftStream(eqJoinEngine), timeColumn=`TradeTime, keyColumn=`Sym, useSystemTime=false, fill=(0, 0)) // create engine: tsEngine2 = createTimeSeriesEngine(name=&#34;snapshotAggr&#34;, windowSize=60000, step=60000, metrics=&amp;lt;[avg(iif(Bid1Price!=NULL, Bid1Price*Bid1Qty, 0))]&amp;gt;, dummyTable=snapshot, outputTable=getRightStream(eqJoinEngine), timeColumn=`Time, keyColumn=`Sym, useSystemTime=false, fill=(0.0)) // subscribe topic subscribeTable(tableName=&#34;trades&#34;, actionName=&#34;minAggr&#34;, handler=tsEngine1, msgAsTable=true, offset=-1, hash=1) subscribeTable(tableName=&#34;snapshot&#34;, actionName=&#34;minAggr&#34;, handler=tsEngine2, msgAsTable=true, offset=-1, hash=2) &lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;291:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;291:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;首先用两个独立的时序聚合引擎（createTimeSeriesEngine）对原始的快照和成交数据流按数据中的时间戳做实时聚合、输出每一分钟的指标，之后通过引擎级联的方式，将两个时序聚合引擎的输出分别作为左右表注入连接引擎。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;Equi Join 引擎对左、右表的处理是完全相同的，即上例中在 createEquiJoinEngine 时交换左右表不会影响关联结果。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为原始输入的 2 个流数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: snapshot t1 = table(`A`B`A`B`A`B as Sym, 10:00:52.000+(3 3 6 6 9 9)*1000 as Time, (3.5 7.6 3.6 7.6 3.6 7.6) as Bid1Price, (1000 2000 500 1500 400 1800) as Bid1Qty) // generate data: trade t2 = table(`A`A`B`A`B`B`A`B`B`A as Sym, 10:00:54.000+(1..10)*700 as TradeTime, (1 2 1 1 1 1 2 1 2 2) as Side, (1..10) * 10 as TradeQty) // input trades.append!(t2) snapshot.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;306:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联得到的结果表 output 如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_5.png&#34; width=&#34;50%&#34; xtrc=&#34;image:14;308:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;364&#34; dita-ot:image-height=&#34;68&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-用-lookup-join-引擎将实时行情与历史日频指标关联&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;310:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;310:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.4. 用 Lookup Join 引擎将实时行情与历史日频指标关联&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;310:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;在当日的实时计算中可能会需要依赖历史指标，本例在行情快照的基础上，通过股票代码关联该股票在昨日的日频指标。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，每条快照记录到达后要求立刻关联输出，如果日频数据里没有对应的股票，输出结果对应的字段为空，输出与原始输入中的每一条行情快照记录一一对应。同时，日频指标并非实时数据，而是一个以较低频率更新的有主键的离线数据集。以下脚本用 Lookup Join 引擎来实现此场景。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`Time`Open`High`Low`Close, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as snapshot historicalData = table(`A`B as Sym, (0.8 0.2) as PreWeight, (3.1 7.6) as PreClose) share table(1:0, `Sym`Time`Open`High`Low`Close`PreWeight`PreClose, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output // create engine lookupJoinEngine = createLookupJoinEngine(name=&#34;lookupJoin&#34;, leftTable=snapshot, rightTable=historicalData, outputTable=output, metrics=&amp;lt;[Time, Open, High, Low, Close, PreWeight, PreClose]&amp;gt;, matchingColumn=`Sym, checkTimes=10s) // subscribe topic subscribeTable(tableName=&#34;snapshot&#34;, actionName=&#34;appendLeftStream&#34;, handler=getLeftStream(lookupJoinEngine), msgAsTable=true, offset=-1)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;订阅流数据表 snapshot 注入引擎的左表。引擎右表为普通内存表 historicalData，它不能且不需要进行订阅。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;330:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;引擎会在内部维护一个最新的右表，在创建引擎时会查询右表 historicalData 并缓存在引擎内部。参数 checkTimes=10s 表示之后的每 10s 引擎会再次查询右表 historicalData 并更新一次内部的缓存。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;332:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为引擎左表输入的流数据表 snapshot：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: snapshot t1 = table(`A`B`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6 9 9)*1000 as Time, (3.5 7.6 3.5 7.6 3.5 7.6) as Open, (3.5 7.6 3.6 7.6 3.6 7.6) as High, (3.5 7.6 3.5 7.6 3.4 7.5) as Low, (3.5 7.6 3.5 7.6 3.6 7.5) as Close) snapshot.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;340:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;输入数据与关联关系如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_6.png&#34; width=&#34;80%&#34; xtrc=&#34;image:15;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;691&#34; dita-ot:image-height=&#34;186&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;结果在左表数据到达引擎时立刻输出，关联得到的结果表 output 如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_7.png&#34; width=&#34;60%&#34; xtrc=&#34;image:16;346:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;460&#34; dita-ot:image-height=&#34;149&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-用-left-semi-join-引擎对逐笔成交数据补充原始委托信息&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.5. 用 Left Semi Join 引擎对逐笔成交数据补充原始委托信息&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;逐笔成交数据中包含买卖双方的原始委托订单号，本例通过股票代码和订单号去关联逐笔委托数据，以达到在成交数据的基础上丰富其原始委托信息的目的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，对于每条逐笔成交都应该找到对应的委托单，输出与原始输入中的逐笔成交记录一一对应。在找到对应的委托单前，该条逐笔成交记录暂时不输出。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;以下脚本用两个 Left Semi Join 引擎级联的方式，对成交表 trades 中的卖方委托单、买方委托单依次进行了关联。多个引擎之间采用了引擎级联的方式处理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`BuyNo`SellNo`TradePrice`TradeQty`TradeTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME]) as trades share streamTable(1:0, `Sym`OrderNo`Side`OrderQty`OrderPrice`OrderTime, [SYMBOL, LONG, INT, LONG, DOUBLE, TIME]) as orders share streamTable(1:0, `Sym`SellNo`BuyNo`TradePrice`TradeQty`TradeTime`BuyOrderQty`BuyOrderPrice`BuyOrderTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME, LONG, DOUBLE, TIME]) as outputTemp share streamTable(1:0, `Sym`BuyNo`SellNo`TradePrice`TradeQty`TradeTime`BuyOrderQty`BuyOrderPrice`BuyOrderTime`SellOrderQty`SellOrderPrice`SellOrderTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME, LONG, DOUBLE, TIME, LONG, DOUBLE, TIME]) as output // create engine: left join buy order ljEngineBuy=createLeftSemiJoinEngine(name=&#34;leftJoinBuy&#34;, leftTable=outputTemp, rightTable=orders, outputTable=output, metrics=&amp;lt;[SellNo, TradePrice, TradeQty, TradeTime, BuyOrderQty, BuyOrderPrice, BuyOrderTime, OrderQty, OrderPrice, OrderTime]&amp;gt;, matchingColumn=[`Sym`BuyNo, `Sym`OrderNo]) // create engine: left join sell order ljEngineSell=createLeftSemiJoinEngine(name=&#34;leftJoinSell&#34;, leftTable=trades, rightTable=orders, outputTable=getLeftStream(ljEngineBuy), metrics=&amp;lt;[BuyNo, TradePrice, TradeQty, TradeTime, OrderQty, OrderPrice, OrderTime]&amp;gt;, matchingColumn=[`Sym`SellNo, `Sym`OrderNo]) // subscribe topic subscribeTable(tableName=&#34;trades&#34;, actionName=&#34;appendLeftStream&#34;, handler=getLeftStream(ljEngineSell), msgAsTable=true, offset=-1) subscribeTable(tableName=&#34;orders&#34;, actionName=&#34;appendRightStreamForSell&#34;, handler=getRightStream(ljEngineSell), msgAsTable=true, offset=-1) subscribeTable(tableName=&#34;orders&#34;, actionName=&#34;appendRightStreamForBuy&#34;, handler=getRightStream(ljEngineBuy), msgAsTable=true, offset=-1) &lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;数据流向：首先，将 trades 和 orders 分为作为左、右表注入引擎 leftJoinSell，此次以 trades 数据中的卖单号关联 orders 中的对应订单。之后，将上述引擎的输出作为左表直接注入引擎 leftJoinBuy，该引擎的右表仍然设置为 orders，此次以 trades 数据中的买单号关联 orders 中的对应订单。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;376:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;内存管理：上例中创建引擎时未显式指定 garbageSize，则使用默认值，garbageSize 不论大小均不改变计算结果。注意，和其他连接引擎不同，该函数的 garbageSize 参数只用于清理左表的历史数据，右表的历史数据不进行回收，因此上述案例中两个引擎至少分别占用一个 orders 表大小的内存。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;378:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为原始输入的 2 个流数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;380:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: trade t1 = table(`A`B`B`A as Sym, [2, 5, 5, 6] as BuyNo, [4, 1, 3, 4] as SellNo, [7.6, 3.5, 3.5, 7.6]as TradePrice, [10, 100, 20, 50]as TradeQty, 10:00:00.000+(400 500 500 600) as TradeTime) // generate data: order t2 = table(`B`A`B`A`B`A as Sym, 1..6 as OrderNo, [2, 1, 2, 2, 1, 1] as Side, [100, 10, 20, 100, 350, 50] as OrderQty, [7.6, 3.5, 7.6, 3.5, 7.6, 3.5] as OrderPrice, 10:00:00.000+(1..6)*100 as OrderTime) // input data orders.append!(t2) trades.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;390:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;输入数据与关联关系如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_8.png&#34; width=&#34;90%&#34; xtrc=&#34;image:17;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;938&#34; dita-ot:image-height=&#34;206&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;394:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;通过两个 Left Semi Join 引擎，上图中 trades 数据流中的每一条记录将分别和 orders 数据流中的两条记录关联，进而取得 orders 中的委托量、价、时间等字段，关联得到的结果表 output 如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_9.png&#34; width=&#34;80%&#34; xtrc=&#34;image:18;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;864&#34; dita-ot:image-height=&#34;110&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;36-用-left-semi-join-引擎关联股票与指数行情并计算相关性&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;3.6. 用 Left Semi Join 引擎关联股票与指数行情并计算相关性&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;400:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;本例中我们实时计算股票和某个指数在过去一段时间内分钟收益率的相关性。输入使用已经降为分钟频率的股票数据和指数数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;402:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;这个场景的特征是，两个数据流的时间戳频率一致，全部股票都需要关联同一支指数，输出与原始输入中的股票数据一一对应。以下脚本用 Left Semi Join 引擎来实现此关联场景。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;404:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// create table share streamTable(1:0, `Sym`Time`Close, [SYMBOL, TIME, DOUBLE]) as stockKline share streamTable(1:0, `Sym`Time`Close, [SYMBOL, TIME, DOUBLE]) as indexKline share streamTable(1:0, `Time`Sym`Close`Index1Close, [TIME, SYMBOL, DOUBLE, DOUBLE]) as stockKlineAddIndex1 share streamTable(1:0, `Sym`Time`Close`Index1Close`Index1Corr, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE]) as output // create engine: calculate correlation rsEngine = createReactiveStateEngine(name=&#34;calCorr&#34;, dummyTable=stockKlineAddIndex1, outputTable=output, metrics=[&amp;lt;Time&amp;gt;, &amp;lt;Close&amp;gt;, &amp;lt;Index1Close&amp;gt;, &amp;lt;mcorr(ratios(Close)-1, ratios(Index1Close)-1, 3)&amp;gt;], keyColumn=&#34;Sym&#34;) // create engine: left join Index1 ljEngine1 = createLeftSemiJoinEngine(name=&#34;leftJoinIndex1&#34;, leftTable=stockKline, rightTable=indexKline, outputTable=getStreamEngine(&#34;calCorr&#34;), metrics=&amp;lt;[Sym, Close, indexKline.Close]&amp;gt;, matchingColumn=`Time) // subscribe topic def appendIndex(engineName, indexName, msg){ tmp = select * from msg where Sym = indexName getRightStream(getStreamEngine(engineName)).append!(tmp) } subscribeTable(tableName=&#34;indexKline&#34;, actionName=&#34;appendIndex1&#34;, handler=appendIndex{&#34;leftJoinIndex1&#34;, &#34;idx1&#34;}, msgAsTable=true, offset=-1, hash=1) subscribeTable(tableName=&#34;stockKline&#34;, actionName=&#34;appendStock&#34;, handler=getLeftStream(ljEngine1), msgAsTable=true, offset=-1, hash=0)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;数据流向：首先，股票数据 stockKline 注入连接引擎 leftJoinIndex1 的左表，指数数据经过滤后注入该引擎的右表，这一步将股票与指数的分钟指标关联。之后，将上述连接引擎的输出直接注入响应式状态引擎（createReactiveStateEngine），利用响应式状态引擎内置的 mcorr 和 ratios 函数计算股票与指数的相关性指标。多个引擎之间采用了引擎级联的方式处理。响应式状态引擎教程见 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;reactive_state_engine.md&#34; xtrc=&#34;xref:10;426:213&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;金融高频因子的流批统一计算：DolphinDB 响应式状态引擎介绍&lt;/xref&gt; 。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;订阅指数数据 indexKline 时指定 handler 为自定义函数 appendIndex，是指不断地收到 indexKline 数据后，首先过滤出指数数据中指数名为 idx1 的数据，然后再注入连接引擎的右表。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;构造数据写入作为原始输入的 2 个流数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;431:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;// generate data: stock Kline t1 = table(`A`B`A`B`A`B`A`B`A`B as Sym, 10:00:00.000+(0 0 1 1 2 2 3 3 4 4)*60000 as Time, (4.1 7.6 3.8 7.6 4.3 7.5 3.5 7.6 4.2 7.6) as Close) // generate data: index Kline t2 = table(`idx1`idx2`idx1`idx2`idx1`idx2`idx1`idx2`idx1`idx2 as Sym, 10:00:00.000+(0 0 1 1 2 2 3 3 4 4)*60000 as Time, (2.1 5 2.2 5 1.9 5 1.7 5 1.7 5) as Close) // input data indexKline.append!(t2) stockKline.append!(t1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;441:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;输入数据与关联关系如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_10.png&#34; width=&#34;70%&#34; xtrc=&#34;image:19;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;580&#34; dita-ot:image-height=&#34;276&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联得到的结果表 output 如下，对于股票 A、B 每分钟都会关联对应分钟的指数 idx1。因为 mcorr 滑动窗口为 3，所以前两分钟结算结果为空。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming-real-time-correlation-processing/3_11.png&#34; width=&#34;40%&#34; xtrc=&#34;image:20;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34; dita-ot:image-width=&#34;331&#34; dita-ot:image-height=&#34;228&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-流数据连接引擎的比较&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;4. 流数据连接引擎的比较&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;6&#34; xtrc=&#34;tgroup:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:4;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:5;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:6;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;451:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;连接引擎&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;451:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;451:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;连接列&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;451:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;451:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;关联机制&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:4;451:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;451:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;类似的 SQL join&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:5;451:122&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;451:123&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;结果表行数&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:6;451:180&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;451:181&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;应用场景&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;453:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;453:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:7;453:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;AsofJoinEngine&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:8;453:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;matchingColumn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:9;453:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;左表每到来一条记录，匹配右表连接列一致且时间戳最近的一条记录。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:10;453:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;asof join&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:11;453:107&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;小于或等于左表行数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:12;453:161&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-asof-join-引擎计算个股交易成本&#34; xtrc=&#34;xref:11;453:162&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;计算个股交易成本&lt;/xref&gt;&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;454:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:13;454:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;WindowJoinEngine&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:14;454:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;matchingColumn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:15;454:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;左表每到来一条记录，匹配右表中连接列一致，且在由左表时间戳确定的窗口范围内的数据。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:16;454:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;window join&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:17;454:117&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;小于或等于左表行数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:18;454:171&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-window-join-引擎将行情快照与逐笔成交数据融合&#34; xtrc=&#34;xref:12;454:172&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;将行情快照和逐笔成交数据融合&lt;/xref&gt;&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:19;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;EquiJoinEngine&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:20;455:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;matchingColumn+timeColumn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:21;455:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;左（右）表每到来一条记录，匹配右（左）表连接列一致的最新的一条记录。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:22;455:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;equi join&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:23;455:110&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;等于左右表能完全等值匹配的行数（在左右表中的连接列均唯一的前提下）&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:24;455:146&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-equi-join-引擎拼接不同数据源的实时分钟指标&#34; xtrc=&#34;xref:13;455:147&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;拼接不同数据源的实时分钟指标&lt;/xref&gt;&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;456:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:25;456:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;LookupJoinEngine&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:26;456:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;matchingColumn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:27;456:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;左表每到来一条记录，匹配右表连接列一致的最新的一条记录。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:28;456:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;left join&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:29;456:108&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;等于左表行数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:30;456:165&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-lookup-join-引擎将实时行情与历史日频指标关联&#34; xtrc=&#34;xref:14;456:166&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;将实时行情与历史日频指标关联&lt;/xref&gt;&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:31;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;LeftSemiJoinEngine&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:32;457:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;matchingColumn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:33;457:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;对于左表的每一条记录，匹配右表连接列一致的第一条或最后一条记录。&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:34;457:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;equi join&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:35;457:108&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;小于或等于左表行数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:36;457:162&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-left-semi-join-引擎对逐笔成交数据补充原始委托信息&#34; xtrc=&#34;xref:15;457:163&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;对逐笔成交数据补充原始委托信息&lt;/xref&gt;、&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#用-left-semi-join-引擎关联股票与指数行情并计算相关性&#34; xtrc=&#34;xref:16;457:218&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;关联股票和指数行情并计算相关性&lt;/xref&gt;。&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;5. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;461:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;DolphinDB 提供了 5 个不同的流数据连接引擎，引擎均内置实现了高效的关联计算、实时触发规则和内存管理机制，开发人员通过简单的引擎参数配置便能够快速实现复杂的实时关联需求。本文重点介绍了各个连接引擎的原理、关联效果、实际应用案例，并在文末简要总结各个引擎的特点，旨在降低开发人员在实时数据流关联处理中的开发门槛。结合 DolphinDB 流数据框架中其他流计算引擎、流水线处理、并行计算等重要特性，开发人员可以将自己的业务场景实时化，通过提升速度掌握更及时的信息、挖掘更多的业务价值。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-附录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;463:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;463:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;6. 附录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;463:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;465:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:31;465:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;流环境清理通用脚本：&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/streaming-real-time-correlation-processing/clearStreamingEnv.dos&#34; xtrc=&#34;xref:17;465:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming-real-time-correlation-processing.md&#34;&gt;&lt;?ditaot usertext?&gt;clearStreamingEnv.dos&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/streaming-real-time-correlation-processing.md"/><meta name="wh-out-relpath" content="tutorials/streaming-real-time-correlation-processing.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="多数据源流式实时关联处理" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="chap7_tutorials_streaming"><div class="title"><a href="../stream/str_intro.html"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming_auto_sub.html">金融场景应用案例</a></div></div></li><li class="active"><div class="topicref" data-id="多数据源流式实时关联处理"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing.html">多数据源流式实时关联处理</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="streamfunctions-d9713e3813" class="topicref" data-id="streamfunctions" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamfunctions-d9713e3813-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_funcs.html" id="streamfunctions-d9713e3813-link">功能简介</a></div></div></li><li role="treeitem"><div data-tocid="入门示例-01实时计算买卖价差-d9713e4044" class="topicref" data-id="入门示例-01实时计算买卖价差" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/try_example1.html" id="入门示例-01实时计算买卖价差-d9713e4044-link">入门示例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="内置流式计算算子-d9713e4090" class="topicref" data-id="内置流式计算算子" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 内置流式计算算子-d9713e4090-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_operator.html" id="内置流式计算算子-d9713e4090-link"><span class="keyword label">流式计算算子</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="streamingEngineTopic-d9713e4229" class="topicref" data-id="streamingEngineTopic" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamingEngineTopic-d9713e4229-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/themes/streamingEngine.html" id="streamingEngineTopic-d9713e4229-link"><span class="keyword label">流计算引擎</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e4506" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e4506-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_join_engine.html" id="chap7_tutorials_streaming-d9713e4506-link"><span class="keyword label">内置多数据源流式关联引擎</span></a></div></div></li><li role="treeitem"><div data-tocid="streamha-d9713e4783" class="topicref" data-id="streamha" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_ha.html" id="streamha-d9713e4783-link"><span class="keyword label">流数据高可用</span></a></div></div></li><li role="treeitem"><div data-tocid="流计算状态监控-d9713e4830" class="topicref" data-id="流计算状态监控" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_monitor.html" id="流计算状态监控-d9713e4830-link">流计算状态监控</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="replay-d9713e4876" class="topicref" data-id="replay" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action replay-d9713e4876-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_replay.html" id="replay-d9713e4876-link"><span class="keyword label">历史数据回放</span></a></div></div></li><li role="treeitem"><div data-tocid="流批一体功能-d9713e5061" class="topicref" data-id="流批一体功能" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_batch.html" id="流批一体功能-d9713e5061-link"><span class="keyword label">流批一体</span></a></div></div></li><li role="treeitem"><div data-tocid="streamengineparser-解析原理介绍-d9713e5108" class="topicref" data-id="streamengineparser-解析原理介绍" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_eng_parser.html" id="streamengineparser-解析原理介绍-d9713e5108-link">StreamEngineParser 解析原理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="realtime_data_acces-d9713e5155" class="topicref" data-id="realtime_data_acces" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action realtime_data_acces-d9713e5155-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/realtime_data_acces.html" id="realtime_data_acces-d9713e5155-link">实时流数据接入</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="cep-d9713e5617" class="topicref" data-id="cep" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action cep-d9713e5617-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/cep.html" id="cep-d9713e5617-link">复杂事件处理（CEP）引擎</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6123" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6123-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/local_sub.html" id="tocId-d9713e6123-link">流处理结果交互方式</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6312" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6312-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_altair.html" id="tocId-d9713e6312-link">数据可视化工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e6405" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e6405-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="tocId-d9713e6405-link">金融场景应用案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e6406" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="节点启动时的流计算自动订阅-d9713e6406-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="k-线计算-d9713e6452" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC.html" id="k-线计算-d9713e6452-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e6498" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant.html" id="金融因子流式实现-d9713e6498-link">金融因子流式实现</a></div></div></li><li role="treeitem" class="active"><div data-tocid="多数据源流式实时关联处理-d9713e6544" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing.html" id="多数据源流式实时关联处理-d9713e6544-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="实时计算高频因子-d9713e6590" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming.html" id="实时计算高频因子-d9713e6590-link">实时计算高频因子</a></div></div></li><li role="treeitem"><div data-tocid="股票行情回放-d9713e6636" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay.html" id="股票行情回放-d9713e6636-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e6682" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility.html" id="金融实时实际波动率预测-d9713e6682-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e6728" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e6728-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e6774" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily.html" id="实时计算日累计逐单资金流-d9713e6774-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e6820" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order.html" id="实时计算分钟资金流-d9713e6820-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e6866" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e6866-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e6959" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc.html" id="处理-level-2-行情数据实例-d9713e6959-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e7005" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc.html" id="实时计算涨幅榜-d9713e7005-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e7051" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV.html" id="基金份额参考价值-iopv-计算-d9713e7051-link">基金份额参考价值 IOPV 计算</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7097" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7097-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_str_app_iot.html" id="tocId-d9713e7097-link">物联网场景应用案例</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">多数据源流式实时关联处理</h1><div class="- topic/body body"><p class="- topic/p p">在进行数据分析时经常需要对多个不同的数据源进行关联操作，因此在各类数据库的 SQL 语言中均包含了丰富的 join 语句，以支持批计算中的多种关联操作。DolphinDB 不仅通过 join 语法支持了对于全量历史数据的关联处理，而且在要求低延时的实时计算场景中，也提供了多种流数据连接引擎来支持对不断增长的数据流进行实时的关联处理。流数据连接引擎在内部实现上以增量计算为原则，在大数据流量下依然能够保持毫秒级的时延性能。</p><p class="- topic/p p">本教程将系统地介绍 DolphinDB 中的 5 种不同的流数据连接引擎，从实时数据流关联、DolphinDB 连接引擎分类、用连接引擎实现金融应用场景等方面层层递进，帮助用户深入理解 DolphinDB 的流计算连接引擎和快速上手多数据源实时关联处理。</p><p class="- topic/p p">DolphinDB 2.00.8 及以上版本支持本篇所有代码。此外，1.30.20 及以上版本支持除 3.2 小节外的所有代码，细节会在该小节内详细说明。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-流数据实时关联"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 流数据实时关联</h2><div class="- topic/body body"><p class="- topic/p p">本章从 DolphinDB 中批计算的表关联语法 join 讲起，介绍实时数据流关联面临的挑战。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-dolphindb-批计算表关联"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1. DolphinDB 批计算表关联</h3><div class="- topic/body body"><p class="- topic/p p">在批计算场景中，DolphinDB SQL 语句中不仅提供了与传统关系型数据库类似的 equi join, full join, left join, prefix join, cross join 等表连接方式，还提供了两种专门为时序数据设计的连接方式：asof join 和 window join。</p><p class="- topic/p p">以下是一个简单的 asof join 批计算的示例，更详细应用介绍请参考：<a class="- topic/xref xref" href="https://ask.dolphindb.cn/blog/9" target="_blank" rel="external noopener">应用教程：使用 Asof Join, Window Join 快速估计个股交易成本</a>。我们将通过它进一步分析实时连接中的挑战。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// data
t1 = table(take(`A, 4) as Sym, 10:10:03.000+(10 2100 2890 6030) as Time, 12.5 12.5 12.6 12.6 as Price)
t2 = table(take(`A, 4) as Sym, 10:10:00.000+(0 3000 6000 9000) as Time, 12.6 12.5 12.7 12.6 as BidPrice)

// asof join calculation
select *  from aj(t1, t2, `Time)</code></pre><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/1_1.png"/><br/><p class="- topic/p p">asof join 能够关联当前时刻或距离当前时刻最近时刻的数据。指定连接列为 Time 字段后，如上图所示，t1 表的每行记录总是关联 t2 表中 Time 值小于它的 Time 值的那一行 t2 记录。关联后的结果如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/1_2.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-实时数据流关联面临的挑战"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2. 实时数据流关联面临的挑战</h3><div class="- topic/body body"><p class="- topic/p p">批计算的关联操作，作为计算输入的 t1 表和 t2 表的数据是有界的，关联操作作用在全量输入数据上，计算结果一次性全量输出。现在考虑一下实时关联的场景，首先在输入上，t1, t2 的记录数会不断增长，表现为数据无界且无法预知下一条记录何时到来，比如股票市场中的交易数据、行情快照数据，而对于关联结果，我们会希望在每一条输入到来后尽快且尽可能正确地输出结果记录，这时计算是不断增量进行的。</p><p class="- topic/p p">那么，对于流式的实时关联场景，我们需要解决以下两个问题：</p><ul class="- topic/ul ul"><li class="- topic/li li">何时触发计算并输出：以上面的 asof join 为例，数据流 t1 中第一条记录（Time 值为 10:10:03:010）到达系统时，假设 t2 数据流中也有一条记录（Time 为 10:10:00.000），此时实时计算模块是决定关联目前 t2 中最近的一条记录并输出，还是等待某个触发条件再关联输出，这是技术实现上要解决的问题。</li><li class="- topic/li li">如何管理内存：为了能够正确地关联到两个数据流，实时计算模块需要缓存历史的数据流，而输入是源源不断的，则需要历史数据的清理机制。</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="2-流数据连接引擎"><h2 class="- topic/title title topictitle2" id="ariaid-title5">2. 流数据连接引擎</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 提供了 createAsofJoinEngine,  createWindowJoinEngine, createEquiJoinEngine, createLeftSemiJoinEngine, createLookupJoinEngine 等 5 种不同的流计算连接引擎函数，不同连接引擎的关联规则基本上与批计算中相应的 join 类似，差异将在后续小节中详细说明。本章首先概述 DolphinDB 流计算引擎，之后依次介绍各个引擎的原理和效果。</p><p class="- topic/p p">流计算连接引擎是 DolphinDB 中对数据流进行实时关联的计算模块，可以理解为一个设置了关联规则的计算黑盒，输入为 2 条数据流，输出为 1 条数据流，引擎内部会自动维护计算状态。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_1.png"/><br/><p class="- topic/p p">以下代码是 1.1 小节中的 asof join SQL 的流计算实现的脚本，首先创建 2 个流数据表作为输入、1 个流数据表作为输出，然后通过函数 createAsofJoinEngine 创建流计算引擎，之后通过函数 subscribeTable 分别订阅 2 个流数据表并将数据实时注入流计算引擎的左、右表。之后当数据不断写入两个流数据表时，输出结果表 output 中的记录数会相应地增加。流数据订阅功能更详细的介绍见 <a class="- topic/xref xref" href="streaming_tutorial.html">流数据订阅</a> 。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`Time`Price, [SYMBOL, TIME, DOUBLE]) as trade
share streamTable(1:0, `Sym`Time`BidPrice, [SYMBOL, TIME, DOUBLE]) as snapshot
share table(1:0, `Time`Sym`Price`t2_Time`BidPrice, [TIME, SYMBOL, DOUBLE, TIME, DOUBLE]) as output

// create engine
ajEngine = createAsofJoinEngine(name="asofJoin", leftTable=trade, rightTable=snapshot, outputTable=output, metrics=&lt;[Price, snapshot.Time, BidPrice]&gt;, matchingColumn=`Sym, timeColumn=`Time, useSystemTime=false, delayedTime=1000)

// subscribe topic
subscribeTable(tableName="trade", actionName="joinLeft", offset=0, handler=getLeftStream(ajEngine), msgAsTable=true)
subscribeTable(tableName="snapshot", actionName="joinRight", offset=0, handler=getRightStream(ajEngine), msgAsTable=true)</code></pre><p class="- topic/p p">以下代码构造输入数据并写入 2 个流数据表，查看结果表 output 将看到引擎计算的结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data
t1 = table(take(`A, 4) as Sym, 10:10:03.000+(10 2100 2890 6030) as Time, 12.5 12.5 12.6 12.6 as Price)
t2 = table(take(`A, 4) as Sym, 10:10:00.000+(0 3000 6000 9000) as Time, 12.6 12.5 12.7 12.6 as BidPrice)
// input data
snapshot.append!(t2)
trade.append!(t1)</code></pre><p class="- topic/p p">流计算连接引擎通过内置实现和简单的参数接口来解决上一章提到的实时数据流关联的问题。对于内存管理，每个引擎都提供了 garbageSize 参数来清理不再需要的历史数据。对于触发计算的机制，不同的引擎会稍有不同，可以大致分为以下几类：</p><ol class="- topic/ol ol"><li class="- topic/li li">若关联计算依赖数据的时间顺序，则处理的方式有：<ol class="- topic/ol ol" type="a"><li class="- topic/li li">以数据注入引擎时的系统时间为时序标准</li><li class="- topic/li li">以数据中的时间列为时序标准，这种情况下因为无法预知后续将到达的数据的时间戳，则时序判断以最新的时间戳为依据，认为时间戳早于它的全部数据都已经到齐，同时辅以超时强制触发的规则</li></ol></li><li class="- topic/li li">关联计算不依赖数据的时间顺序，则处理的方式有：<ol class="- topic/ol ol" type="a"><li class="- topic/li li">在数据注入引擎时立即计算输出</li><li class="- topic/li li">等待到匹配数据后才计算输出，同时辅以超时强制触发的规则</li></ol></li></ol><p class="- topic/p p">关联规则和触发规则决定了引擎的计算结果，下面我们详细介绍每一个连接引擎的原理和关联效果。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="21-asof-join-引擎createasofjoinengine"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.1. Asof Join 引擎（createAsofJoinEngine）</h3><div class="- topic/body body"><p class="- topic/p p">Asof Join 引擎的连接机制类似于 SQL 中的 asof join，按连接列分组，在每个分组内按时间邻近度关联左右表。引擎默认左右表是有序的，在连接列分组内，对于左表的每一条记录，当引擎判断邻近的时刻到来后，在右表缓存中选取在该条左表记录的时刻之前且最接近的一条记录，不论是否找到，引擎都将输出一条结果。</p><p class="- topic/p p">Asof join 引擎在创建时通过参数 useSystemTime 指定以下两种规则中的一种，用于判断临近时刻是否到来：</p><ul class="- topic/ul ul"><li class="- topic/li li">规则一：以数据注入引擎时的系统时间为时序标准，则每一条左表记录注入引擎时立刻关联并输出；</li><li class="- topic/li li">规则二：以数据中的时间列为时序标准，当右表数据的最新时刻大于左表数据的时刻时触发关联并输出。</li></ul><p class="- topic/p p">在规则二的基础上，还可以通过参数 delayedTime 设置超时强制触发规则。</p><p class="- topic/p p">下图展示在一个分组中，以非系统时间触发输出的 Asof Join 引擎效果（未设置超时强制触发），触发输出的时刻由右表到来新数据决定。后文将介绍一个 Asof Join 引擎的实际应用场景：<a class="- topic/xref xref" href="#%E7%94%A8-asof-join-%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E4%B8%AA%E8%82%A1%E4%BA%A4%E6%98%93%E6%88%90%E6%9C%AC">计算个股交易成本</a>。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_2.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="22-window-join-引擎createwindowjoinengine"><h3 class="- topic/title title topictitle3" id="ariaid-title7">2.2. Window Join 引擎（createWindowJoinEngine）</h3><div class="- topic/body body"><p class="- topic/p p">Window Join 引擎的连接机制类似于 SQL 中的 window join，上一小节的 Asof Join 引擎可以看做是 Window Join 引擎的一个特例。按连接列分组，在每个分组内按时间邻近关联右表一个时间窗口内的数据，这个窗口由左表的每一条记录的时刻和创建引擎时指定的窗口（参数 window）决定。引擎默认左右表是有序的，在连接列分组内，对于左表中的每一条记录，会在右表缓存中选取由左表的时刻确定的窗口范围内的记录，可能会找到 0 至多条记录，引擎将输出一条结果，这条结果由多条右表记录聚合为一条后与左表拼接而成。</p><p class="- topic/p p">Window Join 引擎在创建时通过参数 useSystemTime 指定以下两种规则中的一种，用于判断临近时刻是否到来：</p><ul class="- topic/ul ul"><li class="- topic/li li">规则一：以数据注入引擎时的系统时间为时序标准，则系统时间达到窗口下边界时立刻关联并输出；</li><li class="- topic/li li">规则二：以数据中的时间列为时序标准，当右表数据的最新时刻大于窗口下边界时触发关联并输出。</li></ul><p class="- topic/p p">在规则二的基础上，还可以通过参数 maxDelayedTime 设置超时强制触发规则。</p><p class="- topic/p p">下图展示在一个分组中，以非系统时间触发输出的普通窗口（参数 window=-1:2）连接的效果，由每一条左表记录基于其时间戳往前 1 个时间刻度、往后 2 个时间刻度划定窗口的上下边界，输出由大于窗口下边界的第一条右表记录触发，窗口计算不包含这条触发记录。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_3.png"/><br/><p class="- topic/p p">下图展示在一个分组中，以非系统时间触发输出的特殊窗口（参数 window=0:0）连接的效果，窗口范围由相邻两条左表记录划定，输出由等于或大于左表时间戳的第一条右表记录触发，窗口计算不包含这条触发记录。后文将介绍一个基于特殊窗口的窗口关联引擎的实际应用场景：<a class="- topic/xref xref" href="#%E7%94%A8-window-join-%E5%BC%95%E6%93%8E%E5%B0%86%E8%A1%8C%E6%83%85%E5%BF%AB%E7%85%A7%E4%B8%8E%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">对行情快照融合逐笔成交数据</a>。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_4.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="23-equi-join-引擎createequijoinengine"><h3 class="- topic/title title topictitle3" id="ariaid-title8">2.3. Equi Join 引擎（createEquiJoinEngine）</h3><div class="- topic/body body"><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">注：自 1.30.21/2.00.9 版本起，<code class="+ topic/ph pr-d/codeph ph codeph">createEqualJoinEngine</code> 更名为 <code class="+ topic/ph pr-d/codeph ph codeph">createEquiJoinEngine</code>，原函数名可继续使用。</em></p><p class="- topic/p p">Equi Join 引擎的连接机制类似于 SQL 中的 equi join，按连接列和时间列等值关联左右表，对于左表（或右表）中的每一条记录，当它成功匹配上右表（或左表）中连接列一致的一条记录时，引擎将输出一条结果。</p><p class="- topic/p p">与 SQL 中的 equi join 不同的是，因为引擎内部并不缓存所有历史数据，所以可能出现左表（或右表）中的某条记录到来后无法关联到已经从引擎缓存中清除的历史右表（或左表）记录，进而不会输出结果。这是由 Equi Join 引擎的设计初衷和内部实现决定的，该引擎是为以连接列和时间列为键值的输入数据设计的，比如每支股票在每分钟有一条记录。</p><p class="- topic/p p">下图展示字段结构为（连接列，时间列，指标）的输入数据注入等值关联引擎的效果。后文 3.3 小节将介绍一个等值关联引擎的实际应用场景：<a class="- topic/xref xref" href="#%E7%94%A8-equi-join-%E5%BC%95%E6%93%8E%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%AE%9E%E6%97%B6%E5%88%86%E9%92%9F%E6%8C%87%E6%A0%87">拼接不同数据源的实时分钟指标</a>。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_5.png"/><br/><p class="- topic/p p">建议按推荐场景使用 Equi Join 引擎，即对连接列和时间列唯一的数据使用本引擎。若非推荐场景，为了理解输出效果，可以参考如下设计原理：Equi Join 引擎内部分别为左右表数据维护两个以连接列和时间列作为键值的键值表作为缓存，并对每条记录标识是否关联过。下面以左表为例介绍，右表同理。当一条左表记录注入引擎，则查找右表缓存，若能成功匹配则输出一条结果，并在右表缓存中标识对应记录为已关联，这时左表缓存中不会保存这条立刻关联输出的左表记录（此原理会导致上图中后续的灰色数据 (A,t1,4) 无法匹配而不输出），若未能匹配成功，则将该条左表记录加入左表缓存，并标识为未关联。</p><p class="- topic/p p">需要注意，对于缓存中的已关联、未关联的数据，Equi Join 引擎都会进行过期清理，清理原理可参考用户手册。若遵循推荐场景使用此引擎，但是引擎输出结果与 SQL equi join 结果仍不完全一致，则是设置的清理规则导致的差异。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="24-lookup-join-引擎createlookupjoinengine"><h3 class="- topic/title title topictitle3" id="ariaid-title9">2.4. Lookup Join 引擎（createLookupJoinEngine）</h3><div class="- topic/body body"><p class="- topic/p p">Lookup Join 引擎的连接机制类似于 SQL 中的 left join，按连接列等值关联左右表，左表中的每一条记录注入引擎时便立刻关联当前时刻的右表，不论是否在右表中匹配到连接列一致的记录，引擎都会立刻输出一条结果，若未能匹配上则结果中右表相关的字段为空。</p><p class="- topic/p p">与 SQL 中的 left join 不同的是，引擎在内部缓存右表的记录时，对于相同连接列的数据总是只保留最新一条，因此对于左表的每一条记录至多只会匹配一条右表记录并输出一次。引擎的右表可以是数据流或者数据集。对于数据流，引擎通过数据流不断地注入引擎来更新内部的右表缓存；对于数据集，引擎通过对数据集的定时查询来更新内部的右表缓存。</p><p class="- topic/p p">下图展示字段结构为（连接列，指标）的输入数据，注入右表保留最新一条记录的 Lookup Join 引擎的效果，左表数据总是在达到后立刻输出。后文将介绍一个 Lookup Join 引擎的实际应用场景：<a class="- topic/xref xref" href="#%E7%94%A8-lookup-join-%E5%BC%95%E6%93%8E%E5%B0%86%E5%AE%9E%E6%97%B6%E8%A1%8C%E6%83%85%E4%B8%8E%E5%8E%86%E5%8F%B2%E6%97%A5%E9%A2%91%E6%8C%87%E6%A0%87%E5%85%B3%E8%81%94">对实时行情关联历史日频指标</a>。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_6.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="25-left-semi-join-引擎createleftsemijoinengine"><h3 class="- topic/title title topictitle3" id="ariaid-title10">2.5. Left Semi Join 引擎（createLeftSemiJoinEngine）</h3><div class="- topic/body body"><p class="- topic/p p">Left Semi Join 引擎的连接机制类似于 SQL 中的 equi join，按连接列等值关联左右表，对于左表中的每一条记录，当它成功匹配上右表中连接列一致的一条记录时，引擎将输出一条结果。未成功匹配的左表的记录将一直由引擎缓存，等待与右表中更新的记录匹配。</p><p class="- topic/p p">与 SQL 中的 equi join 不同的是，引擎在内部缓存右表的记录时，对于相同连接列的数据总是只保留第一条或者最新一条，因此对于左表的每一条记录至多只会匹配一条右表记录并输出一次。</p><p class="- topic/p p">下图展示字段结构为（连接列，指标）的输入数据，注入右表保留最新一条记录的 Left Semi Join 引擎的效果，左表数据总是等到匹配成功才输出。后文将分别介绍两个 Left Semi Join 引擎的实际应用场景：一是<a class="- topic/xref xref" href="#%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%AF%B9%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%A1%A5%E5%85%85%E5%8E%9F%E5%A7%8B%E5%A7%94%E6%89%98%E4%BF%A1%E6%81%AF">对逐笔成交数据补充原始委托信息</a>，二是<a class="- topic/xref xref" href="#%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%85%B3%E8%81%94%E8%82%A1%E7%A5%A8%E4%B8%8E%E6%8C%87%E6%95%B0%E8%A1%8C%E6%83%85%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E6%80%A7">关联股票和指数行情并计算相关性</a>。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/2_7.png"/><br/></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title11" id="3-实时关联应用案例"><h2 class="- topic/title title topictitle2" id="ariaid-title11">3. 实时关联应用案例</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 中流计算连接引擎是结合各类实际业务场景而设计的，本章将从 6 个实际应用案例出发介绍各个连接引擎适用的具体场景。为了便于解释关联效果，下文案例中均以少量的模拟数据依次注入右表、左表来模拟数据流输入。</p><p class="- topic/p p">流计算脚本开发和调试过程中推荐使用 getStreamingStat 函数监控流订阅的状态，getStreamEngineStat 函数监控流数据引擎的状态。此外，文末<a class="- topic/xref xref" href="#%E9%99%84%E5%BD%95">附录</a>中提供了清理流数据环境的通用脚本，用于一键清理所有的流数据表、取消所有的订阅、释放所有的流引擎。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="31-用-asof-join-引擎计算个股交易成本"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.1. 用 Asof Join 引擎计算个股交易成本</h3><div class="- topic/body body"><p class="- topic/p p">因为逐笔成交数据和报价数据的发生时间不可能完全一致而不能使用常用的等值连接，往往需要以成交时间为基准找到交易发生前的最近一次报价数据，因此需要以邻近匹配的方式关联两个数据流。</p><p class="- topic/p p">这个场景的特征是，每条成交记录匹配一条时刻早于自己的报价记录，输出与原始的每一条成交记录一一对应。以下脚本用 Asof Join 引擎来实现此场景：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`TradeTime`TradePrice, [SYMBOL, TIME, DOUBLE]) as trades
share streamTable(1:0, `Sym`Time`Bid1Price`Ask1Price, [SYMBOL, TIME, DOUBLE, DOUBLE]) as snapshot
share streamTable(1:0, `TradeTime`Sym`TradePrice`TradeCost`SnapshotTime, [TIME, SYMBOL, DOUBLE, DOUBLE, TIME]) as output

// create engine
ajEngine = createAsofJoinEngine(name="asofJoin", leftTable=trades, rightTable=snapshot, outputTable=output, metrics=&lt;[TradePrice, abs(TradePrice-(Bid1Price+Ask1Price)/2), snapshot.Time]&gt;, matchingColumn=`Sym, timeColumn=`TradeTime`Time, useSystemTime=false, delayedTime=1000)

// subscribe topic
subscribeTable(tableName="trades", actionName="appendLeftStream", handler=getLeftStream(ajEngine), msgAsTable=true, offset=-1, hash=0)
subscribeTable(tableName="snapshot", actionName="appendRightStream", handler=getRightStream(ajEngine), msgAsTable=true, offset=-1, hash=1)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">逐笔成交数据 trades 注入引擎的左表，报价数据 snapshot 注入引擎的右表。</li><li class="- topic/li li">引擎参数 useSystemTime=false 表示通过数据中的时间列（左表为 TradeTime 字段，右表为 Time 字段）来判断左右表中记录的时序关系。</li><li class="- topic/li li">引擎参数 delayedTime 是对默认触发机制的补充，以超时强制触发的方式保证左表及时匹配并输出。若未设置 delayedTime 是默认触发机制，对于任意一条左表记录，它必须等到右表出现一条时间戳大于它的记录才输出。但考虑到实际的应用场景中，某条右表记录可能迟迟未能到达或者始终不可能出现一条大于某些左表数据的右表记录，同时期望左表中每条记录都能匹配并输出，那么建议设置 dalayTime，在这种情况下将以左表出现更新的数据或者系统时间超时来强制触发计算。</li><li class="- topic/li li">引擎参数 metrics 中 snapshot.Time 表示取右表 snapshot 中的 Time 字段，因为左表 trades 中也具有 Time 字段，若不加前缀、直接写 Time，则默认取左表的 Time 字段。</li><li class="- topic/li li">上例中创建引擎时未显式指定 garbageSize，则使用默认值，garbageSize 不论大小均不改变计算结果，只影响引擎的内存占用。</li></ul><p class="- topic/p p">构造数据写入作为原始输入的 2 个流数据表，先写入右表，再写入左表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: trade
t1 = table(`A`A`B`A`B`B as Sym, 10:00:02.000+(1..6)*700 as TradeTime,  (3.4 3.5 7.7 3.5 7.5 7.6) as TradePrice)
// generate data: snapshot
t2 = table(`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6)*1000 as Time, (3.5 7.6 3.5 7.6) as Bid1Price, (3.5 7.6 3.6 7.6) as Ask1Price)
// input data
snapshot.append!(t2)
trades.append!(t1)</code></pre><p class="- topic/p p">输入数据与关联关系如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_1.png"/><br/><p class="- topic/p p">关联得到的结果表 output 如下，左表中全部 7 条数据都有对应的输出。本例中，在创建引擎时指定了 delayedTime 参数，因此对于分组 B，即使右表 snapshot 中没有比 10:00:06.200 更大的时间戳，左表 trades 中最后一条数据 (B,10:00:06.200, 7.6) 仍然能够在注入引擎 2s 后强制输出。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_2.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="32-用-window-join-引擎将行情快照与逐笔成交数据融合"><h3 class="- topic/title title topictitle3" id="ariaid-title13">3.2. 用 Window Join 引擎将行情快照与逐笔成交数据融合</h3><div class="- topic/body body"><p class="- topic/p p">行情快照和逐笔成交数据包含着不同的信息，很多高频因子的计算同时依赖行情快照和成交数据，本例在行情快照数据的基础上融合前后两个快照之间的逐笔成交数据，融合后的数据可以更方便地作为后续复杂因子的计算的输入。</p><p class="- topic/p p">这个场景的特征是，每条行情快照记录匹配一个时间窗口内的全部逐笔成交记录的聚合值，这个时间窗口的上下界由两条行情快照数据的时刻决定，输出与原始的每一条行情快照记录一一对应。对于一个窗口中的逐笔成交记录，既需要计算交易量总和这样的聚合值，也希望以一个字段保留窗口内的全部逐笔成交明细。以下脚本用 Window Join 引擎的特殊窗口来实现此场景。</p><p class="- topic/p p">注意，1.30 版本的 DolphinDB 不支持 array vector 数据形式，以下脚本包含 array vector 功能，因此仅支持 2.00 版本。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`TradeTime`Side`TradeQty, [SYMBOL, TIME, INT, LONG]) as trades
share streamTable(1:0, `Sym`Time`Open`High`Low`Close, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as snapshot
share streamTable(1:0, `Time`Sym`Open`High`Low`Close`BuyQty`SellQty`TradeQtyList`TradeTimeList, [TIME, SYMBOL, DOUBLE, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, LONG[], TIME[]]) as output

// create engine
wjMetrics = &lt;[Open, High, Low, Close, sum(iif(Side==1, TradeQty, 0)), sum(iif(Side==2, TradeQty, 0)), TradeQty, TradeTime]&gt;
fillArray = [00:00:00.000, "", 0, 0, 0, 0, 0, 0, [], []]
wjEngine = createWindowJoinEngine(name="windowJoin", leftTable=snapshot, rightTable=trades, outputTable=output, window=0:0, metrics=wjMetrics, matchingColumn=`Sym, timeColumn=`Time`TradeTime, useSystemTime=false, nullFill=fillArray)

// subscribe topic
subscribeTable(tableName="snapshot", actionName="appendLeftStream", handler=getLeftStream(wjEngine), msgAsTable=true, offset=-1, hash=0)
subscribeTable(tableName="trades", actionName="appendRightStream", handler=getRightStream(wjEngine), msgAsTable=true, offset=-1, hash=1)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">行情快照数据 snapshot 注入引擎的左表，逐笔成交数据 trades 注入引擎的右表。</li><li class="- topic/li li">引擎参数 useSystemTime=false 表示通过数据中的时间列（左表为 Time 字段，右表为 TradeTime 字段）来判断左右表中记录的时序关系。</li><li class="- topic/li li">引擎参数 window=0:0 表示右表 trades 的计算窗口将由左表 snapshot 当前和其上一条数据的时间戳划定。</li><li class="- topic/li li">引擎参数 metrics 表示计算指标，如 Open 表示取左表 snapshot 中 Open 字段，sum(iif(Side==1, TradeQty, 0)) 表示对右表 trades 在窗口内的数据做聚合计算。注意，TradeQty 是右表 trades 中的字段，且此处对 TradeQty 没有使用聚合函数，则表示对右表 trades 在窗口内的全部 TradeQty 值保留明细，对应的输出为一个数据类型为 array vector 的字段。</li><li class="- topic/li li">引擎参数 nullFill 为可选参数，表示如何填充输出表中的空值，本例中结合实际场景，对于表示价格的字段如 Open 等都指定将空值填充为 0。注意，nullFill 为元组，必须和输出表列字段等长且类型一一对应。</li></ul><p class="- topic/p p">构造数据写入作为原始输入的 2 个流数据表，先写入右表，再写入左表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: snapshot
t1 = table(`A`B`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6 9 9)*1000 as Time, (NULL NULL 3.5 7.6 3.5 7.6) as Open, (3.5 7.6 3.6 7.6 3.6 7.6) as High, (3.5 7.6 3.5 7.6 3.4 7.5) as Low, (3.5 7.6 3.5 7.6 3.6 7.5) as Close)
// generate data: trade
t2 = table(`A`A`B`A`B`B`A`B`A`A as Sym, 10:00:02.000+(1..10)*700 as TradeTime,  (1 2 1 1 1 1 2 1 2 2) as Side, (1..10) * 10 as TradeQty)
// input data
trades.append!(t2)
snapshot.append!(t1)</code></pre><p class="- topic/p p">输入数据与关联关系如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_3.png"/><br/><p class="- topic/p p">关联得到的结果表 output 如下，其中最后两列为 array vector 类型数据，记录了窗口中全部成交记录的 TradeQty 字段明细、TradeTime 字段明细。</p><p class="- topic/p p">注意，输出表比左表 snapshot 少一条数据，即左表 sanpshot 中分组 B 内时间戳为 10:00:09.000 的数据没有输出，这是因为右表 trades 中分组 B 内没有等于或大于 10:00:09.000 的数据来关闭窗口。在实际生产中，当接入实时数据时，若需要左表 snapshot 一旦达到引擎便立即输出，则建议选择 useSystemTime=true，即用系统时间作为时间戳，这时，对于任意一条左表记录，右表窗口是从前一条左表记录到达到本条记录到达之间进入引擎的全部右表数据。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_4.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="33-用-equi-join-引擎拼接不同数据源的实时分钟指标"><h3 class="- topic/title title topictitle3" id="ariaid-title14">3.3. 用 Equi Join 引擎拼接不同数据源的实时分钟指标</h3><div class="- topic/body body"><p class="- topic/p p">在量化金融的实盘中往往会对原始的行情快照、逐笔成交等进行降采样形成分钟指标，以作为输入提供给进一步的交易策略，这时则需要将多个不同数据源计算出的指标关联到同一张表中。本例将对快照和成交数据分别做实时的 1 分钟聚合，并将快照指标和成交指标关联后输出到同一张宽表中。</p><p class="- topic/p p">这个场景的特征是，每支股票的行情快照分钟指标在每一分钟只有一条记录，逐笔成交分钟指标同样有这样的唯一性，并且在某一分钟的输出上，期望总是在两类指标都计算完成后再将关联输出。以下脚本用 Equi Join 引擎来实现此场景。</p><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">注意：如您使用的 DolphinDB 版本早于 1.30.21/2.00.9，请将脚本中的 <code class="+ topic/ph pr-d/codeph ph codeph">createEquiJoinEngine</code> 替换为 <code class="+ topic/ph pr-d/codeph ph codeph">createEqualJoinEngine</code>。自 1.30.21/2.00.9 版本起，<code class="+ topic/ph pr-d/codeph ph codeph">createEqualJoinEngine</code> 更名为 <code class="+ topic/ph pr-d/codeph ph codeph">createEquiJoinEngine</code>，原函数名可继续使用。</em></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`TradeTime`Side`TradeQty, [SYMBOL, TIME, INT, LONG]) as trades
share streamTable(1:0, `UpdateTime`Sym`BuyTradeQty`SellTradeQty, [TIME, SYMBOL, LONG, LONG]) as tradesMin
share streamTable(1:0, `Sym`Time`Bid1Price`Bid1Qty, [SYMBOL, TIME, DOUBLE, LONG]) as snapshot
share streamTable(1:0, `UpdateTime`Sym`AvgBid1Amt, [TIME, SYMBOL, DOUBLE]) as snapshotMin
share streamTable(1:0, `UpdateTime`Sym`AvgBid1Amt`BuyTradeQty`SellTradeQty, [TIME, SYMBOL, DOUBLE, LONG, LONG]) as output

// create engine: 
eqJoinEngine = createEquiJoinEngine(name="EquiJoin", leftTable=tradesMin, rightTable=snapshotMin, outputTable=output, metrics=&lt;[AvgBid1Amt, BuyTradeQty, SellTradeQty]&gt;, matchingColumn=`Sym, timeColumn=`UpdateTime)
// create engine: 
tsEngine1 = createTimeSeriesEngine(name="tradesAggr", windowSize=60000, step=60000, metrics=&lt;[sum(iif(Side==1, 0, TradeQty)), sum(iif(Side==2, 0, TradeQty))]&gt;, dummyTable=trades, outputTable=getLeftStream(eqJoinEngine), timeColumn=`TradeTime, keyColumn=`Sym, useSystemTime=false, fill=(0, 0))
// create engine: 
tsEngine2 = createTimeSeriesEngine(name="snapshotAggr", windowSize=60000, step=60000, metrics=&lt;[avg(iif(Bid1Price!=NULL, Bid1Price*Bid1Qty, 0))]&gt;, dummyTable=snapshot, outputTable=getRightStream(eqJoinEngine), timeColumn=`Time, keyColumn=`Sym, useSystemTime=false, fill=(0.0))

// subscribe topic
subscribeTable(tableName="trades", actionName="minAggr", handler=tsEngine1, msgAsTable=true, offset=-1, hash=1)
subscribeTable(tableName="snapshot", actionName="minAggr", handler=tsEngine2, msgAsTable=true, offset=-1, hash=2) </code></pre><ul class="- topic/ul ul"><li class="- topic/li li">首先用两个独立的时序聚合引擎（createTimeSeriesEngine）对原始的快照和成交数据流按数据中的时间戳做实时聚合、输出每一分钟的指标，之后通过引擎级联的方式，将两个时序聚合引擎的输出分别作为左右表注入连接引擎。</li><li class="- topic/li li">Equi Join 引擎对左、右表的处理是完全相同的，即上例中在 createEquiJoinEngine 时交换左右表不会影响关联结果。</li></ul><p class="- topic/p p">构造数据写入作为原始输入的 2 个流数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: snapshot
t1 = table(`A`B`A`B`A`B as Sym, 10:00:52.000+(3 3 6 6 9 9)*1000 as Time, (3.5 7.6 3.6 7.6 3.6 7.6) as Bid1Price, (1000 2000 500 1500 400 1800) as Bid1Qty)
// generate data: trade
t2 = table(`A`A`B`A`B`B`A`B`B`A as Sym, 10:00:54.000+(1..10)*700 as TradeTime,  (1 2 1 1 1 1 2 1 2 2) as Side, (1..10) * 10 as TradeQty)
// input
trades.append!(t2)
snapshot.append!(t1)</code></pre><p class="- topic/p p">关联得到的结果表 output 如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_5.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="34-用-lookup-join-引擎将实时行情与历史日频指标关联"><h3 class="- topic/title title topictitle3" id="ariaid-title15">3.4. 用 Lookup Join 引擎将实时行情与历史日频指标关联</h3><div class="- topic/body body"><p class="- topic/p p">在当日的实时计算中可能会需要依赖历史指标，本例在行情快照的基础上，通过股票代码关联该股票在昨日的日频指标。</p><p class="- topic/p p">这个场景的特征是，每条快照记录到达后要求立刻关联输出，如果日频数据里没有对应的股票，输出结果对应的字段为空，输出与原始输入中的每一条行情快照记录一一对应。同时，日频指标并非实时数据，而是一个以较低频率更新的有主键的离线数据集。以下脚本用 Lookup Join 引擎来实现此场景。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`Time`Open`High`Low`Close, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as snapshot
historicalData = table(`A`B as Sym, (0.8 0.2) as PreWeight, (3.1 7.6) as PreClose)
share table(1:0, `Sym`Time`Open`High`Low`Close`PreWeight`PreClose, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) as output

// create engine
lookupJoinEngine = createLookupJoinEngine(name="lookupJoin", leftTable=snapshot, rightTable=historicalData, outputTable=output, metrics=&lt;[Time, Open, High, Low, Close, PreWeight, PreClose]&gt;, matchingColumn=`Sym, checkTimes=10s)

// subscribe topic
subscribeTable(tableName="snapshot", actionName="appendLeftStream", handler=getLeftStream(lookupJoinEngine), msgAsTable=true, offset=-1)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">订阅流数据表 snapshot 注入引擎的左表。引擎右表为普通内存表 historicalData，它不能且不需要进行订阅。</li><li class="- topic/li li">引擎会在内部维护一个最新的右表，在创建引擎时会查询右表 historicalData 并缓存在引擎内部。参数 checkTimes=10s 表示之后的每 10s 引擎会再次查询右表 historicalData 并更新一次内部的缓存。</li></ul><p class="- topic/p p">构造数据写入作为引擎左表输入的流数据表 snapshot：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: snapshot
t1 = table(`A`B`A`B`A`B as Sym, 10:00:00.000+(3 3 6 6 9 9)*1000 as Time, (3.5 7.6 3.5 7.6 3.5 7.6) as Open, (3.5 7.6 3.6 7.6 3.6 7.6) as High, (3.5 7.6 3.5 7.6 3.4 7.5) as Low, (3.5 7.6 3.5 7.6 3.6 7.5) as Close)
snapshot.append!(t1)</code></pre><p class="- topic/p p">输入数据与关联关系如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_6.png"/><br/><p class="- topic/p p">结果在左表数据到达引擎时立刻输出，关联得到的结果表 output 如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_7.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="35-用-left-semi-join-引擎对逐笔成交数据补充原始委托信息"><h3 class="- topic/title title topictitle3" id="ariaid-title16">3.5. 用 Left Semi Join 引擎对逐笔成交数据补充原始委托信息</h3><div class="- topic/body body"><p class="- topic/p p">逐笔成交数据中包含买卖双方的原始委托订单号，本例通过股票代码和订单号去关联逐笔委托数据，以达到在成交数据的基础上丰富其原始委托信息的目的。</p><p class="- topic/p p">这个场景的特征是，对于每条逐笔成交都应该找到对应的委托单，输出与原始输入中的逐笔成交记录一一对应。在找到对应的委托单前，该条逐笔成交记录暂时不输出。</p><p class="- topic/p p">以下脚本用两个 Left Semi Join 引擎级联的方式，对成交表 trades 中的卖方委托单、买方委托单依次进行了关联。多个引擎之间采用了引擎级联的方式处理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`BuyNo`SellNo`TradePrice`TradeQty`TradeTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME]) as trades
share streamTable(1:0, `Sym`OrderNo`Side`OrderQty`OrderPrice`OrderTime, [SYMBOL, LONG, INT, LONG, DOUBLE, TIME]) as orders
share streamTable(1:0, `Sym`SellNo`BuyNo`TradePrice`TradeQty`TradeTime`BuyOrderQty`BuyOrderPrice`BuyOrderTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME, LONG, DOUBLE, TIME]) as outputTemp
share streamTable(1:0, `Sym`BuyNo`SellNo`TradePrice`TradeQty`TradeTime`BuyOrderQty`BuyOrderPrice`BuyOrderTime`SellOrderQty`SellOrderPrice`SellOrderTime, [SYMBOL, LONG, LONG, DOUBLE, LONG, TIME, LONG, DOUBLE, TIME, LONG, DOUBLE, TIME]) as output

// create engine: left join buy order
ljEngineBuy=createLeftSemiJoinEngine(name="leftJoinBuy", leftTable=outputTemp, rightTable=orders, outputTable=output,  metrics=&lt;[SellNo, TradePrice, TradeQty, TradeTime, BuyOrderQty, BuyOrderPrice, BuyOrderTime, OrderQty, OrderPrice, OrderTime]&gt;, matchingColumn=[`Sym`BuyNo, `Sym`OrderNo])

//  create engine: left join sell order 
ljEngineSell=createLeftSemiJoinEngine(name="leftJoinSell", leftTable=trades, rightTable=orders, outputTable=getLeftStream(ljEngineBuy),  metrics=&lt;[BuyNo, TradePrice, TradeQty, TradeTime, OrderQty, OrderPrice, OrderTime]&gt;, matchingColumn=[`Sym`SellNo, `Sym`OrderNo])

// subscribe topic
subscribeTable(tableName="trades", actionName="appendLeftStream", handler=getLeftStream(ljEngineSell), msgAsTable=true, offset=-1)
subscribeTable(tableName="orders", actionName="appendRightStreamForSell", handler=getRightStream(ljEngineSell), msgAsTable=true, offset=-1)
subscribeTable(tableName="orders", actionName="appendRightStreamForBuy", handler=getRightStream(ljEngineBuy), msgAsTable=true, offset=-1) </code></pre><ul class="- topic/ul ul"><li class="- topic/li li">数据流向：首先，将 trades 和 orders 分为作为左、右表注入引擎 leftJoinSell，此次以 trades 数据中的卖单号关联 orders 中的对应订单。之后，将上述引擎的输出作为左表直接注入引擎 leftJoinBuy，该引擎的右表仍然设置为 orders，此次以 trades 数据中的买单号关联 orders 中的对应订单。</li><li class="- topic/li li">内存管理：上例中创建引擎时未显式指定 garbageSize，则使用默认值，garbageSize 不论大小均不改变计算结果。注意，和其他连接引擎不同，该函数的 garbageSize 参数只用于清理左表的历史数据，右表的历史数据不进行回收，因此上述案例中两个引擎至少分别占用一个 orders 表大小的内存。</li></ul><p class="- topic/p p">构造数据写入作为原始输入的 2 个流数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: trade
t1 = table(`A`B`B`A as Sym, [2, 5, 5, 6] as BuyNo, [4, 1, 3, 4] as SellNo, [7.6, 3.5, 3.5, 7.6]as TradePrice, [10, 100, 20, 50]as TradeQty, 10:00:00.000+(400 500 500 600) as TradeTime)
// generate data: order
t2 = table(`B`A`B`A`B`A as Sym, 1..6 as OrderNo, [2, 1, 2, 2, 1, 1] as Side, [100, 10, 20, 100, 350, 50] as OrderQty, [7.6, 3.5, 7.6, 3.5, 7.6, 3.5] as OrderPrice, 10:00:00.000+(1..6)*100 as OrderTime)
// input data
orders.append!(t2)
trades.append!(t1)</code></pre><p class="- topic/p p">输入数据与关联关系如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_8.png"/><br/><p class="- topic/p p">通过两个 Left Semi Join 引擎，上图中 trades 数据流中的每一条记录将分别和 orders 数据流中的两条记录关联，进而取得 orders 中的委托量、价、时间等字段，关联得到的结果表 output 如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_9.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="36-用-left-semi-join-引擎关联股票与指数行情并计算相关性"><h3 class="- topic/title title topictitle3" id="ariaid-title17">3.6. 用 Left Semi Join 引擎关联股票与指数行情并计算相关性</h3><div class="- topic/body body"><p class="- topic/p p">本例中我们实时计算股票和某个指数在过去一段时间内分钟收益率的相关性。输入使用已经降为分钟频率的股票数据和指数数据。</p><p class="- topic/p p">这个场景的特征是，两个数据流的时间戳频率一致，全部股票都需要关联同一支指数，输出与原始输入中的股票数据一一对应。以下脚本用 Left Semi Join 引擎来实现此关联场景。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create table
share streamTable(1:0, `Sym`Time`Close, [SYMBOL, TIME, DOUBLE]) as stockKline
share streamTable(1:0, `Sym`Time`Close, [SYMBOL, TIME, DOUBLE]) as indexKline
share streamTable(1:0, `Time`Sym`Close`Index1Close, [TIME, SYMBOL, DOUBLE, DOUBLE]) as stockKlineAddIndex1
share streamTable(1:0, `Sym`Time`Close`Index1Close`Index1Corr, [SYMBOL, TIME, DOUBLE, DOUBLE, DOUBLE]) as output

//  create engine: calculate correlation
rsEngine = createReactiveStateEngine(name="calCorr", dummyTable=stockKlineAddIndex1, outputTable=output, metrics=[&lt;Time&gt;, &lt;Close&gt;, &lt;Index1Close&gt;, &lt;mcorr(ratios(Close)-1, ratios(Index1Close)-1, 3)&gt;], keyColumn="Sym")

//  create engine: left join Index1
ljEngine1 = createLeftSemiJoinEngine(name="leftJoinIndex1", leftTable=stockKline, rightTable=indexKline, outputTable=getStreamEngine("calCorr"), metrics=&lt;[Sym, Close, indexKline.Close]&gt;, matchingColumn=`Time)

// subscribe topic
def appendIndex(engineName, indexName, msg){
 tmp = select * from msg where Sym = indexName
 getRightStream(getStreamEngine(engineName)).append!(tmp)
}
subscribeTable(tableName="indexKline", actionName="appendIndex1", handler=appendIndex{"leftJoinIndex1", "idx1"}, msgAsTable=true, offset=-1, hash=1)
subscribeTable(tableName="stockKline", actionName="appendStock", handler=getLeftStream(ljEngine1), msgAsTable=true, offset=-1, hash=0)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">数据流向：首先，股票数据 stockKline 注入连接引擎 leftJoinIndex1 的左表，指数数据经过滤后注入该引擎的右表，这一步将股票与指数的分钟指标关联。之后，将上述连接引擎的输出直接注入响应式状态引擎（createReactiveStateEngine），利用响应式状态引擎内置的 mcorr 和 ratios 函数计算股票与指数的相关性指标。多个引擎之间采用了引擎级联的方式处理。响应式状态引擎教程见 <a class="- topic/xref xref" href="reactive_state_engine.html">金融高频因子的流批统一计算：DolphinDB 响应式状态引擎介绍</a> 。</li><li class="- topic/li li">订阅指数数据 indexKline 时指定 handler 为自定义函数 appendIndex，是指不断地收到 indexKline 数据后，首先过滤出指数数据中指数名为 idx1 的数据，然后再注入连接引擎的右表。</li></ul><p class="- topic/p p">构造数据写入作为原始输入的 2 个流数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// generate data: stock Kline
t1 = table(`A`B`A`B`A`B`A`B`A`B as Sym, 10:00:00.000+(0 0 1 1 2 2 3 3 4 4)*60000 as Time, (4.1 7.6 3.8 7.6 4.3 7.5 3.5 7.6 4.2 7.6) as Close)
// generate data: index Kline
t2 = table(`idx1`idx2`idx1`idx2`idx1`idx2`idx1`idx2`idx1`idx2 as Sym, 10:00:00.000+(0 0 1 1 2 2 3 3 4 4)*60000 as Time, (2.1 5 2.2 5 1.9 5 1.7 5 1.7 5) as Close)
// input data
indexKline.append!(t2)
stockKline.append!(t1)</code></pre><p class="- topic/p p">输入数据与关联关系如下：</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_10.png"/><br/><p class="- topic/p p">关联得到的结果表 output 如下，对于股票 A、B 每分钟都会关联对应分钟的指数 idx1。因为 mcorr 滑动窗口为 3，所以前两分钟结算结果为空。</p><img class="- topic/image image" src="images/streaming-real-time-correlation-processing/3_11.png"/><br/></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title18" id="4-流数据连接引擎的比较"><h2 class="- topic/title title topictitle2" id="ariaid-title18">4. 流数据连接引擎的比较</h2><div class="- topic/body body"><div class="table-container"><table class="- topic/table table" data-cols="6"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__1"><strong class="+ topic/ph hi-d/b ph b">连接引擎</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__2"><strong class="+ topic/ph hi-d/b ph b">连接列</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__3"><strong class="+ topic/ph hi-d/b ph b">关联机制</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__4"><strong class="+ topic/ph hi-d/b ph b">类似的 SQL join</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__5"><strong class="+ topic/ph hi-d/b ph b">结果表行数</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="4-流数据连接引擎的比较__entry__6"><strong class="+ topic/ph hi-d/b ph b">应用场景</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__1">AsofJoinEngine</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__2">matchingColumn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__3">左表每到来一条记录，匹配右表连接列一致且时间戳最近的一条记录。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__4">asof join</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__5">小于或等于左表行数</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__6"><a class="- topic/xref xref" href="#%E7%94%A8-asof-join-%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E4%B8%AA%E8%82%A1%E4%BA%A4%E6%98%93%E6%88%90%E6%9C%AC">计算个股交易成本</a></td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__1">WindowJoinEngine</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__2">matchingColumn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__3">左表每到来一条记录，匹配右表中连接列一致，且在由左表时间戳确定的窗口范围内的数据。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__4">window join</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__5">小于或等于左表行数</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__6"><a class="- topic/xref xref" href="#%E7%94%A8-window-join-%E5%BC%95%E6%93%8E%E5%B0%86%E8%A1%8C%E6%83%85%E5%BF%AB%E7%85%A7%E4%B8%8E%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88">将行情快照和逐笔成交数据融合</a></td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__1">EquiJoinEngine</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__2">matchingColumn+timeColumn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__3">左（右）表每到来一条记录，匹配右（左）表连接列一致的最新的一条记录。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__4">equi join</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__5">等于左右表能完全等值匹配的行数（在左右表中的连接列均唯一的前提下）</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__6"><a class="- topic/xref xref" href="#%E7%94%A8-equi-join-%E5%BC%95%E6%93%8E%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%AE%9E%E6%97%B6%E5%88%86%E9%92%9F%E6%8C%87%E6%A0%87">拼接不同数据源的实时分钟指标</a></td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__1">LookupJoinEngine</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__2">matchingColumn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__3">左表每到来一条记录，匹配右表连接列一致的最新的一条记录。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__4">left join</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__5">等于左表行数</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__6"><a class="- topic/xref xref" href="#%E7%94%A8-lookup-join-%E5%BC%95%E6%93%8E%E5%B0%86%E5%AE%9E%E6%97%B6%E8%A1%8C%E6%83%85%E4%B8%8E%E5%8E%86%E5%8F%B2%E6%97%A5%E9%A2%91%E6%8C%87%E6%A0%87%E5%85%B3%E8%81%94">将实时行情与历史日频指标关联</a></td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__1">LeftSemiJoinEngine</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__2">matchingColumn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__3">对于左表的每一条记录，匹配右表连接列一致的第一条或最后一条记录。</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__4">equi join</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__5">小于或等于左表行数</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="4-流数据连接引擎的比较__entry__6"><a class="- topic/xref xref" href="#%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%AF%B9%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%A1%A5%E5%85%85%E5%8E%9F%E5%A7%8B%E5%A7%94%E6%89%98%E4%BF%A1%E6%81%AF">对逐笔成交数据补充原始委托信息</a>、<a class="- topic/xref xref" href="#%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%85%B3%E8%81%94%E8%82%A1%E7%A5%A8%E4%B8%8E%E6%8C%87%E6%95%B0%E8%A1%8C%E6%83%85%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E6%80%A7">关联股票和指数行情并计算相关性</a>。</td></tr></tbody></table></div></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="5-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title19">5. 总结</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 提供了 5 个不同的流数据连接引擎，引擎均内置实现了高效的关联计算、实时触发规则和内存管理机制，开发人员通过简单的引擎参数配置便能够快速实现复杂的实时关联需求。本文重点介绍了各个连接引擎的原理、关联效果、实际应用案例，并在文末简要总结各个引擎的特点，旨在降低开发人员在实时数据流关联处理中的开发门槛。结合 DolphinDB 流数据框架中其他流计算引擎、流水线处理、并行计算等重要特性，开发人员可以将自己的业务场景实时化，通过提升速度掌握更及时的信息、挖掘更多的业务价值。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="6-附录"><h2 class="- topic/title title topictitle2" id="ariaid-title20">6. 附录</h2><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li">流环境清理通用脚本：<a class="- topic/xref xref" href="script/streaming-real-time-correlation-processing/clearStreamingEnv.dos">clearStreamingEnv.dos</a></li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%B5%81%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E5%85%B3%E8%81%94" data-tocid="1-流数据实时关联">1. 流数据实时关联</a><ul><li class="topic-item"><a href="#11-dolphindb-%E6%89%B9%E8%AE%A1%E7%AE%97%E8%A1%A8%E5%85%B3%E8%81%94" data-tocid="11-dolphindb-批计算表关联">1.1. DolphinDB 批计算表关联</a></li><li class="topic-item"><a href="#12-%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E6%B5%81%E5%85%B3%E8%81%94%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98" data-tocid="12-实时数据流关联面临的挑战">1.2. 实时数据流关联面临的挑战</a></li></ul></li><li class="topic-item"><a href="#2-%E6%B5%81%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%95%E6%93%8E" data-tocid="2-流数据连接引擎">2. 流数据连接引擎</a><ul><li class="topic-item"><a href="#21-asof-join-%E5%BC%95%E6%93%8Ecreateasofjoinengine" data-tocid="21-asof-join-引擎createasofjoinengine">2.1. Asof Join 引擎（createAsofJoinEngine）</a></li><li class="topic-item"><a href="#22-window-join-%E5%BC%95%E6%93%8Ecreatewindowjoinengine" data-tocid="22-window-join-引擎createwindowjoinengine">2.2. Window Join 引擎（createWindowJoinEngine）</a></li><li class="topic-item"><a href="#23-equi-join-%E5%BC%95%E6%93%8Ecreateequijoinengine" data-tocid="23-equi-join-引擎createequijoinengine">2.3. Equi Join 引擎（createEquiJoinEngine）</a></li><li class="topic-item"><a href="#24-lookup-join-%E5%BC%95%E6%93%8Ecreatelookupjoinengine" data-tocid="24-lookup-join-引擎createlookupjoinengine">2.4. Lookup Join 引擎（createLookupJoinEngine）</a></li><li class="topic-item"><a href="#25-left-semi-join-%E5%BC%95%E6%93%8Ecreateleftsemijoinengine" data-tocid="25-left-semi-join-引擎createleftsemijoinengine">2.5. Left Semi Join 引擎（createLeftSemiJoinEngine）</a></li></ul></li><li class="topic-item"><a href="#3-%E5%AE%9E%E6%97%B6%E5%85%B3%E8%81%94%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="3-实时关联应用案例">3. 实时关联应用案例</a><ul><li class="topic-item"><a href="#31-%E7%94%A8-asof-join-%E5%BC%95%E6%93%8E%E8%AE%A1%E7%AE%97%E4%B8%AA%E8%82%A1%E4%BA%A4%E6%98%93%E6%88%90%E6%9C%AC" data-tocid="31-用-asof-join-引擎计算个股交易成本">3.1. 用 Asof Join 引擎计算个股交易成本</a></li><li class="topic-item"><a href="#32-%E7%94%A8-window-join-%E5%BC%95%E6%93%8E%E5%B0%86%E8%A1%8C%E6%83%85%E5%BF%AB%E7%85%A7%E4%B8%8E%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88" data-tocid="32-用-window-join-引擎将行情快照与逐笔成交数据融合">3.2. 用 Window Join 引擎将行情快照与逐笔成交数据融合</a></li><li class="topic-item"><a href="#33-%E7%94%A8-equi-join-%E5%BC%95%E6%93%8E%E6%8B%BC%E6%8E%A5%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E6%BA%90%E7%9A%84%E5%AE%9E%E6%97%B6%E5%88%86%E9%92%9F%E6%8C%87%E6%A0%87" data-tocid="33-用-equi-join-引擎拼接不同数据源的实时分钟指标">3.3. 用 Equi Join 引擎拼接不同数据源的实时分钟指标</a></li><li class="topic-item"><a href="#34-%E7%94%A8-lookup-join-%E5%BC%95%E6%93%8E%E5%B0%86%E5%AE%9E%E6%97%B6%E8%A1%8C%E6%83%85%E4%B8%8E%E5%8E%86%E5%8F%B2%E6%97%A5%E9%A2%91%E6%8C%87%E6%A0%87%E5%85%B3%E8%81%94" data-tocid="34-用-lookup-join-引擎将实时行情与历史日频指标关联">3.4. 用 Lookup Join 引擎将实时行情与历史日频指标关联</a></li><li class="topic-item"><a href="#35-%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%AF%B9%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E8%A1%A5%E5%85%85%E5%8E%9F%E5%A7%8B%E5%A7%94%E6%89%98%E4%BF%A1%E6%81%AF" data-tocid="35-用-left-semi-join-引擎对逐笔成交数据补充原始委托信息">3.5. 用 Left Semi Join 引擎对逐笔成交数据补充原始委托信息</a></li><li class="topic-item"><a href="#36-%E7%94%A8-left-semi-join-%E5%BC%95%E6%93%8E%E5%85%B3%E8%81%94%E8%82%A1%E7%A5%A8%E4%B8%8E%E6%8C%87%E6%95%B0%E8%A1%8C%E6%83%85%E5%B9%B6%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3%E6%80%A7" data-tocid="36-用-left-semi-join-引擎关联股票与指数行情并计算相关性">3.6. 用 Left Semi Join 引擎关联股票与指数行情并计算相关性</a></li></ul></li><li class="topic-item"><a href="#4-%E6%B5%81%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%95%E6%93%8E%E7%9A%84%E6%AF%94%E8%BE%83" data-tocid="4-流数据连接引擎的比较">4. 流数据连接引擎的比较</a></li><li class="topic-item"><a href="#5-%E6%80%BB%E7%BB%93" data-tocid="5-总结">5. 总结</a></li><li class="topic-item"><a href="#6-%E9%99%84%E5%BD%95" data-tocid="6-附录">6. 附录</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>