<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在使用 DolphinDB 的脚本进行开发时，可以创建可复用模块，以封装自定义函数。模块可以将大量函数按目录树结构组织在不同模块中。既可以在系统初始化时预加载模块，也可以在需要使用的时候引入模块。 在 DolphinDB 中，模块是只包含函数定义的脚本文件。它具有以下特点： 模块文件默认保存在 [home]/modules 目录下。 模块文件名的后缀为 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="模块概述"/><title>模块概述</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;模块概述&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:1;1:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:1;1:1&#34;&gt;模块概述&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:1;1:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:1;3:1&#34;&gt;在使用 DolphinDB 的脚本进行开发时，可以创建可复用模块，以封装自定义函数。模块可以将大量函数按目录树结构组织在不同模块中。既可以在系统初始化时预加载模块，也可以在需要使用的时候引入模块。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;1-module模块介绍&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:2;5:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:2;5:1&#34;&gt;1. Module（模块）介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:2;5:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:2;7:1&#34;&gt;在 DolphinDB 中，模块是只包含函数定义的脚本文件。它具有以下特点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:1;9:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:1;9:1&#34;&gt;模块文件默认保存在 [home]/modules 目录下。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:2;10:1&#34;&gt;模块文件名的后缀为 .dos（&#34;DolphinScript&#34;的缩写）或 .dom（&#34;DolphinModule&#34;的缩写）。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:3;11:1&#34;&gt;模块文件第一行只能使用 module 后接模块名以声明模块，即 module module_name。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:4;12:1&#34;&gt;模块文件除第一行外，仅可包含模块导入语句与函数定义。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;2-定义模块&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:3;14:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:3;14:1&#34;&gt;2. 定义模块&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:3;14:1&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;21-创建模块目录&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:4;16:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:4;16:1&#34;&gt;2.1. 创建模块目录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:4;16:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:3;18:1&#34;&gt;所有的模块定义默认存放在 [home]/modules 目录下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:2;20:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:5;20:1&#34;&gt;[home] 目录由系统配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:1;20:21&#34;&gt;home&lt;/i&gt; 决定，可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:1;20:36&#34;&gt;getHomeDir&lt;/codeph&gt; 函数查看。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:6;21:1&#34;&gt;节点的模块目录由配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:2;21:16&#34;&gt;moduleDir&lt;/i&gt; 来指定，其默认值是相对路径 modules。系统会首先到节点的 home 目录寻找该目录，如果没有找到，会依次在节点的工作目录与可执行文件所在目录寻找。请注意，单节点模式下，这三个目录默认相同。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;22-创建模块文件&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:5;23:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:5;23:1&#34;&gt;2.2. 创建模块文件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:5;23:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:4;25:1&#34;&gt;在 modules 目录下创建以 .dos 为后缀的模块文件，例如 fileLog.dos。模块文件的第一行必须是模块声明语句。例如在 fileLog.dos 中声明模块：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:1;26:1&#34;&gt;module fileLog&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:5;29:1&#34;&gt;其中 fileLog 是模块名，必须与模块文件（fileLog.dos）的名称一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:6;31:1&#34;&gt;模块文件除第一行外的内容仅可包含函数定义或模块导入语句（如需引用其它模块）。例如，fileLog 模块仅包括向指定日志文件写入日志的函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:2;31:70&#34;&gt;appendLog&lt;/codeph&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:2;32:1&#34;&gt;module fileLog def appendLog(filePath, logText){ f = file(filePath,&#34;a+&#34;) f.writeLine(string(now()) + &#34; : &#34; + logText) f.close() }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:7;42:1&#34;&gt;在模块文件中，&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;b:1;42:8&#34;&gt;除函数定义、模块声明语句和模块导入语句外，其它代码将被忽略&lt;/b&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;23-序列化模块文件&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:6;44:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:6;44:1&#34;&gt;2.3. 序列化模块文件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:6;44:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:8;46:1&#34;&gt;使用 saveModule 函数可以将模块序列化成扩展名为 dom 的二进制文件。将模块序列化为 dom 文件能够增强代码的保密性和安全性。例如，序列化上一节中的 module fileLog：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:3;48:1&#34;&gt;saveModule(&#34;fileLog&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:9;52:1&#34;&gt;dom 文件会保存至 dos 文件所在的目录。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:10;54:1&#34;&gt;注意：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:3;55:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:7;55:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:11;55:3&#34;&gt;如果 dos 文件的内容发生改变，需要重新执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:3;55:27&#34;&gt;saveModule&lt;/codeph&gt; 函数来生成新的 dom 文件。可将 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:4;55:58&#34;&gt;saveModule&lt;/codeph&gt; 函数的 overwrite 参数设置为 true 来覆盖已有的 dom 文件。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:4;57:2&#34;&gt; saveModule(&#34;fileLog&#34; , , true)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:8;60:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:12;60:3&#34;&gt;如果当前模块引用了另一个模块的函数，则在序列化该模块中只会对其依赖模块的名称进行序列化，不会序列化依赖函数的定义。因此，在加载或移动 .dom 文件时，需同时加载或移动其依赖的模块文件。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;3-导入模块&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:7;62:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:7;62:1&#34;&gt;3. 导入模块&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:7;62:1&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;31-使用use关键字&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:8;64:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:8;64:1&#34;&gt;3.1. 使用use关键字&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:8;64:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:13;66:1&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:5;66:4&#34;&gt;use&lt;/codeph&gt; 关键字来导入一个模块。如果导入的模块依赖了其他模块，系统会自动加载其他模块。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:14;68:1&#34;&gt;注意:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:4;69:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:9;69:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:6;69:3&#34;&gt;use&lt;/codeph&gt; 关键字导入的模块是会话隔离的，仅对当前会话有效。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:10;70:1&#34;&gt;自 2.00.12 版本起，use 关键字支持导入后缀为 .dos 的模块文件或 .dom 的二进制文件。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:15;72:1&#34;&gt;导入模块后，可以通过以下两种方式来使用模块内的自定义函数：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:16;74:1&#34;&gt;(1) 直接使用模块中的函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:5;75:1&#34;&gt;use fileLog appendLog(&#34;mylog.txt&#34;, &#34;test my log&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:17;80:1&#34;&gt;(2) 指定模块中的函数的命名空间（即在 modules 目录下的完整路径）：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:6;81:1&#34;&gt;use fileLog fileLog::appendLog(&#34;mylog.txt&#34;, &#34;test my log&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:18;85:1&#34;&gt;若导入的不同模块中含有相同名称的函数，则必须通过此种方式调用此类函数。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;32-将模块内函数加载为系统内置函数&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:9;87:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:9;87:1&#34;&gt;3.2. 将模块内函数加载为系统内置函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:9;87:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:19;89:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;b:2;89:1&#34;&gt;注意&lt;/b&gt;：该功能在1.20.1及以上版本支持。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:20;91:1&#34;&gt;3.1节提到，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:7;91:8&#34;&gt;use&lt;/codeph&gt; 关键字导入的模块是会话隔离的，这在实际使用中会带来一些不便。为了解决这一问题，DolphinDB 支持通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:8;91:68&#34;&gt;loadModule&lt;/codeph&gt; 函数或者配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:3;91:90&#34;&gt;preloadModules&lt;/i&gt; 将模块定义的函数加载为系统的内置函数，这样模块对所有会话都是可见的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:21;93:1&#34;&gt;模块定义的函数成为内置函数之后，具有以下特点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:5;95:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:11;95:1&#34;&gt;用户无法覆盖函数的定义。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:12;96:1&#34;&gt;如果在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:9;96:7&#34;&gt;remoteRun&lt;/codeph&gt; 或 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:10;96:21&#34;&gt;rpc&lt;/codeph&gt; 中使用了该函数，系统不会序列化该函数的定义到远程节点。因此远程节点也必须加载该模块，否则系统会抛出无法找到函数的异常。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:13;97:1&#34;&gt;该函数在系统内存中只有一份，且对所有会话可见。不仅节约了内存，还减少了每个会话加载模块的时间。另外，无需使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:11;97:58&#34;&gt;use&lt;/codeph&gt; 关键字导入模块，使得调用模块的代码更加简洁，API 调用模块函数更加方便。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:22;99:1&#34;&gt;可以通过 .dos 文件或 .dom 文件加载模块。系统会自动到 modules 目录寻找模块文件。如果目录中包含同名的 .dos 文件和 .dom 文件，系统只加载 .dom 文件。如果加载的是 .dom 文件，则用户无法查看模块内函数的定义。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:23;101:1&#34;&gt;如果加载的模块中引用了其他模块：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:6;102:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:14;102:1&#34;&gt;如果加载的是 .dos 文件，则系统在加载时会自动加载其依赖的模块。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:15;103:1&#34;&gt;如果加载的是 .dom 文件，则必须先加载该模块中所依赖的模块文件。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;321-通过-loadmodule-函数加载&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:10;105:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:10;105:1&#34;&gt;3.2.1. 通过 loadModule 函数加载&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:10;105:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:24;107:1&#34;&gt;该函数只能在系统的初始化脚本（默认是dolphindb.dos）中使用，不能在命令行或者 GUI 中执行。例如，加载上文“创建模块文件”节中的模块 fileLog，在 dolphindb.dos 文件末尾加上：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:7;109:1&#34;&gt;loadModule(&#34;fileLog&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:25;112:1&#34;&gt;通过此方法加载模块后，在调用模块函数时必须指定函数的命名空间（即在 modules 目录下的完整路径）：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:8;114:1&#34;&gt;fileLog::appendLog(&#34;mylog.txt&#34;, &#34;test my log&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;322-通过配置参数-preloadmodules-加载&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:11;118:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:11;118:1&#34;&gt;3.2.2. 通过配置参数 preloadModules 加载&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:11;118:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:26;120:1&#34;&gt;对单机版，该参数在 dolphindb.cfg 中配置。对集群版，需要为 controller 和 datanode 加载相同的模块。最简单的方法在 controller.cfg 和 cluster.cfg 中配置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:4;120:109&#34;&gt;preloadModules&lt;/i&gt; 参数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:27;122:1&#34;&gt;例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:9;124:1&#34;&gt;preloadModules=fileLog&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:28;127:1&#34;&gt;如果需要加载多个模块，使用逗号分隔。模块函数加载方法同 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:12;127:29&#34;&gt;loadModule&lt;/codeph&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;323-与函数视图function-view的区别&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:12;129:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:12;129:1&#34;&gt;3.2.3. 与函数视图（function view）的区别&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:12;129:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:29;131:1&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:13;131:4&#34;&gt;loadModule&lt;/codeph&gt; 或 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:5;131:19&#34;&gt;preloadModules&lt;/i&gt; 生成的内置函数与 function view 对比，有以下区别：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:7;133:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:16;133:1&#34;&gt;dom 模块的函数对所有人均不可见，包括系统管理员和 owner，保密性更高。function view 的定义对 admin 和 owner 以及授权用户可见。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:17;134:1&#34;&gt;所有模块都会有模块名称。function view 目前不支持域名限定。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:18;135:1&#34;&gt;序列化一个模块时，不会序列化依赖的函数，只会序列化依赖的模块名称。而 function view 序列化时，会序列化所有的依赖，以及依赖的依赖，实现 self-contained。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:30;137:1&#34;&gt;function view 和模块的应用场景有所不同。function view 一般用于跟数据库相关的数据访问。模块中的函数一般是通用的处理逻辑或算法。function view 可能会调用模块中的函数，但是模块中的函数一般不调用 function view。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;4-模块分类&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:13;139:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:13;139:1&#34;&gt;4. 模块分类&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:13;139:1&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;41-声明模块类别命名空间&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:14;141:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:14;141:1&#34;&gt;4.1. 声明模块类别命名空间&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:14;141:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:31;143:1&#34;&gt;如果需要对模块进行分类，可在 modules 目录下设置多个子目录，以作为不同模块类别的命名空间。例如，现有两个模块 fileLog 和 dateUtil，它们分别存放于 modules/system/log/fileLog.dos 与 modules/system/temperal/dateUtil.dos。这两个模块相应的声明语句分别为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:14;143:173&#34;&gt;module system::log::fileLog&lt;/codeph&gt; 与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:15;143:209&#34;&gt;module system::temperal::dateUtil&lt;/codeph&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;42-调用命名空间模块&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:15;145:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:15;145:1&#34;&gt;4.2. 调用命名空间模块&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:15;145:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:32;147:1&#34;&gt;在对模块进行序列化（saveModule）、通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:16;147:26&#34;&gt;use&lt;/codeph&gt; 语句导入、以及通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:17;147:42&#34;&gt;loadModule&lt;/codeph&gt; 函数或 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;i:6;147:59&#34;&gt;preloadModules&lt;/i&gt; 配置参数加载时，均需指定完整路径。例如，导入上一节中的 fileLog 模块：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:10;148:1&#34;&gt;use system::log::fileLog&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:33;151:1&#34;&gt;可以通过以下两种方法调用模块函数：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:8;153:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:19;153:1&#34;&gt;直接调用其中函数：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:11;154:1&#34;&gt;appendLog(&#34;mylog.txt&#34;, &#34;test my log&#34;)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:9;157:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:20;157:1&#34;&gt;使用全路径调用其中函数：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:12;158:1&#34;&gt;system::log::fileLog::appendLog(&#34;mylog.txt&#34;, &#34;test my log&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;5-gui中远程调试模块&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:16;162:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:16;162:1&#34;&gt;5. GUI中远程调试模块&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:16;162:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:34;164:1&#34;&gt;当 GUI 所在机器与 DolphinDB 服务器不是同一台机器时，在 GUI 中编辑的模块代码，需要先上传到远程服务器的 [home]/modules 目录，才能通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:18;164:87&#34;&gt;use&lt;/codeph&gt; 语句调用模块。其中[home]表示DolphinDB 的主目录，通过配置项 home 指定。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:35;166:1&#34;&gt;DolphinDB GUI 从0.99.2版本开始提供了远程同步模块的功能，具体用法如下：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ol:1;168:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:21;168:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:36;168:4&#34;&gt;指定远程服务器路径：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:10;169:4&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:22;169:4&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:37;169:6&#34;&gt;添加远程服务器（Server-&amp;gt;Add Server）时，指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:19;169:38&#34;&gt;Remote Directory&lt;/codeph&gt; 目录:&lt;?linebreak?&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/GUI/add_server.png&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;image:1;170:4&#34; dita-ot:image-width=&#34;629&#34; dita-ot:image-height=&#34;414&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;alt:1;170:4&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:23;172:4&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:38;172:6&#34;&gt;若上步中未指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:20;172:14&#34;&gt;Remote Directory&lt;/codeph&gt;，可通过 Server-&amp;gt;Edit Server 进行添加：&lt;?linebreak?&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/GUI/module_sync.png&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;image:2;173:4&#34; dita-ot:image-width=&#34;351&#34; dita-ot:image-height=&#34;655&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;alt:2;173:4&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:24;175:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:39;175:4&#34;&gt;点击下图 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:21;175:9&#34;&gt;Synchronize to server&lt;/codeph&gt; 将 modules 目录下的所有文件和子目录同步到步骤1设置的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:22;175:65&#34;&gt;Remote Directory&lt;/codeph&gt; 下。 &lt;image class=&#34;- topic/image &#34; href=&#34;images/GUI/module_sync.png&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;image:3;176:1&#34; dita-ot:image-width=&#34;351&#34; dita-ot:image-height=&#34;655&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;alt:3;176:1&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:40;178:1&#34;&gt;假设 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:23;178:4&#34;&gt;Remote Directory&lt;/codeph&gt; 设置为'[home]/modules'，本地需要同步的文件名是 &#34;C:/users/usr1/Project/scripts/test.dos&#34;。同步的时候，系统会在远端自动创建目录和相应文件 '[home]/modules/Project/scripts/test.dos'。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:41;180:1&#34;&gt;同步完成后，就可以在远程服务器上执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:24;180:20&#34;&gt;use&lt;/codeph&gt; 语句导入模块。需要注意的是，在使用模块前，需要参考&lt;xref class=&#34;- topic/xref &#34; href=&#34;#创建模块目录&#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;xref:1;180:51&#34;&gt;&lt;?ditaot usertext?&gt;上文“创建模块目录”&lt;/xref&gt;设置模块路径。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;6-注意事项&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:17;182:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:17;182:1&#34;&gt;6. 注意事项&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:17;182:1&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;61-同名函数定义规则&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:18;184:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:18;184:1&#34;&gt;6.1. 同名函数定义规则&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:18;184:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:42;186:1&#34;&gt;不同模块中可以定义相同名字的函数。如果使用全路径调用函数，可以通过模块命名空间来区分函数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:43;188:1&#34;&gt;如果直接调用函数：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:11;190:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:25;190:1&#34;&gt;若只有一个已导入模块包含该函数，DolphinDB 会调用该模块的函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:26;191:1&#34;&gt;若多个已导入模块包含该函数，会抛出异常：&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:13;192:2&#34;&gt; Modules [Module1] and [Module2] contain function [functionName]. Please use module name to qualify the function.&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:27;195:1&#34;&gt;若所有已导入的模块中均不包含该函数，DolphinDB 会在系统内置函数中搜索该函数。如果内置函数中也没有该函数，将抛出函数未定义的异常。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:28;196:1&#34;&gt;若已导入模块中某函数与某自定义函数重名，调用时需要通过命名空间来区分函数。自定义函数和内置函数的默认命名空间为根目录，用两个冒号表示。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:44;198:1&#34;&gt;下例中，首先创建自定义函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:25;198:14&#34;&gt;myfunc&lt;/codeph&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:14;199:1&#34;&gt;login(&#34;admin&#34;,&#34;123456&#34;) def myfunc(){ return 1 } addFunctionView(myfunc)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:45;206:1&#34;&gt;然后定义模块sys，其中含有函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:26;206:17&#34;&gt;myfunc&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:15;207:1&#34;&gt;module sys def myfunc(){ return 3 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:46;213:1&#34;&gt;若要调用模块sys中的函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:27;213:14&#34;&gt;myfunc&lt;/codeph&gt;，可在使用&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:16;214:1&#34;&gt;use sys&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:47;217:1&#34;&gt;之后，使用：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:17;218:1&#34;&gt;sys::myfunc()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:48;221:1&#34;&gt;或：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:18;222:1&#34;&gt;myfunc()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:49;225:1&#34;&gt;若要使用模块外的自定义函数，可使用：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeblock:19;226:1&#34;&gt;::myfunc()&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;62-刷新模块定义&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:19;230:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:19;230:1&#34;&gt;6.2. 刷新模块定义&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:19;230:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;p:50;232:1&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;codeph:28;232:4&#34;&gt;use&lt;/codeph&gt; 导入模块时，模块函数被加载到缓存中，后续调用函数时，都将从缓存中进行调用。若需要在测试过程中快速反复修改模块代码并刷新定义，可采用以下方法：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:12;234:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:29;234:1&#34;&gt;在模块文件修改后执行全部的模块代码。这种方法仅对当前会话有效。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:30;235:1&#34;&gt;调用命令 clearCachedModules，强制清除缓存的模块。当缓存清除后，执行 use 语句时，会重新从文件加载模块，无需重启节点。只有 admin 才有权限执行这个命令。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;63-模块间互相调用&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;topic:20;237:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;title:20;237:1&#34;&gt;6.3. 模块间互相调用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;body:20;237:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;ul:13;239:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:31;239:1&#34;&gt;模块之间可以单向引用，例如允许模块a引用b，b引用c。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/module_tutorial.md&#34; xtrc=&#34;li:32;240:1&#34;&gt;模块之间不支持交叉引用，例如不允许模块a引用b，模块b又引用a。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/module_tutorial.md"/><meta name="wh-out-relpath" content="tutorials/module_tutorial.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="模块概述" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                    
                    <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="wh_topic_body">
                        
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">模块概述</h1><div class="- topic/body body"><p class="- topic/p p">在使用 DolphinDB 的脚本进行开发时，可以创建可复用模块，以封装自定义函数。模块可以将大量函数按目录树结构组织在不同模块中。既可以在系统初始化时预加载模块，也可以在需要使用的时候引入模块。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-module模块介绍"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. Module（模块）介绍</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，模块是只包含函数定义的脚本文件。它具有以下特点：</p><ul class="- topic/ul ul"><li class="- topic/li li">模块文件默认保存在 [home]/modules 目录下。</li><li class="- topic/li li">模块文件名的后缀为 .dos（"DolphinScript"的缩写）或 .dom（"DolphinModule"的缩写）。</li><li class="- topic/li li">模块文件第一行只能使用 module 后接模块名以声明模块，即 module module_name。</li><li class="- topic/li li">模块文件除第一行外，仅可包含模块导入语句与函数定义。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-定义模块"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 定义模块</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-创建模块目录"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1. 创建模块目录</h3><div class="- topic/body body"><p class="- topic/p p">所有的模块定义默认存放在 [home]/modules 目录下：</p><ul class="- topic/ul ul"><li class="- topic/li li">[home] 目录由系统配置参数 <em class="+ topic/ph hi-d/i ph i">home</em> 决定，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">getHomeDir</code> 函数查看。</li><li class="- topic/li li">节点的模块目录由配置参数 <em class="+ topic/ph hi-d/i ph i">moduleDir</em> 来指定，其默认值是相对路径 modules。系统会首先到节点的 home 目录寻找该目录，如果没有找到，会依次在节点的工作目录与可执行文件所在目录寻找。请注意，单节点模式下，这三个目录默认相同。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="22-创建模块文件"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.2. 创建模块文件</h3><div class="- topic/body body"><p class="- topic/p p">在 modules 目录下创建以 .dos 为后缀的模块文件，例如 fileLog.dos。模块文件的第一行必须是模块声明语句。例如在 fileLog.dos 中声明模块：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>module fileLog</code></pre><p class="- topic/p p">其中 fileLog 是模块名，必须与模块文件（fileLog.dos）的名称一致。</p><p class="- topic/p p">模块文件除第一行外的内容仅可包含函数定义或模块导入语句（如需引用其它模块）。例如，fileLog 模块仅包括向指定日志文件写入日志的函数 <code class="+ topic/ph pr-d/codeph ph codeph">appendLog</code>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>module fileLog

def appendLog(filePath, logText){
	f = file(filePath,"a+")
	f.writeLine(string(now()) + " : " + logText)
	f.close()
}</code></pre><p class="- topic/p p">在模块文件中，<strong class="+ topic/ph hi-d/b ph b">除函数定义、模块声明语句和模块导入语句外，其它代码将被忽略</strong>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="23-序列化模块文件"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.3. 序列化模块文件</h3><div class="- topic/body body"><p class="- topic/p p">使用 saveModule 函数可以将模块序列化成扩展名为 dom 的二进制文件。将模块序列化为 dom 文件能够增强代码的保密性和安全性。例如，序列化上一节中的 module fileLog：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>saveModule("fileLog")</code></pre><p class="- topic/p p">dom 文件会保存至 dos 文件所在的目录。</p><p class="- topic/p p">注意：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">如果 dos 文件的内容发生改变，需要重新执行 <code class="+ topic/ph pr-d/codeph ph codeph">saveModule</code> 函数来生成新的 dom 文件。可将 <code class="+ topic/ph pr-d/codeph ph codeph">saveModule</code> 函数的 overwrite 参数设置为 true 来覆盖已有的 dom 文件。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>	saveModule("fileLog" , , true)</code></pre></li><li class="- topic/li li"><p class="- topic/p p">如果当前模块引用了另一个模块的函数，则在序列化该模块中只会对其依赖模块的名称进行序列化，不会序列化依赖函数的定义。因此，在加载或移动 .dom 文件时，需同时加载或移动其依赖的模块文件。</p></li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="3-导入模块"><h2 class="- topic/title title topictitle2" id="ariaid-title7">3. 导入模块</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="31-使用use关键字"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.1. 使用use关键字</h3><div class="- topic/body body"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 关键字来导入一个模块。如果导入的模块依赖了其他模块，系统会自动加载其他模块。</p><p class="- topic/p p">注意:</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">use</code> 关键字导入的模块是会话隔离的，仅对当前会话有效。</li><li class="- topic/li li">自 2.00.12 版本起，use 关键字支持导入后缀为 .dos 的模块文件或 .dom 的二进制文件。</li></ul><p class="- topic/p p">导入模块后，可以通过以下两种方式来使用模块内的自定义函数：</p><p class="- topic/p p">(1) 直接使用模块中的函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use fileLog
appendLog("mylog.txt", "test my log")</code></pre><p class="- topic/p p">(2) 指定模块中的函数的命名空间（即在 modules 目录下的完整路径）：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use fileLog
fileLog::appendLog("mylog.txt", "test my log")</code></pre><p class="- topic/p p">若导入的不同模块中含有相同名称的函数，则必须通过此种方式调用此类函数。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="32-将模块内函数加载为系统内置函数"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.2. 将模块内函数加载为系统内置函数</h3><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：该功能在1.20.1及以上版本支持。</p><p class="- topic/p p">3.1节提到，<code class="+ topic/ph pr-d/codeph ph codeph">use</code> 关键字导入的模块是会话隔离的，这在实际使用中会带来一些不便。为了解决这一问题，DolphinDB 支持通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadModule</code> 函数或者配置参数 <em class="+ topic/ph hi-d/i ph i">preloadModules</em> 将模块定义的函数加载为系统的内置函数，这样模块对所有会话都是可见的。</p><p class="- topic/p p">模块定义的函数成为内置函数之后，具有以下特点：</p><ul class="- topic/ul ul"><li class="- topic/li li">用户无法覆盖函数的定义。</li><li class="- topic/li li">如果在 <code class="+ topic/ph pr-d/codeph ph codeph">remoteRun</code> 或 <code class="+ topic/ph pr-d/codeph ph codeph">rpc</code> 中使用了该函数，系统不会序列化该函数的定义到远程节点。因此远程节点也必须加载该模块，否则系统会抛出无法找到函数的异常。</li><li class="- topic/li li">该函数在系统内存中只有一份，且对所有会话可见。不仅节约了内存，还减少了每个会话加载模块的时间。另外，无需使用 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 关键字导入模块，使得调用模块的代码更加简洁，API 调用模块函数更加方便。</li></ul><p class="- topic/p p">可以通过 .dos 文件或 .dom 文件加载模块。系统会自动到 modules 目录寻找模块文件。如果目录中包含同名的 .dos 文件和 .dom 文件，系统只加载 .dom 文件。如果加载的是 .dom 文件，则用户无法查看模块内函数的定义。</p><p class="- topic/p p">如果加载的模块中引用了其他模块：</p><ul class="- topic/ul ul"><li class="- topic/li li">如果加载的是 .dos 文件，则系统在加载时会自动加载其依赖的模块。</li><li class="- topic/li li">如果加载的是 .dom 文件，则必须先加载该模块中所依赖的模块文件。</li></ul></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="321-通过-loadmodule-函数加载"><h4 class="- topic/title title topictitle4" id="ariaid-title10">3.2.1. 通过 loadModule 函数加载</h4><div class="- topic/body body"><p class="- topic/p p">该函数只能在系统的初始化脚本（默认是dolphindb.dos）中使用，不能在命令行或者 GUI 中执行。例如，加载上文“创建模块文件”节中的模块 fileLog，在 dolphindb.dos 文件末尾加上：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>loadModule("fileLog")</code></pre><p class="- topic/p p">通过此方法加载模块后，在调用模块函数时必须指定函数的命名空间（即在 modules 目录下的完整路径）：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>fileLog::appendLog("mylog.txt", "test my log")</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="322-通过配置参数-preloadmodules-加载"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.2.2. 通过配置参数 preloadModules 加载</h4><div class="- topic/body body"><p class="- topic/p p">对单机版，该参数在 dolphindb.cfg 中配置。对集群版，需要为 controller 和 datanode 加载相同的模块。最简单的方法在 controller.cfg 和 cluster.cfg 中配置 <em class="+ topic/ph hi-d/i ph i">preloadModules</em> 参数。</p><p class="- topic/p p">例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>preloadModules=fileLog</code></pre><p class="- topic/p p">如果需要加载多个模块，使用逗号分隔。模块函数加载方法同 <code class="+ topic/ph pr-d/codeph ph codeph">loadModule</code>。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="323-与函数视图function-view的区别"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.2.3. 与函数视图（function view）的区别</h4><div class="- topic/body body"><p class="- topic/p p">通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadModule</code> 或 <em class="+ topic/ph hi-d/i ph i">preloadModules</em> 生成的内置函数与 function view 对比，有以下区别：</p><ul class="- topic/ul ul"><li class="- topic/li li">dom 模块的函数对所有人均不可见，包括系统管理员和 owner，保密性更高。function view 的定义对 admin 和 owner 以及授权用户可见。</li><li class="- topic/li li">所有模块都会有模块名称。function view 目前不支持域名限定。</li><li class="- topic/li li">序列化一个模块时，不会序列化依赖的函数，只会序列化依赖的模块名称。而 function view 序列化时，会序列化所有的依赖，以及依赖的依赖，实现 self-contained。</li></ul><p class="- topic/p p">function view 和模块的应用场景有所不同。function view 一般用于跟数据库相关的数据访问。模块中的函数一般是通用的处理逻辑或算法。function view 可能会调用模块中的函数，但是模块中的函数一般不调用 function view。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="4-模块分类"><h2 class="- topic/title title topictitle2" id="ariaid-title13">4. 模块分类</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="41-声明模块类别命名空间"><h3 class="- topic/title title topictitle3" id="ariaid-title14">4.1. 声明模块类别命名空间</h3><div class="- topic/body body"><p class="- topic/p p">如果需要对模块进行分类，可在 modules 目录下设置多个子目录，以作为不同模块类别的命名空间。例如，现有两个模块 fileLog 和 dateUtil，它们分别存放于 modules/system/log/fileLog.dos 与 modules/system/temperal/dateUtil.dos。这两个模块相应的声明语句分别为 <code class="+ topic/ph pr-d/codeph ph codeph">module system::log::fileLog</code> 与 <code class="+ topic/ph pr-d/codeph ph codeph">module system::temperal::dateUtil</code>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="42-调用命名空间模块"><h3 class="- topic/title title topictitle3" id="ariaid-title15">4.2. 调用命名空间模块</h3><div class="- topic/body body"><p class="- topic/p p">在对模块进行序列化（saveModule）、通过 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 语句导入、以及通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadModule</code> 函数或 <em class="+ topic/ph hi-d/i ph i">preloadModules</em> 配置参数加载时，均需指定完整路径。例如，导入上一节中的 fileLog 模块：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use system::log::fileLog</code></pre><p class="- topic/p p">可以通过以下两种方法调用模块函数：</p><ul class="- topic/ul ul"><li class="- topic/li li">直接调用其中函数：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>appendLog("mylog.txt", "test my log")</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">使用全路径调用其中函数：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>system::log::fileLog::appendLog("mylog.txt", "test my log")</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title16" id="5-gui中远程调试模块"><h2 class="- topic/title title topictitle2" id="ariaid-title16">5. GUI中远程调试模块</h2><div class="- topic/body body"><p class="- topic/p p">当 GUI 所在机器与 DolphinDB 服务器不是同一台机器时，在 GUI 中编辑的模块代码，需要先上传到远程服务器的 [home]/modules 目录，才能通过 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 语句调用模块。其中[home]表示DolphinDB 的主目录，通过配置项 home 指定。</p><p class="- topic/p p">DolphinDB GUI 从0.99.2版本开始提供了远程同步模块的功能，具体用法如下：</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">指定远程服务器路径：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">添加远程服务器（Server-&gt;Add Server）时，指定 <code class="+ topic/ph pr-d/codeph ph codeph">Remote Directory</code> 目录:<br/><img class="- topic/image image" src="images/GUI/add_server.png" alt="image"/><br/></p></li><li class="- topic/li li"><p class="- topic/p p">若上步中未指定 <code class="+ topic/ph pr-d/codeph ph codeph">Remote Directory</code>，可通过 Server-&gt;Edit Server 进行添加：<br/><img class="- topic/image image" src="images/GUI/module_sync.png" alt="image"/><br/></p></li></ul></li><li class="- topic/li li"><p class="- topic/p p">点击下图 <code class="+ topic/ph pr-d/codeph ph codeph">Synchronize to server</code> 将 modules 目录下的所有文件和子目录同步到步骤1设置的 <code class="+ topic/ph pr-d/codeph ph codeph">Remote Directory</code> 下。
<img class="- topic/image image" src="images/GUI/module_sync.png" alt="image"/><br/></p></li></ol><p class="- topic/p p">假设 <code class="+ topic/ph pr-d/codeph ph codeph">Remote Directory</code> 设置为'[home]/modules'，本地需要同步的文件名是 "C:/users/usr1/Project/scripts/test.dos"。同步的时候，系统会在远端自动创建目录和相应文件 '[home]/modules/Project/scripts/test.dos'。</p><p class="- topic/p p">同步完成后，就可以在远程服务器上执行 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 语句导入模块。需要注意的是，在使用模块前，需要参考<a class="- topic/xref xref" href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9B%AE%E5%BD%95">上文“创建模块目录”</a>设置模块路径。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="6-注意事项"><h2 class="- topic/title title topictitle2" id="ariaid-title17">6. 注意事项</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="61-同名函数定义规则"><h3 class="- topic/title title topictitle3" id="ariaid-title18">6.1. 同名函数定义规则</h3><div class="- topic/body body"><p class="- topic/p p">不同模块中可以定义相同名字的函数。如果使用全路径调用函数，可以通过模块命名空间来区分函数。</p><p class="- topic/p p">如果直接调用函数：</p><ul class="- topic/ul ul"><li class="- topic/li li">若只有一个已导入模块包含该函数，DolphinDB 会调用该模块的函数。</li><li class="- topic/li li">若多个已导入模块包含该函数，会抛出异常：<pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>	Modules [Module1] and [Module2] contain function [functionName]. Please use module name to qualify the function.</code></pre></li><li class="- topic/li li">若所有已导入的模块中均不包含该函数，DolphinDB 会在系统内置函数中搜索该函数。如果内置函数中也没有该函数，将抛出函数未定义的异常。</li><li class="- topic/li li">若已导入模块中某函数与某自定义函数重名，调用时需要通过命名空间来区分函数。自定义函数和内置函数的默认命名空间为根目录，用两个冒号表示。</li></ul><p class="- topic/p p">下例中，首先创建自定义函数<code class="+ topic/ph pr-d/codeph ph codeph">myfunc</code>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>login("admin","123456")
def myfunc(){
 return 1
}
addFunctionView(myfunc)</code></pre><p class="- topic/p p">然后定义模块sys，其中含有函数<code class="+ topic/ph pr-d/codeph ph codeph">myfunc</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>module sys
def myfunc(){
 return 3
}</code></pre><p class="- topic/p p">若要调用模块sys中的函数<code class="+ topic/ph pr-d/codeph ph codeph">myfunc</code>，可在使用</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use sys</code></pre><p class="- topic/p p">之后，使用：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sys::myfunc()</code></pre><p class="- topic/p p">或：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>myfunc()</code></pre><p class="- topic/p p">若要使用模块外的自定义函数，可使用：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>::myfunc()</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="62-刷新模块定义"><h3 class="- topic/title title topictitle3" id="ariaid-title19">6.2. 刷新模块定义</h3><div class="- topic/body body"><p class="- topic/p p">通过 <code class="+ topic/ph pr-d/codeph ph codeph">use</code> 导入模块时，模块函数被加载到缓存中，后续调用函数时，都将从缓存中进行调用。若需要在测试过程中快速反复修改模块代码并刷新定义，可采用以下方法：</p><ul class="- topic/ul ul"><li class="- topic/li li">在模块文件修改后执行全部的模块代码。这种方法仅对当前会话有效。</li><li class="- topic/li li">调用命令 clearCachedModules，强制清除缓存的模块。当缓存清除后，执行 use 语句时，会重新从文件加载模块，无需重启节点。只有 admin 才有权限执行这个命令。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title20" id="63-模块间互相调用"><h3 class="- topic/title title topictitle3" id="ariaid-title20">6.3. 模块间互相调用</h3><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li">模块之间可以单向引用，例如允许模块a引用b，b引用c。</li><li class="- topic/li li">模块之间不支持交叉引用，例如不允许模块a引用b，模块b又引用a。</li></ul></div></article></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-module%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D" data-tocid="1-module模块介绍">1. Module（模块）介绍</a></li><li class="topic-item"><a href="#2-%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97" data-tocid="2-定义模块">2. 定义模块</a><ul><li class="topic-item"><a href="#21-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E7%9B%AE%E5%BD%95" data-tocid="21-创建模块目录">2.1. 创建模块目录</a></li><li class="topic-item"><a href="#22-%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6" data-tocid="22-创建模块文件">2.2. 创建模块文件</a></li><li class="topic-item"><a href="#23-%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6" data-tocid="23-序列化模块文件">2.3. 序列化模块文件</a></li></ul></li><li class="topic-item"><a href="#3-%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97" data-tocid="3-导入模块">3. 导入模块</a><ul><li class="topic-item"><a href="#31-%E4%BD%BF%E7%94%A8use%E5%85%B3%E9%94%AE%E5%AD%97" data-tocid="31-使用use关键字">3.1. 使用use关键字</a></li><li class="topic-item"><a href="#32-%E5%B0%86%E6%A8%A1%E5%9D%97%E5%86%85%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD%E4%B8%BA%E7%B3%BB%E7%BB%9F%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0" data-tocid="32-将模块内函数加载为系统内置函数">3.2. 将模块内函数加载为系统内置函数</a><ul><li class="topic-item"><a href="#321-%E9%80%9A%E8%BF%87-loadmodule-%E5%87%BD%E6%95%B0%E5%8A%A0%E8%BD%BD" data-tocid="321-通过-loadmodule-函数加载">3.2.1. 通过 loadModule 函数加载</a></li><li class="topic-item"><a href="#322-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0-preloadmodules-%E5%8A%A0%E8%BD%BD" data-tocid="322-通过配置参数-preloadmodules-加载">3.2.2. 通过配置参数 preloadModules 加载</a></li><li class="topic-item"><a href="#323-%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A7%86%E5%9B%BEfunction-view%E7%9A%84%E5%8C%BA%E5%88%AB" data-tocid="323-与函数视图function-view的区别">3.2.3. 与函数视图（function view）的区别</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB" data-tocid="4-模块分类">4. 模块分类</a><ul><li class="topic-item"><a href="#41-%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97%E7%B1%BB%E5%88%AB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" data-tocid="41-声明模块类别命名空间">4.1. 声明模块类别命名空间</a></li><li class="topic-item"><a href="#42-%E8%B0%83%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%9D%97" data-tocid="42-调用命名空间模块">4.2. 调用命名空间模块</a></li></ul></li><li class="topic-item"><a href="#5-gui%E4%B8%AD%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%A8%A1%E5%9D%97" data-tocid="5-gui中远程调试模块">5. GUI中远程调试模块</a></li><li class="topic-item"><a href="#6-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" data-tocid="6-注意事项">6. 注意事项</a><ul><li class="topic-item"><a href="#61-%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E8%A7%84%E5%88%99" data-tocid="61-同名函数定义规则">6.1. 同名函数定义规则</a></li><li class="topic-item"><a href="#62-%E5%88%B7%E6%96%B0%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89" data-tocid="62-刷新模块定义">6.2. 刷新模块定义</a></li><li class="topic-item"><a href="#63-%E6%A8%A1%E5%9D%97%E9%97%B4%E4%BA%92%E7%9B%B8%E8%B0%83%E7%94%A8" data-tocid="63-模块间互相调用">6.3. 模块间互相调用</a></li></ul></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>