<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="DolphinDB 是一款支持多用户多任务并发操作的高性能分布式时序数据库软件（distributed time-series database）。针对大数据的高效的内存管理是其性能优异的原因之一。 DolphinDB 使用 TCMalloc 进行内存分配。当用户查询操作或编程环境需要内存时，DolphinDB 会以 512MB ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="内存管理"/><title>内存管理</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;内存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;内存管理&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 是一款支持多用户多任务并发操作的高性能分布式时序数据库软件（distributed time-series database）。针对大数据的高效的内存管理是其性能优异的原因之一。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:71;99:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1--内存管理机制及相关配置参数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;1. 内存管理机制及相关配置参数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 使用 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://google.github.io/tcmalloc/&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;8:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;TCMalloc&lt;/xref&gt; 进行内存分配。当用户查询操作或编程环境需要内存时，DolphinDB 会以 512MB 为单位向操作系统申请内存。如果操作系统无法提供大块的连续内存，则会尝试 256MB，128MB 等更小的内存块。系统会每隔 30 秒扫描一次，如果内存块完全空闲，则会整体还给操作系统，如果仍有小部分内存在使用，比如 512MB 的内存块中仍有 10MB 在使用，则不会归还操作系统。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 开放了一些内存管理相关的配置项，方便用户根据系统情况进行合理设置。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过参数 maxMemSize 设定节点的最大内存使用量：该参数指定节点的最大可使用内存。如果设置太小，会严重限制集群的性能；如果设置值超过物理内存，则内存使用量过大时可能会触发操作系统强制关闭进程。同一个服务器上各数据节点的最大内存使用量之和，建议设置为机器可用内存的 75%。例如机器内存为 16GB，并且只部署 1 个节点，建议将该参数设置为 12GB 左右。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;参数 warningMemSize 设定最多可缓存的数据量：当节点的内存使用总量小于 warningMemSize（以 GB 为单位，默认值为 maxMemSize 的 75%）时，DolphinDB 会尽可能多的缓存数据库分区数据，以便提升用户下次访问该数据块的速度。当内存使用量超过 warningMemSize 时，系统采用 LRU 的内存回收策略，自动清理部分数据库的缓存，以避免出现 OOM 异常。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;参数 reservedMemSize 和 maxBlockSizeForReservedMemory：当系统剩余可用的内存不能满足用户的操作需要时，可能会出现数据读写失败、OOM 等问题。当已分配内存不满 maxMemSize 但已达到 maxMemSize - reservedMemSize 时，新分配内存的操作如大于 maxBlockSizeForReservedMemory 将受限或失败，从而减少系统关键操作失败的概率。例如，当出现因内存不够导致写入失败时，仍然能够正常回滚，避免出现数据不一致的问题。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;参数 memoryReleaseRate 控制将未使用的内存释放给操作系统的速率：memoryReleaseRate 是 0 到 10 之间的浮点数。memoryReleaseRate=0 表示不会主动释放未使用的内存。设置值越高，DolphinDB 释放内存的速度越快。默认值是 5。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;参数 maxPartitionNumPerQuery 控制单次查询数据量：系统默认允许单次最多可查找 65536 个分区的数据。若一次查询过多分区，需加载到内存的数据量过大，则可能导致 OOM。可根据需求以及可用内存量，适当调节该参数，控制单次可查询的分区数量。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;关于参数配置的详情，参见用户手册，内存配置参数（单实例配置）&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2--高效使用内存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;2. 高效使用内存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;在企业的生产环境中，DolphinDB 往往作为流数据处理中心以及历史数据仓库，为业务人员提供数据查询和计算。当用户较多时，不当的使用容易造成 Server 端内存耗尽，抛出 &#34;Out of Memory&#34; 异常。可遵循以下建议，尽量避免内存的不合理使用。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;合理均匀分区：DolphinDB 以分区为单位加载数据，因此，分区大小对内存影响巨大。合理均匀的分区，不管对内存使用还是对性能而言，都有积极的作用。因此，在创建数据库的时候，根据数据规模，合理规划分区大小。每个分区压缩前的数据量在 100M B 到 1GB 之间为宜。具体分区设计，请参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;database.md#分区设计注意事项&#34; xtrc=&#34;xref:2;24:147&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;分区注意事项&lt;/xref&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;及时释放数据量较大的变量：若用户创建数据量较大的变量，例如 v = 1..10000000，或者将含有大量数据的查询结果赋值给一个变量 t = select * from t where date = 2010.01.01，v 和 t 将会在用户的 session 占用大量的内存。如果不及时释放，执行其他任务时，就有可能因为内存不足而抛出异常。用户的私有变量在其创建的 session 里面保存。session 关闭的时候，会回收这些内存。可通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;25:229&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef&lt;/codeph&gt; 函数将其赋值为 NULL，或者关闭 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;25:255&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;session&lt;/codeph&gt; 来及时释放变量的内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;只查询需要的列：避免使用 select *，select * 会把该分区所有列加载到内存，而实际查询往往只需要几列的数据。因此，为避免内存浪费，尽量明确写出所有查询的列。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;数据查询尽可能使用分区过滤条件：DolphinDB 按照分区进行数据检索，如果不加分区过滤条件，则会全部扫描所有数据，数据量大时，内存很快被耗尽。若存在多个过滤条件，将包含分区列的过滤条件前置。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;合理配置流数据的缓存区：一般情况下流数据的容量 (capacity) 会直接影响发布节点的内存占用。比如，在对流数据表进行持久化时，若 capacity 设置为 1000 万条，那么流数据表在超过 1000 万条时，会将约一半的数据进行存盘并回收，也就是内存中会保留 500 万条左右。因此，应根据发布节点的最大内存，合理设计流数据表的 capacity。尤其是在多张发布表的情况，更需要谨慎设计。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3--内存监控及常见问题&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3. 内存监控及常见问题&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31--内存监控&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1. 内存监控&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;311--controller-上监控集群中节点内存占用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.1. controller 上监控集群中节点内存占用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;在 controller 上提供函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;36:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getClusterPerf()&lt;/codeph&gt; 函数，显示集群中各个节点的内存占用情况。包括： &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;37:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;memoryAlloc&lt;/b&gt;：节点上分配的总内存，近似于向操作系统申请的内存总和。&lt;?linebreak?&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;memoryUsed&lt;/b&gt;：节点已经使用的内存。该内存包括变量、分布式表缓存以及各种缓存队列等。&lt;?linebreak?&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;maxMemSize&lt;/b&gt;：节点可使用的最大内存限制。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;312--mem-函数监控某个节点内存占用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.2. &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;41:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem()&lt;/codeph&gt; 函数监控某个节点内存占用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem()&lt;/codeph&gt; 函数可以显示整个节点的内存分配和占用情况。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;43:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;allocatedBytes&lt;/codeph&gt; 为已分配内存；&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;43:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;freeBytes&lt;/codeph&gt; 是可用内存。两者之差为已占用内存。通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;43:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem().allocatedBytes - mem().freeBytes&lt;/codeph&gt; 得到节点所使用的总的内存大小。（注：如使用 1.20.0 及更早版本，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;43:165&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;sum(mem().allocatedBytes - mem().freeBytes)&lt;/codeph&gt; 进行计算。）&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;313--objs-函数监控某个会话内各变量的内存占用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.3. &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;45:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs()&lt;/codeph&gt; 函数监控某个会话内各变量的内存占用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;47:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs&lt;/codeph&gt; 来查看会话内所有变量的内存占用。该函数返回一个表，其中列 bytes 表示变量占用的内存块大小。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;47:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs(true)&lt;/codeph&gt; 除返回当前会话中变量的内存占用外，还返回共享变量的内存占用（包括其他会话共享的变量）。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;314--查看某个对象占用的内存大小&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.4. 查看某个对象占用的内存大小&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;51:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;51:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;memSize&lt;/codeph&gt; 来查看某个对象占用内存的具体大小，单位为字节。比如&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;52:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;v=1..1000000 memSize(v)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出：4000000。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;315--监控节点上不同-session-的内存占用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.5. 监控节点上不同 session 的内存占用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;可通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;60:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getSessionMemoryStat()&lt;/codeph&gt; 查看节点上每个 session 占用的内存量，输出结果只包含 session 内定义的变量。由于共享表和分布式表不属于某个用户或会话，因此返回结果中不包含它们占用的内存信息。由于输出结果亦包含用户名，也可查看每个用户的内存使用情况。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;316--查看后台正在运行的任务&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.1.6. 查看后台正在运行的任务&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;以上方法无法获取后台运行任务所占用的内存。可以通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;64:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getRecentJobs&lt;/codeph&gt; 来查看正在运行的后台任务。目前，DolphinDB 无法通过函数查看后台任务的内存占用情况，需用户根据业务逻辑进行估算。若内存比较紧张，可以取消一些暂无必要执行的后台任务，以释放内存空间。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32--常见问题&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2. 常见问题&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;321--监控显示节点内存占用太高&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.1. 监控显示节点内存占用太高&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;若节点内存接近 warningMemSize，通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;70:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;clearAllCache()&lt;/codeph&gt; 来手动释放节点的缓存数据。如果内存占用仍然未显著降低，请依次排查下述问题：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;72:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;72:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getSessionMemoryStat()&lt;/codeph&gt; 结合 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;72:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs()&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;72:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs(true)&lt;/codeph&gt; 排查是否某个用户忘记 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;72:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef&lt;/codeph&gt; 了变量 ;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;74:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;74:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getRecentJobs()&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;74:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getConsoleJobs()&lt;/codeph&gt; 查看是否还有超过预期运行时长的后台或交互任务。运行中的任务的内存占用不反映在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;74:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getSessionMemoryStat()&lt;/codeph&gt; ;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;76:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;76:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamingStat()&lt;/codeph&gt; 查看流数据内存占用，详见 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#流数据消息缓存队列&#34; xtrc=&#34;xref:3;76:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;流数据消息缓存队列&lt;/xref&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;322--out-of-memory-oom&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.2. Out of Memory (OOM)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;该异常往往是由于 query 所需的内存大于系统可提供的内存导致的。请先执行下列脚本查看所有数据节点内存使用情况，其中 maxMemSize 为配置的节点最大可用内存，memoryUsed 为节点已使用内存，memoryAlloc 为节点已分配内存。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;82:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select site, maxMemSize, memoryUsed, memoryAlloc from rpc(getControllerAlias(),getClusterPerf)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;OOM 一般可能由以下原因导致:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;87:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;查询没有加分区过滤条件或者条件太宽，导致单个 query 涉及的数据量太大。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;89:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;查询涉及多少分区可用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;89:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;sqlDS&lt;/codeph&gt; 函数来判断，示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;90:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;ds=sqlDS(&amp;lt;select * from loadTable(&#34;dfs://demo&#34;,&#34;sensor&#34;)&amp;gt;) ds.size()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;94:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;为避免这个问题，参见本文档的&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#高效使用内存&#34; xtrc=&#34;xref:4;94:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 按照分区进行数据检索&lt;/xref&gt; ，更详细的说明请参考教程 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;ddb_sql_cases.md&#34; xtrc=&#34;xref:5;94:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;SQL 案例分区剪枝&lt;/xref&gt;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;96:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;96:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;写入缓存占用了大量内存。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;98:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getCacheEngineMemSize() //查看 OLAP 引擎的 Cache Engine 占用内存 getTSDBCacheEngineSize() //查看 TSDB 引擎的 Cache Engine 占用内存&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;102:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;为避免这个问题，请参考本文档 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#为分布式数据库提供写入缓存&#34; xtrc=&#34;xref:6;102:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;为分布式数据库提供写入缓存&lt;/xref&gt;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;104:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;分区不均匀。可能某个分区过大，该分区的数据超过节点配置的最大内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;106:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;查询每个分区的大小可用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;106:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getTabletsMeta&lt;/codeph&gt; 函数，例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;107:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getTabletsMeta(&#34;/demo/%&#34;, `sensor, true);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;110:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;为避免这个问题，参见&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;database.md#分区设计注意事项&#34; xtrc=&#34;xref:7;110:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;分区设计注意事项&lt;/xref&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;112:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;某个 session 持有大的变量，导致节点可用的内存很小。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;114:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;可以通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;114:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getSessionMemoryStat()&lt;/codeph&gt; 查看各个 session 占用的内存大小。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;116:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;某个 session 持有大的变量，导致节点可用的内存很小。 通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;117:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getSessionMemoryStat()&lt;/codeph&gt; 查看各个 session 占用的内存大小及各 session 对应的用户。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;119:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过以下脚本查看每个数据节点上定义的变量和占用的内存：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;120:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;pnodeRun(objs) //查询每个节点定义变量占用内存（非共享变量） pnodeRun(objs{true}) //查询每个节点定义变量占用内存（包含共享变量）&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;124:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;为避免这个问题，请参考本文档&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#高效使用内存&#34; xtrc=&#34;xref:8;124:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;高效使用内存&lt;/xref&gt;下的“及时释放数据量较大的变量”&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;126:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;126:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;流数据计算引擎占用了大量内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;128:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;128:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamingStat()&lt;/codeph&gt; 来查看发布、订阅各个队列的深度。用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;128:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamEngineStat()&lt;/codeph&gt; 查看流计算引擎占用内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;130:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;为避免这个问题，请参考本文档 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#流数据消息缓存队列&#34; xtrc=&#34;xref:9;130:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;流数据消息缓存队列&lt;/xref&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;323--查询时dolphindb-进程退出没有-coredump-产生&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.3. 查询时，DolphinDB 进程退出，没有 coredump 产生&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;这种情况往往是由于给节点分配的内存超过系统物理内存的限制，操作系统把 DolphinDB 强制关闭。Linux 内核有个机制叫 OOM killer(Out of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用很大内存的进程，为防止内存耗尽而自动把该进程杀掉。排查 OOM killer 可用 dmesg 命令，示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;136:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;dmesg -T|grep dolphindb&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;若打印结果中出现了“Out of memory: Kill process”，说明操作系统杀死了 DolphinDB 进程（详情请见 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://www.kernel.org/doc/gorman/html/understand/understand016.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:10;140:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;Linux Kernel 相关文档&lt;/xref&gt;）。解决这种问题的办法是：通过参数 maxMemSize（单节点模式修改 dolphindb.cfg，集群模式修改 cluster.cfg）设定节点的最大内存使用量。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;324--执行-memtrue-或-clearallcache-后操作系统实际内存占用未降低如-linux-中-rss-占用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.4. 执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;142:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem(true)&lt;/codeph&gt; 或 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;142:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;clearAllCache()&lt;/codeph&gt; 后，操作系统实际内存占用未降低（如 Linux 中 RSS 占用）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;这是由于未使用的内存没有及时释放给操作系统。通过 memoryReleaseRate 控制将未使用的内存释放给操作系统的速率，memoryReleaseRate=10 表示以最快的速度释放内存，默认值是 5。该参数等价于设置了 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://gperftools.github.io/gperftools/tcmalloc.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:11;144:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;?ditaot usertext?&gt;TCMalloc&lt;/xref&gt; 的 tcmalloc_release_rate。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;注：执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;146:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem()&lt;/codeph&gt; 以显示本地节点内存使用情况。如设置其参数 freeUnusedBlocks=true，系统将会释放未使用的内存块。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;325--执行-loadtext-大批量加载到内存时时间过久或卡死&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.5. 执行 loadText 大批量加载到内存时，时间过久或卡死&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;可检查 log 中是否打印 Cache Engine 相关的信息。若存在这样的信息，说明使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;150:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;loadText&lt;/codeph&gt; 加载到内存的事务超过了 chunkCacheEngineMemSize 或 TSDBCacheEngineSize 的大小，导致事务卡死。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;解决方案如下：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;调大配置中的 chunkCacheEngineMemSize 或 TSDBCacheEngineSize 值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;2.00.4 及以上版本，请使用 loadTextEx 函数加载数据。这是因为 loadTextEx 函数可以通过参数 atomic，设置将大文件加载过程拆分为多个事务进行。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;326--getclusterperf-返回的节点分配内存memoryalloc与操作系统实际显示值有差异&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;3.2.6. &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;158:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getClusterPerf()&lt;/codeph&gt; 返回的节点分配内存（memoryAlloc）与操作系统实际显示值有差异&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;160:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 是 C++ 程序，本身需要一些基础的数据结构和内存开销，memoryAlloc 显示内存不包括这些内存。在执行 clearAllCache 后，如果 memoryAlloc 的值占操作系统实际显示值的 80% 以上，属于正常现象。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4--变量的内存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;4. 变量的内存管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 为用户提供与回收编程环境所需内存，本节介绍为变量分配内存，及释放变量内存的方法。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41--创建变量&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;4.1. 创建变量&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 1. 创建一个 vector，含有 1 亿个 INT 类型元素，约 400MB。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;v = 1..100000000 mem().allocatedBytes - mem().freeBytes //输出内存占用结果&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;结果为：402,865,056，内存占用 400MB 左右，符合预期。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 2. 创建一个 table，1000 万行，5 列，每列 4 字节，约 200MB。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;n = 10000000 t = table(n:n,[&#34;tag1&#34;,&#34;tag2&#34;,&#34;tag3&#34;,&#34;tag4&#34;,&#34;tag5&#34;],[INT,INT,INT,INT,INT]) mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;结果为：612,530,448，约 600MB，符合预期。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42--释放变量&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;4.2. 释放变量&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;可通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;185:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef&lt;/codeph&gt; 函数或者赋值为 NULL，释放变量的内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 3. 使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;187:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef&lt;/codeph&gt; 函数&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef(`v)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;或者&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;v = NULL&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;释放共享变量占用内存示例如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;undef(&#34;sharedTable&#34;, SHARED)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;除了手动释放变量，当 session 关闭时，比如关闭 GUI 和其他 API 连接，都会触发对该 session 的所有内存进行回收。当通过 web notebook 连接时，10 分钟内无操作，系统会关闭 session，自动回收内存。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5--分布式数据库读缓存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5. 分布式数据库读缓存管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 在不同存储引擎的读缓存管理上存在区别。本节分别介绍 OLAP 引擎和 TSDB 引擎读缓存的分配和管理。OLAP 引擎自动将查询过的历史数据加载到读缓存，后续相关数据的查询将先从缓存中读取。多个会话共享分区表读缓存数据，以提高内存使用率。TSDB 引擎通过索引可快速定位分布式表的数据位置，所以 TSDB 引擎的读缓存只缓存查询数据相关的索引文件，不缓存查询的数据。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51--olap-引擎分布式表的缓存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1. OLAP 引擎分布式表的缓存管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 对分布式表是以分区中的列为单位管理的。系统自动将查询的分区数据加载到读缓存，后续相关数据的查询将首先从缓存中读取。DolphinDB 记录所有数据的版本号，通过版本机制系统可以快速确定是否需要为一个查询更新缓存。读缓存无需用户指定，系统自动进行管理，当内存不足时，系统自动释放一部分缓存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;历史数据一般以分布式表的形式存在数据库中，用户平时查询操作也往往直接查询分布式表。分布式表的内存管理有如下特点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;内存以分区的一列为单位进行管理。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;212:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;数据只加载到所在的节点，不会在节点间转移。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;多个用户访问相同分区时，使用同一份缓存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;内存使用不超过 warningMemSize 情况下，尽量多缓存数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;缓存数据达到 warningMemSize 时，系统开始自动回收。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;以下多个示例是基于以下集群：部署于 2 个数据节点，采用单副本模式。按天分 30 个区，每个分区 1000 万行，11 列（1 列 DATE 类型，1 列 INT 类型，9 列 LONG 类型），所以每个分区的每列 (LONG 类型）数据量为 1000 万行 * 8 字节/列 = 80M，每个分区共 1000 万行 * 80 字节/行 = 800M，整个表共 3 亿行，大小为 24GB。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;219:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;219:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;clearAllCache()&lt;/codeph&gt; 可清空已经缓存的数据。下面的每次测试前，先用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;219:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;pnodeRun(clearAllCache)&lt;/codeph&gt; 清空节点上的所有缓存。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;221:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;login(`admin,`123456) if(existsDatabase(&#34;dfs://mem&#34;)){ dropDatabase(&#34;dfs://mem&#34;) } db = database(&#34;dfs://mem&#34;,VALUE,2022.01.01..2022.01.30) m = &#34;tag&#34; + string(1..9) schema = table(1:0,`id`day join m, [INT,DATE] join take(LONG,9) ) db.createPartitionedTable(schema,&#34;pt1&#34;,`day) //写入模拟数据 for (i in 0..29){ t=table(1..10000000 as tagid,take(2022.01.01+i,10000000) as date,1..10000000 as tag1,1..10000000 as tag2,1..10000000 as tag3,1..10000000 as tag4,1..10000000 as tag5,1..10000000 as tag6,1..10000000 as tag7,1..10000000 as tag8,1..10000000 as tag9 ) dfsTable=loadTable(&#34;dfs://mem&#34;,&#34;pt1&#34;) dfsTable.append!(t) } //查询15个分区的数据 t=select top 15 * from rpc(getControllerAlias(),getClusterChunksStatus) where file like &#34;/mem%&#34; and replicas like &#34;node1%&#34; order by file pnodeRun(clearAllCache) days=datetimeParse(t.file.substr(5,8),&#34;yyyyMMdd&#34;) for(d in days){ select * from loadTable(&#34;dfs://mem&#34;,&#34;pt1&#34;) where day= d print mem().allocatedBytes - mem().freeBytes }&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;511--内存以分区列为单位进行管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1.1. 内存以分区列为单位进行管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 采用列式存储，当用户对分布式表的数据进行查询时，加载数据的原则是，只把用户所要求的分区和列加载到内存中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 4. 计算分区 2022.01.01 最大的 tag1 的值。我们只查询 1 个分区的一列数据，仅把该列数据全部加载到内存，其他的列不加载。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;该分区储存在 node1 上（可以在 controller 上通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;253:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getClusterChunksStatus()&lt;/codeph&gt; 查看分区分布情况，而且由上面可知，每列约 80MB）。在 node1 上 执行如下代码，并查看内存占用。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select max(tag1) from loadTable(dbName,tableName) where day = 2022.01.01 mem().allocatedBytes - mem().freeBytes)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出结果为 84,267,136。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 5. 在 node1 上查询 2022.01.01 的前 100 条数据，并观察内存占用。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select top 100 * from loadTable(dbName,tableName) where day = 2022.01.01 mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出结果为 839,255,392。虽然我们只取 100 条数据，但是 DolphinDB 加载数据的最小单位是分区列，所以需要加载每个列的全部数据，也就是整个分区的全部数据，约 800MB。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;注意：&lt;/b&gt; 合理分区以避免 &#34;out of memory&#34;：DolphinDB 以分区为单位管理内存，因此内存的使用量跟分区关系密切。假如分区不均匀，导致某个分区数据量超大，甚至机器的全部内存都不足以容纳整个分区，那么当涉及到该分区的查询计算时，系统会抛出 &#34;out of memory&#34; 的异常。一般原则，数据表的每个分区的数据量在 100MB-1GB 之间为宜。如果表有 10 列，每个字段 8 字节，则每个分区约 100-200 万行。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;512--数据只加载到所在的节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1.2. 数据只加载到所在的节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;在数据量大的情况下，节点间转移数据是非常耗时的操作。DolphinDB 的数据是分布式存储的，当执行任务时，把任务发送到数据所在的节点，然后把结果汇总到发送任务的节点。系统会尽最大努力避免将数据跨节点转移。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;273:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 6. 在 node1 上计算两个分区中 tag1 的最大值。其中分区 2022.01.02 的数据存储在 node1 上，分区 2022.01.03 的数据存储在 node2 上。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;274:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select max(tag1) from loadTable(dbName,tableName) where day in [2022.01.02,2022.01.03] mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;278:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出结果为 84,284,096。在 node2 上查看内存占用为 84,250,624 字节。每个节点存储的数据都为 80MB 左右，也就是 node1 上存储了分区 2022.01.02 的数据，node2 上仅存储了 2022.01.03 的数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;280:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 7. 在 node1 上查询分区 2022.01.02 和 2022.01.03 的所有数据，我们预期 node1 加载 2022.01.02 数据，node2 加载 2022.01.03 的数据，都是 800MB 左右，执行如下代码并观察内存。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select top 100 * from loadTable(dbName,tableName) where day in [2022.01.02,2022.01.03] mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;285:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;node1 上输出结果为 839,279,968 字节。node2 上输出结果为 839,246,496 字节。结果符合预期。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;注意：&lt;/b&gt; 请谨慎使用没有过滤条件的 &#34;select *&#34;，因为这会将所有数据载入内存。特别在列数很多的时候，建议仅加载需要的列。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;513--多个用户访问相同分区时使用同一份缓存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;289:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;289:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1.3. 多个用户访问相同分区时，使用同一份缓存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;289:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;291:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 支持海量数据的并发查询。为了高效利用内存，对相同分区的数据，内存中只保留同一份副本。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 8. 打开两个 GUI，分别连接 node1 和 node2，查询分区 2022.01.01 的数据，该分区的数据存储在 node1 上。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select * from loadTable(dbName,tableName) where date = 2022.01.01 mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;node1 上内存显示 839,101,024，而 node2 上无内存占用。系统将分区数据载入 node1 内存，然后将数据传输到 node2 内存，最后下载到客户端。之后，系统会将此次操作在 node2 所用内存释放。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;514--节点内存使用不超过-warningmemsize-情况下尽量多缓存数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1.4. 节点内存使用不超过 warningMemSize 情况下，尽量多缓存数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;302:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通常情况下，最近访问的数据往往更容易再次被访问，因此 DolphinDB 在内存允许的情况下（内存占用不超过用户设置的 warningMemSize），尽量多缓存数据，来提升后续查询效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 9. 数据节点设置的 maxMemSize=10,warningMemSize=8。连续加载 9 个分区，每个分区约 800M，总内存占用约 7.2GB，观察内存的变化趋势。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;dbPath = right(dbName,strlen(dbName)-5) p = select top 9 * from rpc(getControllerAlias(),getClusterChunksStatus) where file like dbPath +&#34;%&#34; and replicas like &#34;node1%&#34; //这里节点1的别名为node1 order by file days = datetimeParse(t.file.substr(strlen(dbPath)+1,8),&#34;yyyyMMdd&#34;) for(d in days){ select * from loadTable(dbName,tableName) where date= d print mem().allocatedBytes - mem().freeBytes } &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;内存随着加载分区数的增加变化规律如下图所示：&lt;?linebreak?&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/memory_managment/partition9.png&#34; xtrc=&#34;image:1;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; dita-ot:image-width=&#34;3596&#34; dita-ot:image-height=&#34;1828&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;当遍历每个分区数据时，在内存使用量不超过 warningMemSize 的情况下，分区数据会全部缓存到内存中，以便用户下次访问时，直接从内存中读取数据，而不需要再次从磁盘加载。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;515--节点内存使用达到-warningmemsize-时系统自动回收&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.1.5. 节点内存使用达到 warningMemSize 时，系统自动回收&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;当总的内存使用达到 warningMemSize 时，DolphinDB 会采用 LRU 的内存回收策略，回收一部分内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 10. 上面用例只加载了 9 天的数据，此时我们继续共遍历 15 天数据，查看缓存达到 warningMemSize 时，内存的占用情况。如下图所示：&lt;?linebreak?&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/memory_managment/partition15.png&#34; xtrc=&#34;image:2;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; dita-ot:image-width=&#34;3740&#34; dita-ot:image-height=&#34;1828&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:2;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;如上图所示，当缓存的数据超过 warningMemSize 时，系统自动回收内存，总的内存使用量仍然小于用户设置的 warningMemSize。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 11. 当缓存数据接近用户设置的 warningMemSize 时，继续申请 Session 变量的内存空间，查看系统内存占用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;此时先查看系统的内存使用：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出结果为 7,550,138,448。内存占用超过 7GB，而用户设置的最大内存使用量为 10GB，此时我们继续申请 4GB 空间。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;v = 1..1000000000 mem().allocatedBytes - mem().freeBytes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;输出结果为 8,196,073,856。约为 8GB，也就是如果用户定义变量时，可使用的内存不足，系统会触发缓存数据的内存回收，以保证有足够的内存提供给用户使用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52--tsdb-引擎分布式表的读缓存管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;5.2. TSDB 引擎分布式表的读缓存管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;346:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;与 OLAP 引擎存储数据的最小文件为列文件不同，TSDB 引擎存储数据的最小文件是 level file。每个 level file 都记录了元信息，数据块和数据块对应的索引。TSDB 查询分布式表数据时，会将分区下 level file 的索引部分加载到内存，然后将索引定位的数据部分加载到内存。正是因为通过索引就可以快速定位数据并加载，TSDB 只需要缓存索引数据，无需缓存查询的分区数据。TSDB 索引缓存的容量由配置参数 TSDBLevelFileIndexCacheSize 指定，单位为 GB，默认值为 maxMemSize 的 5%，最小值为 0.1GB。若索引缓存空间不够时，会按照 LRU 算法，释放最近最少使用的 5% 的缓存空间。可通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;346:334&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getLevelFileIndexCacheStatus&lt;/codeph&gt; 获取 TSDB 索引数据占用的内存空间大小。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;示例 12.TSDB 引擎下已经创建了如下分布式表&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;n=10000 ID=rand(100, n) dates=2021.08.07..2021.08.11 date=rand(dates, n) vol=rand(1..10 join int(), n) t=table(ID, date, vol) if(existsDatabase(&#34;dfs://TSDB_db1&#34;)){ dropDatabase(&#34;dfs://TSDB_db1&#34;) } db=database(directory=&#34;dfs://TSDB_db1&#34;, partitionType=VALUE, partitionScheme=2021.08.07..2021.08.11, engine=&#34;TSDB&#34;) pt1=db.createPartitionedTable(table=t, tableName=`pt1, partitionColumns=`date, sortColumns=`ID)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;363:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;重启 server，查看索引缓存&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;365:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getLevelFileIndexCacheStatus().usage //输出结果为：0&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;加载分区 2021.08.07 下的数据，查询索引缓存和数据缓存&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select * from loadTable(&#34;dfs://TSDB_db1&#34;,`pt1) where date=2021.08.07 getLevelFileIndexCacheStatus().usage //输出结果为：39128 mem().allocatedBytes - mem().freeBytes //输出结果为：28537352&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;379:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;继续加载分区 2021.08.08 下的数据，查询索引缓存和数据缓存。索引缓存增加，数据缓存无变化（因为 TSDB 引擎查询结束会将释放内存中的数据，不会占用缓存）&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;select * from loadTable(&#34;dfs://TSDB_db1&#34;,`pt1) where date=2021.08.08 getLevelFileIndexCacheStatus().usage //输出结果为：78256 mem().allocatedBytes - mem().freeBytes //输出结果为：28561912&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6--为分布式数据库提供写入缓存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;6. 为分布式数据库提供写入缓存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;389:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;Cache Engine 是 DolphinDB 中的一种数据写入缓存机制，用于提升海量数据写入性能。DolphinDB 采用先写入 Redo log（预写式日志）和 Cache Engine（写入缓存）的通用做法，等数据积累到一定数量时，批量写入。DolphinDB 2.00.0 及以上版本支持多模存储（OLAP 与 TSDB），不同的存储引擎拥有独立的 Cache Engine。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;393:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;Cache Engine 需根据系统配置和实际场景合理设置。若设置过小，可能导致 Cache Engine 频繁刷盘，影响系统性能；若设置过大，Cache Engine 可能会缓存大量未刷盘的数据，此时若发生了机器断电或关机，重启后就需要回放大量事务，导致系统启动过慢。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61--olap-引擎的写入缓存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;6.1. OLAP 引擎的写入缓存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;397:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;默认情况下，OLAP 存储引擎是不开启 Redo Log 的，即写入事务不会进行缓存，直接进行刷盘。若需要缓存事务进行批量刷盘，则需要通过 chunkCacheEngineMemSize 为 OLAP 指定 Cache Engine 的容量，且指定 dataSync=1 启用 Redo Log。下图示意了开启 Cache Engine 和 Redo Log 后事务的写入流程：事务先写入 Redo Log 和 Cache Engine。达到 cache engine 的刷盘条件后，三个事务的数据将被一次性写入到 DFS 的数据库上。 &lt;image class=&#34;- topic/image &#34; href=&#34;images/memory_managment/cacheEngine.png&#34; xtrc=&#34;image:3;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; dita-ot:image-width=&#34;949&#34; dita-ot:image-height=&#34;462&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:3;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;400:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;Cache Engine 空间一般推荐设置为 maxMemSize 的 1/8 到 1/4。chunkCacheEngineMemSize 不是一个刚性的限制，其实际内存占用可能会高于设置的值 ; 根据经验，cacheEngine 不建议设置超过 32G 以上的值，否则会造成 Redo Log 回收慢和内存占用过高的问题; 更多设置请参阅 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;redoLog_cacheEngine.md&#34; xtrc=&#34;xref:12;400:173&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;Cache Engine 与数据库日志&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;402:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;写入过程中，可用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;402:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getCacheEngineMemSize()&lt;/codeph&gt; 查看 OLAP 引擎的 Cache Engine 占用内存情况。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62--tsdb-引擎的写入缓存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;404:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;404:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;6.2. TSDB 引擎的写入缓存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;404:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;406:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;与 OLAP 不同的是，TSDB 引擎必须开启 Cache Engine（由配置参数 TSDBCacheEngineSize 指定）和 Redo Log。TSDB 引擎的 Cache Engine 内部会对缓存的数据进行排序，当 Cache Engine 写满或经过十分钟后刷入磁盘。刷盘过程中，Cache Engine 为只读状态，不能继续写入数据，此时，如果又有数据写入到 Cache Engine 里，系统会为 TSDB 引擎重新分配一个内存空间作为 TSDB 的 Cache Engine。因此，极端情况下，TSDB 的 Cache Engine 内存占用最多可达到两倍的 TSDBCacheEngineSize。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;408:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;通过配置参数 TSDBCacheEngineCompression 设置 TSDB 引擎对 Cache Engine 里的数据进行压缩，来缓存更多（约 5 倍）的数据在缓存中，降低查询数据的时延。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;410:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;写入过程中，可用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;410:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getTSDBCacheEngineSize()&lt;/codeph&gt; 查看 TSDB 引擎的 Cache Engine 占用内存情况。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7--流数据消息缓存队列&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:33;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:33;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;7. 流数据消息缓存队列&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:33;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;DolphinDB 为流数据发送节点提供持久化队列缓存和发送队列缓存，为订阅节点提供接收数据队列缓存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;当数据进入流数据系统时，首先写入流数据表，然后写入持久化队列和发送队列。假设用户设置为异步持久化，则持久化队列异步写入磁盘，发送队列发送到订阅端。 当订阅端收到数据后，先放入接受队列，然后用户定义的 handler 从接收队列中取数据并处理。如果 handler 处理缓慢，会导致接收队列有数据堆积，占用内存。如下图所示：&lt;?linebreak?&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/memory_managment/streaming.png&#34; xtrc=&#34;image:4;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34; dita-ot:image-width=&#34;987&#34; dita-ot:image-height=&#34;448&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:4;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:101;420:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;流数据内存相关的主要配置选项：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;maxPersistenceQueueDepth: 发布节点流表持久化队列的最大队列深度（消息数上限）。该选项默认设置为 10000000。在磁盘写入成为瓶颈时，队列会堆积数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;422:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;maxPubQueueDepthPerSite: 发布节点发送队列的最大队列深度（消息数上限）。默认值为 1000 万，当网络出现拥塞时，该发送队列会堆积数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;maxSubQueueDepth: 订阅节点上每个订阅线程接收队列的最大队列深度（消息数上限）。订阅的消息，会先放入订阅消息队列。默认设置为 1000 万，当 handler 处理速度较慢，不能及时处理订阅到的消息时，该队列会有数据堆积。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;424:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;流表的 capacity：由函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;424:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;enableTablePersistence()&lt;/codeph&gt; 中第四个参数指定，该值表示流表中保存在内存中的最大行数，达到该值时，从内存中删除一半数据。当流数据节点中，流表比较多时，要整体合理设置该值，防止内存不足。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:102;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;可以通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;426:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs(true)&lt;/codeph&gt; 或 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;426:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;objs()&lt;/codeph&gt; 来查看流表占用内存占用大小，用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;426:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamingStat()&lt;/codeph&gt; 来查看各个队列的深度。流计算引擎可能会占用较多内存，可使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;426:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamEngineStat()&lt;/codeph&gt; 以查看流计算引擎的内存使用量。例如，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;426:141&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/memory_management.md&#34;&gt;getStreamEngineStat().TimeSeriesEngine.memoryUsed&lt;/codeph&gt; 以查看时间序列引擎的内存使用量。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/memory_management.md"/><meta name="wh-out-relpath" content="tutorials/memory_management.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="内存管理" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/scheduledJob_2.html">系统运维</a></div></div></li><li class="active"><div class="topicref" data-id="内存管理"><div class="title"><a href="../tutorials/memory_management.html">内存管理</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="定时作业-d9713e100956" class="topicref" data-id="定时作业" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="定时作业-d9713e100956-link">定时作业</a></div></div></li><li role="treeitem"><div data-tocid="作业管理-d9713e101002" class="topicref" data-id="作业管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/job_management_tutorial_2.html" id="作业管理-d9713e101002-link">作业管理</a></div></div></li><li role="treeitem"><div data-tocid="用户权限管理-d9713e101048" class="topicref" data-id="用户权限管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ACL_and_Security_2.html" id="用户权限管理-d9713e101048-link">用户权限管理</a></div></div></li><li role="treeitem"><div data-tocid="数据备份以及恢复-130202008及之后版本-d9713e101094" class="topicref" data-id="数据备份以及恢复-130202008及之后版本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/backup-restore-new.html" id="数据备份以及恢复-130202008及之后版本-d9713e101094-link">数据备份以及恢复 （1.30.20/2.00.8及之后版本）</a></div></div></li><li role="treeitem"><div data-tocid="数据备份以及恢复-130202008以前版本-d9713e101140" class="topicref" data-id="数据备份以及恢复-130202008以前版本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/backup_restore_before_208.html" id="数据备份以及恢复-130202008以前版本-d9713e101140-link">数据备份以及恢复 （1.30.20/2.00.8以前版本）</a></div></div></li><li role="treeitem"><div data-tocid="数据再平衡-d9713e101186" class="topicref" data-id="数据再平衡" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Data_Move_Rebalance.html" id="数据再平衡-d9713e101186-link">数据再平衡</a></div></div></li><li role="treeitem"><div data-tocid="集群间数据库同步-d9713e101232" class="topicref" data-id="集群间数据库同步" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_sync_among_clusters.html" id="集群间数据库同步-d9713e101232-link">集群间数据库同步</a></div></div></li><li role="treeitem"><div data-tocid="集群间异步复制-d9713e101278" class="topicref" data-id="集群间异步复制" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/async_replication.html" id="集群间异步复制-d9713e101278-link">集群间异步复制</a></div></div></li><li role="treeitem"><div data-tocid="数据导入最容易忽略的十个细节-d9713e101324" class="topicref" data-id="数据导入最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_import_details.html" id="数据导入最容易忽略的十个细节-d9713e101324-link">数据导入最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="线程模型-d9713e101370" class="topicref" data-id="线程模型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/threading_model.html" id="线程模型-d9713e101370-link">线程模型</a></div></div></li><li role="treeitem"><div data-tocid="线程简介-d9713e101416" class="topicref" data-id="线程简介" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/thread_intro_2.html" id="线程简介-d9713e101416-link">线程简介</a></div></div></li><li role="treeitem" class="active"><div data-tocid="内存管理-d9713e101463" class="topicref" data-id="内存管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/memory_management.html" id="内存管理-d9713e101463-link">内存管理</a></div></div></li><li role="treeitem"><div data-tocid="out-of-memory-d9713e101509" class="topicref" data-id="out-of-memory" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/oom_settlement_2.html" id="out-of-memory-d9713e101509-link">Out of Memory</a></div></div></li><li role="treeitem"><div data-tocid="非标权限管理-d9713e101555" class="topicref" data-id="非标权限管理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/non-standard_permission_management.html" id="非标权限管理-d9713e101555-link">非标权限管理</a></div></div></li><li role="treeitem"><div data-tocid="节点启动流程简析与常见问题-d9713e101601" class="topicref" data-id="节点启动流程简析与常见问题" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/node_startup_process_and_questions.html" id="节点启动流程简析与常见问题-d9713e101601-link">节点启动流程简析与常见问题</a></div></div></li><li role="treeitem"><div data-tocid="用户级别的资源跟踪详解-d9713e101647" class="topicref" data-id="用户级别的资源跟踪详解" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/user_level_resource_tracking.html" id="用户级别的资源跟踪详解-d9713e101647-link">用户级别的资源跟踪详解</a></div></div></li><li role="treeitem"><div data-tocid="使用-prometheus-监控告警-d9713e101693" class="topicref" data-id="使用-prometheus-监控告警" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/promethues2.html" id="使用-prometheus-监控告警-d9713e101693-link">使用 Prometheus 监控告警</a></div></div></li><li role="treeitem"><div data-tocid="redash-连接-dolphindb-数据源-d9713e101739" class="topicref" data-id="redash-连接-dolphindb-数据源" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_interface_for_redash.html" id="redash-连接-dolphindb-数据源-d9713e101739-link">Redash 连接 DolphinDB 数据源</a></div></div></li><li role="treeitem"><div data-tocid="使用-chart-组件展示数据-d9713e101785" class="topicref" data-id="使用-chart-组件展示数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/web_chart_integration.html" id="使用-chart-组件展示数据-d9713e101785-link">使用 chart 组件展示数据</a></div></div></li><li role="treeitem"><div data-tocid="debezium--kafka-实时同步-oracle-11g-数据到-dolphindb-运维手册-d9713e101831" class="topicref" data-id="debezium--kafka-实时同步-oracle-11g-数据到-dolphindb-运维手册" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/debezium_kafka_real_time_synchronization_of_oracle_11g_data.html" id="debezium--kafka-实时同步-oracle-11g-数据到-dolphindb-运维手册-d9713e101831-link">Debezium + Kafka 实时同步 Oracle 11g 数据到 DolphinDB 运维手册</a></div></div></li><li role="treeitem"><div data-tocid="基于_zabbix_的_dolphindb_集群运维监控-d9713e101877" class="topicref" data-id="基于_zabbix_的_dolphindb_集群运维监控" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/zabbix_cluster_monitoring.html" id="基于_zabbix_的_dolphindb_集群运维监控-d9713e101877-link">基于 Zabbix 的 DolphinDB 集群运维监控</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">内存管理</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 是一款支持多用户多任务并发操作的高性能分布式时序数据库软件（distributed time-series database）。针对大数据的高效的内存管理是其性能优异的原因之一。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1--内存管理机制及相关配置参数"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1.  内存管理机制及相关配置参数</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 使用 <a class="- topic/xref xref" href="https://google.github.io/tcmalloc/" target="_blank" rel="external noopener">TCMalloc</a> 进行内存分配。当用户查询操作或编程环境需要内存时，DolphinDB 会以 512MB 为单位向操作系统申请内存。如果操作系统无法提供大块的连续内存，则会尝试 256MB，128MB 等更小的内存块。系统会每隔 30 秒扫描一次，如果内存块完全空闲，则会整体还给操作系统，如果仍有小部分内存在使用，比如 512MB 的内存块中仍有 10MB 在使用，则不会归还操作系统。</p><p class="- topic/p p">DolphinDB 开放了一些内存管理相关的配置项，方便用户根据系统情况进行合理设置。</p><ul class="- topic/ul ul"><li class="- topic/li li">通过参数 maxMemSize 设定节点的最大内存使用量：该参数指定节点的最大可使用内存。如果设置太小，会严重限制集群的性能；如果设置值超过物理内存，则内存使用量过大时可能会触发操作系统强制关闭进程。同一个服务器上各数据节点的最大内存使用量之和，建议设置为机器可用内存的 75%。例如机器内存为 16GB，并且只部署 1 个节点，建议将该参数设置为 12GB 左右。</li><li class="- topic/li li">参数 warningMemSize 设定最多可缓存的数据量：当节点的内存使用总量小于 warningMemSize（以 GB 为单位，默认值为 maxMemSize 的 75%）时，DolphinDB 会尽可能多的缓存数据库分区数据，以便提升用户下次访问该数据块的速度。当内存使用量超过 warningMemSize 时，系统采用 LRU 的内存回收策略，自动清理部分数据库的缓存，以避免出现 OOM 异常。</li><li class="- topic/li li">参数 reservedMemSize 和 maxBlockSizeForReservedMemory：当系统剩余可用的内存不能满足用户的操作需要时，可能会出现数据读写失败、OOM 等问题。当已分配内存不满 maxMemSize 但已达到 maxMemSize -  reservedMemSize 时，新分配内存的操作如大于 maxBlockSizeForReservedMemory 将受限或失败，从而减少系统关键操作失败的概率。例如，当出现因内存不够导致写入失败时，仍然能够正常回滚，避免出现数据不一致的问题。</li><li class="- topic/li li">参数 memoryReleaseRate 控制将未使用的内存释放给操作系统的速率：memoryReleaseRate 是 0 到 10 之间的浮点数。memoryReleaseRate=0 表示不会主动释放未使用的内存。设置值越高，DolphinDB 释放内存的速度越快。默认值是 5。</li><li class="- topic/li li">参数 maxPartitionNumPerQuery 控制单次查询数据量：系统默认允许单次最多可查找 65536 个分区的数据。若一次查询过多分区，需加载到内存的数据量过大，则可能导致 OOM。可根据需求以及可用内存量，适当调节该参数，控制单次可查询的分区数量。</li></ul><p class="- topic/p p">关于参数配置的详情，参见用户手册，内存配置参数（单实例配置）</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2--高效使用内存"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2.  高效使用内存</h2><div class="- topic/body body"><p class="- topic/p p">在企业的生产环境中，DolphinDB 往往作为流数据处理中心以及历史数据仓库，为业务人员提供数据查询和计算。当用户较多时，不当的使用容易造成 Server 端内存耗尽，抛出 "Out of Memory" 异常。可遵循以下建议，尽量避免内存的不合理使用。</p><ul class="- topic/ul ul"><li class="- topic/li li">合理均匀分区：DolphinDB 以分区为单位加载数据，因此，分区大小对内存影响巨大。合理均匀的分区，不管对内存使用还是对性能而言，都有积极的作用。因此，在创建数据库的时候，根据数据规模，合理规划分区大小。每个分区压缩前的数据量在 100M B 到 1GB 之间为宜。具体分区设计，请参考<a class="- topic/xref xref" href="database.html#%E5%88%86%E5%8C%BA%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">分区注意事项</a>。</li><li class="- topic/li li">及时释放数据量较大的变量：若用户创建数据量较大的变量，例如 v = 1..10000000，或者将含有大量数据的查询结果赋值给一个变量 t = select * from t where date = 2010.01.01，v 和 t 将会在用户的 session 占用大量的内存。如果不及时释放，执行其他任务时，就有可能因为内存不足而抛出异常。用户的私有变量在其创建的 session 里面保存。session 关闭的时候，会回收这些内存。可通过 <code class="+ topic/ph pr-d/codeph ph codeph">undef</code> 函数将其赋值为 NULL，或者关闭 <code class="+ topic/ph pr-d/codeph ph codeph">session</code> 来及时释放变量的内存。</li><li class="- topic/li li">只查询需要的列：避免使用 select *，select * 会把该分区所有列加载到内存，而实际查询往往只需要几列的数据。因此，为避免内存浪费，尽量明确写出所有查询的列。</li><li class="- topic/li li">数据查询尽可能使用分区过滤条件：DolphinDB 按照分区进行数据检索，如果不加分区过滤条件，则会全部扫描所有数据，数据量大时，内存很快被耗尽。若存在多个过滤条件，将包含分区列的过滤条件前置。</li><li class="- topic/li li">合理配置流数据的缓存区：一般情况下流数据的容量 (capacity) 会直接影响发布节点的内存占用。比如，在对流数据表进行持久化时，若 capacity 设置为 1000 万条，那么流数据表在超过 1000 万条时，会将约一半的数据进行存盘并回收，也就是内存中会保留 500 万条左右。因此，应根据发布节点的最大内存，合理设计流数据表的 capacity。尤其是在多张发布表的情况，更需要谨慎设计。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3--内存监控及常见问题"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3.  内存监控及常见问题</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="31--内存监控"><h3 class="- topic/title title topictitle3" id="ariaid-title5">3.1.  内存监控</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title6" id="311--controller-上监控集群中节点内存占用"><h4 class="- topic/title title topictitle4" id="ariaid-title6">3.1.1.  controller 上监控集群中节点内存占用</h4><div class="- topic/body body"><p class="- topic/p p">在 controller 上提供函数 <code class="+ topic/ph pr-d/codeph ph codeph">getClusterPerf()</code> 函数，显示集群中各个节点的内存占用情况。包括：
<strong class="+ topic/ph hi-d/b ph b">memoryAlloc</strong>：节点上分配的总内存，近似于向操作系统申请的内存总和。<br/><strong class="+ topic/ph hi-d/b ph b">memoryUsed</strong>：节点已经使用的内存。该内存包括变量、分布式表缓存以及各种缓存队列等。<br/><strong class="+ topic/ph hi-d/b ph b">maxMemSize</strong>：节点可使用的最大内存限制。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title7" id="312--mem-函数监控某个节点内存占用"><h4 class="- topic/title title topictitle4" id="ariaid-title7">3.1.2.  <code class="+ topic/ph pr-d/codeph ph codeph">mem()</code> 函数监控某个节点内存占用</h4><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">mem()</code> 函数可以显示整个节点的内存分配和占用情况。<code class="+ topic/ph pr-d/codeph ph codeph">allocatedBytes</code> 为已分配内存；<code class="+ topic/ph pr-d/codeph ph codeph">freeBytes</code> 是可用内存。两者之差为已占用内存。通过 <code class="+ topic/ph pr-d/codeph ph codeph">mem().allocatedBytes - mem().freeBytes</code> 得到节点所使用的总的内存大小。（注：如使用 1.20.0 及更早版本，通过 <code class="+ topic/ph pr-d/codeph ph codeph">sum(mem().allocatedBytes - mem().freeBytes)</code> 进行计算。）</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="313--objs-函数监控某个会话内各变量的内存占用"><h4 class="- topic/title title topictitle4" id="ariaid-title8">3.1.3.  <code class="+ topic/ph pr-d/codeph ph codeph">objs()</code> 函数监控某个会话内各变量的内存占用</h4><div class="- topic/body body"><p class="- topic/p p">通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">objs</code> 来查看会话内所有变量的内存占用。该函数返回一个表，其中列 bytes 表示变量占用的内存块大小。<code class="+ topic/ph pr-d/codeph ph codeph">objs(true)</code> 除返回当前会话中变量的内存占用外，还返回共享变量的内存占用（包括其他会话共享的变量）。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="314--查看某个对象占用的内存大小"><h4 class="- topic/title title topictitle4" id="ariaid-title9">3.1.4.  查看某个对象占用的内存大小</h4><div class="- topic/body body"><p class="- topic/p p">通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">memSize</code> 来查看某个对象占用内存的具体大小，单位为字节。比如</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>v=1..1000000
memSize(v)</code></pre><p class="- topic/p p">输出：4000000。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="315--监控节点上不同-session-的内存占用"><h4 class="- topic/title title topictitle4" id="ariaid-title10">3.1.5.  监控节点上不同 session 的内存占用</h4><div class="- topic/body body"><p class="- topic/p p">可通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getSessionMemoryStat()</code> 查看节点上每个 session 占用的内存量，输出结果只包含 session 内定义的变量。由于共享表和分布式表不属于某个用户或会话，因此返回结果中不包含它们占用的内存信息。由于输出结果亦包含用户名，也可查看每个用户的内存使用情况。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="316--查看后台正在运行的任务"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.1.6.  查看后台正在运行的任务</h4><div class="- topic/body body"><p class="- topic/p p">以上方法无法获取后台运行任务所占用的内存。可以通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs</code> 来查看正在运行的后台任务。目前，DolphinDB 无法通过函数查看后台任务的内存占用情况，需用户根据业务逻辑进行估算。若内存比较紧张，可以取消一些暂无必要执行的后台任务，以释放内存空间。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="32--常见问题"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.2.  常见问题</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="321--监控显示节点内存占用太高"><h4 class="- topic/title title topictitle4" id="ariaid-title13">3.2.1.  监控显示节点内存占用太高</h4><div class="- topic/body body"><p class="- topic/p p">若节点内存接近 warningMemSize，通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">clearAllCache()</code> 来手动释放节点的缓存数据。如果内存占用仍然未显著降低，请依次排查下述问题：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getSessionMemoryStat()</code> 结合 <code class="+ topic/ph pr-d/codeph ph codeph">objs()</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">objs(true)</code> 排查是否某个用户忘记 <code class="+ topic/ph pr-d/codeph ph codeph">undef</code> 了变量  ;</p></li><li class="- topic/li li"><p class="- topic/p p">通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getRecentJobs()</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">getConsoleJobs()</code> 查看是否还有超过预期运行时长的后台或交互任务。运行中的任务的内存占用不反映在 <code class="+ topic/ph pr-d/codeph ph codeph">getSessionMemoryStat()</code> ;</p></li><li class="- topic/li li"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">getStreamingStat()</code> 查看流数据内存占用，详见 <a class="- topic/xref xref" href="#%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97">流数据消息缓存队列</a>。</p></li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="322--out-of-memory-oom"><h4 class="- topic/title title topictitle4" id="ariaid-title14">3.2.2.  Out of Memory (OOM)</h4><div class="- topic/body body"><p class="- topic/p p">该异常往往是由于 query 所需的内存大于系统可提供的内存导致的。请先执行下列脚本查看所有数据节点内存使用情况，其中 maxMemSize 为配置的节点最大可用内存，memoryUsed 为节点已使用内存，memoryAlloc 为节点已分配内存。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select site, maxMemSize, memoryUsed, memoryAlloc from rpc(getControllerAlias(),getClusterPerf)</code></pre><p class="- topic/p p">OOM 一般可能由以下原因导致:</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">查询没有加分区过滤条件或者条件太宽，导致单个 query 涉及的数据量太大。</p><p class="- topic/p p">查询涉及多少分区可用 <code class="+ topic/ph pr-d/codeph ph codeph">sqlDS</code> 函数来判断，示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>ds=sqlDS(&lt;select * from loadTable("dfs://demo","sensor")&gt;)
ds.size()</code></pre><p class="- topic/p p">为避免这个问题，参见本文档的<a class="- topic/xref xref" href="#%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98">DolphinDB 按照分区进行数据检索</a> ，更详细的说明请参考教程 <a class="- topic/xref xref" href="ddb_sql_cases.html">SQL 案例分区剪枝</a></p></li><li class="- topic/li li"><p class="- topic/p p">写入缓存占用了大量内存。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>getCacheEngineMemSize() //查看 OLAP 引擎的 Cache Engine 占用内存
getTSDBCacheEngineSize() //查看 TSDB 引擎的 Cache Engine 占用内存</code></pre><p class="- topic/p p">为避免这个问题，请参考本文档 <a class="- topic/xref xref" href="#%E4%B8%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E4%BE%9B%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98">为分布式数据库提供写入缓存</a></p></li><li class="- topic/li li"><p class="- topic/p p">分区不均匀。可能某个分区过大，该分区的数据超过节点配置的最大内存。</p><p class="- topic/p p">查询每个分区的大小可用 <code class="+ topic/ph pr-d/codeph ph codeph">getTabletsMeta</code> 函数，例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>getTabletsMeta("/demo/%", `sensor, true);</code></pre><p class="- topic/p p">为避免这个问题，参见<a class="- topic/xref xref" href="database.html#%E5%88%86%E5%8C%BA%E8%AE%BE%E8%AE%A1%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">分区设计注意事项</a>。</p></li><li class="- topic/li li"><p class="- topic/p p">某个 session 持有大的变量，导致节点可用的内存很小。</p><p class="- topic/p p">可以通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getSessionMemoryStat()</code> 查看各个 session 占用的内存大小。</p></li><li class="- topic/li li"><p class="- topic/p p">某个 session 持有大的变量，导致节点可用的内存很小。
通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getSessionMemoryStat()</code> 查看各个 session 占用的内存大小及各 session 对应的用户。</p><p class="- topic/p p">通过以下脚本查看每个数据节点上定义的变量和占用的内存：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>pnodeRun(objs) //查询每个节点定义变量占用内存（非共享变量）
pnodeRun(objs{true}) //查询每个节点定义变量占用内存（包含共享变量）</code></pre><p class="- topic/p p">为避免这个问题，请参考本文档<a class="- topic/xref xref" href="#%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98">高效使用内存</a>下的“及时释放数据量较大的变量”</p></li><li class="- topic/li li"><p class="- topic/p p">流数据计算引擎占用了大量内存。</p><p class="- topic/p p">用 <code class="+ topic/ph pr-d/codeph ph codeph">getStreamingStat()</code> 来查看发布、订阅各个队列的深度。用 <code class="+ topic/ph pr-d/codeph ph codeph">getStreamEngineStat()</code> 查看流计算引擎占用内存。</p><p class="- topic/p p">为避免这个问题，请参考本文档 <a class="- topic/xref xref" href="#%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97">流数据消息缓存队列</a>。</p></li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="323--查询时dolphindb-进程退出没有-coredump-产生"><h4 class="- topic/title title topictitle4" id="ariaid-title15">3.2.3.  查询时，DolphinDB 进程退出，没有 coredump 产生</h4><div class="- topic/body body"><p class="- topic/p p">这种情况往往是由于给节点分配的内存超过系统物理内存的限制，操作系统把 DolphinDB 强制关闭。Linux 内核有个机制叫 OOM killer(Out of Memory killer)，该机制会监控那些占用内存过大，尤其是瞬间占用很大内存的进程，为防止内存耗尽而自动把该进程杀掉。排查 OOM killer 可用 dmesg 命令，示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dmesg -T|grep dolphindb</code></pre><p class="- topic/p p">若打印结果中出现了“Out of memory: Kill process”，说明操作系统杀死了 DolphinDB 进程（详情请见 <a class="- topic/xref xref" href="https://www.kernel.org/doc/gorman/html/understand/understand016.html" target="_blank" rel="external noopener">Linux Kernel 相关文档</a>）。解决这种问题的办法是：通过参数 maxMemSize（单节点模式修改 dolphindb.cfg，集群模式修改 cluster.cfg）设定节点的最大内存使用量。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="324--执行-memtrue-或-clearallcache-后操作系统实际内存占用未降低如-linux-中-rss-占用"><h4 class="- topic/title title topictitle4" id="ariaid-title16">3.2.4.  执行 <code class="+ topic/ph pr-d/codeph ph codeph">mem(true)</code> 或 <code class="+ topic/ph pr-d/codeph ph codeph">clearAllCache()</code> 后，操作系统实际内存占用未降低（如 Linux 中 RSS 占用）</h4><div class="- topic/body body"><p class="- topic/p p">这是由于未使用的内存没有及时释放给操作系统。通过 memoryReleaseRate 控制将未使用的内存释放给操作系统的速率，memoryReleaseRate=10 表示以最快的速度释放内存，默认值是 5。该参数等价于设置了 <a class="- topic/xref xref" href="https://gperftools.github.io/gperftools/tcmalloc.html" target="_blank" rel="external noopener">TCMalloc</a> 的 tcmalloc_release_rate。</p><p class="- topic/p p">注：执行 <code class="+ topic/ph pr-d/codeph ph codeph">mem()</code> 以显示本地节点内存使用情况。如设置其参数 freeUnusedBlocks=true，系统将会释放未使用的内存块。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title17" id="325--执行-loadtext-大批量加载到内存时时间过久或卡死"><h4 class="- topic/title title topictitle4" id="ariaid-title17">3.2.5.  执行 loadText 大批量加载到内存时，时间过久或卡死</h4><div class="- topic/body body"><p class="- topic/p p">可检查 log 中是否打印 Cache Engine 相关的信息。若存在这样的信息，说明使用 <code class="+ topic/ph pr-d/codeph ph codeph">loadText</code> 加载到内存的事务超过了 chunkCacheEngineMemSize 或 TSDBCacheEngineSize 的大小，导致事务卡死。</p><p class="- topic/p p">解决方案如下：</p><p class="- topic/p p">调大配置中的 chunkCacheEngineMemSize 或 TSDBCacheEngineSize 值。</p><p class="- topic/p p">2.00.4 及以上版本，请使用 loadTextEx 函数加载数据。这是因为 loadTextEx 函数可以通过参数 atomic，设置将大文件加载过程拆分为多个事务进行。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="326--getclusterperf-返回的节点分配内存memoryalloc与操作系统实际显示值有差异"><h4 class="- topic/title title topictitle4" id="ariaid-title18">3.2.6.  <code class="+ topic/ph pr-d/codeph ph codeph">getClusterPerf()</code> 返回的节点分配内存（memoryAlloc）与操作系统实际显示值有差异</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 是 C++ 程序，本身需要一些基础的数据结构和内存开销，memoryAlloc 显示内存不包括这些内存。在执行 clearAllCache 后，如果 memoryAlloc 的值占操作系统实际显示值的 80% 以上，属于正常现象。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="4--变量的内存管理"><h2 class="- topic/title title topictitle2" id="ariaid-title19">4.  变量的内存管理</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 为用户提供与回收编程环境所需内存，本节介绍为变量分配内存，及释放变量内存的方法。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title20" id="41--创建变量"><h3 class="- topic/title title topictitle3" id="ariaid-title20">4.1.  创建变量</h3><div class="- topic/body body"><p class="- topic/p p">示例 1. 创建一个 vector，含有 1 亿个 INT 类型元素，约 400MB。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>v = 1..100000000
mem().allocatedBytes - mem().freeBytes //输出内存占用结果</code></pre><p class="- topic/p p">结果为：402,865,056，内存占用 400MB 左右，符合预期。</p><p class="- topic/p p">示例 2. 创建一个 table，1000 万行，5 列，每列 4 字节，约 200MB。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 10000000
t = table(n:n,["tag1","tag2","tag3","tag4","tag5"],[INT,INT,INT,INT,INT])
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">结果为：612,530,448，约 600MB，符合预期。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="42--释放变量"><h3 class="- topic/title title topictitle3" id="ariaid-title21">4.2.  释放变量</h3><div class="- topic/body body"><p class="- topic/p p">可通过 <code class="+ topic/ph pr-d/codeph ph codeph">undef</code> 函数或者赋值为 NULL，释放变量的内存。</p><p class="- topic/p p">示例 3. 使用 <code class="+ topic/ph pr-d/codeph ph codeph">undef</code> 函数</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>undef(`v)</code></pre><p class="- topic/p p">或者</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>v = NULL</code></pre><p class="- topic/p p">释放共享变量占用内存示例如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>undef("sharedTable", SHARED)</code></pre><p class="- topic/p p">除了手动释放变量，当 session 关闭时，比如关闭 GUI 和其他 API 连接，都会触发对该 session 的所有内存进行回收。当通过 web notebook 连接时，10 分钟内无操作，系统会关闭 session，自动回收内存。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title22" id="5--分布式数据库读缓存管理"><h2 class="- topic/title title topictitle2" id="ariaid-title22">5.  分布式数据库读缓存管理</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 在不同存储引擎的读缓存管理上存在区别。本节分别介绍 OLAP 引擎和 TSDB 引擎读缓存的分配和管理。OLAP 引擎自动将查询过的历史数据加载到读缓存，后续相关数据的查询将先从缓存中读取。多个会话共享分区表读缓存数据，以提高内存使用率。TSDB 引擎通过索引可快速定位分布式表的数据位置，所以 TSDB 引擎的读缓存只缓存查询数据相关的索引文件，不缓存查询的数据。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title23" id="51--olap-引擎分布式表的缓存管理"><h3 class="- topic/title title topictitle3" id="ariaid-title23">5.1.  OLAP 引擎分布式表的缓存管理</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 对分布式表是以分区中的列为单位管理的。系统自动将查询的分区数据加载到读缓存，后续相关数据的查询将首先从缓存中读取。DolphinDB 记录所有数据的版本号，通过版本机制系统可以快速确定是否需要为一个查询更新缓存。读缓存无需用户指定，系统自动进行管理，当内存不足时，系统自动释放一部分缓存。</p><p class="- topic/p p">历史数据一般以分布式表的形式存在数据库中，用户平时查询操作也往往直接查询分布式表。分布式表的内存管理有如下特点：</p><ul class="- topic/ul ul"><li class="- topic/li li">内存以分区的一列为单位进行管理。</li><li class="- topic/li li">数据只加载到所在的节点，不会在节点间转移。</li><li class="- topic/li li">多个用户访问相同分区时，使用同一份缓存。</li><li class="- topic/li li">内存使用不超过 warningMemSize 情况下，尽量多缓存数据。</li><li class="- topic/li li">缓存数据达到 warningMemSize 时，系统开始自动回收。</li></ul><p class="- topic/p p">以下多个示例是基于以下集群：部署于 2 个数据节点，采用单副本模式。按天分 30 个区，每个分区 1000 万行，11 列（1 列 DATE 类型，1 列 INT 类型，9 列 LONG 类型），所以每个分区的每列 (LONG 类型）数据量为 1000 万行 * 8 字节/列 = 80M，每个分区共 1000 万行 * 80 字节/行 = 800M，整个表共 3 亿行，大小为 24GB。</p><p class="- topic/p p">函数 <code class="+ topic/ph pr-d/codeph ph codeph">clearAllCache()</code> 可清空已经缓存的数据。下面的每次测试前，先用 <code class="+ topic/ph pr-d/codeph ph codeph">pnodeRun(clearAllCache)</code> 清空节点上的所有缓存。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>login(`admin,`123456)
if(existsDatabase("dfs://mem")){
	dropDatabase("dfs://mem")
}
db = database("dfs://mem",VALUE,2022.01.01..2022.01.30)
m = "tag" + string(1..9)
schema = table(1:0,`id`day join m, [INT,DATE] join take(LONG,9) )
db.createPartitionedTable(schema,"pt1",`day)
//写入模拟数据
for (i in 0..29){
	t=table(1..10000000 as tagid,take(2022.01.01+i,10000000) as date,1..10000000 as tag1,1..10000000 as tag2,1..10000000 as tag3,1..10000000 as tag4,1..10000000 as tag5,1..10000000 as tag6,1..10000000 as tag7,1..10000000 as tag8,1..10000000 as tag9 )
	dfsTable=loadTable("dfs://mem","pt1")
	dfsTable.append!(t)
}

//查询15个分区的数据
t=select top 15 * from rpc(getControllerAlias(),getClusterChunksStatus) where file like "/mem%" and replicas like "node1%" order by file
pnodeRun(clearAllCache)
days=datetimeParse(t.file.substr(5,8),"yyyyMMdd")
for(d in days){
    select * from loadTable("dfs://mem","pt1") where  day= d
    print mem().allocatedBytes - mem().freeBytes
}</code></pre></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title24" id="511--内存以分区列为单位进行管理"><h4 class="- topic/title title topictitle4" id="ariaid-title24">5.1.1.  内存以分区列为单位进行管理</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 采用列式存储，当用户对分布式表的数据进行查询时，加载数据的原则是，只把用户所要求的分区和列加载到内存中。</p><p class="- topic/p p">示例 4. 计算分区 2022.01.01 最大的 tag1 的值。我们只查询 1 个分区的一列数据，仅把该列数据全部加载到内存，其他的列不加载。</p><p class="- topic/p p">该分区储存在 node1 上（可以在 controller 上通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getClusterChunksStatus()</code> 查看分区分布情况，而且由上面可知，每列约 80MB）。在 node1 上 执行如下代码，并查看内存占用。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select max(tag1) from loadTable(dbName,tableName) where day = 2022.01.01
mem().allocatedBytes - mem().freeBytes)</code></pre><p class="- topic/p p">输出结果为 84,267,136。</p><p class="- topic/p p">示例 5. 在 node1 上查询 2022.01.01 的前 100 条数据，并观察内存占用。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 100 * from loadTable(dbName,tableName) where day = 2022.01.01
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">输出结果为 839,255,392。虽然我们只取 100 条数据，但是 DolphinDB 加载数据的最小单位是分区列，所以需要加载每个列的全部数据，也就是整个分区的全部数据，约 800MB。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意：</strong> 合理分区以避免 "out of memory"：DolphinDB 以分区为单位管理内存，因此内存的使用量跟分区关系密切。假如分区不均匀，导致某个分区数据量超大，甚至机器的全部内存都不足以容纳整个分区，那么当涉及到该分区的查询计算时，系统会抛出 "out of memory" 的异常。一般原则，数据表的每个分区的数据量在 100MB-1GB 之间为宜。如果表有 10 列，每个字段 8 字节，则每个分区约 100-200 万行。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title25" id="512--数据只加载到所在的节点"><h4 class="- topic/title title topictitle4" id="ariaid-title25">5.1.2.  数据只加载到所在的节点</h4><div class="- topic/body body"><p class="- topic/p p">在数据量大的情况下，节点间转移数据是非常耗时的操作。DolphinDB 的数据是分布式存储的，当执行任务时，把任务发送到数据所在的节点，然后把结果汇总到发送任务的节点。系统会尽最大努力避免将数据跨节点转移。</p><p class="- topic/p p">示例 6. 在 node1 上计算两个分区中 tag1 的最大值。其中分区 2022.01.02 的数据存储在 node1 上，分区 2022.01.03 的数据存储在 node2 上。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select max(tag1) from loadTable(dbName,tableName) where day in [2022.01.02,2022.01.03]
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">输出结果为 84,284,096。在 node2 上查看内存占用为 84,250,624 字节。每个节点存储的数据都为 80MB 左右，也就是 node1 上存储了分区 2022.01.02 的数据，node2 上仅存储了 2022.01.03 的数据。</p><p class="- topic/p p">示例 7. 在 node1 上查询分区 2022.01.02 和 2022.01.03 的所有数据，我们预期 node1 加载 2022.01.02 数据，node2 加载 2022.01.03 的数据，都是 800MB 左右，执行如下代码并观察内存。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 100 * from loadTable(dbName,tableName) where day in [2022.01.02,2022.01.03]
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">node1 上输出结果为 839,279,968 字节。node2 上输出结果为 839,246,496 字节。结果符合预期。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意：</strong> 请谨慎使用没有过滤条件的 "select *"，因为这会将所有数据载入内存。特别在列数很多的时候，建议仅加载需要的列。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title26" id="513--多个用户访问相同分区时使用同一份缓存"><h4 class="- topic/title title topictitle4" id="ariaid-title26">5.1.3.  多个用户访问相同分区时，使用同一份缓存</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 支持海量数据的并发查询。为了高效利用内存，对相同分区的数据，内存中只保留同一份副本。</p><p class="- topic/p p">示例 8. 打开两个 GUI，分别连接 node1 和 node2，查询分区 2022.01.01 的数据，该分区的数据存储在 node1 上。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable(dbName,tableName) where date = 2022.01.01
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">node1 上内存显示 839,101,024，而 node2 上无内存占用。系统将分区数据载入 node1 内存，然后将数据传输到 node2 内存，最后下载到客户端。之后，系统会将此次操作在 node2 所用内存释放。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title27" id="514--节点内存使用不超过-warningmemsize-情况下尽量多缓存数据"><h4 class="- topic/title title topictitle4" id="ariaid-title27">5.1.4.  节点内存使用不超过 warningMemSize 情况下，尽量多缓存数据</h4><div class="- topic/body body"><p class="- topic/p p">通常情况下，最近访问的数据往往更容易再次被访问，因此 DolphinDB 在内存允许的情况下（内存占用不超过用户设置的 warningMemSize），尽量多缓存数据，来提升后续查询效率。</p><p class="- topic/p p">示例 9. 数据节点设置的 maxMemSize=10,warningMemSize=8。连续加载 9 个分区，每个分区约 800M，总内存占用约 7.2GB，观察内存的变化趋势。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbPath =  right(dbName,strlen(dbName)-5)
p = select top 9 * from rpc(getControllerAlias(),getClusterChunksStatus) 
    where file like dbPath +"%" and replicas like "node1%" //这里节点1的别名为node1
    order by file
days = datetimeParse(t.file.substr(strlen(dbPath)+1,8),"yyyyMMdd")
for(d in days){
    select * from loadTable(dbName,tableName) where  date= d
    print mem().allocatedBytes - mem().freeBytes
}
</code></pre><p class="- topic/p p">内存随着加载分区数的增加变化规律如下图所示：<br/><img class="- topic/image image" src="images/memory_managment/partition9.png" alt="image"/><br/></p><p class="- topic/p p">当遍历每个分区数据时，在内存使用量不超过 warningMemSize 的情况下，分区数据会全部缓存到内存中，以便用户下次访问时，直接从内存中读取数据，而不需要再次从磁盘加载。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title28" id="515--节点内存使用达到-warningmemsize-时系统自动回收"><h4 class="- topic/title title topictitle4" id="ariaid-title28">5.1.5.  节点内存使用达到 warningMemSize 时，系统自动回收</h4><div class="- topic/body body"><p class="- topic/p p">当总的内存使用达到 warningMemSize 时，DolphinDB 会采用 LRU 的内存回收策略，回收一部分内存。</p><p class="- topic/p p">示例 10. 上面用例只加载了 9 天的数据，此时我们继续共遍历 15 天数据，查看缓存达到 warningMemSize 时，内存的占用情况。如下图所示：<br/><img class="- topic/image image" src="images/memory_managment/partition15.png" alt="image"/><br/></p><p class="- topic/p p">如上图所示，当缓存的数据超过 warningMemSize 时，系统自动回收内存，总的内存使用量仍然小于用户设置的 warningMemSize。</p><p class="- topic/p p">示例 11. 当缓存数据接近用户设置的 warningMemSize 时，继续申请 Session 变量的内存空间，查看系统内存占用。</p><p class="- topic/p p">此时先查看系统的内存使用：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">输出结果为 7,550,138,448。内存占用超过 7GB，而用户设置的最大内存使用量为 10GB，此时我们继续申请 4GB 空间。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>v = 1..1000000000
mem().allocatedBytes - mem().freeBytes</code></pre><p class="- topic/p p">输出结果为 8,196,073,856。约为 8GB，也就是如果用户定义变量时，可使用的内存不足，系统会触发缓存数据的内存回收，以保证有足够的内存提供给用户使用。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="52--tsdb-引擎分布式表的读缓存管理"><h3 class="- topic/title title topictitle3" id="ariaid-title29">5.2.  TSDB 引擎分布式表的读缓存管理</h3><div class="- topic/body body"><p class="- topic/p p">与 OLAP 引擎存储数据的最小文件为列文件不同，TSDB 引擎存储数据的最小文件是 level file。每个 level file 都记录了元信息，数据块和数据块对应的索引。TSDB 查询分布式表数据时，会将分区下 level file 的索引部分加载到内存，然后将索引定位的数据部分加载到内存。正是因为通过索引就可以快速定位数据并加载，TSDB 只需要缓存索引数据，无需缓存查询的分区数据。TSDB 索引缓存的容量由配置参数 TSDBLevelFileIndexCacheSize 指定，单位为 GB，默认值为 maxMemSize 的 5%，最小值为 0.1GB。若索引缓存空间不够时，会按照 LRU 算法，释放最近最少使用的 5% 的缓存空间。可通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">getLevelFileIndexCacheStatus</code> 获取 TSDB 索引数据占用的内存空间大小。</p><p class="- topic/p p">示例 12.TSDB 引擎下已经创建了如下分布式表</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n=10000
ID=rand(100, n)
dates=2021.08.07..2021.08.11
date=rand(dates, n)
vol=rand(1..10 join int(), n)
t=table(ID, date, vol)
if(existsDatabase("dfs://TSDB_db1")){
dropDatabase("dfs://TSDB_db1")
}
db=database(directory="dfs://TSDB_db1", partitionType=VALUE, partitionScheme=2021.08.07..2021.08.11, engine="TSDB")
pt1=db.createPartitionedTable(table=t, tableName=`pt1, partitionColumns=`date, sortColumns=`ID)</code></pre><p class="- topic/p p">重启 server，查看索引缓存</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>getLevelFileIndexCacheStatus().usage
//输出结果为：0</code></pre><p class="- topic/p p">加载分区 2021.08.07 下的数据，查询索引缓存和数据缓存</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable("dfs://TSDB_db1",`pt1) where date=2021.08.07
getLevelFileIndexCacheStatus().usage
//输出结果为：39128
mem().allocatedBytes - mem().freeBytes
//输出结果为：28537352</code></pre><p class="- topic/p p">继续加载分区 2021.08.08 下的数据，查询索引缓存和数据缓存。索引缓存增加，数据缓存无变化（因为 TSDB 引擎查询结束会将释放内存中的数据，不会占用缓存）</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable("dfs://TSDB_db1",`pt1) where date=2021.08.08
getLevelFileIndexCacheStatus().usage  
//输出结果为：78256
mem().allocatedBytes - mem().freeBytes
//输出结果为：28561912</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title30" id="6--为分布式数据库提供写入缓存"><h2 class="- topic/title title topictitle2" id="ariaid-title30">6.  为分布式数据库提供写入缓存</h2><div class="- topic/body body"><p class="- topic/p p">Cache Engine 是 DolphinDB 中的一种数据写入缓存机制，用于提升海量数据写入性能。DolphinDB 采用先写入 Redo log（预写式日志）和 Cache Engine（写入缓存）的通用做法，等数据积累到一定数量时，批量写入。DolphinDB 2.00.0 及以上版本支持多模存储（OLAP 与 TSDB），不同的存储引擎拥有独立的 Cache Engine。</p><p class="- topic/p p">Cache Engine 需根据系统配置和实际场景合理设置。若设置过小，可能导致 Cache Engine 频繁刷盘，影响系统性能；若设置过大，Cache Engine 可能会缓存大量未刷盘的数据，此时若发生了机器断电或关机，重启后就需要回放大量事务，导致系统启动过慢。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title31" id="61--olap-引擎的写入缓存"><h3 class="- topic/title title topictitle3" id="ariaid-title31">6.1.  OLAP 引擎的写入缓存</h3><div class="- topic/body body"><p class="- topic/p p">默认情况下，OLAP 存储引擎是不开启 Redo Log 的，即写入事务不会进行缓存，直接进行刷盘。若需要缓存事务进行批量刷盘，则需要通过 chunkCacheEngineMemSize 为 OLAP 指定 Cache Engine 的容量，且指定 dataSync=1 启用 Redo Log。下图示意了开启 Cache Engine 和 Redo Log 后事务的写入流程：事务先写入 Redo Log 和 Cache Engine。达到 cache engine 的刷盘条件后，三个事务的数据将被一次性写入到 DFS 的数据库上。
<img class="- topic/image image" src="images/memory_managment/cacheEngine.png" alt="image"/><br/></p><p class="- topic/p p">Cache Engine 空间一般推荐设置为 maxMemSize 的 1/8 到 1/4。chunkCacheEngineMemSize 不是一个刚性的限制，其实际内存占用可能会高于设置的值 ;  根据经验，cacheEngine 不建议设置超过 32G 以上的值，否则会造成 Redo Log 回收慢和内存占用过高的问题; 更多设置请参阅 <a class="- topic/xref xref" href="redoLog_cacheEngine.html">Cache Engine 与数据库日志</a>。</p><p class="- topic/p p">写入过程中，可用 <code class="+ topic/ph pr-d/codeph ph codeph">getCacheEngineMemSize()</code> 查看 OLAP 引擎的 Cache Engine 占用内存情况。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title32" id="62--tsdb-引擎的写入缓存"><h3 class="- topic/title title topictitle3" id="ariaid-title32">6.2.  TSDB 引擎的写入缓存</h3><div class="- topic/body body"><p class="- topic/p p">与 OLAP 不同的是，TSDB 引擎必须开启 Cache Engine（由配置参数 TSDBCacheEngineSize 指定）和 Redo Log。TSDB 引擎的 Cache Engine 内部会对缓存的数据进行排序，当 Cache Engine 写满或经过十分钟后刷入磁盘。刷盘过程中，Cache Engine 为只读状态，不能继续写入数据，此时，如果又有数据写入到 Cache Engine 里，系统会为 TSDB 引擎重新分配一个内存空间作为 TSDB 的 Cache Engine。因此，极端情况下，TSDB 的 Cache Engine 内存占用最多可达到两倍的 TSDBCacheEngineSize。</p><p class="- topic/p p">通过配置参数 TSDBCacheEngineCompression 设置 TSDB 引擎对 Cache Engine 里的数据进行压缩，来缓存更多（约 5 倍）的数据在缓存中，降低查询数据的时延。</p><p class="- topic/p p">写入过程中，可用 <code class="+ topic/ph pr-d/codeph ph codeph">getTSDBCacheEngineSize()</code> 查看 TSDB 引擎的 Cache Engine 占用内存情况。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title33" id="7--流数据消息缓存队列"><h2 class="- topic/title title topictitle2" id="ariaid-title33">7.  流数据消息缓存队列</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 为流数据发送节点提供持久化队列缓存和发送队列缓存，为订阅节点提供接收数据队列缓存。</p><p class="- topic/p p">当数据进入流数据系统时，首先写入流数据表，然后写入持久化队列和发送队列。假设用户设置为异步持久化，则持久化队列异步写入磁盘，发送队列发送到订阅端。
当订阅端收到数据后，先放入接受队列，然后用户定义的 handler 从接收队列中取数据并处理。如果 handler 处理缓慢，会导致接收队列有数据堆积，占用内存。如下图所示：<br/><img class="- topic/image image" src="images/memory_managment/streaming.png" alt="image"/><br/></p><p class="- topic/p p">流数据内存相关的主要配置选项：</p><ul class="- topic/ul ul"><li class="- topic/li li">maxPersistenceQueueDepth: 发布节点流表持久化队列的最大队列深度（消息数上限）。该选项默认设置为 10000000。在磁盘写入成为瓶颈时，队列会堆积数据。</li><li class="- topic/li li">maxPubQueueDepthPerSite: 发布节点发送队列的最大队列深度（消息数上限）。默认值为 1000 万，当网络出现拥塞时，该发送队列会堆积数据。</li><li class="- topic/li li">maxSubQueueDepth: 订阅节点上每个订阅线程接收队列的最大队列深度（消息数上限）。订阅的消息，会先放入订阅消息队列。默认设置为 1000 万，当 handler 处理速度较慢，不能及时处理订阅到的消息时，该队列会有数据堆积。</li><li class="- topic/li li">流表的 capacity：由函数 <code class="+ topic/ph pr-d/codeph ph codeph">enableTablePersistence()</code> 中第四个参数指定，该值表示流表中保存在内存中的最大行数，达到该值时，从内存中删除一半数据。当流数据节点中，流表比较多时，要整体合理设置该值，防止内存不足。</li></ul><p class="- topic/p p">可以通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">objs(true)</code> 或 <code class="+ topic/ph pr-d/codeph ph codeph">objs()</code> 来查看流表占用内存占用大小，用 <code class="+ topic/ph pr-d/codeph ph codeph">getStreamingStat()</code> 来查看各个队列的深度。流计算引擎可能会占用较多内存，可使用 <code class="+ topic/ph pr-d/codeph ph codeph">getStreamEngineStat()</code> 以查看流计算引擎的内存使用量。例如，<code class="+ topic/ph pr-d/codeph ph codeph">getStreamEngineStat().TimeSeriesEngine.memoryUsed</code> 以查看时间序列引擎的内存使用量。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1--%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0" data-tocid="1--内存管理机制及相关配置参数">1.  内存管理机制及相关配置参数</a></li><li class="topic-item"><a href="#2--%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98" data-tocid="2--高效使用内存">2.  高效使用内存</a></li><li class="topic-item"><a href="#3--%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" data-tocid="3--内存监控及常见问题">3.  内存监控及常见问题</a><ul><li class="topic-item"><a href="#31--%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7" data-tocid="31--内存监控">3.1.  内存监控</a><ul><li class="topic-item"><a href="#311--controller-%E4%B8%8A%E7%9B%91%E6%8E%A7%E9%9B%86%E7%BE%A4%E4%B8%AD%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8" data-tocid="311--controller-上监控集群中节点内存占用">3.1.1.  controller 上监控集群中节点内存占用</a></li><li class="topic-item"><a href="#312--mem-%E5%87%BD%E6%95%B0%E7%9B%91%E6%8E%A7%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8" data-tocid="312--mem-函数监控某个节点内存占用">3.1.2.  <code class="+ topic/ph pr-d/codeph ph codeph">mem()</code> 函数监控某个节点内存占用</a></li><li class="topic-item"><a href="#313--objs-%E5%87%BD%E6%95%B0%E7%9B%91%E6%8E%A7%E6%9F%90%E4%B8%AA%E4%BC%9A%E8%AF%9D%E5%86%85%E5%90%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8" data-tocid="313--objs-函数监控某个会话内各变量的内存占用">3.1.3.  <code class="+ topic/ph pr-d/codeph ph codeph">objs()</code> 函数监控某个会话内各变量的内存占用</a></li><li class="topic-item"><a href="#314--%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F" data-tocid="314--查看某个对象占用的内存大小">3.1.4.  查看某个对象占用的内存大小</a></li><li class="topic-item"><a href="#315--%E7%9B%91%E6%8E%A7%E8%8A%82%E7%82%B9%E4%B8%8A%E4%B8%8D%E5%90%8C-session-%E7%9A%84%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8" data-tocid="315--监控节点上不同-session-的内存占用">3.1.5.  监控节点上不同 session 的内存占用</a></li><li class="topic-item"><a href="#316--%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%8F%B0%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1" data-tocid="316--查看后台正在运行的任务">3.1.6.  查看后台正在运行的任务</a></li></ul></li><li class="topic-item"><a href="#32--%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" data-tocid="32--常见问题">3.2.  常见问题</a><ul><li class="topic-item"><a href="#321--%E7%9B%91%E6%8E%A7%E6%98%BE%E7%A4%BA%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%A4%AA%E9%AB%98" data-tocid="321--监控显示节点内存占用太高">3.2.1.  监控显示节点内存占用太高</a></li><li class="topic-item"><a href="#322--out-of-memory-oom" data-tocid="322--out-of-memory-oom">3.2.2.  Out of Memory (OOM)</a></li><li class="topic-item"><a href="#323--%E6%9F%A5%E8%AF%A2%E6%97%B6dolphindb-%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E6%B2%A1%E6%9C%89-coredump-%E4%BA%A7%E7%94%9F" data-tocid="323--查询时dolphindb-进程退出没有-coredump-产生">3.2.3.  查询时，DolphinDB 进程退出，没有 coredump 产生</a></li><li class="topic-item"><a href="#324--%E6%89%A7%E8%A1%8C-memtrue-%E6%88%96-clearallcache-%E5%90%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%99%85%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%9C%AA%E9%99%8D%E4%BD%8E%E5%A6%82-linux-%E4%B8%AD-rss-%E5%8D%A0%E7%94%A8" data-tocid="324--执行-memtrue-或-clearallcache-后操作系统实际内存占用未降低如-linux-中-rss-占用">3.2.4.  执行 <code class="+ topic/ph pr-d/codeph ph codeph">mem(true)</code> 或 <code class="+ topic/ph pr-d/codeph ph codeph">clearAllCache()</code> 后，操作系统实际内存占用未降低（如 Linux 中 RSS 占用）</a></li><li class="topic-item"><a href="#325--%E6%89%A7%E8%A1%8C-loadtext-%E5%A4%A7%E6%89%B9%E9%87%8F%E5%8A%A0%E8%BD%BD%E5%88%B0%E5%86%85%E5%AD%98%E6%97%B6%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85%E6%88%96%E5%8D%A1%E6%AD%BB" data-tocid="325--执行-loadtext-大批量加载到内存时时间过久或卡死">3.2.5.  执行 loadText 大批量加载到内存时，时间过久或卡死</a></li><li class="topic-item"><a href="#326--getclusterperf-%E8%BF%94%E5%9B%9E%E7%9A%84%E8%8A%82%E7%82%B9%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98memoryalloc%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%99%85%E6%98%BE%E7%A4%BA%E5%80%BC%E6%9C%89%E5%B7%AE%E5%BC%82" data-tocid="326--getclusterperf-返回的节点分配内存memoryalloc与操作系统实际显示值有差异">3.2.6.  <code class="+ topic/ph pr-d/codeph ph codeph">getClusterPerf()</code> 返回的节点分配内存（memoryAlloc）与操作系统实际显示值有差异</a></li></ul></li></ul></li><li class="topic-item"><a href="#4--%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" data-tocid="4--变量的内存管理">4.  变量的内存管理</a><ul><li class="topic-item"><a href="#41--%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F" data-tocid="41--创建变量">4.1.  创建变量</a></li><li class="topic-item"><a href="#42--%E9%87%8A%E6%94%BE%E5%8F%98%E9%87%8F" data-tocid="42--释放变量">4.2.  释放变量</a></li></ul></li><li class="topic-item"><a href="#5--%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86" data-tocid="5--分布式数据库读缓存管理">5.  分布式数据库读缓存管理</a><ul><li class="topic-item"><a href="#51--olap-%E5%BC%95%E6%93%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86" data-tocid="51--olap-引擎分布式表的缓存管理">5.1.  OLAP 引擎分布式表的缓存管理</a><ul><li class="topic-item"><a href="#511--%E5%86%85%E5%AD%98%E4%BB%A5%E5%88%86%E5%8C%BA%E5%88%97%E4%B8%BA%E5%8D%95%E4%BD%8D%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86" data-tocid="511--内存以分区列为单位进行管理">5.1.1.  内存以分区列为单位进行管理</a></li><li class="topic-item"><a href="#512--%E6%95%B0%E6%8D%AE%E5%8F%AA%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%89%80%E5%9C%A8%E7%9A%84%E8%8A%82%E7%82%B9" data-tocid="512--数据只加载到所在的节点">5.1.2.  数据只加载到所在的节点</a></li><li class="topic-item"><a href="#513--%E5%A4%9A%E4%B8%AA%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AE%E7%9B%B8%E5%90%8C%E5%88%86%E5%8C%BA%E6%97%B6%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%BB%BD%E7%BC%93%E5%AD%98" data-tocid="513--多个用户访问相同分区时使用同一份缓存">5.1.3.  多个用户访问相同分区时，使用同一份缓存</a></li><li class="topic-item"><a href="#514--%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E4%B8%8D%E8%B6%85%E8%BF%87-warningmemsize-%E6%83%85%E5%86%B5%E4%B8%8B%E5%B0%BD%E9%87%8F%E5%A4%9A%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE" data-tocid="514--节点内存使用不超过-warningmemsize-情况下尽量多缓存数据">5.1.4.  节点内存使用不超过 warningMemSize 情况下，尽量多缓存数据</a></li><li class="topic-item"><a href="#515--%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E8%BE%BE%E5%88%B0-warningmemsize-%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%94%B6" data-tocid="515--节点内存使用达到-warningmemsize-时系统自动回收">5.1.5.  节点内存使用达到 warningMemSize 时，系统自动回收</a></li></ul></li><li class="topic-item"><a href="#52--tsdb-%E5%BC%95%E6%93%8E%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E7%9A%84%E8%AF%BB%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86" data-tocid="52--tsdb-引擎分布式表的读缓存管理">5.2.  TSDB 引擎分布式表的读缓存管理</a></li></ul></li><li class="topic-item"><a href="#6--%E4%B8%BA%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8F%90%E4%BE%9B%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98" data-tocid="6--为分布式数据库提供写入缓存">6.  为分布式数据库提供写入缓存</a><ul><li class="topic-item"><a href="#61--olap-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98" data-tocid="61--olap-引擎的写入缓存">6.1.  OLAP 引擎的写入缓存</a></li><li class="topic-item"><a href="#62--tsdb-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98" data-tocid="62--tsdb-引擎的写入缓存">6.2.  TSDB 引擎的写入缓存</a></li></ul></li><li class="topic-item"><a href="#7--%E6%B5%81%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF%E7%BC%93%E5%AD%98%E9%98%9F%E5%88%97" data-tocid="7--流数据消息缓存队列">7.  流数据消息缓存队列</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>