<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="时间序列数据、截面数据和面板数据是金融领域中常见的数据组织方式。面板数据包含了时间序列和横截面两个维度。在 Python 中，通常可以用 pandas 的 DataFrame 或 numpy 的二维数组来表示。在 DolphinDB 中面板数据也可以用表（table）或矩阵（matrix）来表示。 本教程主要介绍如何在 DolphinDB 中表示和分析面板数据。本文的所有例子都基于 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="面板数据处理"/><title>面板数据处理</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;面板数据处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;面板数据处理&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;时间序列数据、截面数据和面板数据是金融领域中常见的数据组织方式。面板数据包含了时间序列和横截面两个维度。在 Python 中，通常可以用 pandas 的 DataFrame 或 numpy 的二维数组来表示。在 DolphinDB 中面板数据也可以用表（table）或矩阵（matrix）来表示。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;本教程主要介绍如何在 DolphinDB 中表示和分析面板数据。本文的所有例子都基于 DolphinDB 1.30.16/2.00.4。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:26;44:73&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-面板数据的表示方法和处理函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;1. 面板数据的表示方法和处理函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 提供了两种方法处理面板数据：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;通过 SQL 和向量化函数来处理用二维表表示的面板数据&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;通过向量化函数来处理用矩阵表示的面板数据&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 中数据表和矩阵都采用了列式存储。以下是表和矩阵中的列常用的计算函数和二元运算符:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;二元运算符：+, -, *, /, ratio, %, &amp;amp;&amp;amp;, ||, &amp;amp;, |, pow&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;序列函数：ratios, deltas, prev, next, move&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;滑动窗口函数：mcount，mavg, msum, mmax, mimax, mimin, mmin, mprod, mstd, mvar, mmed, mpercentile, mrank, mwavg, mwsum, mbeta, mcorr, mcovar&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;累计窗口函数：cumcount, cumavg, cumsum, cummax, cummin, cumprod, cumstd, cumvar, cummed, cumpercentile, cumPositiveStreak, cumrank, cumwavg, cumwsum, cumbeta, cumcorr, cumcovar&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;聚合函数：count, avg, sum, sum2, first, firstNot, last, lastNot, max, min, std, var, med, mode, percentile, atImax, atImin, wavg, wsum, beta, corr, covar&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;row 系列函数（针对面板数据的每一行进行计算）：rowCount, rowAvg, rowSum, rowSum2, rowProd, rowMax, rowMin, rowStd, rowVar, rowBeta, rowCorr, rowAnd, rowOr, rowXor&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;下文通过举例的方式让读者更能了解这些函数是如何进行面板数据操作。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-sql-语句处理面板数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;2. SQL 语句处理面板数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;当使用 DolphinDB 的二维数据表来表示 SQL 的面板数据时，通常一个列存储一个指标，譬如 open, high, low, close, volume 等，一行代表一个股票在一个时间点的数据。这样的好处是，多个指标进行处理时，不再需要对齐数据。缺点是分组计算（按股票分组的时间序列计算，或者按时间分组的横截面计算），需要先分组。SQL 语句的 group by/context by/pivot by 子句均可用于分组。分组有一定的开销，通常尽可能把所有的计算在一次分组内全部计算完成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 的 SQL 不仅支持 SQL 的标准功能，还进行了扩展，包括面板数据处理，非同时连接，窗口连接，窗口函数等。本章节中会分别展示如何用 SQL 语句处理面板数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;首先，模拟一份含有 3 种股票代码的数据。这份数据在之后的例子中都会用到：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;sym = `C`C`C`C`MS`MS`MS`IBM`IBM timestamp = [09:34:57,09:34:59,09:35:01,09:35:02,09:34:57,09:34:59,09:35:01,09:35:01,09:35:02] price= 50.6 50.62 50.63 50.64 29.46 29.48 29.5 174.97 175.02 volume = 2200 1900 2100 3200 6800 5400 1300 2500 8800 t = table(sym, timestamp, price, volume); t; // output sym timestamp price volume --- --------- ------ ------ C 09:34:57 50.6 2200 C 09:34:59 50.62 1900 C 09:35:01 50.63 2100 C 09:35:02 50.64 3200 MS 09:34:57 29.46 6800 MS 09:34:59 29.48 5400 MS 09:35:01 29.5 1300 IBM 09:35:01 174.97 2500 IBM 09:35:02 175.02 8800&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-context-by&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;2.1. context by&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;context by 是 DolphinDB 独有的功能，是对标准 SQL 语句的拓展，我们可以通过 context by 子句实现的分组计算功能来简化对数据面板的操作。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;SQL 的 group by 子句将数据分成多组，每组产生一个值，也就是一行。因此使用 group by 子句后，行数一般会大大减少。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;在对面板数据进行分组后，每一组数据通常是时间序列数据，譬如按股票分组，每一个组内的数据是一个股票的价格序列。处理面板数据时，有时候希望保持每个组的数据行数，也就是为组内的每一行数据生成一个值。例如，根据一个股票的价格序列生成回报序列，或者根据价格序列生成一个移动平均价格序列。其它数据库系统（例如 SQL Server, PostgreSQL），用窗口函数（window function）来解决这个问题。DolpinDB 引入了 context by 子句来处理面板数据。context by 与 group by, pivot by 一起组成了 DolphinDB 分组数据处理系统。它与窗口函数相比，除了语法更简洁以外，表达能力上也更强大，具体表现在：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;64:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;不仅能与 select 配合查询数据，也可以与 update 配合更新数据。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;66:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;绝大多数数据库系统在窗口函数中只能使用表中现有的字段分组。context by 子句可以使用任何现有字段和计算字段。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;68:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;绝大多数数据库系统的窗口函数仅限于少数几个函数。context by 不仅不限制使用的函数，而且可以使用任意表达式，譬如多个函数的组合。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;70:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;context by 可以与 having 子句配合使用，以过滤每个组内部的行。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;例：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(1) 按股票代码进行分组，应用序列函数计算每一只股票的前后交易量比率，进行对比：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select timestamp, sym, price, ratios(volume) ,volume from t context by sym; // output timestamp sym price ratios_volume volume --------- --- ------ ------------- ------ 09:34:57 C 50.6 2200 09:34:59 C 50.62 0.86 1900 09:35:01 C 50.63 1.106 2100 09:35:02 C 50.64 1.52 3200 09:35:01 IBM 174.97 2500 09:35:02 IBM 175.02 3.52 8800 09:34:57 MS 29.46 6800 09:34:59 MS 29.48 0.79 5400 09:35:01 MS 29.5 0.24 1300&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(2) 结合滑动窗口函数，计算每只股票在 3 次数据更新中的平均价格：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select *, mavg(price,3) from t context by sym; // output sym timestamp price volume mavg_price --- --------- ------ ------ ----------- C 09:34:57 50.60 2200 C 09:34:59 50.62 1900 C 09:35:01 50.63 2100 50.62 C 09:35:02 50.64 3200 50.63 IBM 09:35:01 174.97 2500 IBM 09:35:02 175.02 8800 MS 09:34:57 29.46 6800 MS 09:34:59 29.48 5400 MS 09:35:01 29.50 1300 29.48 &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(3) 结合累计窗口函数，计算每只股票在每一次的数据更新中最大交易量：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select timestamp, sym, price,volume, cummax(volume) from t context by sym; // output timestamp sym price volume cummax_volume --------- --- ------ ------ ------------- 09:34:57 C 50.6 2200 2200 09:34:59 C 50.62 1900 2200 09:35:01 C 50.63 2100 2200 09:35:02 C 50.64 3200 3200 09:35:01 IBM 174.97 2500 2500 09:35:02 IBM 175.02 8800 8800 09:34:57 MS 29.46 6800 6800 09:34:59 MS 29.48 5400 6800 09:35:01 MS 29.5 1300 6800&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;130:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(4) 应用聚合函数，计算每只股票在每分钟中的最大交易量：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select *, max(volume) from t context by sym, timestamp.minute(); // output sym timestamp price volume max_volume --- --------- ------ ------ ---------- C 09:34:57 50.61 2200 2200 C 09:34:59 50.62 1900 2200 C 09:35:01 50.63 2100 3200 C 09:35:02 50.64 3200 3200 IBM 09:35:01 174.97 2500 8800 IBM 09:35:02 175.02 8800 8800 MS 09:34:57 29.46 6800 6800 MS 09:34:59 29.48 5400 6800 MS 09:35:01 29.5 1300 1300&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-pivot-by&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;2.2. pivot by&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;149:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;pivot by 是 DolphinDB 的独有功能，是对标准 SQL 语句的拓展，可将数据表中某列的内容按照两个维度整理，产生数据表或矩阵。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;通过应用 pivot by 子句，可以对于数据表 t 进行重新排列整理：每行为一秒钟，每列为一只股票，既能够了解单个股票每个时刻的变化，也可以了解各股票之间的差异。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;153:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;如：对比同一时间段不同股票的交易价格：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select price from t pivot by timestamp, sym; // output timestamp C IBM MS --------- ----- ------ ----- 09:34:57 50.6 29.46 09:34:59 50.62 29.48 09:35:01 50.63 174.97 29.5 09:35:02 50.64 175.02&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;pivot by 还可以与聚合函数一起使用。比如，将数据中每分钟的平均收盘价转换为数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;select avg(price) from t where sym in `C`IBM pivot by minute(timestamp) as minute, sym; // output minute C IBM ------ ------ ------- 09:34m 50.61 09:35m 50.635 174.995 &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;pivot by 与 select 子句一起使用时返回一个表，而和 exec 语句一起使用时返回一个矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;resM = exec avg(price) from t where sym in `C`IBM pivot by minute(timestamp) as minute, sym; resM // output C IBM ------ ------- 09:34m|50.61 09:35m|50.635 174.995&lt;/codeblock&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;typestr(resM) // output FAST DOUBLE MATRIX&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-向量化函数处理面板数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3. 向量化函数处理面板数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;当使用 DolphinDB 的矩阵来表示面板数据时，数据按时间序列和横截面两个维度进行排列。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;对矩阵表示的面板数据进行分析时，如：每行是按时间戳排序的时间点，每列是一只股票，我们既可以对某一只股票进行多个时间点的动态变化分析，也可以了解多个股票之间在某个时点的差异情况。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;向量化函数 panel 可将一列或多列数据转换为矩阵。例如，将数据表 t 中的 price 列转换为一个矩阵：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;price = panel(t.timestamp, t.sym, t.price); price; // output C IBM MS ----- ------ ----- 09:34:57|50.60 29.46 09:34:59|50.62 29.48 09:35:01|50.63 174.97 29.5 09:35:02|50.64 175.02&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;218:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;以下脚本将 price 与 volume 列分别转换为矩阵。返回的结果是一个元组，每个元素对应一列转换而来的矩阵。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;price, volume = panel(t.timestamp, t.sym, [t.price, t.volume]);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;223:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;使用 panel 函数时，可以指定结果矩阵的行与列的标签。这里需要注意，行与列的标签均需严格升序。例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;rowLabel = 09:34:59..09:35:02; colLabel = [&#34;C&#34;, &#34;MS&#34;]; volume = panel(t.timestamp, t.sym, t.volume, rowLabel, colLabel); volume; // output C MS ---- ---- 09:34:59|1900 5400 09:35:00| 09:35:01|2100 1300 09:35:02|3200 &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;使用 rowNames 和 colNames 函数可以获取 panel 函数返回的矩阵的行和列标签：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;volume.rowNames(); volume.colNames();&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;248:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;如果后续要对面板数据做一步的计算和处理，推荐使用矩阵来表示面板数据。这是因为矩阵天然支持向量化操作和二元操作，计算效率会更高，代码会更简洁。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-矩阵操作示例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.1. 矩阵操作示例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;下文例举了矩阵形式面板数据的常用操作。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(1) 通过序列函数，对每个股票的相邻价格进行比较。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;price = panel(t.timestamp, t.sym, t.price); deltas(price); // output C IBM MS ---- ---- ----- 09:34:57| 09:34:59|0.02 0.02 09:35:01|0.01 0.02 09:35:02|0.01 0.05&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(2) 结合滑动窗口函数，计算每只股票在每 2 次数据更新中的平均价格。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;mavg(price,2); // output C IBM MS ------ ------ ----------- 09:34:57| 09:34:59|50.61 29.47 09:35:01|50.63 174.97 29.49 09:35:02|50.63 175.00 29.50&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(3) 结合累计窗口函数，计算每只股票中价格的排序。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;284:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;cumrank(price); // output C IBM MS - --- -- 09:34:57|0 0 09:34:59|1 1 09:35:01|2 0 2 09:35:02|3 1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;295:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(4) 通过聚合函数, 得到每只股票中的最低价格。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;297:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;min(price); // output [50.60,174.97,29.46] &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;304:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(5) 通过聚合函数，得到每一个同时间段的最低股票价格。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;rowMin(price); // output [29.46,29.48,29.5,50.64]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-对齐矩阵的二次运算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.2. 对齐矩阵的二次运算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;普通矩阵进行二元运算时，按照对应元素分别进行计算，需要保持维度 (shape) 一致，DolphinDB 提供了矩阵对齐的方法，使得矩阵计算不再受维度的限制。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;在 1.30.20/2.00.8 版本前，用户需要通过 indexedMatrix 和 indexedSeries 来支持矩阵的对齐运算，其标签必须是严格递增的。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;indexedMatrix：以行列标签为索引的矩阵。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;indexedSeries：带索引标签的向量。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;indexedMatrix 和 indexedSeries 在进行二元运算时，系统会自动以 &#34;outer join&#34; 的方式对齐，然后进行运算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;323:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;1.30.20/2.00.8 版本后，DolphinDB 提供了用于矩阵对齐的函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;323:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;align&lt;/codeph&gt;，拓展了标签矩阵的对齐功能，使矩阵对齐和运算更加灵活。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(1) indexedSeries 之间的对齐运算&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;两个 indexedSeries 进行二元操作，会根据 index 进行对齐再做计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;index1 = 2020.11.01..2020.11.06; value1 = 1..6; s1 = indexedSeries(index1, value1); index2 = 2020.11.04..2020.11.09; value2 =4..9; s2 = indexedSeries(index2, value2); s1+s2; // output #0 -- 2020.11.01| 2020.11.02| 2020.11.03| 2020.11.04|8 2020.11.05|10 2020.11.06|12 2020.11.07| 2020.11.08| 2020.11.09|&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(2) indexedMatrix 之间的对齐运算&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;两个 indexedMatrix 进行二元操作，其对齐的方法和 indexedSeries 一致。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;id1 = 2020.11.01..2020.11.06; m1 = matrix(1..6, 7..12, 13..18).rename!(id1, `a`b`d) m1.setIndexedMatrix!() id2 = 2020.11.04..2020.11.09; m2 = matrix(4..9, 10..15, 16..21).rename!(id2, `a`b`c) m2.setIndexedMatrix!() m1+m2; // output a b c d -- -- - - 2020.11.01| 2020.11.02| 2020.11.03| 2020.11.04|8 20 2020.11.05|10 22 2020.11.06|12 24 2020.11.07| 2020.11.08| 2020.11.09|&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;382:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(3) indexedSeries 和 indexedMatrix 之间的对齐运算&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;384:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;indexedSeries 与 indexedMatrix 进行二元操作，会根据行标签进行对齐，indexedSeries 与 indexedMatrix 的每列进行计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;386:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;m1=matrix(1..6, 11..16); m1.rename!(2020.11.04..2020.11.09, `A`B); m1.setIndexedMatrix!(); m1; // output A B - -- 2020.11.04|1 11 2020.11.05|2 12 2020.11.06|3 13 2020.11.07|4 14 2020.11.08|5 15 2020.11.09|6 16 s1; // output #0 -- 2020.11.01|1 2020.11.02|2 2020.11.03|3 2020.11.04|4 2020.11.05|5 2020.11.06|6 m1 + s1; // output A B - -- 2020.11.01| 2020.11.02| 2020.11.03| 2020.11.04|5 15 2020.11.05|7 17 2020.11.06|9 19 2020.11.07| 2020.11.08| 2020.11.09|&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;(4) 使用 align 函数进行对齐&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;432:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;x1 = [09:00:00, 09:00:01, 09:00:03] x2 = [09:00:00, 09:00:03, 09:00:03, 09:00:04] y1 = `a`a`b y2 = `a`b`b m1 = matrix(1 2 3, 2 3 4, 3 4 5).rename!(y1,x1) m2 = matrix(11 12 13, 12 13 14, 13 14 15, 14 15 16).rename!(y2,x2) a, b = align(m1, m2, 'ej,aj', false); a; // output 09:00:00 09:00:01 09:00:03 -------- -------- -------- a|1 2 3 a|2 3 4 b|3 4 5 b; // output 09:00:00 09:00:01 09:00:03 -------- -------- -------- a|11 11 13 b|12 12 14 b|13 13 15&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-重采样和频度转换&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.3. 重采样和频度转换&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 提供了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;462:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;resample&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;462:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;asfreq&lt;/codeph&gt; 函数，用于对有时间类型索引的 indexedSeries 或者 indexedMatrix 进行重采样和频度转换。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;其实现目的是为用户提供一个对常规时间序列数据重新采样和频率转换的便捷的方法。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;331-resample重采样&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.3.1. resample（重采样）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;重采样是指将时间序列的频度转换为另一个频度。重采样时必须指定一个聚合函数对数据进行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;470:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;降低采样频率为月：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;471:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;index=2020.01.01..2020.06.30; s=indexedSeries(index, take(1,size(index))); s.resample(&#34;M&#34;,sum); // output #0 -- 2020.01.31|31 2020.02.29|29 2020.03.31|31 2020.04.30|30 2020.05.31|31 2020.06.30|30&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;332-asfreq频率转换&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;487:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;487:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.3.2. asfreq（频率转换）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;487:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;489:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;asfreq 函数转换给定数据的时间频率。与 resample 函数不同，asfreq 不能使用聚合函数对数据进行处理。asfreq 通常应用于将低频转时间换为高频时间的场景，且与各类 fill 函数配合使用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;491:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;提高采样频率为日：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;492:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;index=2020.01.01 2020.01.05 2020.01.10 s=indexedSeries(index, take(1,size(index))); s.asfreq(&#34;D&#34;).ffill() // output #0 -- 2020.01.01|1 2020.01.02|1 2020.01.03|1 2020.01.04|1 2020.01.05|1 2020.01.06|1 2020.01.07|1 2020.01.08|1 2020.01.09|1 2020.01.10|1&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;333-null-值的处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;512:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;512:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.3.3. NULL 值的处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;512:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;在重采样和频率转换中，可能需要对结果的 NULL 值进行处理。具体的处理方法请参考：&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;matrix.md&#34; xtrc=&#34;xref:1;514:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;矩阵运算教程&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-矩阵聚合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;516:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;516:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.4. 矩阵聚合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;516:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;341-列聚合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.4.1. 列聚合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;520:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;对矩阵应用内置的向量函数、聚合函数以及窗口函数，计算都是按列进行的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;522:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;以对某个矩阵应用求和 sum 为例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;m = rand(10, 20)$10:2 sum(m) // output [69, 38]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;531:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;可以看出，矩阵每一列都被单独视为一个向量进行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;533:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;自定义函数，若要应用到矩阵每列单独计算，可以通过高阶函数 each 实现。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;535:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;m = rand(10, 20)$10:2 m // output #0 #1 -- -- 6 6 9 2 7 0 5 5 8 8 8 1 8 4 7 8 4 3 7 0 def mfunc(x, flag){if(flag==1) return sum(x); else return avg(x)} each(mfunc, m, 0 1) // output [6.5, 38]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;342-行聚合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.4.2. 行聚合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;560:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;562:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 提供了按行进行运算的高阶函数 byRow，以及一系列内置的 row 函数（参见 row 系列函数）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;564:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;以对某个矩阵应用 row 函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;564:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;rowCount&lt;/codeph&gt; 为例：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;m=matrix([4.5 NULL 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]); rowCount(m); // output [3,2,2]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;574:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;rowCount 统计每行非空的元素个数，返回一个长度和原矩阵行数相同的向量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;576:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;自定义函数，若要应用到矩阵每行单独计算，可以通过高阶函数 byRow 实现。复用自定义函数 mfunc 和矩阵 m：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;578:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;byRow(mfunc{, 0}, m) // output [6,5.5,3.5,5,8,4.5,6,7.5,3.5,3.5]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;343-分组聚合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;3.4.3. 分组聚合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;587:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;数据表的分组聚合可以通过 SQL 的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;587:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;group by&lt;/codeph&gt; 语句实现；而通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;587:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;regroup&lt;/codeph&gt; 函数，可以实现矩阵的分组聚合操作。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;589:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;根据给出的时间标签将一个价格矩阵进行分组聚合：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;591:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;timestamp = 09:00:00 + rand(10000, 1000).sort!() id= rand(['st1', 'st2'], 1000) price = (190 + rand(10.0, 2000))$1000:2 regroup(price, minute(timestamp), avg, true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;598:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;对于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;598:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;pivot by&lt;/codeph&gt; 产生的面板矩阵，按照 label 进行聚合，可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;598:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;rowNames&lt;/codeph&gt; 或者 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;598:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;colNames&lt;/codeph&gt; 获取标签：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;600:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;n=1000 timestamp = 09:00:00 + rand(10000, n).sort!() id = take(`st1`st2`st3, n) vol = 100 + rand(10.0, n) t = table(timestamp, id, vol) m = exec vol from t pivot by timestamp, id regroup(m,minute(m.rowNames()), avg)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-面板数据处理方式的对比&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;611:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;611:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;4. 面板数据处理方式的对比&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;611:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;613:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;下面以一个更为复杂的实际例子演示如何高效的解决面板数据问题。著名论文 &lt;xref class=&#34;- topic/xref &#34; format=&#34;pdf&#34; href=&#34;https://arxiv.org/ftp/arxiv/papers/1601/1601.00991.pdf&#34; scope=&#34;external&#34; xtrc=&#34;xref:2;613:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;101 Formulaic Alphas&lt;/xref&gt; 给出了世界顶级量化对冲基金 WorldQuant 所使用的 101 个因子公式，其中里面 80% 的因子仍然行之有效并被运用在实盘项目中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;615:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;这里选取了 WorldQuant 公开的 Alpha98 因子的表达式。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:31;616:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;alpha_098 = (rank(decay_linear(correlation(((high_0+low_0+open_0+close_0)*0.25), sum(mean(volume_0,5), 26.4719), 4.58418), 7.18088)) -rank(decay_linear(ts_rank(ts_argmin(correlation(rank(open_0), rank(mean(volume_0,15)), 20.8187), 8.62571),6.95668), 8.07206)))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;为了更好的对比各个处理方式之间的差异，我们选择了一年的股票每日数据，涉及的原始数据量约为 100 万条。如需数据请参考 &lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/panel_data/panelDataDailySimulate.dos&#34; xtrc=&#34;xref:3;619:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;模拟数据脚本&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;621:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;以下是脚本测试所需要的数据, 输入数据为包含以下字段的 table：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;623:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;securityid：股票代码&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;625:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;625:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;tradetime：时间日期&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;627:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;627:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;vol：成交量&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;629:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;629:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;vwap：成交量的加权平均价格&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;631:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;open：开盘价格&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;633:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;633:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;close：收盘价格&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-dolphindb-sql-与向量化函数处理面板数据的对比&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;4.1. DolphinDB SQL 与向量化函数处理面板数据的对比&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;637:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;下例分别使用 DolphinDB SQL 语句和矩阵来实现计算 Alpha98 因子。全部 DolphinDB 脚本请参考 &lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/panel_data/alpha98InDDB.dos&#34; xtrc=&#34;xref:4;637:63&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 实现 98 号因子脚本&lt;/xref&gt;。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;640:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;640:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB SQL 语句实现 Alpha98 因子计算的脚本如下：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:32;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;def alpha98(stock){ t = select securityid, tradetime, vwap, open, mavg(vol, 5) as adv5, mavg(vol,15) as adv15 from stock context by securityid update t set rank_open = rank(open), rank_adv15 = rank(adv15) context by tradetime update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by securityid return select securityid, tradetime, rank(decay7)-rank(decay8) as A98 from t context by tradetime } &lt;/codeblock&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:33;651:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;t = loadTable(&#34;dfs://k_day_level&#34;,&#34;k_day&#34;) timer alpha98(t)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;656:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;656:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;以下是在 DolphinDB 中通过向量化函数来计算 98 号因子的脚本：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:34;658:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;def myrank(x){ return rowRank(x)\x.columns() } def alphaPanel98(vwap, open, vol){ return myrank(mavg(mcorr(vwap, msum(mavg(vol, 5), 26), 5), 1..7)) - myrank(mavg(mrank(9 - mimin(mcorr(myrank(open), myrank(mavg(vol, 15)), 21), 9), true, 7), 1..8)) }&lt;/codeblock&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:35;669:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;t = select * from loadTable(&#34;dfs://k_day_level&#34;,&#34;k_day&#34;) timer vwap, open, vol = panel(t.tradetime, t.securityid, [t.vwap, t.open, t.vol]) timer res = alphaPanel98(vwap, open, vol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;675:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;通过两个 Alpha98 因子脚本的对比，可以发现用向量化函数来实现 Alpha98 因子的脚本会更加简洁一点。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;677:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;因为 Alpha98 因子在计算过程中用到了截面数据，也用到了大量时间序列的计算结果。所以在计算某支股票某一天的因子中，既要用到该股票的历史数据，也要用到当天所有股票的信息，对信息量的要求很大。而矩阵形式的面板数据是截面数据和时间序列数据综合起来的一种数据类型，可以支持股票数据按两个维度进行排列，在实现 Alpha98 因子计算中，不需要多次对中间数据或输出数据进行维度转换，简化了计算逻辑。在实现 Alpha98 因子计算的过程中，进行函数嵌套的同时还需要多次进行分组计算来处理数据。对比使用 SQL 语句执行计算，用 panel 函数来处理面板数据，明显计算效率会更高，代码会更简洁。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;679:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;在性能测试方面，使用单线程计算，SQL 语句计算 Alpha98 因子耗时 610ms。而 panel 函数生成面板数据耗时 70ms，计算 Alpha98 因子耗时 440ms。两者的耗时差异不大，矩阵方式可能略胜一筹。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;但是向量化函数处理面板数据也有局限性, 矩阵的面板数据无法进行再次分组，单值模型格式不够直观，而 SQL 支持多列分组，可以联合查询多个字段的信息，适用于海量数据的并行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;683:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;在处理面板数据时，客户可根据自身对数据的分析需求，来选择不同的方法处理面板数据。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-dolphindb-与-pandas-处理面板数据的性能对比&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;4.2. DolphinDB 与 pandas 处理面板数据的性能对比：&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;686:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;688:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;pandas 实现 alpha98 因子的部分脚本如下，完整脚本请参考 &lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/panel_data/alpha98InPython.py&#34; xtrc=&#34;xref:5;688:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;python 中实现 98 号因子脚本&lt;/xref&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:36;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;def myrank(x): return ((x.rank(axis=1,method='min'))-1)/x.shape[1] def imin(x): return np.where(x==min(x))[0][0] def rank(x): s = pd.Series(x) return (s.rank(ascending=True, method=&#34;min&#34;)[len(s)-1])-1 def alpha98(vwap, open, vol): return myrank(vwap.rolling(5).corr(vol.rolling(5).mean().rolling(26).sum()).rolling(7).apply(lambda x: np.sum(np.arange(1, 8)*x)/np.sum(np.arange(1, 8)))) - myrank((9 - myrank(open).rolling(21).corr(myrank(vol.rolling(15).mean())).rolling(9).apply(imin)).rolling(7).apply(rank).rolling(8).apply(lambda x: np.sum(np.arange(1, 9)*x)/np.sum(np.arange(1, 9))))&lt;/codeblock&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:37;707:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;start_time = time.time() re=alpha98(vwap, open, vol) print(&#34;--- %s seconds ---&#34; % (time.time() - start_time))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;713:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;使用 pandas 计算 Alpha98 的耗时为 520s，而使用矩阵实现计算仅耗时 440ms，性能相差千倍。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;715:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;DolphinDB 内置了许多与时序数据相关的函数，并进行了优化，性能优于其它系统 1~2 个数量级。例如上面例子中使用到的 mavg, mcorr, mrank, mimin, msum 等计算滑动窗口函数。 尤其在计算测试二元滑动窗口（mcorr）中，DolphinDB 的计算耗时 0.6 秒，pandas 耗时 142 秒，性能相差 200 倍以上。为了避免计算结果的偶然性，我们使用了十年的股市收盘价数据，涉及的原始数据量约为 530 万条，对比结果是连续运行十次的耗时。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;718:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;整体而言，在 Alpha98 因子的计算中，DolphinDB 出现性能上的断层式优势是有迹可循的。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-附录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;720:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;720:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;5. 附录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;720:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;722:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;722:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/panel_data/panelDataDailySimulate.dos&#34; xtrc=&#34;xref:6;722:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;模拟数据脚本&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/panel_data/alpha98InDDB.dos&#34; xtrc=&#34;xref:7;723:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 实现 98 号因子脚本&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;724:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;py&#34; href=&#34;script/panel_data/alpha98InPython.py&#34; xtrc=&#34;xref:8;724:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/panel_data.md&#34;&gt;&lt;?ditaot usertext?&gt;Python 实现 98 号因子脚本&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/panel_data.md"/><meta name="wh-out-relpath" content="tutorials/panel_data.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="面板数据处理" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="面板数据处理"><div class="title"><a href="../tutorials/panel_data.html">面板数据处理</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem" class="active"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">面板数据处理</h1><div class="- topic/body body"><p class="- topic/p p">时间序列数据、截面数据和面板数据是金融领域中常见的数据组织方式。面板数据包含了时间序列和横截面两个维度。在 Python 中，通常可以用 pandas 的 DataFrame 或 numpy 的二维数组来表示。在 DolphinDB 中面板数据也可以用表（table）或矩阵（matrix）来表示。</p><p class="- topic/p p">本教程主要介绍如何在 DolphinDB 中表示和分析面板数据。本文的所有例子都基于 DolphinDB 1.30.16/2.00.4。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-面板数据的表示方法和处理函数"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 面板数据的表示方法和处理函数</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 提供了两种方法处理面板数据：</p><ul class="- topic/ul ul"><li class="- topic/li li">通过 SQL 和向量化函数来处理用二维表表示的面板数据</li><li class="- topic/li li">通过向量化函数来处理用矩阵表示的面板数据</li></ul><p class="- topic/p p">DolphinDB 中数据表和矩阵都采用了列式存储。以下是表和矩阵中的列常用的计算函数和二元运算符:</p><ul class="- topic/ul ul"><li class="- topic/li li">二元运算符：+, -, *, /, ratio, %, &amp;&amp;, ||, &amp;, |, pow</li><li class="- topic/li li">序列函数：ratios, deltas, prev, next, move</li><li class="- topic/li li">滑动窗口函数：mcount，mavg, msum, mmax, mimax, mimin, mmin, mprod, mstd, mvar, mmed, mpercentile, mrank, mwavg, mwsum, mbeta, mcorr, mcovar</li><li class="- topic/li li">累计窗口函数：cumcount, cumavg, cumsum, cummax, cummin, cumprod, cumstd, cumvar, cummed, cumpercentile, cumPositiveStreak, cumrank, cumwavg, cumwsum, cumbeta, cumcorr, cumcovar</li><li class="- topic/li li">聚合函数：count, avg, sum, sum2, first, firstNot, last, lastNot, max, min, std, var, med, mode, percentile, atImax, atImin, wavg, wsum, beta, corr, covar</li><li class="- topic/li li">row 系列函数（针对面板数据的每一行进行计算）：rowCount, rowAvg, rowSum, rowSum2, rowProd, rowMax, rowMin, rowStd, rowVar, rowBeta, rowCorr, rowAnd, rowOr, rowXor</li></ul><p class="- topic/p p">下文通过举例的方式让读者更能了解这些函数是如何进行面板数据操作。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-sql-语句处理面板数据"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. SQL 语句处理面板数据</h2><div class="- topic/body body"><p class="- topic/p p">当使用 DolphinDB 的二维数据表来表示 SQL 的面板数据时，通常一个列存储一个指标，譬如 open, high, low, close, volume 等，一行代表一个股票在一个时间点的数据。这样的好处是，多个指标进行处理时，不再需要对齐数据。缺点是分组计算（按股票分组的时间序列计算，或者按时间分组的横截面计算），需要先分组。SQL 语句的 group by/context by/pivot by 子句均可用于分组。分组有一定的开销，通常尽可能把所有的计算在一次分组内全部计算完成。</p><p class="- topic/p p">DolphinDB 的 SQL 不仅支持 SQL 的标准功能，还进行了扩展，包括面板数据处理，非同时连接，窗口连接，窗口函数等。本章节中会分别展示如何用 SQL 语句处理面板数据。</p><p class="- topic/p p">首先，模拟一份含有 3 种股票代码的数据。这份数据在之后的例子中都会用到：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sym = `C`C`C`C`MS`MS`MS`IBM`IBM
timestamp = [09:34:57,09:34:59,09:35:01,09:35:02,09:34:57,09:34:59,09:35:01,09:35:01,09:35:02]
price= 50.6 50.62 50.63 50.64 29.46 29.48 29.5 174.97 175.02
volume = 2200 1900 2100 3200 6800 5400 1300 2500 8800
t = table(sym, timestamp, price, volume);
t;

// output
sym timestamp price  volume
--- --------- ------ ------
C   09:34:57  50.6   2200
C   09:34:59  50.62  1900
C   09:35:01  50.63  2100
C   09:35:02  50.64  3200
MS  09:34:57  29.46  6800
MS  09:34:59  29.48  5400
MS  09:35:01  29.5   1300
IBM 09:35:01  174.97 2500
IBM 09:35:02  175.02 8800</code></pre></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-context-by"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1. context by</h3><div class="- topic/body body"><p class="- topic/p p">context by 是 DolphinDB 独有的功能，是对标准 SQL 语句的拓展，我们可以通过 context by 子句实现的分组计算功能来简化对数据面板的操作。</p><p class="- topic/p p">SQL 的 group by 子句将数据分成多组，每组产生一个值，也就是一行。因此使用 group by 子句后，行数一般会大大减少。</p><p class="- topic/p p">在对面板数据进行分组后，每一组数据通常是时间序列数据，譬如按股票分组，每一个组内的数据是一个股票的价格序列。处理面板数据时，有时候希望保持每个组的数据行数，也就是为组内的每一行数据生成一个值。例如，根据一个股票的价格序列生成回报序列，或者根据价格序列生成一个移动平均价格序列。其它数据库系统（例如 SQL Server, PostgreSQL），用窗口函数（window function）来解决这个问题。DolpinDB 引入了 context by 子句来处理面板数据。context by 与 group by, pivot by 一起组成了 DolphinDB 分组数据处理系统。它与窗口函数相比，除了语法更简洁以外，表达能力上也更强大，具体表现在：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">不仅能与 select 配合查询数据，也可以与 update 配合更新数据。</p></li><li class="- topic/li li"><p class="- topic/p p">绝大多数数据库系统在窗口函数中只能使用表中现有的字段分组。context by 子句可以使用任何现有字段和计算字段。</p></li><li class="- topic/li li"><p class="- topic/p p">绝大多数数据库系统的窗口函数仅限于少数几个函数。context by 不仅不限制使用的函数，而且可以使用任意表达式，譬如多个函数的组合。</p></li><li class="- topic/li li"><p class="- topic/p p">context by 可以与 having 子句配合使用，以过滤每个组内部的行。</p></li></ul><p class="- topic/p p">例：</p><p class="- topic/p p">(1) 按股票代码进行分组，应用序列函数计算每一只股票的前后交易量比率，进行对比：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select timestamp, sym, price, ratios(volume) ,volume from t context by sym;

// output
timestamp sym price  ratios_volume volume
--------- --- ------ ------------- ------
09:34:57  C   50.6                  2200
09:34:59  C   50.62  0.86           1900
09:35:01  C   50.63  1.106          2100
09:35:02  C   50.64  1.52           3200
09:35:01  IBM 174.97                2500
09:35:02  IBM 175.02 3.52           8800
09:34:57  MS  29.46                 6800
09:34:59  MS  29.48  0.79           5400
09:35:01  MS  29.5   0.24           1300</code></pre><p class="- topic/p p">(2) 结合滑动窗口函数，计算每只股票在 3 次数据更新中的平均价格：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select *, mavg(price,3) from t context by sym;

// output
sym timestamp price  volume mavg_price
--- --------- ------ ------ -----------
C   09:34:57  50.60  2200
C   09:34:59  50.62  1900
C   09:35:01  50.63  2100   50.62
C   09:35:02  50.64  3200   50.63
IBM 09:35:01  174.97 2500
IBM 09:35:02  175.02 8800
MS  09:34:57  29.46  6800
MS  09:34:59  29.48  5400
MS  09:35:01  29.50  1300   29.48
</code></pre><p class="- topic/p p">(3) 结合累计窗口函数，计算每只股票在每一次的数据更新中最大交易量：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select timestamp, sym, price,volume, cummax(volume) from t context by sym;

// output
timestamp sym price  volume cummax_volume
--------- --- ------ ------ -------------
09:34:57  C   50.6   2200   2200
09:34:59  C   50.62  1900   2200
09:35:01  C   50.63  2100   2200
09:35:02  C   50.64  3200   3200
09:35:01  IBM 174.97 2500   2500
09:35:02  IBM 175.02 8800   8800
09:34:57  MS  29.46  6800   6800
09:34:59  MS  29.48  5400   6800
09:35:01  MS  29.5   1300   6800</code></pre><p class="- topic/p p">(4) 应用聚合函数，计算每只股票在每分钟中的最大交易量：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select *, max(volume) from t context by sym, timestamp.minute();

// output
sym timestamp price  volume max_volume
--- --------- ------ ------ ----------
C   09:34:57  50.61  2200   2200
C   09:34:59  50.62  1900   2200
C   09:35:01  50.63  2100   3200
C   09:35:02  50.64  3200   3200
IBM 09:35:01  174.97 2500   8800
IBM 09:35:02  175.02 8800   8800
MS  09:34:57  29.46  6800   6800
MS  09:34:59  29.48  5400   6800
MS  09:35:01  29.5   1300   1300</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="22-pivot-by"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.2. pivot by</h3><div class="- topic/body body"><p class="- topic/p p">pivot by 是 DolphinDB 的独有功能，是对标准 SQL 语句的拓展，可将数据表中某列的内容按照两个维度整理，产生数据表或矩阵。</p><p class="- topic/p p">通过应用 pivot by 子句，可以对于数据表 t 进行重新排列整理：每行为一秒钟，每列为一只股票，既能够了解单个股票每个时刻的变化，也可以了解各股票之间的差异。</p><p class="- topic/p p">如：对比同一时间段不同股票的交易价格：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select price from t pivot by timestamp, sym;

// output
timestamp C     IBM    MS
--------- ----- ------ -----
09:34:57  50.6         29.46
09:34:59  50.62        29.48
09:35:01  50.63 174.97 29.5
09:35:02  50.64 175.02</code></pre><p class="- topic/p p">pivot by 还可以与聚合函数一起使用。比如，将数据中每分钟的平均收盘价转换为数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select avg(price) from t where sym in `C`IBM pivot by minute(timestamp) as minute, sym;

// output
minute C      IBM
------ ------ -------
09:34m 50.61
09:35m 50.635 174.995
</code></pre><p class="- topic/p p">pivot by 与 select 子句一起使用时返回一个表，而和 exec 语句一起使用时返回一个矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>resM = exec avg(price) from t where sym in `C`IBM pivot by minute(timestamp) as minute, sym;
resM

// output
       C      IBM
       ------ -------
09:34m|50.61
09:35m|50.635 174.995</code></pre><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>typestr(resM)

// output
FAST DOUBLE MATRIX</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title6" id="3-向量化函数处理面板数据"><h2 class="- topic/title title topictitle2" id="ariaid-title6">3. 向量化函数处理面板数据</h2><div class="- topic/body body"><p class="- topic/p p">当使用 DolphinDB 的矩阵来表示面板数据时，数据按时间序列和横截面两个维度进行排列。</p><p class="- topic/p p">对矩阵表示的面板数据进行分析时，如：每行是按时间戳排序的时间点，每列是一只股票，我们既可以对某一只股票进行多个时间点的动态变化分析，也可以了解多个股票之间在某个时点的差异情况。</p><p class="- topic/p p">向量化函数 panel 可将一列或多列数据转换为矩阵。例如，将数据表 t 中的 price 列转换为一个矩阵：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>price = panel(t.timestamp, t.sym, t.price);
price;

// output
         C     IBM    MS
         ----- ------ -----
09:34:57|50.60        29.46
09:34:59|50.62        29.48
09:35:01|50.63 174.97 29.5
09:35:02|50.64 175.02</code></pre><p class="- topic/p p">以下脚本将 price 与 volume 列分别转换为矩阵。返回的结果是一个元组，每个元素对应一列转换而来的矩阵。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>price, volume = panel(t.timestamp, t.sym, [t.price, t.volume]);</code></pre><p class="- topic/p p">使用 panel 函数时，可以指定结果矩阵的行与列的标签。这里需要注意，行与列的标签均需严格升序。例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rowLabel = 09:34:59..09:35:02;
colLabel = ["C", "MS"];
volume = panel(t.timestamp, t.sym, t.volume, rowLabel, colLabel);
volume;

// output
         C    MS
         ---- ----
09:34:59|1900 5400
09:35:00|
09:35:01|2100 1300
09:35:02|3200
</code></pre><p class="- topic/p p">使用 rowNames 和 colNames 函数可以获取 panel 函数返回的矩阵的行和列标签：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>volume.rowNames();
volume.colNames();</code></pre><p class="- topic/p p">如果后续要对面板数据做一步的计算和处理，推荐使用矩阵来表示面板数据。这是因为矩阵天然支持向量化操作和二元操作，计算效率会更高，代码会更简洁。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="31-矩阵操作示例"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.1. 矩阵操作示例</h3><div class="- topic/body body"><p class="- topic/p p">下文例举了矩阵形式面板数据的常用操作。</p><p class="- topic/p p">(1) 通过序列函数，对每个股票的相邻价格进行比较。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>price = panel(t.timestamp, t.sym, t.price);
deltas(price);

// output
         C    IBM  MS
         ---- ---- -----
09:34:57|
09:34:59|0.02      0.02
09:35:01|0.01      0.02
09:35:02|0.01 0.05</code></pre><p class="- topic/p p">(2) 结合滑动窗口函数，计算每只股票在每 2 次数据更新中的平均价格。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>mavg(price,2);

// output
         C      IBM      MS
         ------ ------ -----------
09:34:57|
09:34:59|50.61         29.47
09:35:01|50.63  174.97 29.49
09:35:02|50.63  175.00 29.50</code></pre><p class="- topic/p p">(3) 结合累计窗口函数，计算每只股票中价格的排序。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>cumrank(price);

// output
         C IBM MS
         - --- --
09:34:57|0     0
09:34:59|1     1
09:35:01|2 0   2
09:35:02|3 1</code></pre><p class="- topic/p p">(4) 通过聚合函数, 得到每只股票中的最低价格。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>min(price);

// output
[50.60,174.97,29.46]
</code></pre><p class="- topic/p p">(5) 通过聚合函数，得到每一个同时间段的最低股票价格。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rowMin(price);

 // output
[29.46,29.48,29.5,50.64]</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="32-对齐矩阵的二次运算"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.2. 对齐矩阵的二次运算</h3><div class="- topic/body body"><p class="- topic/p p">普通矩阵进行二元运算时，按照对应元素分别进行计算，需要保持维度 (shape) 一致，DolphinDB 提供了矩阵对齐的方法，使得矩阵计算不再受维度的限制。</p><p class="- topic/p p">在 1.30.20/2.00.8 版本前，用户需要通过 indexedMatrix 和 indexedSeries 来支持矩阵的对齐运算，其标签必须是严格递增的。</p><ul class="- topic/ul ul"><li class="- topic/li li">indexedMatrix：以行列标签为索引的矩阵。</li><li class="- topic/li li">indexedSeries：带索引标签的向量。</li></ul><p class="- topic/p p">indexedMatrix 和 indexedSeries 在进行二元运算时，系统会自动以 "outer join" 的方式对齐，然后进行运算。</p><p class="- topic/p p">1.30.20/2.00.8 版本后，DolphinDB 提供了用于矩阵对齐的函数 <code class="+ topic/ph pr-d/codeph ph codeph">align</code>，拓展了标签矩阵的对齐功能，使矩阵对齐和运算更加灵活。</p><p class="- topic/p p">(1) indexedSeries 之间的对齐运算</p><p class="- topic/p p">两个 indexedSeries 进行二元操作，会根据 index 进行对齐再做计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>index1 = 2020.11.01..2020.11.06;
value1 = 1..6;
s1 = indexedSeries(index1, value1);

index2 = 2020.11.04..2020.11.09;
value2 =4..9;
s2 = indexedSeries(index2, value2);

s1+s2;

 // output
           #0
           --
2020.11.01|
2020.11.02|
2020.11.03|
2020.11.04|8
2020.11.05|10
2020.11.06|12
2020.11.07|
2020.11.08|
2020.11.09|</code></pre><p class="- topic/p p">(2) indexedMatrix 之间的对齐运算</p><p class="- topic/p p">两个 indexedMatrix 进行二元操作，其对齐的方法和 indexedSeries  一致。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>id1 = 2020.11.01..2020.11.06;
m1 = matrix(1..6, 7..12, 13..18).rename!(id1, `a`b`d)
m1.setIndexedMatrix!()

id2 = 2020.11.04..2020.11.09;
m2 = matrix(4..9, 10..15, 16..21).rename!(id2, `a`b`c)
m2.setIndexedMatrix!()

m1+m2;

 // output
           a  b  c d
           -- -- - -
2020.11.01|         
2020.11.02|         
2020.11.03|         
2020.11.04|8  20    
2020.11.05|10 22    
2020.11.06|12 24    
2020.11.07|         
2020.11.08|         
2020.11.09|</code></pre><p class="- topic/p p">(3) indexedSeries 和 indexedMatrix 之间的对齐运算</p><p class="- topic/p p">indexedSeries 与 indexedMatrix 进行二元操作，会根据行标签进行对齐，indexedSeries 与 indexedMatrix 的每列进行计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>m1=matrix(1..6, 11..16);
m1.rename!(2020.11.04..2020.11.09, `A`B);
m1.setIndexedMatrix!();
m1;

 // output
           A B
           - --
2020.11.04|1 11
2020.11.05|2 12
2020.11.06|3 13
2020.11.07|4 14
2020.11.08|5 15
2020.11.09|6 16

s1;

 // output
           #0
           --
2020.11.01|1
2020.11.02|2
2020.11.03|3
2020.11.04|4
2020.11.05|5
2020.11.06|6

m1 + s1;

 // output
           A B
           - --
2020.11.01|
2020.11.02|
2020.11.03|
2020.11.04|5 15
2020.11.05|7 17
2020.11.06|9 19
2020.11.07|
2020.11.08|
2020.11.09|</code></pre><p class="- topic/p p">(4) 使用 align 函数进行对齐</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>x1 = [09:00:00, 09:00:01, 09:00:03]
x2 = [09:00:00, 09:00:03, 09:00:03, 09:00:04]
y1 = `a`a`b
y2 = `a`b`b
m1 = matrix(1 2 3, 2 3 4, 3 4 5).rename!(y1,x1)
m2 = matrix(11 12 13, 12 13 14, 13 14 15, 14 15 16).rename!(y2,x2)
a, b = align(m1, m2, 'ej,aj', false);
a;

// output
  09:00:00 09:00:01 09:00:03
  -------- -------- --------
a|1        2        3       
a|2        3        4       
b|3        4        5      

b;

// output
  09:00:00 09:00:01 09:00:03
  -------- -------- --------
a|11       11       13      
b|12       12       14      
b|13       13       15</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="33-重采样和频度转换"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.3. 重采样和频度转换</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 提供了 <code class="+ topic/ph pr-d/codeph ph codeph">resample</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">asfreq</code> 函数，用于对有时间类型索引的 indexedSeries 或者 indexedMatrix 进行重采样和频度转换。</p><p class="- topic/p p">其实现目的是为用户提供一个对常规时间序列数据重新采样和频率转换的便捷的方法。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="331-resample重采样"><h4 class="- topic/title title topictitle4" id="ariaid-title10">3.3.1. resample（重采样）</h4><div class="- topic/body body"><p class="- topic/p p">重采样是指将时间序列的频度转换为另一个频度。重采样时必须指定一个聚合函数对数据进行计算。</p><p class="- topic/p p">降低采样频率为月：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>index=2020.01.01..2020.06.30;
s=indexedSeries(index, take(1,size(index)));
s.resample("M",sum);

 // output
           #0
           --
2020.01.31|31
2020.02.29|29
2020.03.31|31
2020.04.30|30
2020.05.31|31
2020.06.30|30</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="332-asfreq频率转换"><h4 class="- topic/title title topictitle4" id="ariaid-title11">3.3.2. asfreq（频率转换）</h4><div class="- topic/body body"><p class="- topic/p p">asfreq 函数转换给定数据的时间频率。与 resample 函数不同，asfreq 不能使用聚合函数对数据进行处理。asfreq 通常应用于将低频转时间换为高频时间的场景，且与各类 fill 函数配合使用。</p><p class="- topic/p p">提高采样频率为日：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>index=2020.01.01 2020.01.05 2020.01.10
s=indexedSeries(index, take(1,size(index)));
s.asfreq("D").ffill()

 // output
            #0
           --
2020.01.01|1
2020.01.02|1
2020.01.03|1
2020.01.04|1
2020.01.05|1
2020.01.06|1
2020.01.07|1
2020.01.08|1
2020.01.09|1
2020.01.10|1</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="333-null-值的处理"><h4 class="- topic/title title topictitle4" id="ariaid-title12">3.3.3. NULL 值的处理</h4><div class="- topic/body body"><p class="- topic/p p">在重采样和频率转换中，可能需要对结果的 NULL 值进行处理。具体的处理方法请参考：<a class="- topic/xref xref" href="matrix.html">矩阵运算教程</a>。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="34-矩阵聚合"><h3 class="- topic/title title topictitle3" id="ariaid-title13">3.4. 矩阵聚合</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="341-列聚合"><h4 class="- topic/title title topictitle4" id="ariaid-title14">3.4.1. 列聚合</h4><div class="- topic/body body"><p class="- topic/p p">对矩阵应用内置的向量函数、聚合函数以及窗口函数，计算都是按列进行的。</p><p class="- topic/p p">以对某个矩阵应用求和 sum 为例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>m = rand(10, 20)$10:2
sum(m)

// output
[69, 38]</code></pre><p class="- topic/p p">可以看出，矩阵每一列都被单独视为一个向量进行计算。</p><p class="- topic/p p">自定义函数，若要应用到矩阵每列单独计算，可以通过高阶函数 each 实现。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>m = rand(10, 20)$10:2
m

// output
#0 #1
-- --
6  6 
9  2 
7  0 
5  5 
8  8 
8  1 
8  4 
7  8 
4  3 
7  0 

def mfunc(x, flag){if(flag==1) return sum(x); else return avg(x)}
each(mfunc, m, 0 1)

// output
[6.5, 38]</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="342-行聚合"><h4 class="- topic/title title topictitle4" id="ariaid-title15">3.4.2. 行聚合</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 提供了按行进行运算的高阶函数 byRow，以及一系列内置的 row 函数（参见 row 系列函数）。</p><p class="- topic/p p">以对某个矩阵应用 row 函数 <code class="+ topic/ph pr-d/codeph ph codeph">rowCount</code> 为例：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>m=matrix([4.5 NULL 1.5, 1.5 4.8 5.9, 4.9 2.0 NULL]);
rowCount(m);

// output
[3,2,2]</code></pre><p class="- topic/p p">rowCount 统计每行非空的元素个数，返回一个长度和原矩阵行数相同的向量。</p><p class="- topic/p p">自定义函数，若要应用到矩阵每行单独计算，可以通过高阶函数 byRow 实现。复用自定义函数 mfunc 和矩阵 m：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>byRow(mfunc{, 0}, m)

// output
[6,5.5,3.5,5,8,4.5,6,7.5,3.5,3.5]</code></pre></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="343-分组聚合"><h4 class="- topic/title title topictitle4" id="ariaid-title16">3.4.3. 分组聚合</h4><div class="- topic/body body"><p class="- topic/p p">数据表的分组聚合可以通过 SQL 的 <code class="+ topic/ph pr-d/codeph ph codeph">group by</code> 语句实现；而通过 <code class="+ topic/ph pr-d/codeph ph codeph">regroup</code> 函数，可以实现矩阵的分组聚合操作。</p><p class="- topic/p p">根据给出的时间标签将一个价格矩阵进行分组聚合：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timestamp = 09:00:00 + rand(10000, 1000).sort!()
id= rand(['st1', 'st2'], 1000)
price = (190 + rand(10.0, 2000))$1000:2
regroup(price, minute(timestamp), avg, true)</code></pre><p class="- topic/p p">对于 <code class="+ topic/ph pr-d/codeph ph codeph">pivot by</code> 产生的面板矩阵，按照 label 进行聚合，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">rowNames</code> 或者 <code class="+ topic/ph pr-d/codeph ph codeph">colNames</code> 获取标签：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n=1000
timestamp = 09:00:00 + rand(10000, n).sort!()
id = take(`st1`st2`st3, n)
vol = 100 + rand(10.0, n)
t = table(timestamp, id, vol)

m = exec vol from t pivot by timestamp, id
regroup(m,minute(m.rowNames()), avg)</code></pre></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="4-面板数据处理方式的对比"><h2 class="- topic/title title topictitle2" id="ariaid-title17">4. 面板数据处理方式的对比</h2><div class="- topic/body body"><p class="- topic/p p">下面以一个更为复杂的实际例子演示如何高效的解决面板数据问题。著名论文 <a class="- topic/xref xref" href="https://arxiv.org/ftp/arxiv/papers/1601/1601.00991.pdf" target="_blank" rel="external noopener">101 Formulaic Alphas</a> 给出了世界顶级量化对冲基金 WorldQuant 所使用的 101 个因子公式，其中里面 80% 的因子仍然行之有效并被运用在实盘项目中。</p><p class="- topic/p p">这里选取了 WorldQuant 公开的 Alpha98 因子的表达式。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>alpha_098 = (rank(decay_linear(correlation(((high_0+low_0+open_0+close_0)*0.25), sum(mean(volume_0,5), 26.4719), 4.58418), 7.18088)) -rank(decay_linear(ts_rank(ts_argmin(correlation(rank(open_0), rank(mean(volume_0,15)), 20.8187), 8.62571),6.95668), 8.07206)))</code></pre><p class="- topic/p p">为了更好的对比各个处理方式之间的差异，我们选择了一年的股票每日数据，涉及的原始数据量约为 100 万条。如需数据请参考 <a class="- topic/xref xref" href="script/panel_data/panelDataDailySimulate.dos">模拟数据脚本</a>。</p><p class="- topic/p p">以下是脚本测试所需要的数据, 输入数据为包含以下字段的 table：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">securityid：股票代码</p></li><li class="- topic/li li"><p class="- topic/p p">tradetime：时间日期</p></li><li class="- topic/li li"><p class="- topic/p p">vol：成交量</p></li><li class="- topic/li li"><p class="- topic/p p">vwap：成交量的加权平均价格</p></li><li class="- topic/li li"><p class="- topic/p p">open：开盘价格</p></li><li class="- topic/li li"><p class="- topic/p p">close：收盘价格</p></li></ul></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="41-dolphindb-sql-与向量化函数处理面板数据的对比"><h3 class="- topic/title title topictitle3" id="ariaid-title18">4.1. DolphinDB SQL 与向量化函数处理面板数据的对比</h3><div class="- topic/body body"><p class="- topic/p p">下例分别使用 DolphinDB SQL 语句和矩阵来实现计算 Alpha98 因子。全部 DolphinDB 脚本请参考 <a class="- topic/xref xref" href="script/panel_data/alpha98InDDB.dos">DolphinDB 实现 98 号因子脚本</a>。</p><ul class="- topic/ul ul"><li class="- topic/li li">DolphinDB SQL 语句实现 Alpha98 因子计算的脚本如下：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def alpha98(stock){
	t = select securityid, tradetime, vwap, open, mavg(vol, 5) as adv5, mavg(vol,15) as adv15 from stock context by securityid
	update t set rank_open = rank(open), rank_adv15 = rank(adv15) context by tradetime
	update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by securityid
	return select securityid, tradetime, rank(decay7)-rank(decay8) as A98 from t context by tradetime
}
</code></pre><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = loadTable("dfs://k_day_level","k_day")
timer alpha98(t)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">以下是在 DolphinDB 中通过向量化函数来计算 98 号因子的脚本：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myrank(x){
	return rowRank(x)\x.columns()
}

def alphaPanel98(vwap, open, vol){
	return myrank(mavg(mcorr(vwap, msum(mavg(vol, 5), 26), 5), 1..7)) - myrank(mavg(mrank(9 - mimin(mcorr(myrank(open), myrank(mavg(vol, 15)), 21), 9), true, 7), 1..8))
}</code></pre><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadTable("dfs://k_day_level","k_day")
timer vwap, open, vol = panel(t.tradetime, t.securityid, [t.vwap, t.open, t.vol])
timer res = alphaPanel98(vwap, open, vol)</code></pre><p class="- topic/p p">通过两个 Alpha98 因子脚本的对比，可以发现用向量化函数来实现 Alpha98 因子的脚本会更加简洁一点。</p><p class="- topic/p p">因为 Alpha98 因子在计算过程中用到了截面数据，也用到了大量时间序列的计算结果。所以在计算某支股票某一天的因子中，既要用到该股票的历史数据，也要用到当天所有股票的信息，对信息量的要求很大。而矩阵形式的面板数据是截面数据和时间序列数据综合起来的一种数据类型，可以支持股票数据按两个维度进行排列，在实现 Alpha98 因子计算中，不需要多次对中间数据或输出数据进行维度转换，简化了计算逻辑。在实现 Alpha98 因子计算的过程中，进行函数嵌套的同时还需要多次进行分组计算来处理数据。对比使用 SQL 语句执行计算，用 panel 函数来处理面板数据，明显计算效率会更高，代码会更简洁。</p><p class="- topic/p p">在性能测试方面，使用单线程计算，SQL 语句计算 Alpha98 因子耗时 610ms。而 panel 函数生成面板数据耗时 70ms，计算 Alpha98 因子耗时 440ms。两者的耗时差异不大，矩阵方式可能略胜一筹。</p><p class="- topic/p p">但是向量化函数处理面板数据也有局限性, 矩阵的面板数据无法进行再次分组，单值模型格式不够直观，而 SQL 支持多列分组，可以联合查询多个字段的信息，适用于海量数据的并行计算。</p><p class="- topic/p p">在处理面板数据时，客户可根据自身对数据的分析需求，来选择不同的方法处理面板数据。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="42-dolphindb-与-pandas-处理面板数据的性能对比"><h3 class="- topic/title title topictitle3" id="ariaid-title19">4.2. DolphinDB 与 pandas 处理面板数据的性能对比：</h3><div class="- topic/body body"><p class="- topic/p p">pandas 实现 alpha98 因子的部分脚本如下，完整脚本请参考 <a class="- topic/xref xref" href="script/panel_data/alpha98InPython.py">python 中实现 98 号因子脚本</a>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myrank(x):
    return ((x.rank(axis=1,method='min'))-1)/x.shape[1]

def imin(x):
    return np.where(x==min(x))[0][0]


def rank(x):
    s = pd.Series(x)
    return (s.rank(ascending=True, method="min")[len(s)-1])-1


def alpha98(vwap, open, vol):
    return myrank(vwap.rolling(5).corr(vol.rolling(5).mean().rolling(26).sum()).rolling(7).apply(lambda x: np.sum(np.arange(1, 8)*x)/np.sum(np.arange(1, 8)))) - myrank((9 - myrank(open).rolling(21).corr(myrank(vol.rolling(15).mean())).rolling(9).apply(imin)).rolling(7).apply(rank).rolling(8).apply(lambda x: np.sum(np.arange(1, 9)*x)/np.sum(np.arange(1, 9))))</code></pre><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>start_time = time.time()
re=alpha98(vwap, open, vol)
print("--- %s seconds ---" % (time.time() - start_time))</code></pre><p class="- topic/p p">使用 pandas 计算 Alpha98 的耗时为 520s，而使用矩阵实现计算仅耗时 440ms，性能相差千倍。</p><p class="- topic/p p">DolphinDB 内置了许多与时序数据相关的函数，并进行了优化，性能优于其它系统 1~2 个数量级。例如上面例子中使用到的 mavg, mcorr, mrank, mimin, msum 等计算滑动窗口函数。
尤其在计算测试二元滑动窗口（mcorr）中，DolphinDB 的计算耗时 0.6 秒，pandas 耗时 142 秒，性能相差 200 倍以上。为了避免计算结果的偶然性，我们使用了十年的股市收盘价数据，涉及的原始数据量约为 530 万条，对比结果是连续运行十次的耗时。</p><p class="- topic/p p">整体而言，在 Alpha98 因子的计算中，DolphinDB 出现性能上的断层式优势是有迹可循的。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="5-附录"><h2 class="- topic/title title topictitle2" id="ariaid-title20">5. 附录</h2><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/panel_data/panelDataDailySimulate.dos">模拟数据脚本</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/panel_data/alpha98InDDB.dos">DolphinDB 实现 98 号因子脚本</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/panel_data/alpha98InPython.py">Python 实现 98 号因子脚本</a></li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E5%92%8C%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" data-tocid="1-面板数据的表示方法和处理函数">1. 面板数据的表示方法和处理函数</a></li><li class="topic-item"><a href="#2-sql-%E8%AF%AD%E5%8F%A5%E5%A4%84%E7%90%86%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE" data-tocid="2-sql-语句处理面板数据">2. SQL 语句处理面板数据</a><ul><li class="topic-item"><a href="#21-context-by" data-tocid="21-context-by">2.1. context by</a></li><li class="topic-item"><a href="#22-pivot-by" data-tocid="22-pivot-by">2.2. pivot by</a></li></ul></li><li class="topic-item"><a href="#3-%E5%90%91%E9%87%8F%E5%8C%96%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE" data-tocid="3-向量化函数处理面板数据">3. 向量化函数处理面板数据</a><ul><li class="topic-item"><a href="#31-%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B" data-tocid="31-矩阵操作示例">3.1. 矩阵操作示例</a></li><li class="topic-item"><a href="#32-%E5%AF%B9%E9%BD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E4%BA%8C%E6%AC%A1%E8%BF%90%E7%AE%97" data-tocid="32-对齐矩阵的二次运算">3.2. 对齐矩阵的二次运算</a></li><li class="topic-item"><a href="#33-%E9%87%8D%E9%87%87%E6%A0%B7%E5%92%8C%E9%A2%91%E5%BA%A6%E8%BD%AC%E6%8D%A2" data-tocid="33-重采样和频度转换">3.3. 重采样和频度转换</a><ul><li class="topic-item"><a href="#331-resample%E9%87%8D%E9%87%87%E6%A0%B7" data-tocid="331-resample重采样">3.3.1. resample（重采样）</a></li><li class="topic-item"><a href="#332-asfreq%E9%A2%91%E7%8E%87%E8%BD%AC%E6%8D%A2" data-tocid="332-asfreq频率转换">3.3.2. asfreq（频率转换）</a></li><li class="topic-item"><a href="#333-null-%E5%80%BC%E7%9A%84%E5%A4%84%E7%90%86" data-tocid="333-null-值的处理">3.3.3. NULL 值的处理</a></li></ul></li><li class="topic-item"><a href="#34-%E7%9F%A9%E9%98%B5%E8%81%9A%E5%90%88" data-tocid="34-矩阵聚合">3.4. 矩阵聚合</a><ul><li class="topic-item"><a href="#341-%E5%88%97%E8%81%9A%E5%90%88" data-tocid="341-列聚合">3.4.1. 列聚合</a></li><li class="topic-item"><a href="#342-%E8%A1%8C%E8%81%9A%E5%90%88" data-tocid="342-行聚合">3.4.2. 行聚合</a></li><li class="topic-item"><a href="#343-%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88" data-tocid="343-分组聚合">3.4.3. 分组聚合</a></li></ul></li></ul></li><li class="topic-item"><a href="#4-%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94" data-tocid="4-面板数据处理方式的对比">4. 面板数据处理方式的对比</a><ul><li class="topic-item"><a href="#41-dolphindb-sql-%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%B9%E6%AF%94" data-tocid="41-dolphindb-sql-与向量化函数处理面板数据的对比">4.1. DolphinDB SQL 与向量化函数处理面板数据的对比</a></li><li class="topic-item"><a href="#42-dolphindb-%E4%B8%8E-pandas-%E5%A4%84%E7%90%86%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94" data-tocid="42-dolphindb-与-pandas-处理面板数据的性能对比">4.2. DolphinDB 与 pandas 处理面板数据的性能对比：</a></li></ul></li><li class="topic-item"><a href="#5-%E9%99%84%E5%BD%95" data-tocid="5-附录">5. 附录</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>