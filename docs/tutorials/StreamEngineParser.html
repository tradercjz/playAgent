<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="流数据引擎解析器（StreamEngineParser）的主要功能是自动构建计算流水线，以及在流批一体计算场景中，将批计算因子翻译成流计算解决方案。以下内容将详细介绍 StreamEngineParser 的计算规则和解析原理。 DolphinDB ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="dita"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="流数据引擎解析器"/><title>流数据引擎解析器</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;dita xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34;&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;流数据引擎解析器&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流数据引擎解析器&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流数据引擎解析器（StreamEngineParser）的主要功能是自动构建计算流水线，以及在流批一体计算场景中，将批计算因子翻译成流计算解决方案。以下内容将详细介绍 StreamEngineParser 的计算规则和解析原理。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:50;73:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;streamengineparser-功能介绍&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 功能介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;DolphinDB 针对不同场景提供了多种流计算引擎，例如用户可以使用响应式状态引擎（ReactiveStateEngine）访问历史状态数据，通过横截面引擎（CrossSectionalEngine）实时计算截面数据等。对于简单的业务场景，只需使用单一引擎即可解决，而对于一些复杂任务，需要将多种引擎串联成流水线，共同完成计算任务。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;相较于手动串联各类引擎需要人工定义每一层引擎实例，并按照特定顺序进行级联，StreamEngineParser 可以帮助用户自动解析表达式，构建流水线，高效实现各类复杂计算业务。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;有了这一功能，用户还可以轻松实现流批一体解决方案。以量化因子研发为例，用户通常需要先对证券历史数据进行批计算，验证因子有效性，然后使用流计算在实盘中做交易。传统的解决方案中，为了批计算的开发效率和维护便捷性，往往采用 Python 等语言，而实盘流计算为了性能，通常采用 C++ 等编译型语言。这就要求用户进行从批到流的因子转写，转写过程不仅带来了冗余繁重的开发工作，还存在流批计算结果不一致的隐患。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 很好地解决了这一问题，用户只需实现因子的批计算，就可以自动构建对应的流计算方案，无需自己转写即可轻松实现流批一体，同时严格保证了流批计算结果的一致性。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;流计算引擎计算规则&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流计算引擎计算规则&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-流计算引擎支持类型&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;1. 流计算引擎支持类型&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;除了上文中提到的响应式状态引擎（ReactiveStateEngine）和横截面引擎（CrossSectionalEngine）， DolphinDB 还提供了时间序列引擎（TimeSeriesEngine）、会话窗口引擎（SessionWindowEngine）、流数据连接引擎（AsofJoinEngine, EqualJoinEngine, WindowJoinEngine, LookupJoinEngine, LeftSemiJoinEngine） 以及异常检测引擎（AnormalyDectionEngine）。其中，异常检测引擎通常用于对实时数据进行监控的场景，流数据连接引擎侧重于异构表的融合。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;目前 StreamEngineParser 仅支持响应式状态引擎、横截面引擎和时间序列引擎。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 可以自动解析因子表达式，然后识别解析出的因子应该放在哪一类计算引擎中，从而实现自动构建流水线。例如，针对用于逐行计算的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;23:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;row&lt;/codeph&gt; 系列函数，StreamEngineParser 会解析生成一个横截面引擎来计算，其特征是函数名以 ”row“ 为前缀；针对用于滑动窗口计算的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;23:157&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rolling&lt;/codeph&gt; 高阶函数，StreamEngineParser 会解析生成时间序列引擎。除此之外，其他函数调用都将解析成状态引擎的指标。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-流计算引擎数据交换规则&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;2. 流计算引擎数据交换规则&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流计算引擎定义类继承了 Table 类，即每一个流计算引擎实例是一个特殊的的数据表。流计算引擎有三个基础要素：输入数据表的表结构（dummyTable）、待计算的逻辑（metrics）和输出数据表的实例引用（outputTable），在创建引擎实例时这三个基础要素是已经确定的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;29:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流计算引擎通过 append 接口将引擎和流数据表的订阅关联起来以接收实时流数据。当引擎的 append 被调用时，会触发计算逻辑，根据引擎的类型来计算指标，计算完成后调用输出表的 append 接口将数据写入。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;由于流计算引擎也是一个数据表，所以一个引擎的实例可以作为另一个引擎的输入或输出，这就是 DolphinDB 流计算流水线构建的基础。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-流计算指标类型&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;3. 流计算指标类型&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流计算引擎的指标依赖 DolphinDB 脚本的表达语义，在解析过程中包括函数、表达式、列引用和常量这几类。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;37:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;37:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;函数&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;解析函数时，StreamEngineParser 可以自动识别函数名称、参数列表及类型和返回值类型。函数可以嵌套调用，即一个函数可以作为另外一个函数的参数，如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mrank(rowRank(low, percent=true), true, 9)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;表达式&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;解析表达式时，StreamEngineParser 可以自动识别表达式的类型，表达式的左值、右值，以及运算符号等，表达式可以在任何引擎中直接使用。如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;sign((vol - mfirst(vol, 2))) * (-1 * (close - mfirst(close, 2)))&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;列引用&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;列引用的计算规则是通过引用列名，将输入表中某一列的值直接拷贝到输出表中。在流计算流水线中，列引用对于从某个 stage 的引擎往后续 stage 传递计算结果至关重要。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;常量&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;常量的引用不涉及指标的计算，也不涉及跨 stage 传递数据，可以在任意 stage 中直接使用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;streamengineparser-解析过程介绍&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 解析过程介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-定义流水线-stage&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;4. 定义流水线 stage&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;定义流水线stage的数据结构，包含当前stage的engine类型，输入Table的schema，计算的metrics列表，假设流水线stage的类名为Process，则其定义为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;class Process { private: EngineType engineType_; TableSP inputDummy_; vector&amp;lt;ObjectSP&amp;gt; metrics_; TableSP outputTableDummy_; } enum EngineType { REACTIVE_STATE_ENGINE, CROSS_SECTIONAL_ENGINE, TIME_SERIES_ENGINE， NONE_ENGINE }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;84:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;前文中我们说明了 engine 实例和计算函数之间的对应关系：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;以 “row” 开头的函数或者 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;86:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;byrow&lt;/codeph&gt; 函数会被解析成 CROSS_SECTIONAL_ENGINE&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;87:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rolling&lt;/codeph&gt; 函数会被解析成 TIME_SERIES_ENGINE&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;其他函数会被解析成 REACTIVE_STATE_ENGINE&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;某一个 stage 仅有一个 engine 实例，仅能计算某一种类型的计算任务，解析过程中当出现某一层的计算指标和当前层的 engine 类型不一致时则需要在当前 engine 的上游新建一个 stage，并将计算的结果以列引用的方式传递给当前 stage。如下图所示：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_1.png&#34; width=&#34;70%&#34; xtrc=&#34;image:1;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;621&#34; dita-ot:image-height=&#34;411&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;94:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;假设当前解析了两层 stage，stage1 是一个 ReactiveStateEngine， stage2 是一个 crossSectionalEngine。在解析过程中识别出来应该在 stage2 的 engine 新增一个计算指标 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;94:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rolling (sum, qty, 6000, 6000, fill=0)&lt;/codeph&gt;。新的指标是一个使用了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;94:172&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rolling&lt;/codeph&gt; 的高阶函数调用，前文中介绍这类调用需要在 TIME_SERIES_ENGINE 中计算，而当前 engine 的类型是 CrossSectionalEngine, 与需要的 engine 类型不匹配， 则需要新建一个时间序列 engine 用来计算新的指标，并在原有的 stage2 中新增一个列引用，引用该计算结果。如下图所示：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_2.png&#34; width=&#34;70%&#34; xtrc=&#34;image:2;96:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;575&#34; dita-ot:image-height=&#34;499&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;值得注意的是，新增的 stage 既可以放在流水线开头，也可以放在当前 stage 的上一层，如果放在流水线的第一层，则在当前层和新增的 stage 之间每一层都需要增加列的引用，否则当前层会拿不到这个指标的计算结果，导致结果错误。放在原有的 stage 的上一层仅需在新的 stage3 中增加对新的 stage2 中新增指标的列的引用即可。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;另外，当我们新增了一个 stage2，则需要在这个 stage2 中针对 stage1 输出表的每一列新增一个列引用。因为现在的 stage3 的输入 table 是 stage1，可以直接访问 stage1 的输出表中的数据，当中间新增了 stage2 后，stage3 的输入 table 是 stage2，没法直接访问 stage1，需要通过 stage2 的列引用作为中间媒介间接访问。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-递归解析&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;5. 递归解析&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 的其中一个参数是指标列表，不同的指标对应的 engine 类型可能会不同，同一个指标因为存在嵌套函数调用可能需要多层 stage 才能完整计算。StreamEngineParser 使用递归完成所有指标的解析，先遍历 StreamEngineParser 的原始输入指标列表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;106:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流水线 stage 的最后一层输出到最终输出表，每一个原始输入指标对应流水线最终输出表的一个列。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;StreamEngineParser 针对每一个原始输入指标递归进行解析，如果是函数调用指标则依次解析函数名和函数参数列表，如果是表达式则依次解析表达式的左右值，直到某一个解析的指标是一个列引用或者是一个常量则退出递归。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;这里我们以 alpha1 因子为例讲解递归解析的完整过程。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;DolphinDB 实现的 alpha1 因子代码为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;def alpha1(close){ ts = mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5) return rowRank(X=ts, percent=true) - 0.5 } inputSchemaT = table(1:0, [&#34;SecurityID&#34;,&#34;TradeTime&#34;,&#34;close&#34;], [SYMBOL,TIMESTAMP,DOUBLE]) resultStream = table(10000:0, [&#34;TradeTime&#34;,&#34;SecurityID&#34;, &#34;factor&#34;], [TIMESTAMP,SYMBOL,DOUBLE]) metrics = &amp;lt;[SecurityID, alpha1(close)]&amp;gt; streamEngine = streamEngineParser(name=&#34;alpha1ParserT&#34;, metrics=metrics, dummyTable=inputSchemaT, outputTable=resultStream, keyColumn=&#34;SecurityID&#34;, timeColumn=`tradetime, triggeringPattern='perBatch', triggeringInterval=4000) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;126:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;在这个例子中，输入 Table 的 schema 为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;126:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;inputSchemaT&lt;/codeph&gt;, 其中有一个 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;126:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;close&lt;/codeph&gt; 输入列，该列被 alpha1 因子作为参数引用。streamEngineParser 的输入指标为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;126:108&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;metrics&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;126:118&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;metrics&lt;/codeph&gt; 中仅有两个指标分别用于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;126:140&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;SecurityID&lt;/codeph&gt; 列引用，和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;126:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;alpha1(close)&lt;/codeph&gt; 因子计算。输出 table 的为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;126:192&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;resultStream&lt;/codeph&gt;，其中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;126:210&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;factor&lt;/codeph&gt; 列的值是&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;126:223&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;alpha1(close)&lt;/codeph&gt; 因子计算后的结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;128:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;alpha1因子有一个赋值表达式&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;130:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;ts = mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;返回的计算表达式 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;134:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=ts, percent=true) - 0.5&lt;/codeph&gt; 中引用了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;134:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;ts&lt;/codeph&gt;。对该因子的递归解析过程如下：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;136:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第一步， 将引用的变量展开，则计算完整表达式为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;138:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true) - 0.5&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第二步，展开后的引用变量最外层是一个表达式，左值为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;142:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true)&lt;/codeph&gt;， 表达式计算符为：”-”, 右值为0.5。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;表达式可以在任意类型的 engine 中计算，因为当前的 stage 中还没有 stage，则创建一个初始的 NONE_STAGE，这个 stage 是万能 stage，后续遇到第一个函数计算时可以将其 NoneEngine 类型转换成对应的 engine 类型。如下图：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_3.png&#34; width=&#34;70%&#34; xtrc=&#34;image:3;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;736&#34; dita-ot:image-height=&#34;275&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第三步， 递归解析表达式的左值 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;148:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true)&lt;/codeph&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;这个是一个以 &#34;row&#34; 为前缀的函数调用，按照前文中的解析规则会被解析成一个 CrossSectionalEngine， 因为当前的 engine 是一个 NoneEngine 类型，则直接将当前 stage 的 engineType 设置成 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;150:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;CROSS_SECTIONAL_ENGINE&lt;/codeph&gt;， 如下图所示：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_4.png&#34; width=&#34;70%&#34; xtrc=&#34;image:4;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;836&#34; dita-ot:image-height=&#34;283&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第四步，接下来解析 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;154:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank&lt;/codeph&gt; 的参数， &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;154:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank&lt;/codeph&gt; 的参数分别为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;154:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;154:130&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;percent=true&lt;/codeph&gt;.&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;先解析 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;156:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;156:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax &lt;/codeph&gt; 函数既不是以 &#34;row&#34; 开头，也不是 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;156:121&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;byrow&lt;/codeph&gt; 高阶函数调用或 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;156:137&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rolling&lt;/codeph&gt; 的高阶函数调用，则应该解析成 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;156:162&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;REACTIVE_STATE_ENGINE&lt;/codeph&gt;， 因为当前层是 CROSS_SECTIONAL_ENGINE，无法计算 REACTIVE_STATE_ENGINE 类型的指标，需要新增一个 stage，并将当前 stage 设置成新增的 stage。如图：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_5.png&#34; width=&#34;70%&#34; xtrc=&#34;image:5;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;695&#34; dita-ot:image-height=&#34;387&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;160:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第五步， 接下来依次解析 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;160:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)&lt;/codeph&gt;参数，其中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;160:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;160:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;pow&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;160:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;iif&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;160:126&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;ratios&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;160:136&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mstd&lt;/codeph&gt; 等函数均应该解析成 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;160:153&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;REACTIVE_STATE_ENGINE&lt;/codeph&gt; 类型，而当前 stage 即 stage1 也是 REACTIVE_STATE_ENGINE，与前述 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;160:228&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax&lt;/codeph&gt; 等函数的解析类型相匹配，所以放在当前 stage 中计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;第六步，回到第二步 表达式的右值是一个常量，不需要新增 Engine，所以 alpha1 最终解析的流水线为：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_6.png&#34; width=&#34;70%&#34; xtrc=&#34;image:6;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;715&#34; dita-ot:image-height=&#34;461&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;流水线仅有两个 stage， stage1 是一个 ReactiveStateEngine 计算 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;166:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0) &lt;/codeph&gt; 这个指标，输出到 table 中对应的列为 &#34;col_0&#34;。stage2 是一个 CrossSectionalEngine, 输入表为 stage1 的输出表， 原来的计算指标&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true) - 0.5&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;经过流水线拆解后，转换成：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(X=col_0, percent=true) - 0.5&lt;/codeph&gt;, 其中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;174:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;col_0&lt;/codeph&gt; 是 stage1 中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;174:64&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;mimax(pow(iif(ratios(close) - 1 &amp;lt; 0, mstd(ratios(close) - 1, 20), close), 2.0)&lt;/codeph&gt; 的结算结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;需要注意的是：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;ReactiveEngine 支持嵌套计算，所以当 ReactinveEngine 的函数指标的参数也是一个 reactiveEngine 时，则可以放到同一个 engine 中执行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;但 TimeSeriesEngine 和 CrossSectionalEngine 不支持嵌套计算，比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;180:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;rowRank(rowRank(close, percent=true), percent=true)&lt;/codeph&gt;, 则需要解析成两个 CrossSectionalEngine。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-优化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;6. 优化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;优化可以尽可能减少流水线的 stage 和避免重复计算。主要的优化方向有两个：尽可能将同类型的指标放在同一个 engine 中计算，并通过列引用传递给后续的 stage；检查某个指标是否已经计算过了，如果已经计算过了则直接引用结果即可。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-在类型匹配的-stage-中计算新增指标-或-为指标匹配-engine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;6.1. 在类型匹配的 stage 中计算新增指标 或 为指标匹配 engine&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;当检测到某个指标和当前 Engine 类型不匹配时，检测下上游所有 stage，是否存在匹配的 engine，若存在，则在匹配的 engine 中计算，并将结果通过列引用透传到当前层。如：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_7.png&#34; width=&#34;70%&#34; xtrc=&#34;image:7;190:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;616&#34; dita-ot:image-height=&#34;552&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;假设当前 stage 是 stage3，解析的一个指标是 ratios(close), 和当前 stage 的 engine 类型不匹配，需要新增一个 reactiveStateEngine 来计算这个指标，但我们检查到上游 stage 中已有了 ReactiveStateEngine 则可以将这个指标在 stage1 中计算，并将结果透传给 stage3. 如下图所示:&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_8.png&#34; width=&#34;60%&#34; xtrc=&#34;image:8;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;605&#34; dita-ot:image-height=&#34;582&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62-检查指标&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;6.2. 检查指标&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;如上例，当 stage3 中新增某一个指标，不论这个指标是否和当前层 engine 类型相匹配，检查下上游 stage 中是否已经计算过了，如果已经计算过了则直接通过列引用引用结果即可。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;63-复检&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;6.3. 复检&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;复检的目的是在 stage 都解析完成后，因为解析顺序以及依赖关系的原因有可能仍然存在多余的相同类型的 engine 的情况，此时需要合并，如下图所示：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_9.png&#34; width=&#34;60%&#34; xtrc=&#34;image:9;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;533&#34; dita-ot:image-height=&#34;725&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34;&gt;当存在上图中的情况时，我们可以检查 stage4 中的每一个指标，如果指标计算需要的参数在 stage1 中都可以满足，则可以将指标放入 stage1 中计算，如果stage4中的指标有依赖 stage3 的计算结果，则无法移动。完成检查后如果 stage4 中所有指标都是列引用则可以删除该 stage，如下图：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/StreamEngineParser/3_10.png&#34; width=&#34;60%&#34; xtrc=&#34;image:10;208:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md&#34; dita-ot:image-width=&#34;535&#34; dita-ot:image-height=&#34;675&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/dita&gt;"/><meta name="wh-source-relpath" content="tutorials/StreamEngineParser.md file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/StreamEngineParser.md"/><meta name="wh-out-relpath" content="tutorials/StreamEngineParser.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html">流数据</a></div></div></li><li class="active"><div class="topicref" data-id="流数据引擎解析器"><div class="title"><a href="../tutorials/StreamEngineParser.html">流数据引擎解析器</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e100449" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="多数据源流式实时关联处理-d9713e100449-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem" class="active"><div data-tocid="流数据引擎解析器-d9713e100495" class="topicref" data-id="流数据引擎解析器" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/StreamEngineParser.html" id="流数据引擎解析器-d9713e100495-link">流数据引擎解析器</a></div></div></li><li role="treeitem"><div data-tocid="流数据高可用-d9713e100541" class="topicref" data-id="流数据高可用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haStreaming.html" id="流数据高可用-d9713e100541-link">流数据高可用</a></div></div></li><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e100587" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub_2.html" id="节点启动时的流计算自动订阅-d9713e100587-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎入门初级高频量价因子策略的实现-d9713e100633" class="topicref" data-id="cep-引擎入门初级高频量价因子策略的实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/getting_started_with_cep_engine.html" id="cep-引擎入门初级高频量价因子策略的实现-d9713e100633-link">CEP 引擎入门：初级高频量价因子策略的实现</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679" class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html" id="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679-link">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li><li role="treeitem"><div data-tocid="流计算时延统计与性能优化-d9713e100725" class="topicref" data-id="流计算时延统计与性能优化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_timer.html" id="流计算时延统计与性能优化-d9713e100725-link">流计算时延统计与性能优化</a></div></div></li><li role="treeitem"><div data-tocid="响应式状态引擎-d9713e100771" class="topicref" data-id="响应式状态引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/reactive_state_engine.html" id="响应式状态引擎-d9713e100771-link">响应式状态引擎</a></div></div></li><li role="treeitem"><div data-tocid="流数据功能应用-d9713e100817" class="topicref" data-id="流数据功能应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_tutorial.html" id="流数据功能应用-d9713e100817-link">流数据功能应用</a></div></div></li><li role="treeitem"><div data-tocid="数据回放-d9713e100863" class="topicref" data-id="数据回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_replay.html" id="数据回放-d9713e100863-link">数据回放</a></div></div></li><li role="treeitem"><div data-tocid="使用-dolphindb-class-来开发流计算状态算子-d9713e100909" class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stateful_stream_operators.html" id="使用-dolphindb-class-来开发流计算状态算子-d9713e100909-link">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="" role="article" aria-labelledby="ariaid-title1"><article class="nested0" aria-labelledby="ariaid-title1" id="流数据引擎解析器"><h1 class="- topic/title title topictitle1" id="ariaid-title1">流数据引擎解析器</h1><div class="- topic/body body"><p class="- topic/p p">流数据引擎解析器（StreamEngineParser）的主要功能是自动构建计算流水线，以及在流批一体计算场景中，将批计算因子翻译成流计算解决方案。以下内容将详细介绍 StreamEngineParser 的计算规则和解析原理。</p></div></article><article class="- topic/topic topic nested0" aria-labelledby="ariaid-title2" id="streamengineparser-功能介绍"><h1 class="- topic/title title topictitle1" id="ariaid-title2">StreamEngineParser 功能介绍</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 针对不同场景提供了多种流计算引擎，例如用户可以使用响应式状态引擎（ReactiveStateEngine）访问历史状态数据，通过横截面引擎（CrossSectionalEngine）实时计算截面数据等。对于简单的业务场景，只需使用单一引擎即可解决，而对于一些复杂任务，需要将多种引擎串联成流水线，共同完成计算任务。</p><p class="- topic/p p">相较于手动串联各类引擎需要人工定义每一层引擎实例，并按照特定顺序进行级联，StreamEngineParser 可以帮助用户自动解析表达式，构建流水线，高效实现各类复杂计算业务。</p><p class="- topic/p p">有了这一功能，用户还可以轻松实现流批一体解决方案。以量化因子研发为例，用户通常需要先对证券历史数据进行批计算，验证因子有效性，然后使用流计算在实盘中做交易。传统的解决方案中，为了批计算的开发效率和维护便捷性，往往采用 Python 等语言，而实盘流计算为了性能，通常采用 C++ 等编译型语言。这就要求用户进行从批到流的因子转写，转写过程不仅带来了冗余繁重的开发工作，还存在流批计算结果不一致的隐患。</p><p class="- topic/p p">StreamEngineParser 很好地解决了这一问题，用户只需实现因子的批计算，就可以自动构建对应的流计算方案，无需自己转写即可轻松实现流批一体，同时严格保证了流批计算结果的一致性。</p></div></article><article class="- topic/topic topic nested0" aria-labelledby="ariaid-title3" id="流计算引擎计算规则"><h1 class="- topic/title title topictitle1" id="ariaid-title3">流计算引擎计算规则</h1><div class="- topic/body body"></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="1-流计算引擎支持类型"><h2 class="- topic/title title topictitle2" id="ariaid-title4">1. 流计算引擎支持类型</h2><div class="- topic/body body"><p class="- topic/p p">除了上文中提到的响应式状态引擎（ReactiveStateEngine）和横截面引擎（CrossSectionalEngine）， DolphinDB 还提供了时间序列引擎（TimeSeriesEngine）、会话窗口引擎（SessionWindowEngine）、流数据连接引擎（AsofJoinEngine, EqualJoinEngine, WindowJoinEngine, LookupJoinEngine, LeftSemiJoinEngine） 以及异常检测引擎（AnormalyDectionEngine）。其中，异常检测引擎通常用于对实时数据进行监控的场景，流数据连接引擎侧重于异构表的融合。</p><p class="- topic/p p">目前 StreamEngineParser 仅支持响应式状态引擎、横截面引擎和时间序列引擎。</p><p class="- topic/p p">StreamEngineParser 可以自动解析因子表达式，然后识别解析出的因子应该放在哪一类计算引擎中，从而实现自动构建流水线。例如，针对用于逐行计算的 <code class="+ topic/ph pr-d/codeph ph codeph">row</code> 系列函数，StreamEngineParser 会解析生成一个横截面引擎来计算，其特征是函数名以 ”row“ 为前缀；针对用于滑动窗口计算的 <code class="+ topic/ph pr-d/codeph ph codeph">rolling</code> 高阶函数，StreamEngineParser 会解析生成时间序列引擎。除此之外，其他函数调用都将解析成状态引擎的指标。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="2-流计算引擎数据交换规则"><h2 class="- topic/title title topictitle2" id="ariaid-title5">2. 流计算引擎数据交换规则</h2><div class="- topic/body body"><p class="- topic/p p">流计算引擎定义类继承了 Table 类，即每一个流计算引擎实例是一个特殊的的数据表。流计算引擎有三个基础要素：输入数据表的表结构（dummyTable）、待计算的逻辑（metrics）和输出数据表的实例引用（outputTable），在创建引擎实例时这三个基础要素是已经确定的。</p><p class="- topic/p p">流计算引擎通过 append 接口将引擎和流数据表的订阅关联起来以接收实时流数据。当引擎的 append 被调用时，会触发计算逻辑，根据引擎的类型来计算指标，计算完成后调用输出表的 append 接口将数据写入。</p><p class="- topic/p p">由于流计算引擎也是一个数据表，所以一个引擎的实例可以作为另一个引擎的输入或输出，这就是 DolphinDB 流计算流水线构建的基础。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title6" id="3-流计算指标类型"><h2 class="- topic/title title topictitle2" id="ariaid-title6">3. 流计算指标类型</h2><div class="- topic/body body"><p class="- topic/p p">流计算引擎的指标依赖 DolphinDB 脚本的表达语义，在解析过程中包括函数、表达式、列引用和常量这几类。</p><ul class="- topic/ul ul"><li class="- topic/li li">函数</li></ul><p class="- topic/p p">解析函数时，StreamEngineParser 可以自动识别函数名称、参数列表及类型和返回值类型。函数可以嵌套调用，即一个函数可以作为另外一个函数的参数，如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>mrank(rowRank(low, percent=true), true, 9)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">表达式</li></ul><p class="- topic/p p">解析表达式时，StreamEngineParser 可以自动识别表达式的类型，表达式的左值、右值，以及运算符号等，表达式可以在任何引擎中直接使用。如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sign((vol - mfirst(vol, 2))) * (-1 * (close - mfirst(close, 2)))</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">列引用</li></ul><p class="- topic/p p">列引用的计算规则是通过引用列名，将输入表中某一列的值直接拷贝到输出表中。在流计算流水线中，列引用对于从某个 stage 的引擎往后续 stage 传递计算结果至关重要。</p><ul class="- topic/ul ul"><li class="- topic/li li">常量</li></ul><p class="- topic/p p">常量的引用不涉及指标的计算，也不涉及跨 stage 传递数据，可以在任意 stage 中直接使用。</p></div></article></article><article class="- topic/topic topic nested0" aria-labelledby="ariaid-title7" id="streamengineparser-解析过程介绍"><h1 class="- topic/title title topictitle1" id="ariaid-title7">StreamEngineParser 解析过程介绍</h1><div class="- topic/body body"></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title8" id="4-定义流水线-stage"><h2 class="- topic/title title topictitle2" id="ariaid-title8">4. 定义流水线 stage</h2><div class="- topic/body body"><p class="- topic/p p">定义流水线stage的数据结构，包含当前stage的engine类型，输入Table的schema，计算的metrics列表，假设流水线stage的类名为Process，则其定义为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>class Process {
  private:
    EngineType engineType_;
    TableSP inputDummy_;
    vector&lt;ObjectSP&gt; metrics_;
    TableSP outputTableDummy_;
}

enum EngineType {
    REACTIVE_STATE_ENGINE,
    CROSS_SECTIONAL_ENGINE,
    TIME_SERIES_ENGINE，
    NONE_ENGINE
}</code></pre><p class="- topic/p p">前文中我们说明了 engine 实例和计算函数之间的对应关系：</p><ul class="- topic/ul ul"><li class="- topic/li li">以 “row” 开头的函数或者 <code class="+ topic/ph pr-d/codeph ph codeph">byrow</code> 函数会被解析成 CROSS_SECTIONAL_ENGINE</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">rolling</code> 函数会被解析成 TIME_SERIES_ENGINE</li><li class="- topic/li li">其他函数会被解析成 REACTIVE_STATE_ENGINE</li></ul><p class="- topic/p p">某一个 stage 仅有一个 engine 实例，仅能计算某一种类型的计算任务，解析过程中当出现某一层的计算指标和当前层的 engine 类型不一致时则需要在当前 engine 的上游新建一个 stage，并将计算的结果以列引用的方式传递给当前 stage。如下图所示：</p><img class="- topic/image image" src="images/StreamEngineParser/3_1.png"/><br/><p class="- topic/p p">假设当前解析了两层 stage，stage1 是一个 ReactiveStateEngine， stage2 是一个 crossSectionalEngine。在解析过程中识别出来应该在 stage2 的 engine 新增一个计算指标 <code class="+ topic/ph pr-d/codeph ph codeph">rolling (sum, qty, 6000, 6000, fill=0)</code>。新的指标是一个使用了 <code class="+ topic/ph pr-d/codeph ph codeph">rolling</code> 的高阶函数调用，前文中介绍这类调用需要在 TIME_SERIES_ENGINE 中计算，而当前 engine 的类型是 CrossSectionalEngine, 与需要的 engine 类型不匹配， 则需要新建一个时间序列 engine 用来计算新的指标，并在原有的 stage2 中新增一个列引用，引用该计算结果。如下图所示：</p><img class="- topic/image image" src="images/StreamEngineParser/3_2.png"/><br/><p class="- topic/p p">值得注意的是，新增的 stage 既可以放在流水线开头，也可以放在当前 stage 的上一层，如果放在流水线的第一层，则在当前层和新增的 stage 之间每一层都需要增加列的引用，否则当前层会拿不到这个指标的计算结果，导致结果错误。放在原有的 stage 的上一层仅需在新的 stage3 中增加对新的 stage2 中新增指标的列的引用即可。</p><p class="- topic/p p">另外，当我们新增了一个 stage2，则需要在这个 stage2 中针对 stage1 输出表的每一列新增一个列引用。因为现在的 stage3 的输入 table 是 stage1，可以直接访问 stage1 的输出表中的数据，当中间新增了 stage2 后，stage3 的输入 table 是 stage2，没法直接访问 stage1，需要通过 stage2 的列引用作为中间媒介间接访问。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title9" id="5-递归解析"><h2 class="- topic/title title topictitle2" id="ariaid-title9">5. 递归解析</h2><div class="- topic/body body"><p class="- topic/p p">StreamEngineParser 的其中一个参数是指标列表，不同的指标对应的 engine 类型可能会不同，同一个指标因为存在嵌套函数调用可能需要多层 stage 才能完整计算。StreamEngineParser 使用递归完成所有指标的解析，先遍历 StreamEngineParser 的原始输入指标列表。</p><p class="- topic/p p">流水线 stage 的最后一层输出到最终输出表，每一个原始输入指标对应流水线最终输出表的一个列。</p><p class="- topic/p p">StreamEngineParser 针对每一个原始输入指标递归进行解析，如果是函数调用指标则依次解析函数名和函数参数列表，如果是表达式则依次解析表达式的左右值，直到某一个解析的指标是一个列引用或者是一个常量则退出递归。</p><p class="- topic/p p">这里我们以 alpha1 因子为例讲解递归解析的完整过程。</p><p class="- topic/p p">DolphinDB 实现的 alpha1 因子代码为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def alpha1(close){
    ts = mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)
    return rowRank(X=ts, percent=true) - 0.5
}

inputSchemaT = table(1:0, ["SecurityID","TradeTime","close"], [SYMBOL,TIMESTAMP,DOUBLE])
resultStream = table(10000:0, ["TradeTime","SecurityID", "factor"], [TIMESTAMP,SYMBOL,DOUBLE])
metrics = &lt;[SecurityID, alpha1(close)]&gt;
streamEngine = streamEngineParser(name="alpha1ParserT", metrics=metrics, dummyTable=inputSchemaT, outputTable=resultStream, keyColumn="SecurityID", timeColumn=`tradetime, triggeringPattern='perBatch', triggeringInterval=4000) </code></pre><p class="- topic/p p">在这个例子中，输入 Table 的 schema 为 <code class="+ topic/ph pr-d/codeph ph codeph">inputSchemaT</code>, 其中有一个 <code class="+ topic/ph pr-d/codeph ph codeph">close</code> 输入列，该列被 alpha1 因子作为参数引用。streamEngineParser 的输入指标为 <code class="+ topic/ph pr-d/codeph ph codeph">metrics</code>，<code class="+ topic/ph pr-d/codeph ph codeph">metrics</code> 中仅有两个指标分别用于 <code class="+ topic/ph pr-d/codeph ph codeph">SecurityID</code> 列引用，和 <code class="+ topic/ph pr-d/codeph ph codeph">alpha1(close)</code> 因子计算。输出 table 的为 <code class="+ topic/ph pr-d/codeph ph codeph">resultStream</code>，其中 <code class="+ topic/ph pr-d/codeph ph codeph">factor</code> 列的值是<code class="+ topic/ph pr-d/codeph ph codeph">alpha1(close)</code> 因子计算后的结果。</p><p class="- topic/p p">alpha1因子有一个赋值表达式</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>ts = mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)</code></pre><p class="- topic/p p">返回的计算表达式 <code class="+ topic/ph pr-d/codeph ph codeph">rowRank(X=ts, percent=true) - 0.5</code> 中引用了 <code class="+ topic/ph pr-d/codeph ph codeph">ts</code>。对该因子的递归解析过程如下：</p><p class="- topic/p p">第一步， 将引用的变量展开，则计算完整表达式为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rowRank(X=mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true) - 0.5</code></pre><p class="- topic/p p">第二步，展开后的引用变量最外层是一个表达式，左值为 <code class="+ topic/ph pr-d/codeph ph codeph">rowRank(X=mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true)</code>， 表达式计算符为：”-”,  右值为0.5。</p><p class="- topic/p p">表达式可以在任意类型的 engine 中计算，因为当前的 stage 中还没有 stage，则创建一个初始的 NONE_STAGE，这个 stage 是万能 stage，后续遇到第一个函数计算时可以将其 NoneEngine 类型转换成对应的 engine 类型。如下图：</p><img class="- topic/image image" src="images/StreamEngineParser/3_3.png"/><br/><p class="- topic/p p">第三步， 递归解析表达式的左值 <code class="+ topic/ph pr-d/codeph ph codeph">rowRank(X=mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true)</code></p><p class="- topic/p p">这个是一个以 "row" 为前缀的函数调用，按照前文中的解析规则会被解析成一个 CrossSectionalEngine， 因为当前的 engine 是一个 NoneEngine 类型，则直接将当前 stage 的 engineType 设置成 <code class="+ topic/ph pr-d/codeph ph codeph">CROSS_SECTIONAL_ENGINE</code>， 如下图所示：</p><img class="- topic/image image" src="images/StreamEngineParser/3_4.png"/><br/><p class="- topic/p p">第四步，接下来解析 <code class="+ topic/ph pr-d/codeph ph codeph">rowRank</code> 的参数， <code class="+ topic/ph pr-d/codeph ph codeph">rowRank</code> 的参数分别为 <code class="+ topic/ph pr-d/codeph ph codeph">mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">percent=true</code>.</p><p class="- topic/p p">先解析 <code class="+ topic/ph pr-d/codeph ph codeph">mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)</code>,  <code class="+ topic/ph pr-d/codeph ph codeph">mimax </code> 函数既不是以 "row" 开头，也不是 <code class="+ topic/ph pr-d/codeph ph codeph">byrow</code> 高阶函数调用或 <code class="+ topic/ph pr-d/codeph ph codeph">rolling</code> 的高阶函数调用，则应该解析成 <code class="+ topic/ph pr-d/codeph ph codeph">REACTIVE_STATE_ENGINE</code>， 因为当前层是 CROSS_SECTIONAL_ENGINE，无法计算 REACTIVE_STATE_ENGINE 类型的指标，需要新增一个 stage，并将当前 stage 设置成新增的 stage。如图：</p><img class="- topic/image image" src="images/StreamEngineParser/3_5.png"/><br/><p class="- topic/p p">第五步， 接下来依次解析 <code class="+ topic/ph pr-d/codeph ph codeph">mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5)</code>参数，其中 <code class="+ topic/ph pr-d/codeph ph codeph">mimax</code>，<code class="+ topic/ph pr-d/codeph ph codeph">pow</code>, <code class="+ topic/ph pr-d/codeph ph codeph">iif</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ratios</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mstd</code> 等函数均应该解析成 <code class="+ topic/ph pr-d/codeph ph codeph">REACTIVE_STATE_ENGINE</code> 类型，而当前 stage 即 stage1 也是 REACTIVE_STATE_ENGINE，与前述 <code class="+ topic/ph pr-d/codeph ph codeph">mimax</code> 等函数的解析类型相匹配，所以放在当前 stage 中计算。</p><p class="- topic/p p">第六步，回到第二步 表达式的右值是一个常量，不需要新增 Engine，所以 alpha1 最终解析的流水线为：</p><img class="- topic/image image" src="images/StreamEngineParser/3_6.png"/><br/><p class="- topic/p p">流水线仅有两个 stage， stage1 是一个 ReactiveStateEngine 计算 <code class="+ topic/ph pr-d/codeph ph codeph">mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0) </code> 这个指标，输出到 table 中对应的列为 "col_0"。stage2 是一个 CrossSectionalEngine, 输入表为 stage1 的输出表， 原来的计算指标</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rowRank(X=mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0), 5), percent=true) - 0.5</code></pre><p class="- topic/p p">经过流水线拆解后，转换成：</p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">rowRank(X=col_0, percent=true) - 0.5</code>,  其中 <code class="+ topic/ph pr-d/codeph ph codeph">col_0</code> 是 stage1 中 <code class="+ topic/ph pr-d/codeph ph codeph">mimax(pow(iif(ratios(close) - 1 &lt; 0, mstd(ratios(close) - 1, 20), close), 2.0)</code> 的结算结果。</p><p class="- topic/p p">需要注意的是：</p><p class="- topic/p p">ReactiveEngine 支持嵌套计算，所以当 ReactinveEngine 的函数指标的参数也是一个 reactiveEngine 时，则可以放到同一个 engine 中执行。</p><p class="- topic/p p">但 TimeSeriesEngine 和 CrossSectionalEngine 不支持嵌套计算，比如 <code class="+ topic/ph pr-d/codeph ph codeph">rowRank(rowRank(close, percent=true), percent=true)</code>, 则需要解析成两个 CrossSectionalEngine。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title10" id="6-优化"><h2 class="- topic/title title topictitle2" id="ariaid-title10">6. 优化</h2><div class="- topic/body body"><p class="- topic/p p">优化可以尽可能减少流水线的 stage 和避免重复计算。主要的优化方向有两个：尽可能将同类型的指标放在同一个 engine 中计算，并通过列引用传递给后续的 stage；检查某个指标是否已经计算过了，如果已经计算过了则直接引用结果即可。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="61-在类型匹配的-stage-中计算新增指标-或-为指标匹配-engine"><h3 class="- topic/title title topictitle3" id="ariaid-title11">6.1. 在类型匹配的 stage 中计算新增指标 或 为指标匹配 engine</h3><div class="- topic/body body"><p class="- topic/p p">当检测到某个指标和当前 Engine 类型不匹配时，检测下上游所有 stage，是否存在匹配的 engine，若存在，则在匹配的 engine 中计算，并将结果通过列引用透传到当前层。如：</p><img class="- topic/image image" src="images/StreamEngineParser/3_7.png"/><br/><p class="- topic/p p">假设当前 stage 是 stage3，解析的一个指标是 ratios(close), 和当前 stage 的 engine 类型不匹配，需要新增一个 reactiveStateEngine 来计算这个指标，但我们检查到上游 stage 中已有了 ReactiveStateEngine 则可以将这个指标在 stage1 中计算，并将结果透传给 stage3. 如下图所示:</p><img class="- topic/image image" src="images/StreamEngineParser/3_8.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="62-检查指标"><h3 class="- topic/title title topictitle3" id="ariaid-title12">6.2. 检查指标</h3><div class="- topic/body body"><p class="- topic/p p">如上例，当 stage3 中新增某一个指标，不论这个指标是否和当前层 engine 类型相匹配，检查下上游 stage 中是否已经计算过了，如果已经计算过了则直接通过列引用引用结果即可。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="63-复检"><h3 class="- topic/title title topictitle3" id="ariaid-title13">6.3. 复检</h3><div class="- topic/body body"><p class="- topic/p p">复检的目的是在 stage 都解析完成后，因为解析顺序以及依赖关系的原因有可能仍然存在多余的相同类型的 engine 的情况，此时需要合并，如下图所示：</p><img class="- topic/image image" src="images/StreamEngineParser/3_9.png"/><br/><p class="- topic/p p">当存在上图中的情况时，我们可以检查 stage4 中的每一个指标，如果指标计算需要的参数在 stage1 中都可以满足，则可以将指标放入 stage1 中计算，如果stage4中的指标有依赖 stage3 的计算结果，则无法移动。完成检查后如果 stage4 中所有指标都是列引用则可以删除该 stage，如下图：</p><img class="- topic/image image" src="images/StreamEngineParser/3_10.png"/><br/></div></article></article></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%B5%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E7%B1%BB%E5%9E%8B" data-tocid="1-流计算引擎支持类型">1. 流计算引擎支持类型</a></li><li class="topic-item"><a href="#2-%E6%B5%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E8%A7%84%E5%88%99" data-tocid="2-流计算引擎数据交换规则">2. 流计算引擎数据交换规则</a></li><li class="topic-item"><a href="#3-%E6%B5%81%E8%AE%A1%E7%AE%97%E6%8C%87%E6%A0%87%E7%B1%BB%E5%9E%8B" data-tocid="3-流计算指标类型">3. 流计算指标类型</a></li><li class="topic-item"><a href="#4-%E5%AE%9A%E4%B9%89%E6%B5%81%E6%B0%B4%E7%BA%BF-stage" data-tocid="4-定义流水线-stage">4. 定义流水线 stage</a></li><li class="topic-item"><a href="#5-%E9%80%92%E5%BD%92%E8%A7%A3%E6%9E%90" data-tocid="5-递归解析">5. 递归解析</a></li><li class="topic-item"><a href="#6-%E4%BC%98%E5%8C%96" data-tocid="6-优化">6. 优化</a><ul><li class="topic-item"><a href="#61-%E5%9C%A8%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E7%9A%84-stage-%E4%B8%AD%E8%AE%A1%E7%AE%97%E6%96%B0%E5%A2%9E%E6%8C%87%E6%A0%87-%E6%88%96-%E4%B8%BA%E6%8C%87%E6%A0%87%E5%8C%B9%E9%85%8D-engine" data-tocid="61-在类型匹配的-stage-中计算新增指标-或-为指标匹配-engine">6.1. 在类型匹配的 stage 中计算新增指标 或 为指标匹配 engine</a></li><li class="topic-item"><a href="#62-%E6%A3%80%E6%9F%A5%E6%8C%87%E6%A0%87" data-tocid="62-检查指标">6.2. 检查指标</a></li><li class="topic-item"><a href="#63-%E5%A4%8D%E6%A3%80" data-tocid="63-复检">6.3. 复检</a></li></ul></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>