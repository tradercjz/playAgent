<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content=" ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="多范式编程"/><title>多范式编程</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;多范式编程&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;多范式编程&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;开发大数据应用，不仅需要一个能支撑海量数据的分布式数据库，一个能高效利用多核多节点的分布式计算框架，更需要一门能与分布式数据库和分布式计算有机融合，高性能易扩展，表达能力强，满足快速开发和建模需要的编程语言。DolphinDB从流行的SQL和Python语言汲取了灵感，设计了大数据处理脚本语言。本教程讲解如何通过混合范式编程，快速开发大数据分析的应用。从中你也可以了解DolphinDB的编程语言（以下简称DolphinDB）如何与数据库和分布式计算融合。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:37;55:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;向量化编程vector-programming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;向量化编程(Vector Programming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;向量化编程是 DolphinDB 中最基本的编程范式。DolphinDB中绝大部分函数支持向量作为函数的输入参数。根据函数的返回值的不同，函数可分为两种：一种是聚合函数（aggregate function），返回标量（scalar）；另一种是向量函数，返回与输入向量等长的向量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;向量化操作有三个主要优点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;代码简洁&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;大幅降低脚本语言的解释成本&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;可对很多算法进行优化&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;时间序列数据通常可以用一个向量来表示，用于数据分析的列式数据库的每一个列也都可以用向量来表示。DolphinDB作为一个内存计算引擎或者作为一个分析型的数据仓库，在进行时间序列数据分析时，特别适合使用向量化编程。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;以两个长度为一千万的向量相加作为一个简单例子。用命令式编程的for语句，不仅语句冗长，而且耗时是向量化编程的百倍以上。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;n = 10000000 a = rand(1.0, n) b = rand(1.0, n) //采用for语句编程： c = array(DOUBLE, n) for(i in 0 : n) c[i] = a[i] + b[i] //采用向量化编程： c = a + b&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;向量化编程实际上是对一组同质数据的批处理，不仅在编译阶段可以利用vectorization对指令进行优化，在很多算法上也可以优化。以经常使用的时间序列数据滑动窗口（sliding window）指标之一的移动平均（moving average）为例。假设总的数据量是n，窗口大小为k，如果不采用批量计算，时间复杂度是O(nk)。但是因为计算完一个窗口的移动平均后，计算下一个窗口时，只有一个数据点发生了变化，所以只要调整这一个点的值，就可以算出新窗口的移动平均，所以批量计算的时间复杂度是O(n)。DolphinDB中，大部分计算滑动窗口指标的函数都经过了优化，性能近似于O(n)。这些函数包括&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;32:298&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mmax&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;32:306&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mmin&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;32:314&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mimax&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;32:323&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mimin&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;32:332&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mavg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;32:340&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;msum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;32:348&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mcount&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;32:358&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mstd&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;32:366&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mvar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;32:374&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mrank&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;32:383&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mcorr&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;32:392&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mcovar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;32:402&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mbeta&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;32:412&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mmed&lt;/codeph&gt;。在下例中，经过优化的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;32:429&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mavg&lt;/codeph&gt;函数的性能超过对每一个窗口使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;32:450&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;avg&lt;/codeph&gt;函数300倍。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;n = 10000000 a = rand(1.0, n) window = 60 //对每一个窗口分别使用avg计算： timer moving(avg, a, window); Time elapsed: 4039.23 ms //采用mavg函数批量计算： timer mavg(a, window); Time elapsed: 12.968 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;50:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;向量化编程也有其局限性。首先，不是所有的操作都可以用向量化计算来完成。在机器学习和统计分析中，在某些场景下，只能对逐行数据进行迭代处理，无法向量化计算。对于这种场景，可使用DolphinDB的JIT（即时编译）版本，将用for语句编写的逐行处理代码在运行时动态编译成机器码执行，从而显著提升性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;52:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;其次，向量化计算通常要将整个向量全部加载到一段连续内存中，Matlab和R都有这样的要求。有时候因为内存碎片原因，无法找到大段的连续内存。DolphinDB针对内存碎片，特别引入了big array，可以将物理上不连续的内存块组成一个逻辑上连续的向量。系统是否采用big array是动态决定的，对用户透明。通常，对big array进行扫描，性能损耗对于连续内存而言，在1%~5%之间；对big array进行随机访问，性能损耗在20%~30%左右。在此方面，DolphinDB是以可以接受的少量性能损失来换取系统的更高可用性。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;sql编程sql-programming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL编程(SQL Programming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL是一个面向问题的语言。用户只需要给出问题的描述，SQL引擎会产生结果。通常SQL引擎属于数据库的一部分，其它系统通过JDBC，ODBC或Native API 与数据库交流。DolphinDB脚本语言的SQL语句不仅支持SQL的标准功能，而且为大数据的分析，尤其是时间序列大数据的分析做了很多扩展，可极大简化代码，方便用户使用。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;sql与编程语言的融合&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL与编程语言的融合&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在DolphinDB中，脚本语言与SQL语言是无缝融合在一起的。这种融合主要体现在几个方面：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL语句是DolphinDB语言的一个子集，一种表达式。SQL语句可以直接赋给一个变量或作为一个函数的参数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL语句中可以使用上下文中的创建的变量和函数。如果SQL语句涉及到分布式表，这些变量和函数会自动序列化到相应的节点。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL语句不再是一个简单的字符串，而是可以动态生成的代码。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;64:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL语句不仅可以对数据表（table）进行操作，也可对其它数据结构如scalar，vector，matrix，set，dictionary进行操作。数据表可以与其它数据结构进行转换。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;66:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;请注意，DolphinDB编程语言区分大小写。在DolphinDB中所有的SQL关键词均必须使用小写。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;下面例子中，首先生成一个员工工资表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;empWages = table(take(1..10, 100) as id, take(2017.10M + 1..10, 100).sort() as month, take(5000 5500 6000 6500, 100) as wage); &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;然后计算给定的一组员工的平均工资。员工列表存储在一个本地变量empIds中。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;empIds = 3 4 6 7 9 select avg(wage) from empWages where id in empIds group by id; id avg_wage -- -------- 3 5500 4 6000 6 6000 7 5500 9 5500&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;除计算平均工资外，同时显示员工的姓名。员工姓名使用一个字典empName来获取。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;empNames = dict(1..10, `Alice`Bob`Jerry`Jessica`Mike`Tim`Henry`Anna`Kevin`Jones) select empNames[first(id)] as name, avg(wage) from empWages where id in empIds group by id; id name avg_wage -- ------- -------- 3 Jerry 5500 4 Jessica 6000 6 Tim 6000 7 Henry 5500 9 Kevin 5500&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;上面的两个例子中，SQL语句的where子句和select子句分别用到了上下文中定义的数组和字典，使得本来需要通过子查询和多表联结来解决的问题，通过简单的hash table就解决了。如果SQL涉及到分布式数据库，这些上下文变量会自动序列化到相应的节点。这不仅让代码看上去更简洁，有更好的可读性，而且提升了性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL的select语句返回的数据表可以直接赋给一个本地变量，做进一步的处理分析。DolphinDB还引入了exec关键词，与select相比，EXEC语句返回的结果可以是一个matrix，vector或scalar，更便于数据分析。下面的例子中，exec与pivot by配合使用，直接返回一个矩阵。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;106:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;exec first(wage) from empWages pivot by month, id; 1 2 3 4 5 6 7 8 9 10 ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- 2017.11M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500 2017.12M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500 2018.01M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500 2018.02M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500 2018.03M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500 2018.04M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500 2018.05M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500 2018.06M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500 2018.07M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500 2018.08M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;对面板数据panel-data的友好支持&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;对面板数据(Panel Data)的友好支持&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL的group by子句将数据分成多组，每组产生一个值，也就是一行。因此使用group by子句后，行数一般会大大减少。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在对面板数据进行分组后，每一组数据通常是时间序列数据，譬如按股票分组，每一个组内的数据是一个股票的价格序列。处理面板数据时，有时候希望保持每个组的数据行数，也就是为组内的每一行数据生成一个值。例如，根据一个股票的价格序列生成回报序列，或者根据价格序列生成一个移动平均价格序列。其它数据库系统（例如SQL Server，PostGreSQL），用窗口函数(window function)来解决这个问题。DolphinDB引入了context by子句来处理面板数据。context by与窗口函数相比，除了语法更简洁，设计更系统化（与group by和pivot by一起组成对分组数据处理的三个子句）以外，表达能力上也更强大，具体表现在下面三个方面：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;129:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;不仅能与select配合在查询中使用，也可以与update配合更新数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;130:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;绝大多数数据库系统在窗口函数中只能使用表中现有的字段分组。context by子句可以使用任何现有字段和计算字段。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;窗口函数仅限于少数几个函数。context by不仅不限制使用的函数，而且可以使用任意表达式，譬如多个函数的组合。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;context by可以与having子句配合使用，以过滤每个组内部的行。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;假定trades数据表记录了每个股票每天的日终价格，可以使用context by子句方便的计算每个股票每天的回报以及每天的排名。首先按股票代码进行分组，计算每个股票每天的回报。这里假设每个股票的数据是时间顺序排列的。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;136:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;update trades set ret = ratios(price) - 1.0 context by symbol;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;按日期进行分组，计算每天每个股票的回报降序排名：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;select date, symbol, ret, rank(ret, false) + 1 as rank from trades where isValid(ret) context by date;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;选择每天回报排名前10的股票：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;select date, symbol, ret from trades where isValid(ret) context by date having rank(ret, false) &amp;lt; 10;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;下面我们以一个更为复杂的实际例子演示context by子句如何高效的解决面板数据问题。一篇论文 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;http://www.followingthetrend.com/?mdocs-file=3424&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;152:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;?ditaot usertext?&gt;101 Formulaic Alphas&lt;/xref&gt;介绍了华尔街的顶级量化对冲基金WorldQuant所使用的101个量化Alpha因子。某基金公司用C#来计算这些因子，其中代表性的98号因子既用到了纵向时间序列数据的多个指标的嵌套，又用到了横向截面数据的排序信息，实现使用了几百行代码。使用中国股市3000多个股票10年近9百万行的历史数据，计算98号Alpha因子耗时约30分钟。而改用DolphinDB实现，如下图所示只用了4行核心代码，耗时仅2秒钟，达到了接近三个数量级的性能提升。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def alpha98(stock){ t = select code, valueDate, adv5, adv15, open, vwap from stock order by valueDate update t set rank_open = rank(open), rank_adv15 = rank(adv15) context by valueDate update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by code return select code, valueDate, rank(decay7)-rank(decay8) as A98 from t context by valueDate }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;对时间序列数据的友好支持&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;对时间序列数据的友好支持&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB的数据库采用列式数据存储，计算的时候又采用向量化的编程，对时间序列数据天然友好。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持不同精度的时间类型。可以通过SQL语句方便的将高频数据转换成不同精度的低频数据，例如秒级、分钟级、小时级, 也可以通过&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;167:73&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;bar&lt;/codeph&gt;函数和group by子句的配合使用，转换成任意时间间隔的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持对时间序列数据的序列关系进行建模，包括领先（lead），滞后（lag），滑动窗口（sliding window），累积窗口（cumulative window）等。更重要的是在这类建模中用到的常用指标和函数，DolphinDB都做了优化，性能优于其它系统1~2个数量级。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB提供了专门为时间序列设计的高效而常用的表联结方式：asof join和window join。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;171:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;我们以一个简单的例子来解释window join。譬如要统计一组人员在某些时间点前三个月的平均工资。我们可以简单的用window join（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;171:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;wj&lt;/codeph&gt;）来实现。window join函数的具体解释请参考用户手册。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;p = table(1 2 3 as id, 2018.06M 2018.07M 2018.07M as month) s = table(1 2 1 2 1 2 as id, 2018.04M + 0 0 1 1 2 2 as month, 4500 5000 6000 5000 6000 4500 as wage) select * from wj(p, s, -3:-1,&amp;lt;avg(wage)&amp;gt;,`id`month) id month avg_wage -- -------- ----------- 1 2018.06M 5250 2 2018.07M 4833.333333 3 2018.07M &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;上面的问题，在其它数据库系统中，可以使用equal join（id字段）和 non-equal join（month字段），以及group by子句来解决。但除了写法更为复杂外，与DolphinDB的window join相比，其它系统性能落后两个数量级以上。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;188:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;window join在金融领分析领域有着广泛的应用。一个经典的应用就是将交易（trades）表和报价（quotes）表进行关联，计算交易成本。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;190:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;以下为交易表（trades），不分区或者按日期和股票代码分区：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sym date time price qty ---- ---------- ------------ ------ --- IBM 2018.06.01 10:01:01.005 143.19 100 MSFT 2018.06.01 10:01:04.006 107.94 200&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;以下为报价表（quotes），不分区或者按日期和股票代码分区：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sym date time bid ask bidSize askSize ---- ---------- ------------ ------ ------ ------- ------- IBM 2018.06.01 10:01:01.006 143.18 143.21 400 200 MSFT 2018.06.01 10:01:04.010 107.92 107.97 800 100&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;208:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用asof join为每一个交易找到最近的一个报价，并利用报价的中间价作为交易成本的基准：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;dateRange = 2018.05.01 : 2018.08.01 select sum(abs(price - (bid+ask)/2.0)*qty)/sum(price*qty) as cost from aj(trades, quotes, `date`sym`time) where date between dateRange group by sym;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用window join为每一个交易找到前10毫秒的报价，计算平均中间价作为交易成本的基准：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;select sum(abs(price - mid)*qty)/sum(price*qty) as cost from pwj(trades, quotes, -10:0, &amp;lt;avg((bid + ask)/2.0) as mid&amp;gt;,`date`sym`time) where date between dateRange group by sym;&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;sql的其它扩展&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;221:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;221:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;SQL的其它扩展&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;221:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;223:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;为满足大数据分析的要求，DolphinDB对SQL还做了很多其他扩展。这儿我们例举一些常用功能。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;用户自定义的函数无需编译、打包和部署，即可在本节点或分布式环境的SQL中使用此函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;如5.4节所示，DolphinDB中的SQL与分布式计算框架紧密集成，实现库内计算（in-database analytics）变得更加便捷和高效。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持组合字段（composite column），可将复杂分析函数的多个返回值输出到数据表的一行。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;如果要在SQL语句中使用组合字段，函数的输出结果必须是简单的键值对（key-value pair)或者数组。如果不是这两种类型，可以用自定义函数进行转换。组合字段的详细用法请参考用户手册。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;factor1=3.2 1.2 5.9 6.9 11.1 9.6 1.4 7.3 2.0 0.1 6.1 2.9 6.3 8.4 5.6 factor2=1.7 1.3 4.2 6.8 9.2 1.3 1.4 7.8 7.9 9.9 9.3 4.6 7.8 2.4 8.7 t=table(take(1 2 3, 15).sort() as id, 1..15 as y, factor1, factor2);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;为每个id运行ols，y = alpha + beta1 * factor1 + beta2 * factor2, 输出参数alpha, beta1, beta2。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;238:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;select ols(y, [factor1,factor2], true, 0) as `alpha`beta1`beta2 from t group by id; id alpha beta1 beta2 -- --------- --------- --------- 1 1.063991 -0.258685 0.732795 2 6.886877 -0.148325 0.303584 3 11.833867 0.272352 -0.065526&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;248:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在输出参数的同时，输出R2。使用自定义函数包装输出结果。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;250:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def myols(y,x){ r=ols(y,x,true,2) return r.Coefficient.beta join r.RegressionStat.statistics[0] } select myols(y,[factor1,factor2]) as `alpha`beta1`beta2`R2 from t group by id; id alpha beta1 beta2 R2 -- --------- --------- --------- -------- 1 1.063991 -0.258685 0.732795 0.946056 2 6.886877 -0.148325 0.303584 0.992413 3 11.833867 0.272352 -0.065526 0.144837&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;命令式编程imperative-programming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;命令式编程(Imperative Programming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;266:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB与主流的脚本语言（Python和JavaScript等）和编译型强类型语言（C++，C和Java）一样，支持命令式编程，即一步一步告诉计算机先做什么再做什么。DolphinDB目前支持18种语句（详细参考用户手册第五章），包括最常用的赋值语句，分支语句if..else，以及循环语句for和do..while等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;268:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持对单变量和多变量进行赋值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;x = 1 2 3 y = 4 5 y += 2 x, y = y, x //swap the value of x and y x, y =1 2 3, 4 5&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;278:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB目前支持的循环语句包括for语句和do..while语句。for语句的循环体可以包括数据对（pair）（左闭右开区间）、数组（vector）、矩阵（matrix）和表（table）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;280:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;1到100累加求和：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;282:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;s = 0 for(x in 1:101) s += x print s&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;数组中的元素求和：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;s = 0; for(x in 1 3 5 9 15) s += x print s&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;打印矩阵每一列的均值：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;m = matrix(1 2 3, 4 5 6, 7 8 9) for(c in m) print c.avg()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;303:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;计算数据表中每一个行两列之乘积：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;t= table([&#34;TV set&#34;, &#34;Phone&#34;, &#34;PC&#34;] as productId, 1200 600 800 as price, 10 20 7 as qty) for(row in t) print row.productId + &#34;: &#34; + row.price * row.qty&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;310:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB的分支语句if..else与其它语言一致。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;311:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;if(condition){ &amp;lt;true statements&amp;gt; } else{ &amp;lt;false statements&amp;gt; }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;对处理海量数据时，不推荐利用控制语句（for语句，if..else语句）对数据逐行处理。这些控制语句一般用于上层模块的处理和调度，比较底层的数据处理模块建议使用向量编程，函数编程，SQL编程等方式来处理。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;函数化编程functional-programming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;函数化编程(Functional Programming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持函数式编程的大部分功能，包括：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;纯函数（pure function）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;自定义函数（user-defined function，或简称udf）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;lambda函数&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;328:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;高阶函数（higher order function）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;部分应用（partial application）&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;详细请参考用户手册第七章。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;自定义函数和lambda函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;自定义函数和lambda函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;335:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB中可以创建自定义函数，函数可以有名称或者没有名称（通常是lambda函数）。创建的函数符合纯函数的要求，也就是说只有函数的输入参数可以影响函数的输出结果。DolphinDB与Python不同，函数体内只能引用函数参数和函数内的局部变量，不能使用函数体外定义的变量。从软件工程的角度看，这牺牲了一部分语法糖的灵活性，但对提高软件质量大有裨益。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;337:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def getWeekDays(dates){ return dates[def(x):weekday(x) between 1:5] } getWeekDays(2018.07.01 2018.08.01 2018.09.01 2018.10.01) [2018.08.01, 2018.10.01] &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;346:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;上面的例子中，我们定义了一个函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;346:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;getWeekDays&lt;/codeph&gt;，该函数接受一组日期，返回其在周一和周五之间的日期。函数的实现采用了向量的过滤功能，也就是接受一个布尔型单目函数用于数据的过滤。我们定义了一个lambda函数用于数据过滤。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;高阶函数higher-order-function&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;高阶函数(Higher Order Function)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;高阶函数是指可以接受另一个函数作为参数的函数。在DolphinDB中，高阶函数主要用作数据处理的模板函数，通常第一个参数是另外一个函数，用于具体的数据处理。譬如说，A对象有m个元素，B对象有n个元素，一种常见的处理模式是，A中的任意一个元素和B中的任意一个元素两两计算，最后产生一个m*n的矩阵。DolphinDB将这种数据处理模式抽象成一个高阶函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;350:176&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;cross&lt;/codeph&gt;。DolphinDB提供了很多类似的高阶函数，包括&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;350:208&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;all&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;350:214&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;any&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;350:220&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;350:227&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;loop&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;350:234&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eachLeft&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;350:245&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eachRight&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;350:257&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eachPre&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;350:267&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eachPost&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;350:278&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;accumulate&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;350:291&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;reduce&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;350:300&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;groupby&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;350:310&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;contextby&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;350:322&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pivot&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;350:330&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;cross&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;350:338&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;moving&lt;/codeph&gt;，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;350:347&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rolling&lt;/codeph&gt;等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;下面的一个例子我们使用三个高阶函数，只用三行代码，根据股票日内tick级别的交易数据，计算出每两只股票之间的相关性。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;模拟生成10000000个数据点（股票代码，交易时间和价格）：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;n=10000000 syms = rand(`FB`GOOG`MSFT`AMZN`IBM, n) time = 09:30:00.000 + rand(21600000, n) price = 500.0 + rand(500.0, n)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;363:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;利用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;363:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pivot&lt;/codeph&gt;函数生成股价透视矩阵，每列为一支股票，每行为一分钟：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;365:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;priceMatrix = pivot(avg, price, time.minute(), syms)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each&lt;/codeph&gt;和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;369:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;ratios&lt;/codeph&gt;函数配合使用，对股价矩阵每列进行操作，将股价转为收益率：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:28;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;retMatrix = each(ratios, priceMatrix) - 1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;cross&lt;/codeph&gt;和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;375:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corr&lt;/codeph&gt;函数配合使用，计算每两支股票收益率的相关性：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:29;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corrMatrix = cross(corr, retMatrix, retMatrix)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;结果为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:30;382:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt; AMZN FB GOOG IBM MSFT --------- --------- --------- --------- --------- AMZN|1 0.015181 -0.056245 0.005822 0.084104 FB |0.015181 1 -0.028113 0.034159 -0.117279 GOOG|-0.056245 -0.028113 1 -0.039278 -0.025165 IBM |0.005822 0.034159 -0.039278 1 -0.049922 MSFT|0.084104 -0.117279 -0.025165 -0.049922 1&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;部分应用partial-application&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;部分应用(Partial Application)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;394:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;部分应用指当一个函数的一部分或全部参数给定后生成一个新的函数。在DolphinDB中，函数调用使用圆括号()，部分应用使用{}。3.2节中的例子用到的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;394:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;ratios&lt;/codeph&gt;函数的具体实现就是高阶函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;394:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eachPre&lt;/codeph&gt;的一个部分应用 eachPre。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;以下两行代码同构：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:31;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;retMatrix = each(ratios, priceMatrix) - 1 retMatrix = each(eachPre{ratio}, priceMatrix) - 1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;403:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;部分应用经常用于高阶函数。使用高阶函数时，通常对某些参数有特定要求，通过部分应用，可以确保所有参数符合要求。例如，计算一个向量a与一个矩阵m中的每一列的相关性，可以将函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;403:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corr&lt;/codeph&gt;与高阶函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;403:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each&lt;/codeph&gt;配合使用。但是若直接将向量与矩阵在&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;403:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each&lt;/codeph&gt;中列为&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;403:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corr&lt;/codeph&gt;的参数，系统将会试图计算向量的某个元素与矩阵的某个列的相关性，导致产生错误。这时，可利用部分应用把函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;403:186&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corr&lt;/codeph&gt;与向量a组成一个新的函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;403:204&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;corr{a}&lt;/codeph&gt;，再与高阶函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;403:220&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each&lt;/codeph&gt;配合使用于矩阵的每一列，如下例所示。我们也可以利用for语句来解决这个问题，但代码冗长且增加耗时。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:32;405:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;a = 12 14 18 m = matrix(5 6 7, 1 3 2, 8 7 11)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;410:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用each和部分应用计算向量a与矩阵中的每一列的相关性：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:33;412:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;each(corr{a}, m)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用for语句解决上述问题：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:34;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;cols = m.columns() c = array(DOUBLE, cols) for(i in 0:cols) c[i] = corr(a, m[i])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;425:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;部分应用的另一个妙用是使函数保持状态。通常我们希望函数是无状态的，即函数的输出结果完全是由输入参数决定的。但有时候我们希望函数是有“状态”的。譬如说，在流计算中，用户通常需要给定一个消息处理函数（message handler），接受一条新的信息后返回一个结果。如果我们希望消息处理函数返回的是迄今为止所有接收到的数据的平均数，可以通过部分应用来解决。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:35;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def cumulativeAverage(mutable stat, newNum){ stat[0] = (stat[0] * stat[1] + newNum)/(stat[1] + 1) stat[1] += 1 return stat[0] } msgHandler = cumulativeAverage{0.0 0.0} each(msgHandler, 1 2 3 4 5) [1,1.5,2,2.5,3]&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;远程过程调用编程rpc-programming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;远程过程调用编程(RPC Programming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;远程过程调用（Remote Procedure Call）是分布式系统最常用的基础设施之一。DolphinDB的分布式文件系统实现，分布式数据库实现，分布式计算框架实现都采用了&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;442:89&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB自己设计&lt;/codeph&gt;的RPC系统。DolphinDB的脚本语言通过RPC可以在远程机器上执行代码。DolphinDB在使用RPC时有以下特点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;443:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;不仅可以执行在远程机器上已经注册的函数，也可以将本地自定义的函数序列化到远程节点执行。在远程机器运行代码时的权限等同于当前登录用户在本地的权限。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;函数的参数既可以是常规的scalar，vector，matrix，set，dictionary和table，也可以是函数包括自定义的函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;既可以使用两个节点之间的独占连接，也可以使用集群数据节点之间的共享连接。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;使用remoterun执行远程函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用remoteRun执行远程函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;449:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;xdb&lt;/codeph&gt;创建一个到远程节点的连接。远程节点可以是任何运行DolphinDB的节点，不必属于当前集群的一部分。创建连接之后可以在远程节点上执行远程节点上注册的函数或本地自定义的函数。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:36;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;h = xdb(&#34;localhost&#34;, 8081);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;454:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在远程节点上执行一段脚本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:37;456:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;remoteRun(h, &#34;sum(1 3 5 7)&#34;); 16&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;460:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;上述远程调用也可以简写成：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:38;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;h(&#34;sum(1 3 5 7)&#34;); 16&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;467:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在远程节点上执行一个在远程节点注册的函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:39;469:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;h(&#34;sum&#34;, 1 3 5 7); 16&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;474:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在远程系节点上执行本地的自定义函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:40;476:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def mysum(x) : reduce(+, x) h(mysum, 1 3 5 7); 16&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;482:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在远程节点（localhost:8081）上创建一个共享表sales：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:41;484:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;h(&#34;share table(2018.07.02 2018.07.02 2018.07.03 as date, 1 2 3 as qty, 10 15 7 as price) as sales&#34;);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;如果本地的自定义函数有依赖，所依赖的自定义函数会自动序列化到远程节点：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:42;489:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;defg salesSum(tableName, d): select mysum(price*qty) from objByName(tableName) where date=d h(salesSum, &#34;sales&#34;, 2018.07.02); 40&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;使用rpc执行远程函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用rpc执行远程函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;497:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB使用远程过程调用功能的另一个途径是&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;497:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;函数。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;497:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;函数接受远程节点的名称，需要执行的函数定义以及需要的参数。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;497:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;只能在同一个集群内的控制节点及数据节点之间使用，但是不需要创建一个新的连接，而是复用已经存在的网络连接。这样做的好处是可以节约网络资源和免去创建新连接带来的延迟。当节点的用户很多时，这一点非常有意义。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;497:174&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;函数只能在远程节点执行一个函数。如果要运行脚本，请把脚本封装在一个自定义函数内。 下面的例子必须在一个DolphinDB集群内使用。nodeB是远程节点的别名，nodeB上已经有共享表sales。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:43;500:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc(&#34;nodeB&#34;, salesSum, &#34;sales&#34;,2018.07.02); 40&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;505:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;在使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;505:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;时，为增加代码的可读性，建议使用部分应用，将函数参数和函数定义写在一起，形成一个新的零参数的函数定义。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:44;507:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc(&#34;nodeB&#34;, salesSum{&#34;sales&#34;, 2018.07.02}); 40&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;511:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;master是控制节点的别名。DolphinDB只能在控制节点上创建用户：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:45;513:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc(&#34;master&#34;, createUser{&#34;jerry&#34;, &#34;123456&#34;});&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;517:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;517:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;函数需要的参数也可以是另外一个函数包括内置函数和自定义函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:46;519:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc(&#34;nodeB&#34;, reduce{+, 1 2 3 4 5}); 15&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;使用其它函数间接执行远程函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用其它函数间接执行远程函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;remoteRun&lt;/codeph&gt;和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;526:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;都可以在一个远程节点上执行用户在本地自定义的函数。这是DolphinDB的RPC子系统与其它RPC系统最大的不同之处。在其它系统中，通常RPC的客户端只能被动调用远程节点已经暴露的注册函数。在大数据分析领域，数据科学家根据新的研发项目经常会提出新的接口需求。如果等待IT部门发布新的API接口，通常需要很长的周期，这会严重影响研发的效率和周期。如果要在远程节点执行自定义的函数，自定义的函数目前必须使用DolphinDB的脚本来开发。另外，对数据的安全性也提出了更高的要求，必须仔细规划和设置用户的访问权限。如果限制用户只能使用注册的函数，用户的访问权限管理可以十分的简单，只要拒绝外部用户访问一切数据，授权外部用户访问注册的视图函数就可以了。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;528:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;除了直接使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;528:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;remoteRun&lt;/codeph&gt;和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;528:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;函数外，DolphinDB也提供了很多函数间接的使用远程过程调用。例如，在分布式数据库的线性回归就用到了&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;528:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;rpc&lt;/codeph&gt;与&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:64;528:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;olsEx&lt;/codeph&gt;。另外，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:65;528:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pnodeRun&lt;/codeph&gt;用于在集群的多个节点上并行运行同一个函数，并将返回的结果合并。这在集群的管理中十分有用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;每个数据节点返回最近的10个正在运行或已经完成的批处理作业：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:47;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pnodeRun(getRecentJobs{10});&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;536:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;返回节点nodeA和nodeB的最近10个SQL query：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:48;538:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pnodeRun(getCompletedQueries{10}, `nodeA`nodeB);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;清除所有数据节点上的缓存：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:49;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;pnodeRun(clearAllCache);&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;分布式计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;分布式计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;550:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:66;550:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mr&lt;/codeph&gt;用于开发基于MapReduce的分布式计算；&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:67;550:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;imr&lt;/codeph&gt;用于开发基于迭代的MapReduce的分布式计算。用户只需要指定分布式数据源和核心函数，譬如map函数，reduce函数，final函数等。下面我们演示使用分布式数据计算中位数和线性回归的例子。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:50;552:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;n=10000000 x1 = pow(rand(1.0,n), 2) x2 = norm(3.0, 1.0, n) y = 0.5 + 3 * x1 - 0.5*x2 + norm(0.0, 1.0, n) t=table(rand(10, n) as id, y, x1, x2) login(`admin,&#34;123456&#34;) db = database(&#34;dfs://testdb&#34;, VALUE, 0..9) db.createPartitionedTable(t, &#34;sample&#34;, &#34;id&#34;).append!(t)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;564:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;利用自定义的map函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:68;564:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;myOLSMap&lt;/codeph&gt;，内置的reduce函数（+），自定义的final函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:69;564:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;myOLSFinal&lt;/codeph&gt;，以及内置的map-reduce框架函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:70;564:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;mr&lt;/codeph&gt;，构建一个在分布式数据源上运行线性回归的函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:71;564:107&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;myOLSEx&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:51;566:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def myOLSMap(table, yColName, xColNames){ x = matrix(take(1.0, table.rows()), table[xColNames]) xt = x.transpose(); return xt.dot(x), xt.dot(table[yColName]) } def myOLSFinal(result){ xtx = result[0] xty = result[1] return xtx.inv().dot(xty)[0] } def myOLSEx(ds, yColName, xColNames){ return mr(ds, myOLSMap{, yColName, xColNames}, +, myOLSFinal) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;584:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用用户自定义的分布式算法和分布式数据源计算线性回归系数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:52;586:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sample = loadTable(&#34;dfs://testdb&#34;, &#34;sample&#34;) myOLSEx(sqlDS(&amp;lt;select * from sample&amp;gt;), `y, `x1`x2); [0.4991, 3.0001, -0.4996]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;592:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用内置的函数ols和未分的数据计算线性回归的系数，得到相同的结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:53;594:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;ols(y, [x1,x2],true); [0.4991, 3.0001, -0.4996]&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;598:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;下面这个例子中，我们构造一个算法，在分布式数据源上计算一组数据的近似中位数。算法的基本原理是利用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:72;598:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;bucketCount&lt;/codeph&gt;函数，在每一个节点上分别计算一组内的数据个数，然后把各个节点上的数据累加。这样我们可以找到中位数应该落在哪个区间内。如果这个区间不够小，进一步细分这个区间，直到小于给定的精度要求。中位数的算法需要多次迭代，我们因此使用了迭代计算框架&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:73;598:178&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;imr&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:54;600:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def medMap(data, range, colName): bucketCount(data[colName], double(range), 1024, true) def medFinal(range, result){ x= result.cumsum() index = x.asof(x[1025]/2.0) ranges = range[1] - range[0] if(index == -1) return (range[0] - ranges*32):range[1] else if(index == 1024) return range[0]:(range[1] + ranges*32) else{ interval = ranges / 1024.0 startValue = range[0] + (index - 1) * interval return startValue : (startValue + interval) } } def medEx(ds, colName, range, precision){ termFunc = def(prev, cur): cur[1] - cur[0] &amp;lt;= precision return imr(ds, range, medMap{,,colName}, +, medFinal, termFunc).avg() }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;624:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用以上近似中位数算法，计算分布式数据的中位数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:55;626:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sample = loadTable(&#34;dfs://testdb&#34;, &#34;sample&#34;) medEx(sqlDS(&amp;lt;select y from sample&amp;gt;), `y, 0.0 : 1.0, 0.001); -0.052973&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;632:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用内置的med函数计算未分区的数据的中位数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:56;634:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;med(y); -0.052947&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;元编程metaprogramming&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;元编程(Metaprogramming)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;元编程指使用程序代码来创建可以动态运行的程序代码。元编程的目的一般是延迟执行代码或动态创建代码。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;643:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB支持使用元编程来动态创建表达式，譬如函数调用的表达式，SQL查询表达式。很多业务细节无法在编码阶段确定。譬如说客户定制报表，只有运行时，客户选择了表格，字段和字段格式，才可以确定一个完整的SQL查询表达式。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;645:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;延迟执行代码一般分为这几种情况：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;646:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;646:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;提供一个回调函数&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;647:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;延迟执行为整体优化创造条件&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;648:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;问题描述在程序编码阶段完成，但是问题实现在程序运行阶段完成&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;650:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB实现元编程的途径有两个，一是使用一对尖括号&amp;lt;&amp;gt;来表示需要延后执行的动态代码，二是使用函数来创建各种表达式。常用的用于元编程的函数包括&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:74;650:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;objByName&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:75;650:89&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sqlCol&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:76;650:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sqlColAlias&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:77;650:114&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;sql&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:78;650:121&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;expr&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:79;650:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;eval&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:80;650:137&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;partial&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:81;650:148&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;makeCall&lt;/codeph&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;652:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用&amp;lt;&amp;gt;来生成延后执行的动态表达式：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:57;654:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;a = &amp;lt;1 + 2 * 3&amp;gt; a.typestr(); CODE a.eval(); 7&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;使用函数来生成延后执行的动态表达式：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:58;665:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;a = expr(1, +, 2, *, 3) a.typestr(); CODE a.eval(); 7&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;674:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;可使用元编程来定制报表。用户的输入包括数据表，字段名称和字段相应的格式字符串。下例中，根据输入的数据表，字段名称和格式，以及过滤条件，动态生成SQL表达式并执行。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:59;676:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;def generateReport(tbl, colNames, colFormat, filter){ colCount = colNames.size() colDefs = array(ANY, colCount) for(i in 0:colCount){ if(colFormat[i] == &#34;&#34;) colDefs[i] = sqlCol(colNames[i]) else colDefs[i] = sqlCol(colNames[i], format{,colFormat[i]}) } return sql(colDefs, tbl, filter).eval() }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;模拟生成一个100行的数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:60;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;t = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;695:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;输入过滤条件，字段和格式，定制报表。过滤条件使用了元编程。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:61;696:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;generateReport(t, [&#34;id&#34;,&#34;date&#34;,&#34;price&#34;,&#34;qty&#34;], [&#34;000&#34;,&#34;MM/dd/yyyy&#34;, &#34;00.00&#34;, &#34;#,###&#34;], &amp;lt; id&amp;lt;5 or id&amp;gt;95 &amp;gt;); id date price qty --- ---------- ----- ----- 001 01/02/2018 50.27 2,886 002 01/03/2018 30.85 1,331 003 01/04/2018 17.89 18 004 01/05/2018 51.00 6,439 096 04/07/2018 57.73 8,339 097 04/08/2018 47.16 2,425 098 04/09/2018 27.90 4,621 099 04/10/2018 31.55 7,644 100 04/11/2018 46.63 8,383&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;712:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB的一些内置函数的参数需要使用元编程。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:82;712:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;窗口连接（window join）&lt;/codeph&gt;中，需要为右表的窗口数据集指定一个或多个聚合函数以及这些函数运行时需要的参数。由于问题的描述和执行在两个不同的阶段，我们采用元编程来实现延后执行。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:62;714:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;t = table(take(`ibm, 3) as sym, 10:01:01 10:01:04 10:01:07 as time, 100 101 105 as price) q = table(take(`ibm, 8) as sym, 10:01:01+ 0..7 as time, 101 103 103 104 104 107 108 107 as ask, 98 99 102 103 103 104 106 106 as bid) wj(t, q, -2 : 1, &amp;lt; [max(ask), min(bid), avg((bid+ask)*0.5) as avg_mid]&amp;gt;, `time); sym time price max_ask min_bid avg_mid --- -------- ----- ------- ------- ------- ibm 10:01:01 100 103 98 100.25 ibm 10:01:04 101 104 99 102.625 ibm 10:01:07 105 108 103 105.625&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;726:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB中另一个使用元编程的内置功能是更新内存分区表。当然内存分区表的更新，删除，排序等功能也可以通过SQL语句来完成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;728:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;创建一个以日期为分区的内存分区数据库，并模拟生成trades表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:63;730:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;db = database(&#34;&#34;, VALUE, 2018.01.02 2018.01.03) date = 2018.01.02 2018.01.02 2018.01.02 2018.01.03 2018.01.03 2018.01.03 t = table(`IBM`MSFT`GOOG`FB`IBM`MSFT as sym, date, 101 103 103 104 104 107 as price, 0 99 102 103 103 104 as qty) trades = db.createPartitionedTable(t, &#34;trades&#34;, &#34;date&#34;).append!(t);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;737:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;删除qty为0的记录，并在每个分区中按交易量进行升序排序：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:64;739:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;trades.erase!(&amp;lt;qty=0&amp;gt;).sortBy!(&amp;lt;price*qty&amp;gt;);&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;增加一个新的字段logPrice：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:65;745:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;trades[`logPrice]=&amp;lt;log(price)&amp;gt;;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;749:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;更新股票IBM的交易数量：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:66;751:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;trades[`qty, &amp;lt;sym=`IBM&amp;gt;]=&amp;lt;qty+100&amp;gt;;&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;小结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;755:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;755:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;小结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;755:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;757:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hybrid_programming_paradigms.md&#34;&gt;DolphinDB是一门为数据分析而生的编程语言。DolphinDB支持向量化计算和分布式计算，具有极快的运行速度。与其它数据分析语言Matlab，SAS，pandas等不同，DolphinDB与分布式数据库和分布式计算紧密集成，天生具备处理海量数据的能力。DolphinDB支持SQL编程，函数化编程和元编程，语言简洁灵活，表达能力强，大大提高了数据科学家的开发效率。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/hybrid_programming_paradigms.md"/><meta name="wh-out-relpath" content="tutorials/hybrid_programming_paradigms.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="多范式编程" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="多范式编程"><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html">多范式编程</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem" class="active"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">多范式编程</h1><div class="- topic/body body"><p class="- topic/p p">开发大数据应用，不仅需要一个能支撑海量数据的分布式数据库，一个能高效利用多核多节点的分布式计算框架，更需要一门能与分布式数据库和分布式计算有机融合，高性能易扩展，表达能力强，满足快速开发和建模需要的编程语言。DolphinDB从流行的SQL和Python语言汲取了灵感，设计了大数据处理脚本语言。本教程讲解如何通过混合范式编程，快速开发大数据分析的应用。从中你也可以了解DolphinDB的编程语言（以下简称DolphinDB）如何与数据库和分布式计算融合。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="向量化编程vector-programming"><h2 class="- topic/title title topictitle2" id="ariaid-title2">向量化编程(Vector Programming)</h2><div class="- topic/body body"><p class="- topic/p p">向量化编程是 DolphinDB 中最基本的编程范式。DolphinDB中绝大部分函数支持向量作为函数的输入参数。根据函数的返回值的不同，函数可分为两种：一种是聚合函数（aggregate function），返回标量（scalar）；另一种是向量函数，返回与输入向量等长的向量。</p><p class="- topic/p p">向量化操作有三个主要优点：</p><ul class="- topic/ul ul"><li class="- topic/li li">代码简洁</li><li class="- topic/li li">大幅降低脚本语言的解释成本</li><li class="- topic/li li">可对很多算法进行优化</li></ul><p class="- topic/p p">时间序列数据通常可以用一个向量来表示，用于数据分析的列式数据库的每一个列也都可以用向量来表示。DolphinDB作为一个内存计算引擎或者作为一个分析型的数据仓库，在进行时间序列数据分析时，特别适合使用向量化编程。</p><p class="- topic/p p">以两个长度为一千万的向量相加作为一个简单例子。用命令式编程的for语句，不仅语句冗长，而且耗时是向量化编程的百倍以上。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 10000000
a = rand(1.0, n)
b = rand(1.0, n)

//采用for语句编程：
c = array(DOUBLE, n)
for(i in 0 : n)
    c[i] = a[i] + b[i]
    
//采用向量化编程：
c = a + b</code></pre><p class="- topic/p p">向量化编程实际上是对一组同质数据的批处理，不仅在编译阶段可以利用vectorization对指令进行优化，在很多算法上也可以优化。以经常使用的时间序列数据滑动窗口（sliding window）指标之一的移动平均（moving average）为例。假设总的数据量是n，窗口大小为k，如果不采用批量计算，时间复杂度是O(nk)。但是因为计算完一个窗口的移动平均后，计算下一个窗口时，只有一个数据点发生了变化，所以只要调整这一个点的值，就可以算出新窗口的移动平均，所以批量计算的时间复杂度是O(n)。DolphinDB中，大部分计算滑动窗口指标的函数都经过了优化，性能近似于O(n)。这些函数包括<code class="+ topic/ph pr-d/codeph ph codeph">mmax</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mmin</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mimax</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mimin</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mavg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">msum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mcount</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mstd</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mvar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mrank</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mcorr</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mcovar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mbeta</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">mmed</code>。在下例中，经过优化的<code class="+ topic/ph pr-d/codeph ph codeph">mavg</code>函数的性能超过对每一个窗口使用<code class="+ topic/ph pr-d/codeph ph codeph">avg</code>函数300倍。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 10000000
a = rand(1.0, n)
window = 60

//对每一个窗口分别使用avg计算：
timer moving(avg, a, window);

Time elapsed: 4039.23 ms

//采用mavg函数批量计算：
timer mavg(a, window);

Time elapsed: 12.968 ms</code></pre><p class="- topic/p p">向量化编程也有其局限性。首先，不是所有的操作都可以用向量化计算来完成。在机器学习和统计分析中，在某些场景下，只能对逐行数据进行迭代处理，无法向量化计算。对于这种场景，可使用DolphinDB的JIT（即时编译）版本，将用for语句编写的逐行处理代码在运行时动态编译成机器码执行，从而显著提升性能。</p><p class="- topic/p p">其次，向量化计算通常要将整个向量全部加载到一段连续内存中，Matlab和R都有这样的要求。有时候因为内存碎片原因，无法找到大段的连续内存。DolphinDB针对内存碎片，特别引入了big array，可以将物理上不连续的内存块组成一个逻辑上连续的向量。系统是否采用big array是动态决定的，对用户透明。通常，对big array进行扫描，性能损耗对于连续内存而言，在1%~5%之间；对big array进行随机访问，性能损耗在20%~30%左右。在此方面，DolphinDB是以可以接受的少量性能损失来换取系统的更高可用性。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="sql编程sql-programming"><h2 class="- topic/title title topictitle2" id="ariaid-title3">SQL编程(SQL Programming)</h2><div class="- topic/body body"><p class="- topic/p p">SQL是一个面向问题的语言。用户只需要给出问题的描述，SQL引擎会产生结果。通常SQL引擎属于数据库的一部分，其它系统通过JDBC，ODBC或Native API 与数据库交流。DolphinDB脚本语言的SQL语句不仅支持SQL的标准功能，而且为大数据的分析，尤其是时间序列大数据的分析做了很多扩展，可极大简化代码，方便用户使用。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="sql与编程语言的融合"><h3 class="- topic/title title topictitle3" id="ariaid-title4">SQL与编程语言的融合</h3><div class="- topic/body body"><p class="- topic/p p">在DolphinDB中，脚本语言与SQL语言是无缝融合在一起的。这种融合主要体现在几个方面：</p><ul class="- topic/ul ul"><li class="- topic/li li">SQL语句是DolphinDB语言的一个子集，一种表达式。SQL语句可以直接赋给一个变量或作为一个函数的参数。</li><li class="- topic/li li">SQL语句中可以使用上下文中的创建的变量和函数。如果SQL语句涉及到分布式表，这些变量和函数会自动序列化到相应的节点。</li><li class="- topic/li li">SQL语句不再是一个简单的字符串，而是可以动态生成的代码。</li><li class="- topic/li li">SQL语句不仅可以对数据表（table）进行操作，也可对其它数据结构如scalar，vector，matrix，set，dictionary进行操作。数据表可以与其它数据结构进行转换。</li></ul><p class="- topic/p p">请注意，DolphinDB编程语言区分大小写。在DolphinDB中所有的SQL关键词均必须使用小写。</p><p class="- topic/p p">下面例子中，首先生成一个员工工资表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>empWages = table(take(1..10, 100) as id, take(2017.10M + 1..10, 100).sort() as month, take(5000 5500 6000 6500, 100) as wage); </code></pre><p class="- topic/p p">然后计算给定的一组员工的平均工资。员工列表存储在一个本地变量empIds中。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>empIds = 3 4 6 7 9
select avg(wage) from empWages where id in empIds group by id;
id avg_wage
-- --------
3  5500
4  6000
6  6000
7  5500
9  5500</code></pre><p class="- topic/p p">除计算平均工资外，同时显示员工的姓名。员工姓名使用一个字典empName来获取。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>empNames = dict(1..10, `Alice`Bob`Jerry`Jessica`Mike`Tim`Henry`Anna`Kevin`Jones)
select empNames[first(id)] as name, avg(wage) from empWages where id in empIds group by id;
id name    avg_wage
-- ------- --------
3  Jerry   5500
4  Jessica 6000
6  Tim     6000
7  Henry   5500
9  Kevin   5500</code></pre><p class="- topic/p p">上面的两个例子中，SQL语句的where子句和select子句分别用到了上下文中定义的数组和字典，使得本来需要通过子查询和多表联结来解决的问题，通过简单的hash table就解决了。如果SQL涉及到分布式数据库，这些上下文变量会自动序列化到相应的节点。这不仅让代码看上去更简洁，有更好的可读性，而且提升了性能。</p><p class="- topic/p p">SQL的select语句返回的数据表可以直接赋给一个本地变量，做进一步的处理分析。DolphinDB还引入了exec关键词，与select相比，EXEC语句返回的结果可以是一个matrix，vector或scalar，更便于数据分析。下面的例子中，exec与pivot by配合使用，直接返回一个矩阵。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>exec first(wage) from empWages pivot by month, id;

         1    2    3    4    5    6    7    8    9    10
         ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
2017.11M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500
2017.12M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500
2018.01M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500
2018.02M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500
2018.03M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500
2018.04M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500
2018.05M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500
2018.06M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500
2018.07M|5000 5500 6000 6500 5000 5500 6000 6500 5000 5500
2018.08M|6000 6500 5000 5500 6000 6500 5000 5500 6000 6500</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="对面板数据panel-data的友好支持"><h3 class="- topic/title title topictitle3" id="ariaid-title5">对面板数据(Panel Data)的友好支持</h3><div class="- topic/body body"><p class="- topic/p p">SQL的group by子句将数据分成多组，每组产生一个值，也就是一行。因此使用group by子句后，行数一般会大大减少。</p><p class="- topic/p p">在对面板数据进行分组后，每一组数据通常是时间序列数据，譬如按股票分组，每一个组内的数据是一个股票的价格序列。处理面板数据时，有时候希望保持每个组的数据行数，也就是为组内的每一行数据生成一个值。例如，根据一个股票的价格序列生成回报序列，或者根据价格序列生成一个移动平均价格序列。其它数据库系统（例如SQL Server，PostGreSQL），用窗口函数(window function)来解决这个问题。DolphinDB引入了context by子句来处理面板数据。context by与窗口函数相比，除了语法更简洁，设计更系统化（与group by和pivot by一起组成对分组数据处理的三个子句）以外，表达能力上也更强大，具体表现在下面三个方面：</p><ul class="- topic/ul ul"><li class="- topic/li li">不仅能与select配合在查询中使用，也可以与update配合更新数据。</li><li class="- topic/li li">绝大多数数据库系统在窗口函数中只能使用表中现有的字段分组。context by子句可以使用任何现有字段和计算字段。</li><li class="- topic/li li">窗口函数仅限于少数几个函数。context by不仅不限制使用的函数，而且可以使用任意表达式，譬如多个函数的组合。</li><li class="- topic/li li">context by可以与having子句配合使用，以过滤每个组内部的行。</li></ul><p class="- topic/p p">假定trades数据表记录了每个股票每天的日终价格，可以使用context by子句方便的计算每个股票每天的回报以及每天的排名。首先按股票代码进行分组，计算每个股票每天的回报。这里假设每个股票的数据是时间顺序排列的。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>update trades set ret = ratios(price) - 1.0 context by symbol;</code></pre><p class="- topic/p p">按日期进行分组，计算每天每个股票的回报降序排名：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select date, symbol,  ret, rank(ret, false) + 1 as rank from trades where isValid(ret) context by date;</code></pre><p class="- topic/p p">选择每天回报排名前10的股票：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select date, symbol, ret from trades where isValid(ret) context by date having rank(ret, false) &lt; 10;</code></pre><p class="- topic/p p">下面我们以一个更为复杂的实际例子演示context by子句如何高效的解决面板数据问题。一篇论文 <a class="- topic/xref xref" href="http://www.followingthetrend.com/?mdocs-file=3424" target="_blank" rel="external noopener">101 Formulaic Alphas</a>介绍了华尔街的顶级量化对冲基金WorldQuant所使用的101个量化Alpha因子。某基金公司用C#来计算这些因子，其中代表性的98号因子既用到了纵向时间序列数据的多个指标的嵌套，又用到了横向截面数据的排序信息，实现使用了几百行代码。使用中国股市3000多个股票10年近9百万行的历史数据，计算98号Alpha因子耗时约30分钟。而改用DolphinDB实现，如下图所示只用了4行核心代码，耗时仅2秒钟，达到了接近三个数量级的性能提升。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def alpha98(stock){
	t = select code, valueDate, adv5, adv15, open, vwap from stock order by valueDate
	update t set rank_open = rank(open), rank_adv15 = rank(adv15) context by valueDate
	update t set decay7 = mavg(mcorr(vwap, msum(adv5, 26), 5), 1..7), decay8 = mavg(mrank(9 - mimin(mcorr(rank_open, rank_adv15, 21), 9), true, 7), 1..8) context by code
	return select code, valueDate, rank(decay7)-rank(decay8) as A98 from t context by valueDate 
}</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="对时间序列数据的友好支持"><h3 class="- topic/title title topictitle3" id="ariaid-title6">对时间序列数据的友好支持</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB的数据库采用列式数据存储，计算的时候又采用向量化的编程，对时间序列数据天然友好。</p><ul class="- topic/ul ul"><li class="- topic/li li">DolphinDB支持不同精度的时间类型。可以通过SQL语句方便的将高频数据转换成不同精度的低频数据，例如秒级、分钟级、小时级, 也可以通过<code class="+ topic/ph pr-d/codeph ph codeph">bar</code>函数和group by子句的配合使用，转换成任意时间间隔的数据。</li><li class="- topic/li li">DolphinDB支持对时间序列数据的序列关系进行建模，包括领先（lead），滞后（lag），滑动窗口（sliding window），累积窗口（cumulative window）等。更重要的是在这类建模中用到的常用指标和函数，DolphinDB都做了优化，性能优于其它系统1~2个数量级。</li><li class="- topic/li li">DolphinDB提供了专门为时间序列设计的高效而常用的表联结方式：asof join和window join。</li></ul><p class="- topic/p p">我们以一个简单的例子来解释window join。譬如要统计一组人员在某些时间点前三个月的平均工资。我们可以简单的用window join（<code class="+ topic/ph pr-d/codeph ph codeph">wj</code>）来实现。window join函数的具体解释请参考用户手册。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>p = table(1 2 3 as id, 2018.06M 2018.07M 2018.07M as month)
s = table(1 2 1 2 1 2 as id, 2018.04M + 0 0 1 1 2 2 as month, 4500 5000 6000 5000 6000 4500 as wage)
select * from wj(p, s, -3:-1,&lt;avg(wage)&gt;,`id`month)

id month    avg_wage
-- -------- -----------
1  2018.06M 5250
2  2018.07M 4833.333333
3  2018.07M
</code></pre><p class="- topic/p p">上面的问题，在其它数据库系统中，可以使用equal join（id字段）和 non-equal join（month字段），以及group by子句来解决。但除了写法更为复杂外，与DolphinDB的window join相比，其它系统性能落后两个数量级以上。</p><p class="- topic/p p">window join在金融领分析领域有着广泛的应用。一个经典的应用就是将交易（trades）表和报价（quotes）表进行关联，计算交易成本。</p><p class="- topic/p p">以下为交易表（trades），不分区或者按日期和股票代码分区：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sym  date       time         price  qty
---- ---------- ------------ ------ ---
IBM  2018.06.01 10:01:01.005 143.19 100
MSFT 2018.06.01 10:01:04.006 107.94 200</code></pre><p class="- topic/p p">以下为报价表（quotes），不分区或者按日期和股票代码分区：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sym  date       time         bid    ask    bidSize askSize
---- ---------- ------------ ------ ------ ------- -------
IBM  2018.06.01 10:01:01.006 143.18 143.21 400     200
MSFT 2018.06.01 10:01:04.010 107.92 107.97 800     100</code></pre><p class="- topic/p p">使用asof join为每一个交易找到最近的一个报价，并利用报价的中间价作为交易成本的基准：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dateRange = 2018.05.01 : 2018.08.01
select sum(abs(price - (bid+ask)/2.0)*qty)/sum(price*qty) as cost from aj(trades, quotes, `date`sym`time) where date between dateRange group by sym;</code></pre><p class="- topic/p p">使用window join为每一个交易找到前10毫秒的报价，计算平均中间价作为交易成本的基准：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select sum(abs(price - mid)*qty)/sum(price*qty) as cost from pwj(trades, quotes, -10:0, &lt;avg((bid + ask)/2.0) as mid&gt;,`date`sym`time) where date between dateRange group by sym;</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="sql的其它扩展"><h3 class="- topic/title title topictitle3" id="ariaid-title7">SQL的其它扩展</h3><div class="- topic/body body"><p class="- topic/p p">为满足大数据分析的要求，DolphinDB对SQL还做了很多其他扩展。这儿我们例举一些常用功能。</p><ul class="- topic/ul ul"><li class="- topic/li li">用户自定义的函数无需编译、打包和部署，即可在本节点或分布式环境的SQL中使用此函数。</li><li class="- topic/li li">如5.4节所示，DolphinDB中的SQL与分布式计算框架紧密集成，实现库内计算（in-database analytics）变得更加便捷和高效。</li><li class="- topic/li li">DolphinDB支持组合字段（composite column），可将复杂分析函数的多个返回值输出到数据表的一行。</li></ul><p class="- topic/p p">如果要在SQL语句中使用组合字段，函数的输出结果必须是简单的键值对（key-value pair)或者数组。如果不是这两种类型，可以用自定义函数进行转换。组合字段的详细用法请参考用户手册。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>factor1=3.2 1.2 5.9 6.9 11.1 9.6 1.4 7.3 2.0 0.1 6.1 2.9 6.3 8.4 5.6
factor2=1.7 1.3 4.2 6.8 9.2 1.3 1.4 7.8 7.9 9.9 9.3 4.6 7.8 2.4 8.7
t=table(take(1 2 3, 15).sort() as id, 1..15 as y, factor1, factor2);</code></pre><p class="- topic/p p">为每个id运行ols，y = alpha + beta1 * factor1 + beta2 * factor2, 输出参数alpha, beta1, beta2。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select ols(y, [factor1,factor2], true, 0) as `alpha`beta1`beta2 from t group by id;

id alpha     beta1     beta2
-- --------- --------- ---------
1  1.063991  -0.258685 0.732795
2  6.886877  -0.148325 0.303584
3  11.833867 0.272352  -0.065526</code></pre><p class="- topic/p p">在输出参数的同时，输出R2。使用自定义函数包装输出结果。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myols(y,x){
    r=ols(y,x,true,2)
    return r.Coefficient.beta join r.RegressionStat.statistics[0]
}
select myols(y,[factor1,factor2]) as `alpha`beta1`beta2`R2 from t group by id;

id alpha     beta1     beta2     R2
-- --------- --------- --------- --------
1  1.063991  -0.258685 0.732795  0.946056
2  6.886877  -0.148325 0.303584  0.992413
3  11.833867 0.272352  -0.065526 0.144837</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title8" id="命令式编程imperative-programming"><h2 class="- topic/title title topictitle2" id="ariaid-title8">命令式编程(Imperative Programming)</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB与主流的脚本语言（Python和JavaScript等）和编译型强类型语言（C++，C和Java）一样，支持命令式编程，即一步一步告诉计算机先做什么再做什么。DolphinDB目前支持18种语句（详细参考用户手册第五章），包括最常用的赋值语句，分支语句if..else，以及循环语句for和do..while等。</p><p class="- topic/p p">DolphinDB支持对单变量和多变量进行赋值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>x = 1 2 3
y = 4 5
y += 2
x, y = y, x //swap the value of x and y
x, y =1 2 3, 4 5</code></pre><p class="- topic/p p">DolphinDB目前支持的循环语句包括for语句和do..while语句。for语句的循环体可以包括数据对（pair）（左闭右开区间）、数组（vector）、矩阵（matrix）和表（table）。</p><p class="- topic/p p">1到100累加求和：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>s = 0
for(x in 1:101) s += x
print s</code></pre><p class="- topic/p p">数组中的元素求和：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>s = 0;
for(x in 1 3 5 9 15) s += x
print s</code></pre><p class="- topic/p p">打印矩阵每一列的均值：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>m = matrix(1 2 3, 4 5 6, 7 8 9)
for(c in m) print c.avg()</code></pre><p class="- topic/p p">计算数据表中每一个行两列之乘积：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t= table(["TV set", "Phone", "PC"] as productId, 1200 600 800 as price, 10 20 7 as qty)
for(row in t) print row.productId + ": " + row.price * row.qty</code></pre><p class="- topic/p p">DolphinDB的分支语句if..else与其它语言一致。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>if(condition){
    &lt;true statements&gt;
}
else{
     &lt;false statements&gt;
}</code></pre><p class="- topic/p p">对处理海量数据时，不推荐利用控制语句（for语句，if..else语句）对数据逐行处理。这些控制语句一般用于上层模块的处理和调度，比较底层的数据处理模块建议使用向量编程，函数编程，SQL编程等方式来处理。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title9" id="函数化编程functional-programming"><h2 class="- topic/title title topictitle2" id="ariaid-title9">函数化编程(Functional Programming)</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB支持函数式编程的大部分功能，包括：</p><ul class="- topic/ul ul"><li class="- topic/li li">纯函数（pure function）</li><li class="- topic/li li">自定义函数（user-defined function，或简称udf）</li><li class="- topic/li li">lambda函数</li><li class="- topic/li li">高阶函数（higher order function）</li><li class="- topic/li li">部分应用（partial application）</li></ul><p class="- topic/p p">详细请参考用户手册第七章。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="自定义函数和lambda函数"><h3 class="- topic/title title topictitle3" id="ariaid-title10">自定义函数和lambda函数</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB中可以创建自定义函数，函数可以有名称或者没有名称（通常是lambda函数）。创建的函数符合纯函数的要求，也就是说只有函数的输入参数可以影响函数的输出结果。DolphinDB与Python不同，函数体内只能引用函数参数和函数内的局部变量，不能使用函数体外定义的变量。从软件工程的角度看，这牺牲了一部分语法糖的灵活性，但对提高软件质量大有裨益。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def getWeekDays(dates){
    return dates[def(x):weekday(x) between 1:5]
}

getWeekDays(2018.07.01 2018.08.01 2018.09.01 2018.10.01)

[2018.08.01, 2018.10.01] </code></pre><p class="- topic/p p">上面的例子中，我们定义了一个函数<code class="+ topic/ph pr-d/codeph ph codeph">getWeekDays</code>，该函数接受一组日期，返回其在周一和周五之间的日期。函数的实现采用了向量的过滤功能，也就是接受一个布尔型单目函数用于数据的过滤。我们定义了一个lambda函数用于数据过滤。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="高阶函数higher-order-function"><h3 class="- topic/title title topictitle3" id="ariaid-title11">高阶函数(Higher Order Function)</h3><div class="- topic/body body"><p class="- topic/p p">高阶函数是指可以接受另一个函数作为参数的函数。在DolphinDB中，高阶函数主要用作数据处理的模板函数，通常第一个参数是另外一个函数，用于具体的数据处理。譬如说，A对象有m个元素，B对象有n个元素，一种常见的处理模式是，A中的任意一个元素和B中的任意一个元素两两计算，最后产生一个m*n的矩阵。DolphinDB将这种数据处理模式抽象成一个高阶函数<code class="+ topic/ph pr-d/codeph ph codeph">cross</code>。DolphinDB提供了很多类似的高阶函数，包括<code class="+ topic/ph pr-d/codeph ph codeph">all</code>，<code class="+ topic/ph pr-d/codeph ph codeph">any</code>，<code class="+ topic/ph pr-d/codeph ph codeph">each</code>，<code class="+ topic/ph pr-d/codeph ph codeph">loop</code>，<code class="+ topic/ph pr-d/codeph ph codeph">eachLeft</code>，<code class="+ topic/ph pr-d/codeph ph codeph">eachRight</code>，<code class="+ topic/ph pr-d/codeph ph codeph">eachPre</code>，<code class="+ topic/ph pr-d/codeph ph codeph">eachPost</code>，<code class="+ topic/ph pr-d/codeph ph codeph">accumulate</code>，<code class="+ topic/ph pr-d/codeph ph codeph">reduce</code>，<code class="+ topic/ph pr-d/codeph ph codeph">groupby</code>，<code class="+ topic/ph pr-d/codeph ph codeph">contextby</code>，<code class="+ topic/ph pr-d/codeph ph codeph">pivot</code>，<code class="+ topic/ph pr-d/codeph ph codeph">cross</code>，<code class="+ topic/ph pr-d/codeph ph codeph">moving</code>，<code class="+ topic/ph pr-d/codeph ph codeph">rolling</code>等。</p><p class="- topic/p p">下面的一个例子我们使用三个高阶函数，只用三行代码，根据股票日内tick级别的交易数据，计算出每两只股票之间的相关性。</p><p class="- topic/p p">模拟生成10000000个数据点（股票代码，交易时间和价格）：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n=10000000
syms = rand(`FB`GOOG`MSFT`AMZN`IBM, n)
time = 09:30:00.000 + rand(21600000, n)
price = 500.0 + rand(500.0, n)</code></pre><p class="- topic/p p">利用<code class="+ topic/ph pr-d/codeph ph codeph">pivot</code>函数生成股价透视矩阵，每列为一支股票，每行为一分钟：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>priceMatrix = pivot(avg, price, time.minute(), syms)</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">each</code>和<code class="+ topic/ph pr-d/codeph ph codeph">ratios</code>函数配合使用，对股价矩阵每列进行操作，将股价转为收益率：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>retMatrix = each(ratios, priceMatrix) - 1</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">cross</code>和<code class="+ topic/ph pr-d/codeph ph codeph">corr</code>函数配合使用，计算每两支股票收益率的相关性：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>corrMatrix = cross(corr, retMatrix, retMatrix)</code></pre><p class="- topic/p p">结果为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>     AMZN      FB        GOOG      IBM       MSFT
     --------- --------- --------- --------- ---------
AMZN|1         0.015181  -0.056245 0.005822  0.084104
FB  |0.015181  1         -0.028113 0.034159  -0.117279
GOOG|-0.056245 -0.028113 1         -0.039278 -0.025165
IBM |0.005822  0.034159  -0.039278 1         -0.049922
MSFT|0.084104  -0.117279 -0.025165 -0.049922 1</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="部分应用partial-application"><h3 class="- topic/title title topictitle3" id="ariaid-title12">部分应用(Partial Application)</h3><div class="- topic/body body"><p class="- topic/p p">部分应用指当一个函数的一部分或全部参数给定后生成一个新的函数。在DolphinDB中，函数调用使用圆括号()，部分应用使用{}。3.2节中的例子用到的<code class="+ topic/ph pr-d/codeph ph codeph">ratios</code>函数的具体实现就是高阶函数<code class="+ topic/ph pr-d/codeph ph codeph">eachPre</code>的一个部分应用 eachPre。</p><p class="- topic/p p">以下两行代码同构：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>retMatrix = each(ratios, priceMatrix) - 1
retMatrix = each(eachPre{ratio}, priceMatrix) - 1</code></pre><p class="- topic/p p">部分应用经常用于高阶函数。使用高阶函数时，通常对某些参数有特定要求，通过部分应用，可以确保所有参数符合要求。例如，计算一个向量a与一个矩阵m中的每一列的相关性，可以将函数<code class="+ topic/ph pr-d/codeph ph codeph">corr</code>与高阶函数<code class="+ topic/ph pr-d/codeph ph codeph">each</code>配合使用。但是若直接将向量与矩阵在<code class="+ topic/ph pr-d/codeph ph codeph">each</code>中列为<code class="+ topic/ph pr-d/codeph ph codeph">corr</code>的参数，系统将会试图计算向量的某个元素与矩阵的某个列的相关性，导致产生错误。这时，可利用部分应用把函数<code class="+ topic/ph pr-d/codeph ph codeph">corr</code>与向量a组成一个新的函数<code class="+ topic/ph pr-d/codeph ph codeph">corr{a}</code>，再与高阶函数<code class="+ topic/ph pr-d/codeph ph codeph">each</code>配合使用于矩阵的每一列，如下例所示。我们也可以利用for语句来解决这个问题，但代码冗长且增加耗时。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a = 12 14 18
m = matrix(5 6 7, 1 3 2, 8 7 11)</code></pre><p class="- topic/p p">使用each和部分应用计算向量a与矩阵中的每一列的相关性：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>each(corr{a}, m)</code></pre><p class="- topic/p p">使用for语句解决上述问题：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>cols = m.columns()
c = array(DOUBLE, cols)
for(i in 0:cols)
    c[i] = corr(a, m[i])</code></pre><p class="- topic/p p">部分应用的另一个妙用是使函数保持状态。通常我们希望函数是无状态的，即函数的输出结果完全是由输入参数决定的。但有时候我们希望函数是有“状态”的。譬如说，在流计算中，用户通常需要给定一个消息处理函数（message handler），接受一条新的信息后返回一个结果。如果我们希望消息处理函数返回的是迄今为止所有接收到的数据的平均数，可以通过部分应用来解决。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def cumulativeAverage(mutable stat, newNum){
    stat[0] = (stat[0] * stat[1] + newNum)/(stat[1] + 1)
    stat[1] += 1
    return stat[0]
}

msgHandler = cumulativeAverage{0.0 0.0}
each(msgHandler, 1 2 3 4 5)

[1,1.5,2,2.5,3]</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="远程过程调用编程rpc-programming"><h2 class="- topic/title title topictitle2" id="ariaid-title13">远程过程调用编程(RPC Programming)</h2><div class="- topic/body body"><p class="- topic/p p">远程过程调用（Remote Procedure Call）是分布式系统最常用的基础设施之一。DolphinDB的分布式文件系统实现，分布式数据库实现，分布式计算框架实现都采用了<code class="+ topic/ph pr-d/codeph ph codeph">DolphinDB自己设计</code>的RPC系统。DolphinDB的脚本语言通过RPC可以在远程机器上执行代码。DolphinDB在使用RPC时有以下特点：</p><ul class="- topic/ul ul"><li class="- topic/li li">不仅可以执行在远程机器上已经注册的函数，也可以将本地自定义的函数序列化到远程节点执行。在远程机器运行代码时的权限等同于当前登录用户在本地的权限。</li><li class="- topic/li li">函数的参数既可以是常规的scalar，vector，matrix，set，dictionary和table，也可以是函数包括自定义的函数。</li><li class="- topic/li li">既可以使用两个节点之间的独占连接，也可以使用集群数据节点之间的共享连接。</li></ul></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="使用remoterun执行远程函数"><h3 class="- topic/title title topictitle3" id="ariaid-title14">使用remoteRun执行远程函数</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB使用<code class="+ topic/ph pr-d/codeph ph codeph">xdb</code>创建一个到远程节点的连接。远程节点可以是任何运行DolphinDB的节点，不必属于当前集群的一部分。创建连接之后可以在远程节点上执行远程节点上注册的函数或本地自定义的函数。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>h = xdb("localhost", 8081);</code></pre><p class="- topic/p p">在远程节点上执行一段脚本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>remoteRun(h, "sum(1 3 5 7)");
16</code></pre><p class="- topic/p p">上述远程调用也可以简写成：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>h("sum(1 3 5 7)");
16</code></pre><p class="- topic/p p">在远程节点上执行一个在远程节点注册的函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>h("sum", 1 3 5 7);
16</code></pre><p class="- topic/p p">在远程系节点上执行本地的自定义函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def mysum(x) : reduce(+, x)
h(mysum, 1 3 5 7);
16</code></pre><p class="- topic/p p">在远程节点（localhost:8081）上创建一个共享表sales：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>h("share table(2018.07.02 2018.07.02 2018.07.03 as date, 1 2 3 as qty, 10 15 7 as price) as sales");</code></pre><p class="- topic/p p">如果本地的自定义函数有依赖，所依赖的自定义函数会自动序列化到远程节点：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg salesSum(tableName, d): select mysum(price*qty) from objByName(tableName) where date=d
h(salesSum, "sales", 2018.07.02);
40</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="使用rpc执行远程函数"><h3 class="- topic/title title topictitle3" id="ariaid-title15">使用rpc执行远程函数</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB使用远程过程调用功能的另一个途径是<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>函数。<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>函数接受远程节点的名称，需要执行的函数定义以及需要的参数。<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>只能在同一个集群内的控制节点及数据节点之间使用，但是不需要创建一个新的连接，而是复用已经存在的网络连接。这样做的好处是可以节约网络资源和免去创建新连接带来的延迟。当节点的用户很多时，这一点非常有意义。<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>函数只能在远程节点执行一个函数。如果要运行脚本，请把脚本封装在一个自定义函数内。
下面的例子必须在一个DolphinDB集群内使用。nodeB是远程节点的别名，nodeB上已经有共享表sales。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rpc("nodeB", salesSum, "sales",2018.07.02);
40</code></pre><p class="- topic/p p">在使用<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>时，为增加代码的可读性，建议使用部分应用，将函数参数和函数定义写在一起，形成一个新的零参数的函数定义。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rpc("nodeB", salesSum{"sales", 2018.07.02});
40</code></pre><p class="- topic/p p">master是控制节点的别名。DolphinDB只能在控制节点上创建用户：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rpc("master", createUser{"jerry", "123456"});</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>函数需要的参数也可以是另外一个函数包括内置函数和自定义函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>rpc("nodeB", reduce{+, 1 2 3 4 5});
15</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="使用其它函数间接执行远程函数"><h3 class="- topic/title title topictitle3" id="ariaid-title16">使用其它函数间接执行远程函数</h3><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">remoteRun</code>和<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>都可以在一个远程节点上执行用户在本地自定义的函数。这是DolphinDB的RPC子系统与其它RPC系统最大的不同之处。在其它系统中，通常RPC的客户端只能被动调用远程节点已经暴露的注册函数。在大数据分析领域，数据科学家根据新的研发项目经常会提出新的接口需求。如果等待IT部门发布新的API接口，通常需要很长的周期，这会严重影响研发的效率和周期。如果要在远程节点执行自定义的函数，自定义的函数目前必须使用DolphinDB的脚本来开发。另外，对数据的安全性也提出了更高的要求，必须仔细规划和设置用户的访问权限。如果限制用户只能使用注册的函数，用户的访问权限管理可以十分的简单，只要拒绝外部用户访问一切数据，授权外部用户访问注册的视图函数就可以了。</p><p class="- topic/p p">除了直接使用<code class="+ topic/ph pr-d/codeph ph codeph">remoteRun</code>和<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>函数外，DolphinDB也提供了很多函数间接的使用远程过程调用。例如，在分布式数据库的线性回归就用到了<code class="+ topic/ph pr-d/codeph ph codeph">rpc</code>与<code class="+ topic/ph pr-d/codeph ph codeph">olsEx</code>。另外，<code class="+ topic/ph pr-d/codeph ph codeph">pnodeRun</code>用于在集群的多个节点上并行运行同一个函数，并将返回的结果合并。这在集群的管理中十分有用。</p><p class="- topic/p p">每个数据节点返回最近的10个正在运行或已经完成的批处理作业：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>pnodeRun(getRecentJobs{10});</code></pre><p class="- topic/p p">返回节点nodeA和nodeB的最近10个SQL query：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>pnodeRun(getCompletedQueries{10}, `nodeA`nodeB);</code></pre><p class="- topic/p p">清除所有数据节点上的缓存：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>pnodeRun(clearAllCache);</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="分布式计算"><h3 class="- topic/title title topictitle3" id="ariaid-title17">分布式计算</h3><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">mr</code>用于开发基于MapReduce的分布式计算；<code class="+ topic/ph pr-d/codeph ph codeph">imr</code>用于开发基于迭代的MapReduce的分布式计算。用户只需要指定分布式数据源和核心函数，譬如map函数，reduce函数，final函数等。下面我们演示使用分布式数据计算中位数和线性回归的例子。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n=10000000
x1 = pow(rand(1.0,n), 2)
x2 = norm(3.0, 1.0, n)
y = 0.5 + 3 * x1 - 0.5*x2 + norm(0.0, 1.0, n)
t=table(rand(10, n) as id, y, x1, x2)

login(`admin,"123456")
db = database("dfs://testdb", VALUE, 0..9)
db.createPartitionedTable(t, "sample", "id").append!(t)</code></pre><p class="- topic/p p">利用自定义的map函数<code class="+ topic/ph pr-d/codeph ph codeph">myOLSMap</code>，内置的reduce函数（+），自定义的final函数<code class="+ topic/ph pr-d/codeph ph codeph">myOLSFinal</code>，以及内置的map-reduce框架函数<code class="+ topic/ph pr-d/codeph ph codeph">mr</code>，构建一个在分布式数据源上运行线性回归的函数<code class="+ topic/ph pr-d/codeph ph codeph">myOLSEx</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myOLSMap(table, yColName, xColNames){
    x = matrix(take(1.0, table.rows()), table[xColNames])
    xt = x.transpose();
    return xt.dot(x), xt.dot(table[yColName])
}

def myOLSFinal(result){
    xtx = result[0]
    xty = result[1]
    return xtx.inv().dot(xty)[0]
}

def myOLSEx(ds, yColName, xColNames){
  return mr(ds, myOLSMap{, yColName, xColNames}, +, myOLSFinal)
}</code></pre><p class="- topic/p p">使用用户自定义的分布式算法和分布式数据源计算线性回归系数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sample = loadTable("dfs://testdb", "sample")
myOLSEx(sqlDS(&lt;select * from sample&gt;), `y, `x1`x2);
[0.4991, 3.0001, -0.4996]</code></pre><p class="- topic/p p">使用内置的函数ols和未分的数据计算线性回归的系数，得到相同的结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>ols(y, [x1,x2],true);
[0.4991, 3.0001, -0.4996]</code></pre><p class="- topic/p p">下面这个例子中，我们构造一个算法，在分布式数据源上计算一组数据的近似中位数。算法的基本原理是利用<code class="+ topic/ph pr-d/codeph ph codeph">bucketCount</code>函数，在每一个节点上分别计算一组内的数据个数，然后把各个节点上的数据累加。这样我们可以找到中位数应该落在哪个区间内。如果这个区间不够小，进一步细分这个区间，直到小于给定的精度要求。中位数的算法需要多次迭代，我们因此使用了迭代计算框架<code class="+ topic/ph pr-d/codeph ph codeph">imr</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def medMap(data, range, colName): bucketCount(data[colName], double(range), 1024, true)

def medFinal(range, result){
    x= result.cumsum()
    index = x.asof(x[1025]/2.0)
    ranges = range[1] - range[0]
    if(index == -1)
        return (range[0] - ranges*32):range[1]
    else if(index == 1024)
        return range[0]:(range[1] + ranges*32)
    else{
        interval = ranges / 1024.0
        startValue = range[0] + (index - 1) * interval
        return startValue : (startValue + interval)
    }
}

def medEx(ds, colName, range, precision){
    termFunc = def(prev, cur): cur[1] - cur[0] &lt;= precision
    return imr(ds, range, medMap{,,colName}, +, medFinal, termFunc).avg()
}</code></pre><p class="- topic/p p">使用以上近似中位数算法，计算分布式数据的中位数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sample = loadTable("dfs://testdb", "sample")
medEx(sqlDS(&lt;select y from sample&gt;), `y, 0.0 : 1.0, 0.001);
-0.052973</code></pre><p class="- topic/p p">使用内置的med函数计算未分区的数据的中位数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>med(y);
-0.052947</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title18" id="元编程metaprogramming"><h2 class="- topic/title title topictitle2" id="ariaid-title18">元编程(Metaprogramming)</h2><div class="- topic/body body"><p class="- topic/p p">元编程指使用程序代码来创建可以动态运行的程序代码。元编程的目的一般是延迟执行代码或动态创建代码。</p><p class="- topic/p p">DolphinDB支持使用元编程来动态创建表达式，譬如函数调用的表达式，SQL查询表达式。很多业务细节无法在编码阶段确定。譬如说客户定制报表，只有运行时，客户选择了表格，字段和字段格式，才可以确定一个完整的SQL查询表达式。</p><p class="- topic/p p">延迟执行代码一般分为这几种情况：</p><ul class="- topic/ul ul"><li class="- topic/li li">提供一个回调函数</li><li class="- topic/li li">延迟执行为整体优化创造条件</li><li class="- topic/li li">问题描述在程序编码阶段完成，但是问题实现在程序运行阶段完成</li></ul><p class="- topic/p p">DolphinDB实现元编程的途径有两个，一是使用一对尖括号&lt;&gt;来表示需要延后执行的动态代码，二是使用函数来创建各种表达式。常用的用于元编程的函数包括<code class="+ topic/ph pr-d/codeph ph codeph">objByName</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sqlCol</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sqlColAlias</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sql</code>, <code class="+ topic/ph pr-d/codeph ph codeph">expr</code>, <code class="+ topic/ph pr-d/codeph ph codeph">eval</code>, <code class="+ topic/ph pr-d/codeph ph codeph">partial</code>, <code class="+ topic/ph pr-d/codeph ph codeph">makeCall</code>。</p><p class="- topic/p p">使用&lt;&gt;来生成延后执行的动态表达式：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a = &lt;1 + 2 * 3&gt;
a.typestr();
CODE

a.eval();
7</code></pre><p class="- topic/p p">使用函数来生成延后执行的动态表达式：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a = expr(1, +, 2, *, 3)
a.typestr();
CODE

a.eval();
7</code></pre><p class="- topic/p p">可使用元编程来定制报表。用户的输入包括数据表，字段名称和字段相应的格式字符串。下例中，根据输入的数据表，字段名称和格式，以及过滤条件，动态生成SQL表达式并执行。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def generateReport(tbl, colNames, colFormat, filter){
	colCount = colNames.size()
	colDefs = array(ANY, colCount)
	for(i in 0:colCount){
		if(colFormat[i] == "") 
			colDefs[i] = sqlCol(colNames[i])
		else
			colDefs[i] = sqlCol(colNames[i], format{,colFormat[i]})
	}
	return sql(colDefs, tbl, filter).eval()
}</code></pre><p class="- topic/p p">模拟生成一个100行的数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(1..100 as id, (1..100 + 2018.01.01) as date, rand(100.0, 100) as price, rand(10000, 100) as qty);</code></pre><p class="- topic/p p">输入过滤条件，字段和格式，定制报表。过滤条件使用了元编程。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>generateReport(t, ["id","date","price","qty"], ["000","MM/dd/yyyy", "00.00", "#,###"], &lt; id&lt;5 or id&gt;95 &gt;);

id  date       price qty
--- ---------- ----- -----
001 01/02/2018 50.27 2,886
002 01/03/2018 30.85 1,331
003 01/04/2018 17.89 18
004 01/05/2018 51.00 6,439
096 04/07/2018 57.73 8,339
097 04/08/2018 47.16 2,425
098 04/09/2018 27.90 4,621
099 04/10/2018 31.55 7,644
100 04/11/2018 46.63 8,383</code></pre><p class="- topic/p p">DolphinDB的一些内置函数的参数需要使用元编程。<code class="+ topic/ph pr-d/codeph ph codeph">窗口连接（window join）</code>中，需要为右表的窗口数据集指定一个或多个聚合函数以及这些函数运行时需要的参数。由于问题的描述和执行在两个不同的阶段，我们采用元编程来实现延后执行。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(take(`ibm, 3) as sym, 10:01:01 10:01:04 10:01:07 as time, 100 101 105 as price)
q = table(take(`ibm, 8) as sym, 10:01:01+ 0..7 as time, 101 103 103 104 104 107 108 107 as ask, 98 99 102 103 103 104 106 106 as bid)
wj(t, q, -2 : 1, &lt; [max(ask), min(bid), avg((bid+ask)*0.5) as avg_mid]&gt;, `time);

sym time     price max_ask min_bid avg_mid
--- -------- ----- ------- ------- -------
ibm 10:01:01 100   103     98      100.25
ibm 10:01:04 101   104     99      102.625
ibm 10:01:07 105   108     103     105.625</code></pre><p class="- topic/p p">DolphinDB中另一个使用元编程的内置功能是更新内存分区表。当然内存分区表的更新，删除，排序等功能也可以通过SQL语句来完成。</p><p class="- topic/p p">创建一个以日期为分区的内存分区数据库，并模拟生成trades表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>db = database("", VALUE, 2018.01.02 2018.01.03)
date = 2018.01.02 2018.01.02 2018.01.02 2018.01.03 2018.01.03 2018.01.03
t = table(`IBM`MSFT`GOOG`FB`IBM`MSFT as sym, date, 101 103 103 104 104 107 as price, 0 99 102 103 103 104 as qty)
trades = db.createPartitionedTable(t, "trades", "date").append!(t);</code></pre><p class="- topic/p p">删除qty为0的记录，并在每个分区中按交易量进行升序排序：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>trades.erase!(&lt;qty=0&gt;).sortBy!(&lt;price*qty&gt;);</code></pre><p class="- topic/p p">增加一个新的字段logPrice：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>trades[`logPrice]=&lt;log(price)&gt;;</code></pre><p class="- topic/p p">更新股票IBM的交易数量：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>trades[`qty, &lt;sym=`IBM&gt;]=&lt;qty+100&gt;;</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="小结"><h2 class="- topic/title title topictitle2" id="ariaid-title19">小结</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB是一门为数据分析而生的编程语言。DolphinDB支持向量化计算和分布式计算，具有极快的运行速度。与其它数据分析语言Matlab，SAS，pandas等不同，DolphinDB与分布式数据库和分布式计算紧密集成，天生具备处理海量数据的能力。DolphinDB支持SQL编程，函数化编程和元编程，语言简洁灵活，表达能力强，大大提高了数据科学家的开发效率。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#%E5%90%91%E9%87%8F%E5%8C%96%E7%BC%96%E7%A8%8Bvector-programming" data-tocid="向量化编程vector-programming">向量化编程(Vector Programming)</a></li><li class="topic-item"><a href="#sql%E7%BC%96%E7%A8%8Bsql-programming" data-tocid="sql编程sql-programming">SQL编程(SQL Programming)</a><ul><li class="topic-item"><a href="#sql%E4%B8%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E8%9E%8D%E5%90%88" data-tocid="sql与编程语言的融合">SQL与编程语言的融合</a></li><li class="topic-item"><a href="#%E5%AF%B9%E9%9D%A2%E6%9D%BF%E6%95%B0%E6%8D%AEpanel-data%E7%9A%84%E5%8F%8B%E5%A5%BD%E6%94%AF%E6%8C%81" data-tocid="对面板数据panel-data的友好支持">对面板数据(Panel Data)的友好支持</a></li><li class="topic-item"><a href="#%E5%AF%B9%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8B%E5%A5%BD%E6%94%AF%E6%8C%81" data-tocid="对时间序列数据的友好支持">对时间序列数据的友好支持</a></li><li class="topic-item"><a href="#sql%E7%9A%84%E5%85%B6%E5%AE%83%E6%89%A9%E5%B1%95" data-tocid="sql的其它扩展">SQL的其它扩展</a></li></ul></li><li class="topic-item"><a href="#%E5%91%BD%E4%BB%A4%E5%BC%8F%E7%BC%96%E7%A8%8Bimperative-programming" data-tocid="命令式编程imperative-programming">命令式编程(Imperative Programming)</a></li><li class="topic-item"><a href="#%E5%87%BD%E6%95%B0%E5%8C%96%E7%BC%96%E7%A8%8Bfunctional-programming" data-tocid="函数化编程functional-programming">函数化编程(Functional Programming)</a><ul><li class="topic-item"><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%92%8Clambda%E5%87%BD%E6%95%B0" data-tocid="自定义函数和lambda函数">自定义函数和lambda函数</a></li><li class="topic-item"><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0higher-order-function" data-tocid="高阶函数higher-order-function">高阶函数(Higher Order Function)</a></li><li class="topic-item"><a href="#%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8partial-application" data-tocid="部分应用partial-application">部分应用(Partial Application)</a></li></ul></li><li class="topic-item"><a href="#%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BC%96%E7%A8%8Brpc-programming" data-tocid="远程过程调用编程rpc-programming">远程过程调用编程(RPC Programming)</a><ul><li class="topic-item"><a href="#%E4%BD%BF%E7%94%A8remoterun%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%87%BD%E6%95%B0" data-tocid="使用remoterun执行远程函数">使用remoteRun执行远程函数</a></li><li class="topic-item"><a href="#%E4%BD%BF%E7%94%A8rpc%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%87%BD%E6%95%B0" data-tocid="使用rpc执行远程函数">使用rpc执行远程函数</a></li><li class="topic-item"><a href="#%E4%BD%BF%E7%94%A8%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0%E9%97%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%87%BD%E6%95%B0" data-tocid="使用其它函数间接执行远程函数">使用其它函数间接执行远程函数</a></li><li class="topic-item"><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97" data-tocid="分布式计算">分布式计算</a></li></ul></li><li class="topic-item"><a href="#%E5%85%83%E7%BC%96%E7%A8%8Bmetaprogramming" data-tocid="元编程metaprogramming">元编程(Metaprogramming)</a></li><li class="topic-item"><a href="#%E5%B0%8F%E7%BB%93" data-tocid="小结">小结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>