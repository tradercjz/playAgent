<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="导读 为了提升 DolphinDB 在高并发读写场景下的性能与稳定性，DolphinDB 在架构上引入了计算节点 （compute node） 。计算节点接管了数据节点的部分职能，负责响应客户端的请求并返回结果。在架构层面，将集群的计算与存储进行分离，保证数据节点的软硬件资源有效服务于 IO 过程，从而提升集群写入性能与稳定性。同时 DolphinDB ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../sys_man/cluster_manage.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="使用计算节点"/><title>使用计算节点</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;使用计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;使用计算节点&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;导读&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;为了提升 DolphinDB 在高并发读写场景下的性能与稳定性，DolphinDB 在架构上引入了计算节点 （compute node） 。计算节点接管了数据节点的部分职能，负责响应客户端的请求并返回结果。在架构层面，将集群的计算与存储进行分离，保证数据节点的软硬件资源有效服务于 IO 过程，从而提升集群写入性能与稳定性。同时 DolphinDB 集群管理者可以根据业务需求和集群负载情况，对计算资源和存储资源独立扩展。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;本教程将重点介绍计算节点的特性、架构设计、应用实践及运维管理等方面内容，通过原理解析、案例分析来讲解如何部署和使用计算节点。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;面向读者&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;架构师（1-5章）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;DolphinDB DBA（第1、2、4章）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;开发工程师 （第1、3章）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;运维工程师 （第1、4章）&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:4;14:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_om.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../sys_man/cluster_manage.dita&#34; mapclass=&#34;- map/topicref &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:2;12:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_om.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot gentext?&gt;集群管理&lt;/linktext&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;概览&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;概览&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;为什么引入计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;为什么引入计算节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;数据节点可以同时承担计算任务和数据读写任务的执行，对于一些计算任务不重的场景来说，数据节点兼任计算任务没有问题，但是对于计算逻辑较复杂，并发度较高的计算密集场景下，可能会有以下影响：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;对于数据写入的影响：由于密集计算任务会大量消耗 CPU 和内存资源，而数据写入时需要 CPU 来进行数据的预处理和压缩，因此会影响数据写入性能。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;对于数据读取的影响: 若大量内存被计算任务占用，那么读取数据时，可能因内存不足导致 OOM 异常。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;DolphinDB 自版本1.30.14，2.00.1开始支持计算节点，能够有效地解决上述问题。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;计算节点简介&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点简介&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;核心特性&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;核心特性&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点，顾名思义，即执行计算任务的节点，相比于数据节点，有以下2个核心特性：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;34:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;34:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;不存储分布式表数据&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;36:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;不存储分布式表数据、元数据文件，是一个轻状态的服务组件。计算节点的启停流程十分精简，任何故障都可以通过重启节点来进行快速修复。同时，计算节点可以进行快速地&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#计算节点扩缩容&#34; xtrc=&#34;xref:1;36:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;扩缩容&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;38:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;如下图所示 3 个数据节点、3 个计算节点的集群：&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:1;40:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;40:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;1-1&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_1.png&#34; width=&#34;50%&#34; xtrc=&#34;image:1;40:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;424&#34; dita-ot:image-height=&#34;226&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;47:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图中 C1-CNODE1 至 C1-CNODE3 为计算节点，P1-DNODE1 至 P3-DNODE1 为数据节点。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;49:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;从文件系统来简单验证下计算节点的无状态特性。查看数据节点 volume 配置：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;51:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;# 查看存储卷 select * from pnodeRun(getConfig{`volumes}) P1-DNODE1 /ssd/ssd0/wfHuang/volumes/P1-DNODE1 P2-DNODE1 /ssd/ssd0/wfHuang/volumes/P2-DNODE1 P3-DNODE1 /ssd/ssd0/wfHuang/volumes/P3-DNODE1&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;59:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;到操作系统去查看数据节点 P1-DNODE1 的 volume 目录：&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:2;61:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;61:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-2&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_2.png&#34; width=&#34;50%&#34; xtrc=&#34;image:2;61:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;898&#34; dita-ot:image-height=&#34;823&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;67:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;可看到 P1-DNODE1 作为数据节点，管理着事务 undo/redo 日志文件，和大量的数据块 CHUNKS 文件。但计算节点不需要配置 volume, 查看 C1-CNODE1 的默认 data 目录：&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:3;69:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;69:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-3&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_3.png&#34; width=&#34;50%&#34; xtrc=&#34;image:3;69:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;692&#34; dita-ot:image-height=&#34;359&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;75:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;可以看到计算节点 C1-CNODE1 不存储任何的分布式数据文件。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;77:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;77:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;77:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;负责计算&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;79:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在分布式表读写场景中，由数据节点负责 map 阶段，计算节点负责 merge-reduce 阶段（详见&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#通过一个-sql-查询理解计算节点&#34; xtrc=&#34;xref:2;79:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;通过一个-sql-查询理解计算节点&lt;/xref&gt;）。在纯内存对象（常规内存表、分区内存表、流数据表等）计算场景中，由计算节点独立执行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;81:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;执行一个分布式表查询 SQL，从文件层面来观察计算节点在数据查询发挥的作用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;83:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;查看计算节点 C1-CNODE1 打开的文件（&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;83:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;open files&lt;/i&gt;）：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;85:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;[appadmin@compute volumes]$ lsof -p pidOfComputenode skip library files compute_w 38563 appadmin 19u IPv4 319181009 0t0 TCP compute:8961-&amp;gt;192.192.168.2:56780 (ESTABLISHED) compute_w 38563 appadmin 20u IPv4 319103550 0t0 TCP compute:8961-&amp;gt;192.192.168.2:56786 (ESTABLISHED) compute_w 38563 appadmin 22u IPv4 319095550 0t0 TCP compute:8961-&amp;gt;192.192.168.2:34842 (ESTABLISHED) ...skip 20 lines...... compute_w 38563 appadmin 44u IPv4 319337513 0t0 TCP compute:42566-&amp;gt;192.192.168.2:8961 (ESTABLISHED)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;94:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;查看数据节点 P1-DNODE1 打开的文件：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;96:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;[appadmin@support4 log]$ lsof -p pidOfDatanode compute_w 99763 appadmin 33u IPv4 49451766 0t0 TCP support4:8961-&amp;gt;192.192.168.1:42474 (ESTABLISHED) compute_w 99763 appadmin 36u IPv4 49455618 0t0 TCP support4:8961-&amp;gt;192.192.168.1:42562 (ESTABLISHED) compute_w 99763 appadmin 39r REG 8,17 272358102 177313580 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220102/hQE/machines_2/1_00000058 compute_w 99763 appadmin 40r REG 8,17 272358117 177313646 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220106/hQE/machines_2/1_00000062 compute_w 99763 appadmin 41r REG 8,17 272358131 177313802 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220227/hQE/machines_2/1_00000072 compute_w 99763 appadmin 42r REG 8,17 272358111 177313644 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220109/hQE/machines_2/1_00000060 ......skip hundreds of lines......&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;107:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;可以观察到计算节点 C1-CNODE1 打开了大量的 TCP 连接符，而数据节点 P1-DNODE1 除了 TCP 连接符外，还打开了大量的磁盘文件。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:4;109:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;109:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-4&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_4.png&#34; width=&#34;50%&#34; xtrc=&#34;image:4;109:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;712&#34; dita-ot:image-height=&#34;278&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;114:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;如上图所示，计算节点 computenode1 负责解析 client 的请求，并协调数据节点 datanode[1-3] 读/写数据（即 map，分布式执行过程）。接收到 datanode[1-3] 的数据后，经过 reduce-merge 过程，将最终结果返回给客户端。存算分离的架构，使得数据节点的物理资源得到隔离，写入和读取数据更为稳定、高效。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;通过一个-sql-查询理解计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;通过一个 SQL 查询理解计算节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;当客户端向计算节点发起一个 sql 查询：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;pt1 = loadTable(database(&#34;dfs://szstock&#34;),&#34;sztrade&#34;) select [HINT_EXPLAIN] securityID, min(price) as LowPx, max(price) as HighPx, sum(tradeQty) as vol , first(price) as OpenPx, last(price) as LastPx, sum(tradeQty * price) as val from pt where execType=&#34;F&#34; group by tradedate,securityID,minute(temporalParse(tradetime$STRING, &#34;yyyyMMddHHmmssSSS&#34;)) as minute order by tradedate,securityID, minute&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;131:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;[HINT_EXPLAIN]&lt;/codeph&gt; 获取执行计划，整个 sql 的执行过程依次为 parse，map，merge，reduce 四个部分。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;133:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;{ &#34;measurement&#34;: &#34;microsecond&#34;, &#34;explain&#34;: { &#34;from&#34;: { &#34;cost&#34;: 2 }, &#34;map&#34;: { &#34;partitions&#34;: { &#34;local&#34;: 0, &#34;remote&#34;: 320 }, &#34;cost&#34;: 5189927, &#34;detail&#34;: { ...skip many lines... }, &#34;merge&#34;: { &#34;cost&#34;: 446588, &#34;rows&#34;: 8522241, &#34;detail&#34;: { ...skip many lines... } } }, &#34;reduce&#34;: { &#34;sql&#34;: &#34;select [98307] * from 702a9832b17f0000 order by tradedate asc,securityID asc,minute asc&#34;, &#34;explain&#34;: { &#34;sort&#34;: { &#34;cost&#34;: 296783 }, &#34;rows&#34;: 8522241, &#34;cost&#34;: 746374 } }, &#34;rows&#34;: 8522241, &#34;cost&#34;: 6691112 } }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;其中，query parse、merge、reduce 过程发生在计算节点，map 阶段则并行发生于各数据节点。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:5;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-5&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_5.png&#34; width=&#34;50%&#34; xtrc=&#34;image:5;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;910&#34; dita-ot:image-height=&#34;337&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;整个执行过程消耗资源具体如下表。&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:4;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;执行步骤&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;182:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;发生节点&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;182:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;消耗资源&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:4;182:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;时间(us)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:5;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;query parse&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;184:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;computenode&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:7;184:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cpu&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:8;184:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;2&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:9;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;map&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:10;185:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;datanode * 3&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:11;185:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;IO, network，cpu, memory&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:12;185:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;5189927&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:13;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;merge&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:14;186:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;computenode&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:15;186:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cpu，network, memory&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:16;186:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;446588&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:17;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;reduce&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:18;187:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;computenode&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:19;187:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cpu，network, memory&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:20;187:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;746374&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;该 SQL 总共涉及 300 个分区，各分区记录数在 60-280 万不等。merge-reduce 阶段分布处理了 850 万的数据。由 C1-CNODE1 承担的 merge-reduce 阶段总耗时占比为&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;191:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;（446588 + 746374）/ 6691112 = 17.8%&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;上述例子 map 阶段 where，group by 算子大大减少了数据量，因此计算节点的算量不大，如果是读取数据类的场景，比如数据导入导出，此比例会大大增加。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;执行过程中，计算节点与数据节点的内存消耗情况如下图所示（node33：计算节点，node34-36：数据节点，下同）。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:6;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-6&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_6.png&#34; width=&#34;50%&#34; xtrc=&#34;image:6;197:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;918&#34; dita-ot:image-height=&#34;298&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;可以看出在 map 阶段在数据节点，是分布式、并行执行的。在 merge-reduce 过程中计算节点的内存消耗逐渐增加。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;引入计算节点的好处&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;引入计算节点的好处&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;保证写入数据的稳定性&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;保证写入数据的稳定性&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;208:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在数据节点上执行复杂业务计算（如因子计算、机器学习等），会占用大量的内存。使得 cacheEngine 无法获取足够多的内存，而发生 cacheEngine 内存溢出等问题，导致写入延迟，甚至失败。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;ChunkCacheEngine can't reclaim any memory after trying 13 times. Transation failed, cacheEngine out of memory.&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;另外，使用 TSDB 引擎，数据刷盘时需进行排序，需要消耗大量的 CPU 资源以及排序 buffer。若 CPU 、内存资源不足时，TSDB 的写入性能会下降。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;218:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;通过在架构上引入计算节点，采用计算与存储分离的架构设计，可以有效地保证集群数据写入的稳定性。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;降低故障平均修复时间&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;降低故障平均修复时间&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;222:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;使用计算节点的集群能显著地降低故障平均修复时间，尽可能地减少对业务的影响。核心原因是由于计算节点不管理分布式数据，重启可以在数秒内完成。当某个计算节点出现拥塞、无法响应等情况，且无法热修复的，重启即可使其恢复正常服务。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:7;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-7：启动流程对比&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_7.png&#34; width=&#34;50%&#34; xtrc=&#34;image:7;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;2120&#34; dita-ot:image-height=&#34;1210&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;231:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;如图，当数据节点启动时，流程中的蓝色标记部分：“回放 redo 日志”，“恢复损坏的 chunk” 等包含了大量的 IO 操作，实际生产环境中耗时为分钟级（具体视数据量大小而定）。而计算节点流程十分精简，可以在秒级完成启动。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;计算节点安装&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点安装&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;235:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;现用如下 4 台服务器部署集群：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;P1: 192.193.168.2&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;238:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;P2: 192.193.168.3&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;P3: 192.193.168.4&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;C1: 192.193.168.1&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;242:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;其中服务器 P1-P3 用于部署数据节点，C1 用于部署计算节点。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;编写配置文件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;编写配置文件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在节点列表文件 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;246:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cluster.nodes&lt;/i&gt; 中编写计算节点及代理节点。推荐计算节点以 CN (取 compute node 首字母) 标识，数据节点以 DN (取 datanode 首字母) 标识，如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;localSite,mode 192.193.168.2:8990:controller1,controller 192.193.168.3:8990:controller2,controller 192.193.168.4:8990:controller3,controller 192.193.168.2:8960:P1-agent,agent 192.193.168.3:8960:P2-agent,agent 192.193.168.4:8960:P3-agent,agent 192.193.168.1:8960:C1-agent,agent 192.193.168.2:8961:DN1,datanode 192.193.168.3:8961:DN2,datanode 192.193.168.4:8961:DN3,datanode 192.193.168.1:8961:CN1,computenode 192.193.168.1:8966:CN2,computenode 192.193.168.1:8967:CN3,computenode&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在配置文件 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;264:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cluster.cfg&lt;/i&gt; 中，需要使用前缀来区分数据节点与计算节点的配置项。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;CN%.workerNum=64 CN%.maxConnections=3000 CN%.maxMemSize=256 CN%.dataSync=0 DN%.maxConnections=512 DN%.maxMemSize=128 DN%.workerNum=32 DN%.chunkCacheEngineMemSize=6 DN%.dataSync=1 DN%.redoLogDir=/ssd/ssd0/wfHuang/volumes/redoLog DN%.volumes=/ssd/ssd0/wfHuang/volumes,/ssd/ssd1/wfHuang/volumes,/ssd/ssd2/wfHuang/volumes&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;279:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;279:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;CN%&lt;/codeph&gt; 匹配 CN 开头的计算节点，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;279:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;DN%&lt;/codeph&gt; 匹配 DN 开头的数据节点。以此保证计算节点与数据节点的配置项不会互相干扰。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注：计算节点必须配置 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;281:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt; dataSync = 0&lt;/codeph&gt; 。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;启动计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;启动计算节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;285:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;multi_machine_cluster_deployment.md&#34; xtrc=&#34;xref:3;285:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;集群安装模式&lt;/xref&gt;部署并启动 agent、controller 节点。启动完成后后，使用 web 启动计算节点。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:8;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图1-8&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/1_8.png&#34; width=&#34;50%&#34; xtrc=&#34;image:8;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;749&#34; dita-ot:image-height=&#34;376&#34;/&gt; &lt;/fig&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;架构设计&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;架构设计&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;计算节点的设计和硬件规划&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点的设计和硬件规划&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;296:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;依据上文解析，计算节点主要负责接收、响应请求以及内存计算，数据节点主要负责数据存储管理。在集群设计与规划时，生产环境最小硬件配置推荐如下：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;5&#34; xtrc=&#34;tgroup:2;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:5;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:6;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:7;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:8;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:9;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:21;298:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;组件&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:22;298:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;CPU&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:23;298:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;内存&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:24;298:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;网络&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:25;298:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;硬盘&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:26;300:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;datanode&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:27;300:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;8 核+&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:28;300:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;64GB+&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:29;300:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;10Gb 网卡&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:30;300:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;ssd/hdd，500GB+建议元数据存 ssd，分区数据存 hdd&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;301:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:31;301:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;computenode&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:32;301:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;16 核+&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:33;301:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;128GB+&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:34;301:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;10Gb 网卡&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:35;301:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;hdd,200GB&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;303:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点更注重 cpu、内存、网卡性能。而数据节点更注重 iops ，存储通道与容量。集群拓扑结构可根据应用场景与需求参考下文设计。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;单计算节点集群架构&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;单计算节点集群架构&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:9;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2-1&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_1.png&#34; width=&#34;50%&#34; xtrc=&#34;image:9;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;413&#34; dita-ot:image-height=&#34;251&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;单一的计算节点，可以做为请求统一入口。此时拓扑简单，部署方便。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;高可用计算节点集群架构&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;高可用计算节点集群架构&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:10;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2_2&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_2.png&#34; width=&#34;50%&#34; xtrc=&#34;image:10;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;551&#34; dita-ot:image-height=&#34;320&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 DolphinDB 数据库层面，部署多个计算节点，扩展集群计算容量，并实现高可用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;324:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;从计算节点发起 DFS 表读写请求时，可以容忍部分数据节点实例级别的故障（比如某个数据节点的服务器断电），其崩溃恢复策略如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;326:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;写&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;328:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;从计算节点写入数据时，如果某个数据节点发生了崩溃，事务管理器会回滚当前失败的事务。并以一个新的事务，重试数据写入，整个过程对于客户端程序是透明无感知的。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:11;331:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;331:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2_3&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_3.png&#34; width=&#34;60%&#34; xtrc=&#34;image:11;331:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;641&#34; dita-ot:image-height=&#34;187&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;336:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;读&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;338:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;DolphinDB 默认采用 2 副本（确保强一致性），当计算节点发现部分子任务失败时，会根据可用 chunk 副本的分布，重新调度新的 subTask 到对应数据节点中去，实现任务的崩溃恢复。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:12;341:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;341:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2_4&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_4.png&#34; width=&#34;60%&#34; xtrc=&#34;image:12;341:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;590&#34; dita-ot:image-height=&#34;187&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;346:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在中间件层面，可以引入负载均衡组件（如 haproxy，F5 等）来实现集群统一访问接口。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;流计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;流计算节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;生产环境中，流数据对时延要求非常高。在多人、多业务场景使用集群时，数据节点由于本身还是承担着数据读写操作，不可避免地在一定程度上影响流计算。在设计上，可以将流计算相关业务单独地部署至某计算节点实例。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:13;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2_5&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_5.png&#34; width=&#34;50%&#34; xtrc=&#34;image:13;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;258&#34; dita-ot:image-height=&#34;167&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图示，使用 computenode3 作为流计算节点，专门负责流计算业务。在另外两个计算节点上进行批量读写，通过计算节点之间的 Share-nothing 架构特性，有效保证流计算的低时延。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;基于计算节点实例的资源隔离&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;基于计算节点实例的资源隔离&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;362:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在生产环境中，若有多人同时使用 DolphinDB 集群，需要一定的资源隔离机制来保障核心业务稳定运行。可以在架构层面，配合负载均衡策略，实现基于计算节点的资源隔离。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:14;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图2_6&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/2_6.png&#34; width=&#34;50%&#34; xtrc=&#34;image:14;364:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;337&#34; dita-ot:image-height=&#34;216&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;以 haproxy 为例，在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;370:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;haproxy.cfg&lt;/i&gt; 中设置2个监听组&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;372:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;ddb-cluster：核心业务使用计算资源组，总共6000连接，2个计算节点，高可用。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;373:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;373:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;ad-hoc-single：用于即席查询的计算节点，配置为单节点，限制1000连接，用于分析师，研究员等对数据做一些探索和即席查询。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;375:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;listen ddb-cluster bind 0.0.0.0:5000 mode tcp balance leastconn server compute1 192.168.168.1:8961 maxconn 3000 check server compute2 192.168.168.1:8966 maxconn 3000 check listen ad-hoc-single bind 0.0.0.0:10090 mode tcp balance leastconn server compute3 192.168.168.1:8967 maxconn 1000 check&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;应用场景&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:33;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;应用场景&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;392:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;394:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;所有数据节点的计算任务、代码都可以无缝迁移到计算节点。集群管理与使用者应当避免直接访问数据节点，转而使用计算节点作为查询与写入的入口。具体演示数据读取、写入、流计算、机器学习。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;数据读取&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:34;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;数据读取&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;398:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;使用 python api 从计算节点读取某一只股票的历史交易数据。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;python&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;400:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;import DolphinDB as ddb def getData(date, securityID, rowNum=1000000): s = ddb.session() s.connect(&#34;computenode1&#34;, 8961, &#34;admin&#34;, &#34;123456&#34;) trade = s.loadTable(tableName=&#34;sztrade&#34;, dbPath=&#34;dfs://szstock) rst = trade.select(&#34;*&#34;).where(&#34;tradedate = %d&#34; % date)\ .where(&#34;securityID = '%s'&#34; % securityID) \ .where(&#34;execType=\&#34;F\&#34;&#34;)\ .limit(rowNum).toDF() s.close() return rst if __name__ == '__main__' : print(getData(20200102, &#34;000014&#34;))&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;数据写入&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:35;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;数据写入&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;420:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;将历史行情数据导入 DolphinDB ，具体操作请参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;stockdata_csv_import_demo.md&#34; xtrc=&#34;xref:4;420:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;国内股票行情数据导入实例&lt;/xref&gt;。导入 2020 年 1 月数据，共计 82G 数据时，集群计算节点，数据节点消耗情况如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;422:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;422:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;422:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cpu/memory&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:15;424:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:36;424:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图3_1&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/3_1.png&#34; width=&#34;80%&#34; xtrc=&#34;image:15;424:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1837&#34; dita-ot:image-height=&#34;332&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;429:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;io&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:16;431:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:37;431:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图3_2&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/3_2.png&#34; width=&#34;80%&#34; xtrc=&#34;image:16;431:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1852&#34; dita-ot:image-height=&#34;313&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在执行导入过程中，计算节点 cpu 均值在15%，峰值达到20%，内存消耗约2.8G。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;流计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:38;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;流计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;流计算的核心诉求是时延，如果采用数据节点作为流计算节点，必不可免地会受到分布式表读取与写入的影响。配置计算节点成为流计算节点，可以有效地保障 CPU，memory，io，worker 线程等软硬件资源服务于流计算，从而保证低时延。并且由于计算节点之间是互不影响的，推荐在架构上设计部分计算节点作为流计算节点，其他计算节点用于分析与查询。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;配置计算节点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:39;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;配置计算节点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;设计 CN1 作为流计算的订阅和发布节点，配置文件如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;# publish CN1.persistenceDir=/ssd/ssd0/persistDir/C1-CNODE1 CN1.persistenceWorkerNum=4 CN1.maxPubConnections=64 # subscribe CN1.maxSubConnections=64 CN1.subPort=8970 CN1.subExecutors=16&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;创建与订阅流数据表&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:40;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;创建与订阅流数据表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;461:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在计算节点 CN1 上创建流数据表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;t = streamTable(1:0, `sym`price, [STRING,DOUBLE]) enableTableShareAndPersistence(t, `tickStream)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;467:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;订阅并编写实时因子计算：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&amp;gt; result = table(1000:0, `sym`factor1, [STRING,DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;) subscribeTable(tableName=`tickStream, actionName=&#34;factors&#34;, offset=-1, handler=tableInsert{rse})&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;478:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;往 CN1 模拟写入消息（同时另一个计算节点 CN2 执行导入数据作业）&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;n = 2000000 data = table(take(&#34;000001.SH&#34;, n) as sym, rand(10.0, n) as price) tickStream.append!(data) getStreamingStat().subWorkers&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;486:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;查看集群的资源消耗情况：&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:17;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:41;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图3_3&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/3_3.png&#34; width=&#34;80%&#34; xtrc=&#34;image:17;488:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;855&#34; dita-ot:image-height=&#34;227&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;493:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;可以看到 CN2, DN1-3 在消耗相对较高的内存和 CPU 时，CN1 并没有受到数据导入的影响，使得流计算的时延得到有效保证。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;机器学习&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:42;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;机器学习&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;497:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;机器学习是计算密集型的场景，模型的训练过程会消耗大量的 CPU、内存资源。将机器学习的作业部署至某个计算节点，可以避免对数据写入、读取类任务的负面影响。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;498:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;def tranAdaBoost(TrainData){ db = database(,HASH, [SYMBOL, 10]) p10TranData = db.createPartitionedTable(table=TrainData, partitionColumns=`SecurityID) p10TranData.append!(TrainData) model = adaBoostRegressor(sqlDS(&amp;lt;select * from p10TranData&amp;gt;), yColName=`targetRV, xColNames=`BAS`DI0`DI1`DI2`DI3`DI4`Press`RV, numTrees=30, maxDepth=16, loss=`square) saveModel(model, &#34;/hdd/data/finance/model/adaBoost.txt&#34;) } jobId=&#34;adaBoost&#34; jobDesc=&#34;adaBoost train snap&#34; submitJob(jobId, jobDesc, tranAdaBoost, Train)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;512:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;完整代码及过程请参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;ml_volatility.md&#34; xtrc=&#34;xref:5;512:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;实时实际波动率预测&lt;/xref&gt; 。使用 10 个线程并行训练，加速训练过程。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:18;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:43;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图3_4&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/3_4.png&#34; width=&#34;80%&#34; xtrc=&#34;image:18;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;870&#34; dita-ot:image-height=&#34;227&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;519:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 CN2 训练过程中，其他节点资源未受影响。同时如果想加速机器学习训练过程，可以使用更多的线程，为 CN2 额外配置一些 CPU、内存资源，在资源管理上非常灵活。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;运维&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:44;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;运维&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;521:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;集群监控&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:45;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;集群监控&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;523:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;525:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;引入计算节点的集群，在运维监控层面，需要以存储与计算分离的架构来进行监控。对于数据节点、计算节点的监控侧重点不同。具体来说，计算节点需要关注客户端请求执行情况的相关性能：包括平均响应时间、连接数、内存、CPU 使用率、网卡带宽使用率等；而数据节点更需要关注磁盘空间、IOPS、读写 MB/s 等 IO 相关指标。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;监控软件部署&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;527:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:46;527:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;监控软件部署&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;527:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;529:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;通过部署第三方软件：Grafana，Prometheus 实现集群的管理与监控，具体流程参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;cluster_monitor.md&#34; xtrc=&#34;xref:6;529:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;集群监控&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;监控面板&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;531:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:47;531:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;监控面板&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;531:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;533:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;提供&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://grafana.com/grafana/dashboards/16194&#34; scope=&#34;external&#34; xtrc=&#34;xref:7;533:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;?ditaot usertext?&gt;计算节点与数据节点监控&lt;/xref&gt; dashboard，是基于存储与计算分离架构设计的一套监控面板。已上传至 Grafana 官方仓库， 可以在快速完成集群的运维监控部署工作。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;535:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;点击 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;535:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;Import&lt;/b&gt; -&amp;gt; 输入对应 dashboardID，点击 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;535:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;Load&lt;/b&gt; 即可完成导入。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:19;537:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:48;537:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_1&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4_1.png&#34; width=&#34;50%&#34; xtrc=&#34;image:19;537:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;899&#34; dita-ot:image-height=&#34;579&#34;/&gt; &lt;/fig&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;查询监控与session管理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:49;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;查询监控与SESSION管理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;542:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;session&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:50;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;session&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;544:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;546:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点监控的关键运行时参数主要是内存、连接数。如何避免个别 session 占用过多内存，而导致其他 session OOM，是运维管理上的重点。&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;548:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;548:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;内存管理&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;550:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在内存紧张时，通过 getSessionMemory 视图进行会话管理，回收空闲会话：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;551:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;select userId ,sessionId ,memSize/1024/1024 as MB ,localtime(createTime) as createTime ,localtime(lastActiveTime) as lastActiveTime ,(now() - localtime(lastActiveTime))/1000 as idleSeconds from getSessionMemoryStat() order by memSize desc&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;563:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;通过 closeSessions(sessionId) 来关闭对应会话并回收内存。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:20;565:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:51;565:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_2&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4_2.png&#34; width=&#34;60%&#34; xtrc=&#34;image:20;565:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;559&#34; dita-ot:image-height=&#34;166&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;571:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图示，test 用户已经空闲15分钟了，视情况可以关闭此 session，并回收1000MB的内存。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;573:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;573:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;连接管理&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;575:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 Linux 中，DolphinDB 的一个 connection 对应一个 TCP 连接。在物联网场景下，需要调整连接数（每个 tcp 连接消耗 4K 内存，对操作系统消耗不大），以应对高 QPS 需求，建议将计算节点的配置设置为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;575:123&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;maxConnections=5000&lt;/codeph&gt; 及以上。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; outputclass=&#34;cmd&#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;577:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;The number of incoming connections has reached the limit of 512&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;580:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;当日志出现以上信息时，说明连接已经不足，检查程序是否存在连接泄露的情况。应急处理请使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;580:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;closeSessions()&lt;/codeph&gt; 清理一些空闲会话以回收连接，并增加 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;580:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;maxConnections&lt;/i&gt; 。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;慢查询&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;582:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:52;582:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;慢查询&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;582:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;584:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;慢查询通常会引起系统雪崩，需要重点关注。DolphinDB 提供一个 job log 日志文件，记录 DFS 表相关查询日志，默认在 log 目录下，名称为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;584:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;nodeAlias_job.log&lt;/i&gt;。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;586:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;586:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;586:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;监控 top10 sql&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;588:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;jobLogFile = getConfig(`jobLogFile) queryLog = loadText(jobLogFile) select node ,userId ,sessionId ,jobDesc as sqlText ,startTime ,endTime ,(endTime$DATETIME - startTime$DATETIME ) as costSeconds from queryLog order by (endTime$DATETIME - startTime$DATETIME ) desc limit 10&lt;/codeblock&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:21;605:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:53;605:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_3&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4_3.png&#34; width=&#34;70%&#34; xtrc=&#34;image:21;605:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;998&#34; dita-ot:image-height=&#34;228&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;611:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;如图，根据 sqlText，userId，运行时间及时长，综合分析处置慢查询，比如限制一些用户进行较大规模的查询，以及对部分查询效率和速度较低的 SQL 语句进行优化。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;参数设置&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:33;613:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:54;613:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;参数设置&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:33;613:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;615:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点不需要设置 DFS 表存储相关的参数，包括：&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;615:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;volumes&lt;/i&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;615:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;chunkCacheEngineMemSize&lt;/i&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;615:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;tsdbCacheEngineSize&lt;/i&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;615:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;redoLogDir&lt;/i&gt; 等。计算节点的核心参数包括：&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;615:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;MaxMemSize&lt;/i&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;615:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;MaxConnections&lt;/i&gt;, &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;615:147&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;workerNum&lt;/i&gt;, *maxQueryResultLimit *等。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;计算节点扩缩容&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:34;617:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:55;617:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点扩缩容&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:34;617:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;619:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;相比于数据节点，计算节点扩缩容非常简单快捷，支持在线扩缩容。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;扩容&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:35;621:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:56;621:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;扩容&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:35;621:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:2;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;623:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;623:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在新机器上部署和配置 agent&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;625:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;拷贝原机器上的 agent 部署包到新机器，并修改 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:14;625:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;agent.cfg&lt;/i&gt;，如&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;626:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;mode=agent workerNum=4 localSite=192.192.168.4:8950:C4-agent controllerSite=192.192.168.4:8990:controller3 sites=192.192.168.4:8950:C4-agent:agent,192.192.168.2:8990:controller1:controller,192.192.168.3:8990:controller2:controller,192.192.168.4:8990:controller3:controller lanCluster=0&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;634:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;634:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注意&lt;/b&gt;：主要修改新机器上代理节点的 IP 和端口，以及控制节点集群的 IP 和端口。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;636:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;636:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 web 集群管理界面修改 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;636:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;Nodes Setup&lt;/codeph&gt; 配置，新增 computenode 和 agent。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:22;638:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:57;638:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_4&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4_4.png&#34; width=&#34;70%&#34; xtrc=&#34;image:22;638:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1055&#34; dita-ot:image-height=&#34;699&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;643:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;643:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注意&lt;/b&gt;：在添加完每个节点的信息之后，切记点一下该行最后的 +（加号），确保添加成功。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;645:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;645:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 server/ 目录下面执行如下命令，启动新节点的 agent&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;646:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;nohup ./DolphinDB -console 0 -mode agent -home data -config config/agent.cfg -logFile log/agent.log &amp;amp;&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;649:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;649:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;重启 controller 节点使配置生效&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:100;651:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;回到 web 管理界面，可以看到已经新增了一个 agent4 并且是未启动状态。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:23;653:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:58;653:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_5&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4.4.1.4_1.png&#34; width=&#34;70%&#34; xtrc=&#34;image:23;653:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1725&#34; dita-ot:image-height=&#34;775&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:101;658:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:9;658:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注意&lt;/b&gt;：代理节点的信息需要在重启集群的controller节点之后才能显示出来，数据节点和计算节点在添加完之后刷新页面就可以观察到。&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:24;660:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:59;660:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_6&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4.4.1.4_2.png&#34; width=&#34;70%&#34; xtrc=&#34;image:24;660:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1725&#34; dita-ot:image-height=&#34;775&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;665:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:102;665:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;启动新计算节点&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:25;667:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:60;667:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_7&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4.4.1.5.png&#34; width=&#34;70%&#34; xtrc=&#34;image:25;667:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1756&#34; dita-ot:image-height=&#34;812&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt; &lt;/fig&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;672:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:103;672:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;进入新增计算机节点 web 页面，执行查询命令，检查新增数据节点是否能够正常工作&lt;/p&gt;&lt;fig align=&#34;left&#34; class=&#34;- topic/fig &#34; xtrc=&#34;fig:26;674:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:61;674:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;图4_8&lt;/title&gt; &lt;image class=&#34;- topic/image &#34; href=&#34;images/Compute_Node/4.4.1.6.png&#34; width=&#34;70%&#34; xtrc=&#34;image:26;674:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34; dita-ot:image-width=&#34;1369&#34; dita-ot:image-height=&#34;888&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt; &lt;/fig&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:104;679:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:10;679:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注意&lt;/b&gt;：新计算节点命名应遵守部署文档中提到的命名规则，以确保 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:15;679:39&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;cluster.cfg&lt;/i&gt; 能赋予新的计算节点正确的配置。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;缩容&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:36;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:62;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;缩容&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:36;681:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:3;683:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;683:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:105;683:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;停止计算节点&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:106;685:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 web 集群管理页面停止对应计算节点，等待其安全关闭，通常需要数秒。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;687:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:107;687:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;修改集群配置&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:108;689:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;689:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;nodes Setup&lt;/codeph&gt; 中删除对应的 computenode 节点。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:109;691:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:11;691:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;注意&lt;/b&gt;：执行完上述操作之后，页面的计算节点信息并不会消失，需要重启集群的控制节点才会消失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:37;693:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:63;693:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:37;693:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:110;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/Compute_Node.md&#34;&gt;计算节点不存储分布式数据，使用计算节点可以有效地提升集群的写入稳定性，缩短故障修复时间。计算节点之间相互隔离，架构设计者可根据应用场景，灵活地部署业务至各计算节点。推荐将流计算、机器学习部署至计算节点。在运维管理上，计算节点可以快速重启、方便地在线扩缩容。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/Compute_Node.md"/><meta name="wh-out-relpath" content="tutorials/Compute_Node.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="使用计算节点" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="chap7_tutorials_system_management"><div class="title"><a href="../sys_man/om_intro.html"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li><div class="topicref" data-id="cluster_manage"><div class="title"><a href="../sys_man/cluster_manage.html">集群管理</a></div></div></li><li class="active"><div class="topicref" data-id="使用计算节点"><div class="title"><a href="../tutorials/Compute_Node.html">使用计算节点</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="true"><div data-tocid="cluster_manage-d9713e7993" class="topicref" data-id="cluster_manage" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action cluster_manage-d9713e7993-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/cluster_manage.html" id="cluster_manage-d9713e7993-link">集群管理</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="集群扩容-d9713e8039" class="topicref" data-id="集群扩容" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scale_out_cluster.html" id="集群扩容-d9713e8039-link">集群扩容</a></div></div></li><li role="treeitem" class="active"><div data-tocid="使用计算节点-d9713e8085" class="topicref" data-id="使用计算节点" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Compute_Node.html" id="使用计算节点-d9713e8085-link">使用计算节点</a></div></div></li><li role="treeitem"><div data-tocid="高可用集群的灰度升级-d9713e8131" class="topicref" data-id="高可用集群的灰度升级" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/gray_scale_upgrade_ha.html" id="高可用集群的灰度升级-d9713e8131-link">高可用集群的灰度升级</a></div></div></li><li role="treeitem"><div data-tocid="使用-haproxy-实现负载均衡-d9713e8177" class="topicref" data-id="使用-haproxy-实现负载均衡" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haProxy_best_practices.html" id="使用-haproxy-实现负载均衡-d9713e8177-link">使用 HAProxy 实现负载均衡</a></div></div></li><li role="treeitem"><div data-tocid="multi_cluster_management-d9713e8223" class="topicref" data-id="multi_cluster_management" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/multi_cluster_management.html" id="multi_cluster_management-d9713e8223-link">多集群管理</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e8269" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e8269-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/thread_intro.html" id="tocId-d9713e8269-link">任务管理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454" class="topicref" data-id="e6_97_a0_e6_a0_87_e9_a2_9810" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/e6_97_a0_e6_a0_87_e9_a2_9810.html" id="e6_97_a0_e6_a0_87_e9_a2_9810-d9713e8454-link">登录管理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="性能监控-d9713e8546" class="topicref" data-id="性能监控" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 性能监控-d9713e8546-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/perf_man.html" id="性能监控-d9713e8546-link"><span class="keyword label">运维监控</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e8639" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e8639-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/bak_resto.html" id="tocId-d9713e8639-link">安全与容灾</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">使用计算节点</h1><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">导读</strong></p><p class="- topic/p p">为了提升 DolphinDB 在高并发读写场景下的性能与稳定性，DolphinDB 在架构上引入了计算节点 （compute node） 。计算节点接管了数据节点的部分职能，负责响应客户端的请求并返回结果。在架构层面，将集群的计算与存储进行分离，保证数据节点的软硬件资源有效服务于 IO 过程，从而提升集群写入性能与稳定性。同时 DolphinDB 集群管理者可以根据业务需求和集群负载情况，对计算资源和存储资源独立扩展。</p><p class="- topic/p p">本教程将重点介绍计算节点的特性、架构设计、应用实践及运维管理等方面内容，通过原理解析、案例分析来讲解如何部署和使用计算节点。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">面向读者</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">架构师（1-5章）</li><li class="- topic/li li">DolphinDB DBA（第1、2、4章）</li><li class="- topic/li li">开发工程师 （第1、3章）</li><li class="- topic/li li">运维工程师 （第1、4章）</li></ul></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="概览"><h2 class="- topic/title title topictitle2" id="ariaid-title2">概览</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="为什么引入计算节点"><h3 class="- topic/title title topictitle3" id="ariaid-title3">为什么引入计算节点</h3><div class="- topic/body body"><p class="- topic/p p">数据节点可以同时承担计算任务和数据读写任务的执行，对于一些计算任务不重的场景来说，数据节点兼任计算任务没有问题，但是对于计算逻辑较复杂，并发度较高的计算密集场景下，可能会有以下影响：</p><ul class="- topic/ul ul"><li class="- topic/li li">对于数据写入的影响：由于密集计算任务会大量消耗 CPU 和内存资源，而数据写入时需要 CPU 来进行数据的预处理和压缩，因此会影响数据写入性能。</li><li class="- topic/li li">对于数据读取的影响: 若大量内存被计算任务占用，那么读取数据时，可能因内存不足导致 OOM 异常。</li></ul><p class="- topic/p p">DolphinDB 自版本1.30.14，2.00.1开始支持计算节点，能够有效地解决上述问题。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="计算节点简介"><h3 class="- topic/title title topictitle3" id="ariaid-title4">计算节点简介</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title5" id="核心特性"><h4 class="- topic/title title topictitle4" id="ariaid-title5">核心特性</h4><div class="- topic/body body"><p class="- topic/p p">计算节点，顾名思义，即执行计算任务的节点，相比于数据节点，有以下2个核心特性：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">不存储分布式表数据</strong></p><p class="- topic/p p">不存储分布式表数据、元数据文件，是一个轻状态的服务组件。计算节点的启停流程十分精简，任何故障都可以通过重启节点来进行快速修复。同时，计算节点可以进行快速地<a class="- topic/xref xref" href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E6%89%A9%E7%BC%A9%E5%AE%B9">扩缩容</a>。</p><p class="- topic/p p">如下图所示 3 个数据节点、3 个计算节点的集群：</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 1</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">1-1</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/1_1.png"/><br/>  
      
    </figure><p class="- topic/p p">图中 C1-CNODE1 至 C1-CNODE3 为计算节点，P1-DNODE1 至 P3-DNODE1 为数据节点。</p><p class="- topic/p p">从文件系统来简单验证下计算节点的无状态特性。查看数据节点 volume 配置：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code># 查看存储卷
select * from pnodeRun(getConfig{`volumes})
P1-DNODE1    /ssd/ssd0/wfHuang/volumes/P1-DNODE1
P2-DNODE1    /ssd/ssd0/wfHuang/volumes/P2-DNODE1
P3-DNODE1    /ssd/ssd0/wfHuang/volumes/P3-DNODE1</code></pre><p class="- topic/p p">到操作系统去查看数据节点 P1-DNODE1 的 volume 目录：</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 2</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-2</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/1_2.png"/><br/>  
      
    </figure><p class="- topic/p p">可看到 P1-DNODE1 作为数据节点，管理着事务 undo/redo 日志文件，和大量的数据块 CHUNKS 文件。但计算节点不需要配置 volume, 查看 C1-CNODE1 的默认 data 目录：</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 3</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-3</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/1_3.png"/><br/>  
      
    </figure><p class="- topic/p p">可以看到计算节点 C1-CNODE1 不存储任何的分布式数据文件。</p></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">负责计算</strong></p><p class="- topic/p p">在分布式表读写场景中，由数据节点负责 map 阶段，计算节点负责 merge-reduce 阶段（详见<a class="- topic/xref xref" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9">通过一个-sql-查询理解计算节点</a>）。在纯内存对象（常规内存表、分区内存表、流数据表等）计算场景中，由计算节点独立执行。</p><p class="- topic/p p">执行一个分布式表查询 SQL，从文件层面来观察计算节点在数据查询发挥的作用。</p><p class="- topic/p p">查看计算节点 C1-CNODE1 打开的文件（<em class="+ topic/ph hi-d/i ph i">open files</em>）：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>[appadmin@compute volumes]$ lsof -p pidOfComputenode
skip library files
compute_w 38563 appadmin   19u     IPv4 319181009       0t0       TCP compute:8961-&gt;192.192.168.2:56780 (ESTABLISHED)
compute_w 38563 appadmin   20u     IPv4 319103550       0t0       TCP compute:8961-&gt;192.192.168.2:56786 (ESTABLISHED)
compute_w 38563 appadmin   22u     IPv4 319095550       0t0       TCP compute:8961-&gt;192.192.168.2:34842 (ESTABLISHED)
...skip 20 lines......
compute_w 38563 appadmin   44u     IPv4 319337513       0t0       TCP compute:42566-&gt;192.192.168.2:8961 (ESTABLISHED)</code></pre><p class="- topic/p p">查看数据节点 P1-DNODE1 打开的文件：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>[appadmin@support4 log]$ lsof -p pidOfDatanode
compute_w 99763 appadmin   33u     IPv4 49451766       0t0       TCP support4:8961-&gt;192.192.168.1:42474 (ESTABLISHED)
compute_w 99763 appadmin   36u     IPv4 49455618       0t0       TCP support4:8961-&gt;192.192.168.1:42562 (ESTABLISHED)
compute_w 99763 appadmin   39r      REG     8,17 272358102 177313580 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220102/hQE/machines_2/1_00000058
compute_w 99763 appadmin   40r      REG     8,17 272358117 177313646 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220106/hQE/machines_2/1_00000062
compute_w 99763 appadmin   41r      REG     8,17 272358131 177313802 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220227/hQE/machines_2/1_00000072
compute_w 99763 appadmin   42r      REG     8,17 272358111 177313644 /ssd/ssd0/wfHuang/volumes/P1-DNODE1/CHUNKS/test_compute/20220109/hQE/machines_2/1_00000060
......skip hundreds of lines......</code></pre><p class="- topic/p p">可以观察到计算节点 C1-CNODE1 打开了大量的 TCP 连接符，而数据节点 P1-DNODE1 除了 TCP 连接符外，还打开了大量的磁盘文件。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 4</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-4</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/1_4.png"/><br/>  
      
    </figure><p class="- topic/p p">如上图所示，计算节点 computenode1 负责解析 client 的请求，并协调数据节点 datanode[1-3] 读/写数据（即 map，分布式执行过程）。接收到 datanode[1-3] 的数据后，经过 reduce-merge 过程，将最终结果返回给客户端。存算分离的架构，使得数据节点的物理资源得到隔离，写入和读取数据更为稳定、高效。</p></li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title6" id="通过一个-sql-查询理解计算节点"><h4 class="- topic/title title topictitle4" id="ariaid-title6">通过一个 SQL 查询理解计算节点</h4><div class="- topic/body body"><p class="- topic/p p">当客户端向计算节点发起一个 sql 查询：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>pt1 = loadTable(database("dfs://szstock"),"sztrade")  
select [HINT_EXPLAIN]
    securityID, min(price) as LowPx, max(price) as HighPx, sum(tradeQty) as vol
    , first(price) as OpenPx, last(price) as LastPx, sum(tradeQty * price) as val
from pt
where execType="F"
group by tradedate,securityID,minute(temporalParse(tradetime$STRING, "yyyyMMddHHmmssSSS")) as minute
order by tradedate,securityID, minute</code></pre><p class="- topic/p p">通过 <code class="+ topic/ph pr-d/codeph ph codeph">[HINT_EXPLAIN]</code> 获取执行计划，整个 sql 的执行过程依次为 parse，map，merge，reduce 四个部分。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>{
    "measurement": "microsecond",
    "explain": {
        "from": {
            "cost": 2
        },
        "map": {
            "partitions": {
                "local": 0,
                "remote": 320
            },
            "cost": 5189927,
            "detail": {
...skip many lines...
        },
        "merge": {
            "cost": 446588,
            "rows": 8522241,
            "detail": {
 ...skip many lines...
                }
            }
        },
        "reduce": {
            "sql": "select [98307] * from 702a9832b17f0000 order by tradedate asc,securityID asc,minute asc",
            "explain": {
                "sort": {
                    "cost": 296783
                },
                "rows": 8522241,
                "cost": 746374
            }
        },
        "rows": 8522241,
        "cost": 6691112
    }
}</code></pre><p class="- topic/p p">其中，query parse、merge、reduce 过程发生在计算节点，map 阶段则并行发生于各数据节点。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 5</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-5</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/1_5.png"/><br/>  
  
</figure><p class="- topic/p p">整个执行过程消耗资源具体如下表。</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="通过一个-sql-查询理解计算节点__entry__1">执行步骤</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="通过一个-sql-查询理解计算节点__entry__2">发生节点</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="通过一个-sql-查询理解计算节点__entry__3">消耗资源</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="通过一个-sql-查询理解计算节点__entry__4">时间(us)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__1">query parse</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__2">computenode</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__3">cpu</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__4">2</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__1">map</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__2">datanode * 3</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__3">IO, network，cpu, memory</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__4">5189927</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__1">merge</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__2">computenode</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__3">cpu，network, memory</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__4">446588</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__1">reduce</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__2">computenode</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__3">cpu，network, memory</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="通过一个-sql-查询理解计算节点__entry__4">746374</td></tr></tbody></table></div><p class="- topic/p p">该 SQL 总共涉及 300 个分区，各分区记录数在 60-280 万不等。merge-reduce 阶段分布处理了 850 万的数据。由 C1-CNODE1 承担的 merge-reduce 阶段总耗时占比为</p><p class="- topic/p p">（446588 + 746374）/ 6691112 = 17.8%</p><p class="- topic/p p">上述例子 map 阶段 where，group by 算子大大减少了数据量，因此计算节点的算量不大，如果是读取数据类的场景，比如数据导入导出，此比例会大大增加。</p><p class="- topic/p p">执行过程中，计算节点与数据节点的内存消耗情况如下图所示（node33：计算节点，node34-36：数据节点，下同）。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 6</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-6</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/1_6.png"/><br/>  
  
</figure><p class="- topic/p p">可以看出在 map 阶段在数据节点，是分布式、并行执行的。在 merge-reduce 过程中计算节点的内存消耗逐渐增加。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="引入计算节点的好处"><h3 class="- topic/title title topictitle3" id="ariaid-title7">引入计算节点的好处</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="保证写入数据的稳定性"><h4 class="- topic/title title topictitle4" id="ariaid-title8">保证写入数据的稳定性</h4><div class="- topic/body body"><p class="- topic/p p">在数据节点上执行复杂业务计算（如因子计算、机器学习等），会占用大量的内存。使得 cacheEngine 无法获取足够多的内存，而发生 cacheEngine 内存溢出等问题，导致写入延迟，甚至失败。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>ChunkCacheEngine can't reclaim any memory after trying 13 times.

Transation failed, cacheEngine out of memory.</code></pre><p class="- topic/p p">另外，使用 TSDB 引擎，数据刷盘时需进行排序，需要消耗大量的 CPU 资源以及排序 buffer。若 CPU 、内存资源不足时，TSDB 的写入性能会下降。</p><p class="- topic/p p">通过在架构上引入计算节点，采用计算与存储分离的架构设计，可以有效地保证集群数据写入的稳定性。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="降低故障平均修复时间"><h4 class="- topic/title title topictitle4" id="ariaid-title9">降低故障平均修复时间</h4><div class="- topic/body body"><p class="- topic/p p">使用计算节点的集群能显著地降低故障平均修复时间，尽可能地减少对业务的影响。核心原因是由于计算节点不管理分布式数据，重启可以在数秒内完成。当某个计算节点出现拥塞、无法响应等情况，且无法热修复的，重启即可使其恢复正常服务。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 7</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-7：启动流程对比</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/1_7.png"/><br/>  
  
</figure><p class="- topic/p p">如图，当数据节点启动时，流程中的蓝色标记部分：“回放 redo 日志”，“恢复损坏的 chunk” 等包含了大量的 IO 操作，实际生产环境中耗时为分钟级（具体视数据量大小而定）。而计算节点流程十分精简，可以在秒级完成启动。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="计算节点安装"><h3 class="- topic/title title topictitle3" id="ariaid-title10">计算节点安装</h3><div class="- topic/body body"><p class="- topic/p p">现用如下 4 台服务器部署集群：</p><ul class="- topic/ul ul"><li class="- topic/li li">P1: 192.193.168.2</li><li class="- topic/li li">P2: 192.193.168.3</li><li class="- topic/li li">P3: 192.193.168.4</li><li class="- topic/li li">C1: 192.193.168.1</li></ul><p class="- topic/p p">其中服务器 P1-P3 用于部署数据节点，C1 用于部署计算节点。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="编写配置文件"><h4 class="- topic/title title topictitle4" id="ariaid-title11">编写配置文件</h4><div class="- topic/body body"><p class="- topic/p p">在节点列表文件 <em class="+ topic/ph hi-d/i ph i">cluster.nodes</em> 中编写计算节点及代理节点。推荐计算节点以 CN (取 compute node 首字母) 标识，数据节点以 DN (取 datanode 首字母) 标识，如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>localSite,mode
192.193.168.2:8990:controller1,controller
192.193.168.3:8990:controller2,controller
192.193.168.4:8990:controller3,controller
192.193.168.2:8960:P1-agent,agent
192.193.168.3:8960:P2-agent,agent
192.193.168.4:8960:P3-agent,agent
192.193.168.1:8960:C1-agent,agent
192.193.168.2:8961:DN1,datanode
192.193.168.3:8961:DN2,datanode
192.193.168.4:8961:DN3,datanode
192.193.168.1:8961:CN1,computenode
192.193.168.1:8966:CN2,computenode
192.193.168.1:8967:CN3,computenode</code></pre><p class="- topic/p p">在配置文件 <em class="+ topic/ph hi-d/i ph i">cluster.cfg</em> 中，需要使用前缀来区分数据节点与计算节点的配置项。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>CN%.workerNum=64
CN%.maxConnections=3000
CN%.maxMemSize=256
CN%.dataSync=0
DN%.maxConnections=512
DN%.maxMemSize=128
DN%.workerNum=32
DN%.chunkCacheEngineMemSize=6
DN%.dataSync=1
DN%.redoLogDir=/ssd/ssd0/wfHuang/volumes/redoLog
DN%.volumes=/ssd/ssd0/wfHuang/volumes,/ssd/ssd1/wfHuang/volumes,/ssd/ssd2/wfHuang/volumes</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">CN%</code> 匹配 CN 开头的计算节点，<code class="+ topic/ph pr-d/codeph ph codeph">DN%</code> 匹配 DN 开头的数据节点。以此保证计算节点与数据节点的配置项不会互相干扰。</p><p class="- topic/p p">注：计算节点必须配置 <code class="+ topic/ph pr-d/codeph ph codeph"> dataSync = 0</code> 。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="启动计算节点"><h4 class="- topic/title title topictitle4" id="ariaid-title12">启动计算节点</h4><div class="- topic/body body"><p class="- topic/p p">参考<a class="- topic/xref xref" href="multi_machine_cluster_deployment.html">集群安装模式</a>部署并启动 agent、controller 节点。启动完成后后，使用 web 启动计算节点。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 8</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图1-8</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/1_8.png"/><br/>  
  
</figure></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="架构设计"><h2 class="- topic/title title topictitle2" id="ariaid-title13">架构设计</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="计算节点的设计和硬件规划"><h3 class="- topic/title title topictitle3" id="ariaid-title14">计算节点的设计和硬件规划</h3><div class="- topic/body body"><p class="- topic/p p">依据上文解析，计算节点主要负责接收、响应请求以及内存计算，数据节点主要负责数据存储管理。在集群设计与规划时，生产环境最小硬件配置推荐如下：</p><div class="table-container"><table class="- topic/table table" data-cols="5"><caption></caption><colgroup><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="计算节点的设计和硬件规划__entry__1">组件</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="计算节点的设计和硬件规划__entry__2">CPU</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="计算节点的设计和硬件规划__entry__3">内存</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="计算节点的设计和硬件规划__entry__4">网络</th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="计算节点的设计和硬件规划__entry__5">硬盘</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__1">datanode</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__2">8 核+</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__3">64GB+</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__4">10Gb 网卡</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__5">ssd/hdd，500GB+建议元数据存 ssd，分区数据存 hdd</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__1">computenode</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__2">16 核+</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__3">128GB+</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__4">10Gb 网卡</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="计算节点的设计和硬件规划__entry__5">hdd,200GB</td></tr></tbody></table></div><p class="- topic/p p">计算节点更注重 cpu、内存、网卡性能。而数据节点更注重 iops ，存储通道与容量。集群拓扑结构可根据应用场景与需求参考下文设计。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="单计算节点集群架构"><h3 class="- topic/title title topictitle3" id="ariaid-title15">单计算节点集群架构</h3><div class="- topic/body body"><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 9</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2-1</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/2_1.png"/><br/>  
  
</figure><p class="- topic/p p">单一的计算节点，可以做为请求统一入口。此时拓扑简单，部署方便。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="高可用计算节点集群架构"><h3 class="- topic/title title topictitle3" id="ariaid-title16">高可用计算节点集群架构</h3><div class="- topic/body body"><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 10</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2_2</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/2_2.png"/><br/>  
  
</figure><p class="- topic/p p">在 DolphinDB 数据库层面，部署多个计算节点，扩展集群计算容量，并实现高可用。</p><p class="- topic/p p">从计算节点发起 DFS 表读写请求时，可以容忍部分数据节点实例级别的故障（比如某个数据节点的服务器断电），其崩溃恢复策略如下：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">写</p><p class="- topic/p p">从计算节点写入数据时，如果某个数据节点发生了崩溃，事务管理器会回滚当前失败的事务。并以一个新的事务，重试数据写入，整个过程对于客户端程序是透明无感知的。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 11</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2_3</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/2_3.png"/><br/>  
      
    </figure></li><li class="- topic/li li"><p class="- topic/p p">读</p><p class="- topic/p p">DolphinDB 默认采用 2 副本（确保强一致性），当计算节点发现部分子任务失败时，会根据可用 chunk 副本的分布，重新调度新的 subTask 到对应数据节点中去，实现任务的崩溃恢复。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 12</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2_4</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/2_4.png"/><br/>  
      
    </figure><p class="- topic/p p">在中间件层面，可以引入负载均衡组件（如 haproxy，F5 等）来实现集群统一访问接口。</p></li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="流计算节点"><h2 class="- topic/title title topictitle2" id="ariaid-title17">流计算节点</h2><div class="- topic/body body"><p class="- topic/p p">生产环境中，流数据对时延要求非常高。在多人、多业务场景使用集群时，数据节点由于本身还是承担着数据读写操作，不可避免地在一定程度上影响流计算。在设计上，可以将流计算相关业务单独地部署至某计算节点实例。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 13</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2_5</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/2_5.png"/><br/>  
  
</figure><p class="- topic/p p">图示，使用 computenode3 作为流计算节点，专门负责流计算业务。在另外两个计算节点上进行批量读写，通过计算节点之间的 Share-nothing 架构特性，有效保证流计算的低时延。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title18" id="基于计算节点实例的资源隔离"><h2 class="- topic/title title topictitle2" id="ariaid-title18">基于计算节点实例的资源隔离</h2><div class="- topic/body body"><p class="- topic/p p">在生产环境中，若有多人同时使用 DolphinDB 集群，需要一定的资源隔离机制来保障核心业务稳定运行。可以在架构层面，配合负载均衡策略，实现基于计算节点的资源隔离。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 14</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图2_6</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/2_6.png"/><br/>  
  
</figure><p class="- topic/p p">以 haproxy 为例，在 <em class="+ topic/ph hi-d/i ph i">haproxy.cfg</em> 中设置2个监听组</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">ddb-cluster：核心业务使用计算资源组，总共6000连接，2个计算节点，高可用。</p></li><li class="- topic/li li"><p class="- topic/p p">ad-hoc-single：用于即席查询的计算节点，配置为单节点，限制1000连接，用于分析师，研究员等对数据做一些探索和即席查询。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>listen ddb-cluster
   bind 0.0.0.0:5000
   mode tcp
   balance leastconn
   server compute1 192.168.168.1:8961 maxconn 3000 check
   server compute2 192.168.168.1:8966 maxconn 3000 check

listen ad-hoc-single
   bind 0.0.0.0:10090
   mode tcp
   balance leastconn
   server compute3 192.168.168.1:8967 maxconn 1000 check</code></pre></li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="应用场景"><h2 class="- topic/title title topictitle2" id="ariaid-title19">应用场景</h2><div class="- topic/body body"><p class="- topic/p p">所有数据节点的计算任务、代码都可以无缝迁移到计算节点。集群管理与使用者应当避免直接访问数据节点，转而使用计算节点作为查询与写入的入口。具体演示数据读取、写入、流计算、机器学习。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title20" id="数据读取"><h3 class="- topic/title title topictitle3" id="ariaid-title20">数据读取</h3><div class="- topic/body body"><p class="- topic/p p">使用 python api 从计算节点读取某一只股票的历史交易数据。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">import</strong> DolphinDB <strong class="hl-keyword">as</strong> ddb

<strong class="hl-keyword">def</strong> getData(date, securityID, rowNum=<span class="hl-number">1000000</span>):
    s = ddb.session()
    s.connect(<span class="hl-string">"computenode1"</span>, <span class="hl-number">8961</span>, <span class="hl-string">"admin"</span>, <span class="hl-string">"123456"</span>)
    trade = s.loadTable(tableName=<span class="hl-string">"sztrade"</span>, dbPath=<span class="hl-string">"dfs://szstock)
</span>    rst = trade.select(<span class="hl-string">"*"</span>).where(<span class="hl-string">"tradedate = %d"</span> % date)\
        .where(<span class="hl-string">"securityID = '%s'"</span> % securityID) \
        .where(<span class="hl-string">"execType=\"F\""</span>)\
        .limit(rowNum).toDF()
    s.close()
    <strong class="hl-keyword">return</strong> rst

<strong class="hl-keyword">if</strong> __name__ == <span class="hl-string">'__main__'</span> :
    <strong class="hl-keyword">print</strong>(getData(<span class="hl-number">20200102</span>, <span class="hl-string">"000014"</span>))</pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="数据写入"><h3 class="- topic/title title topictitle3" id="ariaid-title21">数据写入</h3><div class="- topic/body body"><p class="- topic/p p">将历史行情数据导入 DolphinDB ，具体操作请参考<a class="- topic/xref xref" href="stockdata_csv_import_demo.html">国内股票行情数据导入实例</a>。导入 2020 年 1 月数据，共计 82G 数据时，集群计算节点，数据节点消耗情况如下：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">cpu/memory</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 15</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图3_1</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/3_1.png"/><br/>  
      
    </figure></li><li class="- topic/li li"><p class="- topic/p p">io</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 16</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图3_2</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/3_2.png"/><br/>  
      
    </figure></li></ul><p class="- topic/p p">在执行导入过程中，计算节点 cpu 均值在15%，峰值达到20%，内存消耗约2.8G。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title22" id="流计算"><h2 class="- topic/title title topictitle2" id="ariaid-title22">流计算</h2><div class="- topic/body body"><p class="- topic/p p">流计算的核心诉求是时延，如果采用数据节点作为流计算节点，必不可免地会受到分布式表读取与写入的影响。配置计算节点成为流计算节点，可以有效地保障 CPU，memory，io，worker 线程等软硬件资源服务于流计算，从而保证低时延。并且由于计算节点之间是互不影响的，推荐在架构上设计部分计算节点作为流计算节点，其他计算节点用于分析与查询。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title23" id="配置计算节点"><h3 class="- topic/title title topictitle3" id="ariaid-title23">配置计算节点</h3><div class="- topic/body body"><p class="- topic/p p">设计 CN1 作为流计算的订阅和发布节点，配置文件如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code># publish
CN1.persistenceDir=/ssd/ssd0/persistDir/C1-CNODE1
CN1.persistenceWorkerNum=4
CN1.maxPubConnections=64

# subscribe 
CN1.maxSubConnections=64
CN1.subPort=8970
CN1.subExecutors=16</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="创建与订阅流数据表"><h3 class="- topic/title title topictitle3" id="ariaid-title24">创建与订阅流数据表</h3><div class="- topic/body body"><p class="- topic/p p">在计算节点 CN1 上创建流数据表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = streamTable(1:0, `sym`price, [STRING,DOUBLE])
enableTableShareAndPersistence(t, `tickStream)</code></pre><p class="- topic/p p">订阅并编写实时因子计算：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&gt;
result = table(1000:0, `sym`factor1, [STRING,DOUBLE])
rse = createReactiveStateEngine(name="reactiveDemo", metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn="sym")
subscribeTable(tableName=`tickStream, actionName="factors", offset=-1, handler=tableInsert{rse})</code></pre><p class="- topic/p p">往 CN1 模拟写入消息（同时另一个计算节点 CN2 执行导入数据作业）</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 2000000
data = table(take("000001.SH", n) as sym, rand(10.0, n) as price)
tickStream.append!(data)
getStreamingStat().subWorkers</code></pre><p class="- topic/p p">查看集群的资源消耗情况：</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 17</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图3_3</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/3_3.png"/><br/>  
  
</figure><p class="- topic/p p">可以看到 CN2, DN1-3 在消耗相对较高的内存和 CPU 时，CN1 并没有受到数据导入的影响，使得流计算的时延得到有效保证。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title25" id="机器学习"><h2 class="- topic/title title topictitle2" id="ariaid-title25">机器学习</h2><div class="- topic/body body"><p class="- topic/p p">机器学习是计算密集型的场景，模型的训练过程会消耗大量的 CPU、内存资源。将机器学习的作业部署至某个计算节点，可以避免对数据写入、读取类任务的负面影响。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def tranAdaBoost(TrainData){
	db = database(,HASH, [SYMBOL, 10])
	p10TranData = db.createPartitionedTable(table=TrainData, partitionColumns=`SecurityID)
	p10TranData.append!(TrainData)
	model = adaBoostRegressor(sqlDS(&lt;select * from p10TranData&gt;), yColName=`targetRV, xColNames=`BAS`DI0`DI1`DI2`DI3`DI4`Press`RV, numTrees=30, maxDepth=16, loss=`square)
	saveModel(model, "/hdd/data/finance/model/adaBoost.txt")
}

jobId="adaBoost" 
jobDesc="adaBoost train snap"
submitJob(jobId, jobDesc, tranAdaBoost, Train)</code></pre><p class="- topic/p p">完整代码及过程请参考<a class="- topic/xref xref" href="ml_volatility.html">实时实际波动率预测</a> 。使用 10 个线程并行训练，加速训练过程。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 18</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图3_4</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/3_4.png"/><br/>  
  
</figure><p class="- topic/p p">在 CN2 训练过程中，其他节点资源未受影响。同时如果想加速机器学习训练过程，可以使用更多的线程，为 CN2 额外配置一些 CPU、内存资源，在资源管理上非常灵活。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title26" id="运维"><h2 class="- topic/title title topictitle2" id="ariaid-title26">运维</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title27" id="集群监控"><h3 class="- topic/title title topictitle3" id="ariaid-title27">集群监控</h3><div class="- topic/body body"><p class="- topic/p p">引入计算节点的集群，在运维监控层面，需要以存储与计算分离的架构来进行监控。对于数据节点、计算节点的监控侧重点不同。具体来说，计算节点需要关注客户端请求执行情况的相关性能：包括平均响应时间、连接数、内存、CPU 使用率、网卡带宽使用率等；而数据节点更需要关注磁盘空间、IOPS、读写 MB/s 等 IO 相关指标。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title28" id="监控软件部署"><h3 class="- topic/title title topictitle3" id="ariaid-title28">监控软件部署</h3><div class="- topic/body body"><p class="- topic/p p">通过部署第三方软件：Grafana，Prometheus 实现集群的管理与监控，具体流程参考 <a class="- topic/xref xref" href="cluster_monitor.html">集群监控</a>。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="监控面板"><h3 class="- topic/title title topictitle3" id="ariaid-title29">监控面板</h3><div class="- topic/body body"><p class="- topic/p p">提供<a class="- topic/xref xref" href="https://grafana.com/grafana/dashboards/16194" target="_blank" rel="external noopener">计算节点与数据节点监控</a> dashboard，是基于存储与计算分离架构设计的一套监控面板。已上传至 Grafana 官方仓库， 可以在快速完成集群的运维监控部署工作。</p><p class="- topic/p p">点击 <strong class="+ topic/ph hi-d/b ph b">Import</strong> -&gt; 输入对应 dashboardID，点击 <strong class="+ topic/ph hi-d/b ph b">Load</strong> 即可完成导入。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 19</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_1</span></figcaption>
<img class="- topic/image image" src="images/Compute_Node/4_1.png"/><br/>  
  
</figure></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title30" id="查询监控与session管理"><h3 class="- topic/title title topictitle3" id="ariaid-title30">查询监控与SESSION管理</h3><div class="- topic/body body"></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title31" id="session"><h4 class="- topic/title title topictitle4" id="ariaid-title31">session</h4><div class="- topic/body body"><p class="- topic/p p">计算节点监控的关键运行时参数主要是内存、连接数。如何避免个别 session 占用过多内存，而导致其他 session OOM，是运维管理上的重点。</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">内存管理</p><p class="- topic/p p">在内存紧张时，通过 getSessionMemory 视图进行会话管理，回收空闲会话：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select 
    userId
    ,sessionId
    ,memSize/1024/1024 as MB
    ,localtime(createTime) as createTime
    ,localtime(lastActiveTime) as lastActiveTime
    ,(now() - localtime(lastActiveTime))/1000 as idleSeconds
from getSessionMemoryStat()
order by memSize desc</code></pre><p class="- topic/p p">通过 closeSessions(sessionId) 来关闭对应会话并回收内存。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 20</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_2</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4_2.png"/><br/>  
      
    </figure><p class="- topic/p p">图示，test 用户已经空闲15分钟了，视情况可以关闭此 session，并回收1000MB的内存。</p></li><li class="- topic/li li"><p class="- topic/p p">连接管理</p><p class="- topic/p p">在 Linux 中，DolphinDB 的一个 connection 对应一个 TCP 连接。在物联网场景下，需要调整连接数（每个 tcp 连接消耗 4K 内存，对操作系统消耗不大），以应对高 QPS 需求，建议将计算节点的配置设置为 <code class="+ topic/ph pr-d/codeph ph codeph">maxConnections=5000</code> 及以上。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock cmd">The number of incoming connections has reached the limit of <span class="hl-number">512</span></pre><p class="- topic/p p">当日志出现以上信息时，说明连接已经不足，检查程序是否存在连接泄露的情况。应急处理请使用 <code class="+ topic/ph pr-d/codeph ph codeph">closeSessions()</code> 清理一些空闲会话以回收连接，并增加 <em class="+ topic/ph hi-d/i ph i">maxConnections</em> 。</p></li></ol></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title32" id="慢查询"><h4 class="- topic/title title topictitle4" id="ariaid-title32">慢查询</h4><div class="- topic/body body"><p class="- topic/p p">慢查询通常会引起系统雪崩，需要重点关注。DolphinDB 提供一个 job log 日志文件，记录 DFS 表相关查询日志，默认在 log 目录下，名称为 <em class="+ topic/ph hi-d/i ph i">nodeAlias_job.log</em>。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">监控 top10 sql</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>jobLogFile = getConfig(`jobLogFile)
queryLog = loadText(jobLogFile)

select 
    node 
    ,userId
    ,sessionId
    ,jobDesc as sqlText
    ,startTime
    ,endTime
    ,(endTime$DATETIME - startTime$DATETIME ) as costSeconds
from queryLog
order by (endTime$DATETIME - startTime$DATETIME ) desc
limit 10</code></pre><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 21</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_3</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4_3.png"/><br/>  
      
    </figure></li></ul><p class="- topic/p p">如图，根据 sqlText，userId，运行时间及时长，综合分析处置慢查询，比如限制一些用户进行较大规模的查询，以及对部分查询效率和速度较低的 SQL 语句进行优化。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title33" id="参数设置"><h3 class="- topic/title title topictitle3" id="ariaid-title33">参数设置</h3><div class="- topic/body body"><p class="- topic/p p">计算节点不需要设置 DFS 表存储相关的参数，包括：<em class="+ topic/ph hi-d/i ph i">volumes</em>, <em class="+ topic/ph hi-d/i ph i">chunkCacheEngineMemSize</em>, <em class="+ topic/ph hi-d/i ph i">tsdbCacheEngineSize</em>, <em class="+ topic/ph hi-d/i ph i">redoLogDir</em> 等。计算节点的核心参数包括：<em class="+ topic/ph hi-d/i ph i">MaxMemSize</em>, <em class="+ topic/ph hi-d/i ph i">MaxConnections</em>, <em class="+ topic/ph hi-d/i ph i">workerNum</em>, *maxQueryResultLimit *等。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title34" id="计算节点扩缩容"><h3 class="- topic/title title topictitle3" id="ariaid-title34">计算节点扩缩容</h3><div class="- topic/body body"><p class="- topic/p p">相比于数据节点，计算节点扩缩容非常简单快捷，支持在线扩缩容。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title35" id="扩容"><h4 class="- topic/title title topictitle4" id="ariaid-title35">扩容</h4><div class="- topic/body body"><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">在新机器上部署和配置 agent</p><p class="- topic/p p">拷贝原机器上的 agent 部署包到新机器，并修改 <em class="+ topic/ph hi-d/i ph i">agent.cfg</em>，如</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>mode=agent
workerNum=4
localSite=192.192.168.4:8950:C4-agent
controllerSite=192.192.168.4:8990:controller3
sites=192.192.168.4:8950:C4-agent:agent,192.192.168.2:8990:controller1:controller,192.192.168.3:8990:controller2:controller,192.192.168.4:8990:controller3:controller
lanCluster=0</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：主要修改新机器上代理节点的 IP 和端口，以及控制节点集群的 IP 和端口。</p></li><li class="- topic/li li"><p class="- topic/p p">在 web 集群管理界面修改 <code class="+ topic/ph pr-d/codeph ph codeph">Nodes Setup</code> 配置，新增 computenode 和 agent。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 22</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_4</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4_4.png"/><br/>  
      
    </figure><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：在添加完每个节点的信息之后，切记点一下该行最后的 +（加号），确保添加成功。</p></li><li class="- topic/li li"><p class="- topic/p p">在 server/ 目录下面执行如下命令，启动新节点的 agent</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>nohup ./DolphinDB -console 0 -mode agent -home data -config config/agent.cfg -logFile log/agent.log &amp;</code></pre></li><li class="- topic/li li"><p class="- topic/p p">重启 controller 节点使配置生效</p><p class="- topic/p p">回到 web 管理界面，可以看到已经新增了一个 agent4 并且是未启动状态。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 23</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_5</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4.4.1.4_1.png"/><br/>  
      
    </figure><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：代理节点的信息需要在重启集群的controller节点之后才能显示出来，数据节点和计算节点在添加完之后刷新页面就可以观察到。</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 24</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_6</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4.4.1.4_2.png"/><br/>  
      
    </figure></li><li class="- topic/li li"><p class="- topic/p p">启动新计算节点</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 25</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_7</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4.4.1.5.png"/><br/>  
      
    </figure></li><li class="- topic/li li"><p class="- topic/p p">进入新增计算机节点 web 页面，执行查询命令，检查新增数据节点是否能够正常工作</p><figure class="- topic/fig fig fignone"><figcaption data-caption-side="top" class="- topic/title title figcap"><span class="figtitleprefix fig--title-label">图<span class="fig--title-label-number"> 26</span><span class="fig--title-label-punctuation">. </span></span><span class="fig--title">图4_8</span></figcaption>
    <img class="- topic/image image" src="images/Compute_Node/4.4.1.6.png"/><br/>  
      
    </figure><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：新计算节点命名应遵守部署文档中提到的命名规则，以确保 <em class="+ topic/ph hi-d/i ph i">cluster.cfg</em> 能赋予新的计算节点正确的配置。</p></li></ol></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title36" id="缩容"><h4 class="- topic/title title topictitle4" id="ariaid-title36">缩容</h4><div class="- topic/body body"><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">停止计算节点</p><p class="- topic/p p">在 web 集群管理页面停止对应计算节点，等待其安全关闭，通常需要数秒。</p></li><li class="- topic/li li"><p class="- topic/p p">修改集群配置</p><p class="- topic/p p">在 <code class="+ topic/ph pr-d/codeph ph codeph">nodes Setup</code> 中删除对应的 computenode 节点。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：执行完上述操作之后，页面的计算节点信息并不会消失，需要重启集群的控制节点才会消失。</p></li></ol></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title37" id="总结"><h2 class="- topic/title title topictitle2" id="ariaid-title37">总结</h2><div class="- topic/body body"><p class="- topic/p p">计算节点不存储分布式数据，使用计算节点可以有效地提升集群的写入稳定性，缩短故障修复时间。计算节点之间相互隔离，架构设计者可根据应用场景，灵活地部署业务至各计算节点。推荐将流计算、机器学习部署至计算节点。在运维管理上，计算节点可以快速重启、方便地在线扩缩容。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#%E6%A6%82%E8%A7%88" data-tocid="概览">概览</a><ul><li class="topic-item"><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9" data-tocid="为什么引入计算节点">为什么引入计算节点</a></li><li class="topic-item"><a href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%AE%80%E4%BB%8B" data-tocid="计算节点简介">计算节点简介</a><ul><li class="topic-item"><a href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7" data-tocid="核心特性">核心特性</a></li><li class="topic-item"><a href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9" data-tocid="通过一个-sql-查询理解计算节点">通过一个 SQL 查询理解计算节点</a></li></ul></li><li class="topic-item"><a href="#%E5%BC%95%E5%85%A5%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E5%A5%BD%E5%A4%84" data-tocid="引入计算节点的好处">引入计算节点的好处</a><ul><li class="topic-item"><a href="#%E4%BF%9D%E8%AF%81%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7" data-tocid="保证写入数据的稳定性">保证写入数据的稳定性</a></li><li class="topic-item"><a href="#%E9%99%8D%E4%BD%8E%E6%95%85%E9%9A%9C%E5%B9%B3%E5%9D%87%E4%BF%AE%E5%A4%8D%E6%97%B6%E9%97%B4" data-tocid="降低故障平均修复时间">降低故障平均修复时间</a></li></ul></li><li class="topic-item"><a href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85" data-tocid="计算节点安装">计算节点安装</a><ul><li class="topic-item"><a href="#%E7%BC%96%E5%86%99%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" data-tocid="编写配置文件">编写配置文件</a></li><li class="topic-item"><a href="#%E5%90%AF%E5%8A%A8%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9" data-tocid="启动计算节点">启动计算节点</a></li></ul></li></ul></li><li class="topic-item"><a href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1" data-tocid="架构设计">架构设计</a><ul><li class="topic-item"><a href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%A1%AC%E4%BB%B6%E8%A7%84%E5%88%92" data-tocid="计算节点的设计和硬件规划">计算节点的设计和硬件规划</a></li><li class="topic-item"><a href="#%E5%8D%95%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84" data-tocid="单计算节点集群架构">单计算节点集群架构</a></li><li class="topic-item"><a href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84" data-tocid="高可用计算节点集群架构">高可用计算节点集群架构</a></li></ul></li><li class="topic-item"><a href="#%E6%B5%81%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9" data-tocid="流计算节点">流计算节点</a></li><li class="topic-item"><a href="#%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%B5%84%E6%BA%90%E9%9A%94%E7%A6%BB" data-tocid="基于计算节点实例的资源隔离">基于计算节点实例的资源隔离</a></li><li class="topic-item"><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" data-tocid="应用场景">应用场景</a><ul><li class="topic-item"><a href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96" data-tocid="数据读取">数据读取</a></li><li class="topic-item"><a href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5" data-tocid="数据写入">数据写入</a></li></ul></li><li class="topic-item"><a href="#%E6%B5%81%E8%AE%A1%E7%AE%97" data-tocid="流计算">流计算</a><ul><li class="topic-item"><a href="#%E9%85%8D%E7%BD%AE%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9" data-tocid="配置计算节点">配置计算节点</a></li><li class="topic-item"><a href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%A2%E9%98%85%E6%B5%81%E6%95%B0%E6%8D%AE%E8%A1%A8" data-tocid="创建与订阅流数据表">创建与订阅流数据表</a></li></ul></li><li class="topic-item"><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" data-tocid="机器学习">机器学习</a></li><li class="topic-item"><a href="#%E8%BF%90%E7%BB%B4" data-tocid="运维">运维</a><ul><li class="topic-item"><a href="#%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7" data-tocid="集群监控">集群监控</a></li><li class="topic-item"><a href="#%E7%9B%91%E6%8E%A7%E8%BD%AF%E4%BB%B6%E9%83%A8%E7%BD%B2" data-tocid="监控软件部署">监控软件部署</a></li><li class="topic-item"><a href="#%E7%9B%91%E6%8E%A7%E9%9D%A2%E6%9D%BF" data-tocid="监控面板">监控面板</a></li><li class="topic-item"><a href="#%E6%9F%A5%E8%AF%A2%E7%9B%91%E6%8E%A7%E4%B8%8Esession%E7%AE%A1%E7%90%86" data-tocid="查询监控与session管理">查询监控与SESSION管理</a><ul><li class="topic-item"><a href="#session" data-tocid="session">session</a></li><li class="topic-item"><a href="#%E6%85%A2%E6%9F%A5%E8%AF%A2" data-tocid="慢查询">慢查询</a></li></ul></li><li class="topic-item"><a href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE" data-tocid="参数设置">参数设置</a></li><li class="topic-item"><a href="#%E8%AE%A1%E7%AE%97%E8%8A%82%E7%82%B9%E6%89%A9%E7%BC%A9%E5%AE%B9" data-tocid="计算节点扩缩容">计算节点扩缩容</a><ul><li class="topic-item"><a href="#%E6%89%A9%E5%AE%B9" data-tocid="扩容">扩容</a></li><li class="topic-item"><a href="#%E7%BC%A9%E5%AE%B9" data-tocid="缩容">缩容</a></li></ul></li></ul></li><li class="topic-item"><a href="#%E6%80%BB%E7%BB%93" data-tocid="总结">总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>