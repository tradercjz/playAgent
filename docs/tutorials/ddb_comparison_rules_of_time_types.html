<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在数据库中，时间是一种常见的数据类型。在处理时间数据时，比较操作是非常常见的需求。然而，在不同的场景下，对时间类型数据进行比较时应用的规则不同。本文将从 DolphinDB 支持的时间类型开始，由浅入深分别介绍时间类型数据在不同场景下的比较规则。涵盖以下场景： 时间类型的转换规则 时间类型的比较规则 时间类型的分区剪枝规则 DolphinDB 支持的时间类型包括：TIME, MINUTE, ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="dolphindb-时间类型比较规则"/><title>DolphinDB 时间类型比较规则</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;dolphindb-时间类型比较规则&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DolphinDB 时间类型比较规则&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在数据库中，时间是一种常见的数据类型。在处理时间数据时，比较操作是非常常见的需求。然而，在不同的场景下，对时间类型数据进行比较时应用的规则不同。本文将从 DolphinDB 支持的时间类型开始，由浅入深分别介绍时间类型数据在不同场景下的比较规则。涵盖以下场景：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间类型的转换规则&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间类型的比较规则&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间类型的分区剪枝规则&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:45;64:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-时间类型介绍&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;1. 时间类型介绍&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DolphinDB 支持的时间类型包括：TIME, MINUTE, SECOND, DATE, MONTH, DATEHOUR, DATETIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。以上数据类型可以按照包含的时间信息分成：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期型：仅包含日期信息，包括 DATE, MONTH&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间型：仅包含时间信息，包括 MINUTE, SECOND, TIME, NANOTIME&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;17:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型：同时包含日期和时间信息，包括 DATEHOUR, DATETIME, TIMESTAMP, NANOTIMESTAMP&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;以下是每个时间类型格式说明和例子：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:4;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;分类&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;数据类型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;格式&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:4;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;例子&lt;/entry&gt; &lt;/row&gt; &lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; morerows=&#34;1&#34; xtrc=&#34;entry:5;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DATE&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:7;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.dd&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:8;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01.04`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:9;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;MONTH&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:10;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.dd（末尾需要加上字母 M ）&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:11;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01M`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; morerows=&#34;3&#34; xtrc=&#34;entry:12;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:13;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;MINUTE&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:14;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;HH:mm（末尾需要加上字母 m ）&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:15;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`13:30m`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:16;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;SECOND&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:17;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;HH:mm:ss&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:18;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`13:30:10`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:19;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;TIME&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:20;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;HH:mm:ss.sss&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:21;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`13:30:10.008`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:22;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;NANOTIME&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:23;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;HH:mm:ss.nnnnnnnnn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:24;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`13:30:10.006007008`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34; morerows=&#34;3&#34; xtrc=&#34;entry:25;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:26;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DATEHOUR&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:27;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.ddTHH 或 YYYY.MM.dd HH&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:28;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01.04T21`，只能通过 `datehour` 函数得到&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:9;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:29;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DATETIME&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:30;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.ddTHH:mm:ss 或 YYYY.MM.dd HH:mm:ss&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:31;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01.04T13:30:10` 或 `2023.01.04 13:30:10`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:10;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:32;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;TIMESTAMP&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:33;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.ddTHH:mm:ss.sss 或 YYYY.MM.dd HH:mm:ss.sss&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:34;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01.04T13:30:10.008` 或 `2023.01.04 13:30:10.008`&lt;/entry&gt; &lt;/row&gt; &lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:11;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;11&#34; xtrc=&#34;entry:35;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;NANOTIMESTAMP&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;11&#34; xtrc=&#34;entry:36;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;YYYY.MM.ddTHH:mm:ss.sss.nnnnnnnnn 或 YYYY.MM.dd HH:mm:ss.sss.nnnnnnnnn&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;11&#34; xtrc=&#34;entry:37;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;`2023.01.04T13:30:10.001002003` 或 `2023.01.04 13:30:10.001002003`&lt;/entry&gt; &lt;/row&gt; &lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;DolphinDB 的时间类型不包含时区信息，由用户来决定时间对下的时区。通过 localtime、 gmtime、convertT 函数可以转换时区信息，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;87:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;today&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;87:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;now&lt;/codeph&gt; 函数可以获取当前的系统时间。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;获取当前的日期，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;89:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;today&lt;/codeph&gt; 函数，函数会返回一个 DATE 类型的数据，表示当前的日期：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;today() // 2024.06.03&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;获取当前的时间，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;95:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;now&lt;/codeph&gt; 函数，默认情况下，该函数返回的是 TIMESTAMP 类型，精确到毫秒；也可以指定参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;95:64&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;nanoSecond=true&lt;/codeph&gt; ，返回 NANOTIMESTAMP 类型，精确到纳秒。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;now() // 2024.06.03T09:29:38.390 now(true) // 2024.06.03T09:31:17.318298137&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-显式的时间类型转换&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2. 显式的时间类型转换&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;106:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在 DolphinDB 中，可以使用数据类型转换函数或者 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;106:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;cast&lt;/codeph&gt; 函数进行数据类型转换。时间类型的转换规则可以总结成下表（横轴为目标数据类型，纵轴为源数据类型，√表示支持转换，x表示不支持转换。）。&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;4&#34; xtrc=&#34;tgroup:2;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:5;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:6;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:7;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:8;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:12;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:38;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt; &lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:39;108:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:40;108:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:41;108:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间型&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:13;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:42;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:43;110:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:44;110:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:45;110:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;×&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:14;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:46;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:47;111:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:48;111:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:49;111:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:15;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:50;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:51;112:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;×&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:52;112:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;×&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:53;112:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;√&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间类型的转换规则可概括为：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;（1）相同分类中的时间类型可以相互转换。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;同为日期型的 DATE 和 MONTH 可以互相转换；&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;date(2012.01M) // 2012.01.01 month(2012.01.02) // 2012.01M&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;125:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;同为时间型的 MINUTE、SECOND、TIME、NANOTIME 可以互相转换；&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;127:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;minute(23:30:00) // 23:30m minute(23:30:00.000) // 23:30m minute(23:30:00.000000000) // 23:30m second(23:30m) // 23:30:00 second(23:30:00.001) // 23:30:00 second(23:30:00.000000001) // 23:30:00 time(23:31m) // 23:31:00.000 time(23:30:01) // 23:30:01.000 time(23:30:01.000000001) // 23:30:01.000 nanotime(23:30m) // 23:30:00.000000000 nanotime(23:30:31) // 23:30:31.000000000 nanotime(23:30:31.001) //23:30:31.001000000&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;同为日期时间型的 DATEHOUR、DATETIME、TIMESTAMP、NANOTIMESTAMP 可以互相转换。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;datehour(2020.01.01 13:30:01) // 2020.01.01T13 datehour(2020.01.01T13:30:01.001) // 2020.01.01T13 datehour(2020.01.01T13:30:01.001002003) // 2020.01.01T13 datetime(datehour(2020.01.01 13:00:01)) // 2020.01.01T13:00:00 datetime(2020.01.01T13:30:01.001) // 2020.01.01T13:30:01 datetime(2020.01.01T13:30:01.001002003) // 2020.01.01T13:30:01 timestamp(datehour(2020.01.01 13:00:01)) // 2020.01.01T13:00:00.000 timestamp(2020.01.01 13:00:01) // 2020.01.01T13:00:01.000 timestamp(2020.01.01T13:30:01.001002003) // 2020.01.01T13:30:01.001 nanotimestamp(datehour(2020.01.01 13:00:01)) // 2020.01.01T13:00:00.000000000 nanotimestamp(2020.01.01T13:30:01) // 2020.01.01T13:30:01.000000000 nanotimestamp(2020.01.01T13:30:01.001) // 2020.01.01T13:30:01.001000000&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;（2）日期型和日期时间型可以相互转换。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期型转换为日期时间型，会自动补充时间为0点的信息。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;datehour(2023.01.02) // 2023.01.02T00 datetime(2023.01.02) // 2023.01.02T00:00:00 timestamp(2023.01.02) // 2023.01.02T00:00:00.000 nanotimestamp(2023.01.02) // 2023.01.02T00:00:00.000000000 datehour(2023.01M) // 2023.01.01T00 datetime(2023.01M) // 2023.01.01T00:00:00 timestamp(2023.01M) // 2023.01.01T00:00:00.000 nanotimestamp(2023.01M) // 2023.01.01T00:00:00.000000000&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型转换为日期型，会舍弃时间信息。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;date(datehour(2020.01.01 13:00:01)) // 2020.01.01 date(2020.01.01 13:00:01) // 2020.01.01 date(2020.01.01 13:00:01.001) // 2020.01.01 date(2020.01.01 13:00:01.001002003) // 2020.01.01 month(datehour(2020.01.01 13:00:01)) // 2020.01M month(2020.01.01 13:00:01) // 2020.01M month(2020.01.01 13:00:01.001) // 2020.01M month(2020.01.01 13:00:01.001002003) // 2020.01M&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;（3）日期时间型可以转换为时间型，但时间型不能转换为日期时间型。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型转换为时间型，会舍弃日期信息；&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;time(2020.01.01 13:00:01.001002003) // 13:00:01.001 minute(2020.01.01 13:00:01) // 13:00m&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间型转换为日期时间型，会抛出异常。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;datetime(13:00:01) // The function datetime does not support second data&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;（4）日期型和时间型不能相互转换。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;month(13:00:01) // The function month does not support second data minute(2020.01.01) // The function minute does not support date data&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-常规的时间类型比较&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;3. 常规的时间类型比较&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在 DolphinDB 中，常规的时间类型比较通常用于数据量比较小的内存表和流表中，或者单纯的只比较两个时间的大小的向量中，例如：对流数据引擎得到的结果根据需要过滤相应时间段的数据。不同时间类型之间可以使用比较运算符（&amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=, ==, !=），in 和 between 进行比较。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;使用比较运算符对不同时间类型进行比较时，系统会按照第2章中的转换规则，尝试将时间粒度较粗的类型转换成时间粒度较细的类型，如果能够转换，就作比较；如果不能够转换，则抛出异常。例如，表达式 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;215:94&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04T13:30:10.001 &amp;gt; 2023.01.04&lt;/codeph&gt; 执行时，会将 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;215:140&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04&lt;/codeph&gt; 转换成 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;215:157&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04T00:00:00.000&lt;/codeph&gt; 再进行比较，因此返回结果是 true。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04T13:30:10.001 &amp;gt; 2023.01.04 // true 2011.01.01T13:00:00 &amp;gt; 2011.01.02 // false 2023.01.04T13:30:10.001 == 2023.01.04 // false 2023.01.04 == 2023.01.04T00:00:00.000 // true&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;需要注意的是，&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;MONTH 类型的数据比较特殊，虽然它可以和日期时间型以及同为日期型的 DATE 类型相互转换，但是它们之间不能进行比较。MONTH 只能和 MONTH 类型进行比较。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;227:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;日期时间型虽然可以转换为时间型，但是它们之间不能比较。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;关系运算符 between 和其他比较运算符不同，只有运算符的左右两边的类型一致时，才可以比较。&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04T13:30:10.001 between 2023.01.04T13:30:10.003:2023.01.04T13:30:10.004 // false&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;234:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;运算符的左右两边的类型不一致时，会报错 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;234:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;Temporal data comparison should have the same data type.&lt;/codeph&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2023.01.04 between 2023.01.04T13:30:10.003:2023.01.04T13:30:10.004 // between(X, Y). Temporal data comparison should have the same data type.'&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-时间类型的分区剪枝&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4. 时间类型的分区剪枝&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在 DolphinDB 的应用实践中，时序数据的时间戳通常会作为分布式数据库的分区列，按照值或者范围分片存储。当查询语句的过滤条件包含分区列时，系统会进行分区剪枝，以减少扫描分区的数量，提升查询性能。了解时间类型的分区剪枝规则能够帮助我们写出高效的 SQL 语句。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在实际使用中，通常会对时间分区列直接进行过滤查询，或者对时间分区列进行显式类型转换后再进行过滤。这两种情况，DolphinDB 的分区剪枝规则略有不同。下面将分开阐述。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;下文介绍中将频繁出现三个名称，在此先介绍它们的概念：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;分区方案类型：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;251:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;database&lt;/codeph&gt; 函数的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;251:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;partitionScheme&lt;/i&gt; 参数指定的数据类型。在这个例子中，分区方案的类型是 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;251:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;[2022.09.01,2022.09.02, 2022.09.03]&lt;/codeph&gt; 的类型，即 DATE 类型：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;dbName = &#34;dfs://time_comparison&#34; if(existsDatabase(dbName)) dropDatabase(dbName) db = database(dbName, VALUE, [2022.09.01,2022.09.02, 2022.09.03])&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;分区列类型：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;260:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;createPartitionedTable&lt;/codeph&gt; 函数的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;260:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;partitionColumns&lt;/i&gt; 指定的列类型。在这个例子中，分区列的类型是表 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;260:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;t&lt;/codeph&gt; 的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;260:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;time&lt;/codeph&gt; 列的类型，即 DATETIME 类型：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;n = 6 t = table(n:n,[`time,`value],[DATETIME,DOUBLE]) t[`time] = [2022.09.01T00:00:00, 2022.09.01T12:00:00, 2022.09.02T00:00:00, 2022.09.02T12:00:00, 2022.09.03T00:00:00, 2022.09.03T12:00:00] t[`value] = 1..6 pt = db.createPartitionedTable(t, `pt, `time).append!(t)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;270:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;过滤比较中的时间对象。在这个例子中，分布式表的分区列 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;270:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;time&lt;/codeph&gt; 和数据 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;270:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 进行比较，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;270:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 则是过滤比较中的时间对象，是 DATE 类型的数据：&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;272:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where time == 2022.09.01 time value ----------------------------------- 2022.09.01T00:00:00 1.00000000 2022.09.01T12:00:00 2.00000000&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-对分区列直接过滤&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;282:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;282:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4.1 对分区列直接过滤&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;282:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;284:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;在分布式查询中，当我们使用运算符 &amp;lt;, &amp;lt;=, =, ==, &amp;gt;, &amp;gt;=, in, between 对时间分区列和其他时间类型的数据进行比较时， 比较的规则和在内存表中相同，且系统会进行分区剪枝。但要注意，当分区方案是 DATEHOUR 和 DATETIME 类型时，不支持创建分区表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;286:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;下例中，时间列的类型为 DATETIME，按照该列对数据按天进行 VALUE 分区。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;288:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;dbName = &#34;dfs://time_comparison&#34; if(existsDatabase(dbName)) dropDatabase(dbName) db = database(dbName, VALUE, [2022.09.01,2022.09.02, 2022.09.03]) n = 6 t = table(n:n,[`time,`value],[DATETIME,DOUBLE]) t[`time] = [2022.09.01T00:00:00, 2022.09.01T12:00:00, 2022.09.02T00:00:00, 2022.09.02T12:00:00, 2022.09.03T00:00:00, 2022.09.03T12:00:00] t[`value] = 1..6 pt = db.createPartitionedTable(t, `pt, `time).append!(t)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;301:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;301:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 这一天的数据，可以直接用分区列和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;301:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 进行比较。即使 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;301:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 的数据类型和分区列的数据类型不同，依然能够进行分区剪枝，只需扫描 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;301:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 这个分区的数据即可。我们可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;301:133&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;sqlDS&lt;/codeph&gt; 来查看分布式查询拆分子查询的情况。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;303:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;sqlDS(&amp;lt;select * from pt where time == 2022.09.01&amp;gt;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;307:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;307:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01T00:00:00.000&lt;/codeph&gt; 这一时刻的数据，也可以直接用分区列和该时刻进行比较，即使两者数据类型不同，依然能进行分区剪枝，只需扫描 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;307:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01&lt;/codeph&gt; 这个分区的数据即可。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;309:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;sqlDS(&amp;lt;select * from pt where time == 2022.09.01T00:00:00.000&amp;gt;)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-对分区列进行显式类型转换后过滤&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4.2 对分区列进行显式类型转换后过滤&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;315:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;317:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;对于显式类型转换的过滤条件中，形如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;317:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func(col) &amp;lt;operator&amp;gt; constant&lt;/codeph&gt; 的表达式，其中 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;317:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func&lt;/codeph&gt; 是 date、month 等时间类型转换函数， &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;317:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;col&lt;/codeph&gt; 是分区列，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;317:117&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;operator&lt;/codeph&gt; 是运算符，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;317:133&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;constant&lt;/codeph&gt; 是比较的值，以下情况可以进行分区剪枝。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;421-使用比较运算符&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4.2.1 使用比较运算符&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;当 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;321:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&amp;lt;operator&amp;gt;&lt;/codeph&gt; 为比较运算符（&amp;lt;, &amp;lt;=, =, ==, &amp;gt;, &amp;gt;=）时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;321:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func&lt;/codeph&gt; 返回的数据类型的精度小于等于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;321:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;constant&lt;/codeph&gt; 的精度，并且 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;321:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func&lt;/codeph&gt; 返回的数据类型的精度小于等于分区列的精度，可以进行分区剪枝。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;323:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;note class=&#34;- topic/note &#34; xtrc=&#34;note:1;323:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;时间精度由低到高的排序为：MONTH ＜ DATE ＜ DATEHOUR ＜ DATETIME ＜ TIMESTAMP ＜ NANOTIMESTAMP &lt;/note&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;这里以 VALUE 分区为例，分区方案的类型为 DATE，按照 DATE 进行分区创建分布式表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;327:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;dbName = &#34;dfs://time_comparison&#34; if(existsDatabase(dbName)) dropDatabase(dbName) db = database(dbName, VALUE, [2022.09.01,2022.09.30,2022.10.01,2022.10.02,2022.10.31,2022.11.01,2022.11.02,2022.12.31,2023.01.01]) n = 10 t = table(n:n,[`time,`value],[DATE,DOUBLE]) t[`time] = take([2022.09.01,2022.09.30,2022.10.01,2022.10.02,2022.10.31,2022.11.01,2022.11.02,2022.12.31,2023.01.01],n) t[`value] = rand(100.0,n) pt = db.createPartitionedTable(t, `pt, `time).append!(t)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;340:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询大于某个月的数据时，如果直接用分区列和 MONTH 类型的数据比较，是不支持的；这个时候可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;340:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;month&lt;/codeph&gt; 函数，将分区列的类型转换为 MONTH 类型来进行比较。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where month(time) &amp;gt; 2022.10M time value ------------------------ 2022.11.01 15.00570112 2022.11.02 66.54577804 2022.12.31 48.09958597 2023.01.01 50.57664175&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;因为运算符左右的类型一致，且 MONTH 类型的精度低于分区列 DATE 类型，系统会将小于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;352:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.11M&lt;/codeph&gt; 的分区都&#34;剪枝&#34;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询等于某一时刻的数据时，可以对分区列使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;354:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;timestamp&lt;/codeph&gt; 函数，和 TIMESTAMP 类型的数据进行比较，比如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where timestamp(time) = 2022.09.30T00:00:00.000 time value ------------------------ 2022.09.30 19.33508650&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;363:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;但这个时候由于转换函数的类型 TIMESTAMP 的精度高于分区列 DATE 的精度，不满足分区剪枝的条件，虽然可以进行比较，但是不能进行分区剪枝。因此在这种情况下，推荐对分区列直接进行过滤的方式进行比较，效率会更高。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;422-使用-between&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;367:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;367:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4.2.2 使用 between&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;367:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;当 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;369:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&amp;lt;operator&amp;gt;&lt;/codeph&gt; 为 between 时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;369:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func&lt;/codeph&gt; 返回的数据类型必须与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;369:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;constant&lt;/codeph&gt; 相同，才能进行分区剪枝。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询在某一连续的月的数据，直接将分区列和 MONTH 类型的数据进行比较，是不支持的：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;373:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where time between month(2022.10M:2022.11M) // between(X, Y). Temporal data comparison should have the same data type.'&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;378:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;可以对分区列使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;378:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;month&lt;/codeph&gt; 函数，和 MONTH 类型的数据进行比较：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;380:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where month(time) between month(2022.10M:2022.11M) time value ------------------------ 2022.10.01 24.45175347 2022.10.02 86.05015869 2022.10.31 78.28769609 2022.11.01 15.00570112 2022.11.02 66.54577804&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;391:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;运算符 between 的左右两边的类型一致，且 MONTH 类型的精度低于分区列 DATE 的精度，满足分区剪枝的条件，系统会从 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;391:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.10.01, 2022.10.02, 2022.10.31, 2022.11.01, 2022.11.02&lt;/codeph&gt; 这5个分区中过滤数据，其他的分区会被“剪枝”。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;423-使用-in&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;4.2.3 使用 in&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;395:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;397:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;当 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;397:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&amp;lt;operator&amp;gt;&lt;/codeph&gt; 为 in 时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;397:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;convert_func&lt;/codeph&gt; 返回的数据类型必须与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;397:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;constant&lt;/codeph&gt; 相同，并且 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;397:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;constant&lt;/codeph&gt; 列表中的连续片段的数量小于16，才能进行分区剪枝。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;399:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;note class=&#34;- topic/note &#34; xtrc=&#34;note:2;399:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;假设列表为&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;399:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;[2020.01.02, 2020.01.03, 2020.01.04, 2020.01.06, 2020.01.07, 2020.01.12]&lt;/codeph&gt;，那么它包含3个连续片段 2020.01.02..2020.01.04，2020.01.06..2020.01.07，2020.01.12。 &lt;/note&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;401:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询在某一不连续的月的数据，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;401:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;month&lt;/codeph&gt; 函数，和 MONTH 类型的数据进行比较：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;403:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where month(time) in [2022.09M, 2022.11M] time value ------------------------ 2022.09.01 51.37807030 2022.09.01 50.86722047 2022.09.30 13.91816022 2022.11.01 76.58300183 2022.11.02 74.23354792&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;运算符 in 的左右两边类型一致，且 MONTH 类型的精度低于分区列 DATE 的精度，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;414:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;[2022.09M, 2022.11M]&lt;/codeph&gt; 是一个不连续的片段，但是片段的数据小于16，满足分区剪枝的条件，系统会从&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;414:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;2022.09.01, 2022.09.30, 2022.11.01, 2022.11.02&lt;/codeph&gt; 这4个分区中过滤数据，其他的分区会被“剪枝”。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;想要查询在某一连续时刻的数据，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;416:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;timestamp&lt;/codeph&gt; 函数，和 TIMESTAMP 类型的数据进行比较：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;select * from pt where timestamp(time) in timestamp(2022.10.31..2022.11.01) time value ------------------------ 2022.10.31 78.28769609 2022.11.01 15.00570112&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;426:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;虽然运算符 in 的左右两边的类型一致，但因为 TIMESTAMP 的精度高于分区列 DATE 的精度，因此不能进行分区剪枝。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;小结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;小结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;430:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;432:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/ddb_comparison_rules_of_time_types.md&#34;&gt;对时间类型进行比较的规则可以分为两类：涉及分区剪枝时的比较和不涉及分区剪枝时的比较。通常时间类型向量比较，内存表查询和分布式表查询中过滤条件为非分区列时的时间类型比较均不涉及分区剪枝。而分布式表查询中过滤条件为分区列时，时间类型比较会涉及分区剪枝。在实际使用过程中，推荐使用支持分区剪枝的 where 条件来提升查询的效率。尤其针对数据量非常大的分区表进行查询时，分区剪枝能够节省大量时间。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/ddb_comparison_rules_of_time_types.md"/><meta name="wh-out-relpath" content="tutorials/ddb_comparison_rules_of_time_types.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="dolphindb-时间类型比较规则" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="dolphindb-时间类型比较规则"><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html">DolphinDB 时间类型比较规则</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem" class="active"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">DolphinDB 时间类型比较规则</h1><div class="- topic/body body"><p class="- topic/p p">在数据库中，时间是一种常见的数据类型。在处理时间数据时，比较操作是非常常见的需求。然而，在不同的场景下，对时间类型数据进行比较时应用的规则不同。本文将从 DolphinDB 支持的时间类型开始，由浅入深分别介绍时间类型数据在不同场景下的比较规则。涵盖以下场景：</p><ul class="- topic/ul ul"><li class="- topic/li li">时间类型的转换规则</li><li class="- topic/li li">时间类型的比较规则</li><li class="- topic/li li">时间类型的分区剪枝规则</li></ul></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-时间类型介绍"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 时间类型介绍</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 支持的时间类型包括：TIME, MINUTE, SECOND, DATE, MONTH, DATEHOUR, DATETIME, TIMESTAMP, NANOTIME, NANOTIMESTAMP。以上数据类型可以按照包含的时间信息分成：</p><ul class="- topic/ul ul"><li class="- topic/li li">日期型：仅包含日期信息，包括 DATE, MONTH</li><li class="- topic/li li">时间型：仅包含时间信息，包括 MINUTE, SECOND, TIME, NANOTIME</li><li class="- topic/li li">日期时间型：同时包含日期和时间信息，包括 DATEHOUR, DATETIME, TIMESTAMP, NANOTIMESTAMP</li></ul><p class="- topic/p p">以下是每个时间类型格式说明和例子：</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead">  
  <tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="1-时间类型介绍__entry__1">分类</th><th class="- topic/entry entry colsep-0 rowsep-0" id="1-时间类型介绍__entry__2">数据类型</th><th class="- topic/entry entry colsep-0 rowsep-0" id="1-时间类型介绍__entry__3">格式</th><th class="- topic/entry entry colsep-0 rowsep-0" id="1-时间类型介绍__entry__4">例子</th>  
  </tr>  
</thead><tbody class="- topic/tbody tbody">  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__1" rowspan="2">日期型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">DATE</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.dd</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01.04`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">MONTH</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.dd（末尾需要加上字母 M ）</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01M`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__1" rowspan="4">时间型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">MINUTE</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">HH:mm（末尾需要加上字母 m ）</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`13:30m`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">SECOND</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">HH:mm:ss</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`13:30:10`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">TIME</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">HH:mm:ss.sss</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`13:30:10.008`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">NANOTIME</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">HH:mm:ss.nnnnnnnnn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`13:30:10.006007008`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__1" rowspan="4">日期时间型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">DATEHOUR</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.ddTHH 或 YYYY.MM.dd HH</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01.04T21`，只能通过 `datehour` 函数得到</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">DATETIME</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.ddTHH:mm:ss 或 YYYY.MM.dd HH:mm:ss</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01.04T13:30:10` 或 `2023.01.04 13:30:10`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">TIMESTAMP</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.ddTHH:mm:ss.sss 或 YYYY.MM.dd HH:mm:ss.sss</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01.04T13:30:10.008` 或 `2023.01.04 13:30:10.008`</td>  
  </tr>  
  <tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__2">NANOTIMESTAMP</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__3">YYYY.MM.ddTHH:mm:ss.sss.nnnnnnnnn 或 YYYY.MM.dd HH:mm:ss.sss.nnnnnnnnn</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="1-时间类型介绍__entry__4">`2023.01.04T13:30:10.001002003` 或 `2023.01.04 13:30:10.001002003`</td>  
  </tr>  
</tbody></table></div><p class="- topic/p p">DolphinDB 的时间类型不包含时区信息，由用户来决定时间对下的时区。通过 localtime、 gmtime、convertT 函数可以转换时区信息，通过 <code class="+ topic/ph pr-d/codeph ph codeph">today</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数可以获取当前的系统时间。</p><p class="- topic/p p">获取当前的日期，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">today</code> 函数，函数会返回一个 DATE 类型的数据，表示当前的日期：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>today()  // 2024.06.03</code></pre><p class="- topic/p p">获取当前的时间，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数，默认情况下，该函数返回的是 TIMESTAMP 类型，精确到毫秒；也可以指定参数 <code class="+ topic/ph pr-d/codeph ph codeph">nanoSecond=true</code> ，返回 NANOTIMESTAMP 类型，精确到纳秒。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>now()  // 2024.06.03T09:29:38.390
now(true)  // 2024.06.03T09:31:17.318298137</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-显式的时间类型转换"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 显式的时间类型转换</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，可以使用数据类型转换函数或者 <code class="+ topic/ph pr-d/codeph ph codeph">cast</code> 函数进行数据类型转换。时间类型的转换规则可以总结成下表（横轴为目标数据类型，纵轴为源数据类型，√表示支持转换，x表示不支持转换。）。</p><div class="table-container"><table class="- topic/table table" data-cols="4"><caption></caption><colgroup><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="2-显式的时间类型转换__entry__1"> </th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-显式的时间类型转换__entry__2">日期型</th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-显式的时间类型转换__entry__3">日期时间型</th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-显式的时间类型转换__entry__4">时间型</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__1">日期型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__2">√</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__3">√</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__4">×</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__1">日期时间型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__2">√</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__3">√</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__4">√</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__1">时间型</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__2">×</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__3">×</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-显式的时间类型转换__entry__4">√</td></tr></tbody></table></div><p class="- topic/p p">时间类型的转换规则可概括为：</p><p class="- topic/p p">（1）相同分类中的时间类型可以相互转换。</p><p class="- topic/p p">同为日期型的 DATE 和 MONTH 可以互相转换；</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>date(2012.01M)   // 2012.01.01
month(2012.01.02)  // 2012.01M</code></pre><p class="- topic/p p">同为时间型的 MINUTE、SECOND、TIME、NANOTIME 可以互相转换；</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>minute(23:30:00)  // 23:30m
minute(23:30:00.000)  // 23:30m
minute(23:30:00.000000000)  // 23:30m
second(23:30m)  // 23:30:00
second(23:30:00.001)  // 23:30:00
second(23:30:00.000000001)  // 23:30:00
time(23:31m)  // 23:31:00.000
time(23:30:01)  // 23:30:01.000
time(23:30:01.000000001)  // 23:30:01.000
nanotime(23:30m)  // 23:30:00.000000000
nanotime(23:30:31)  // 23:30:31.000000000
nanotime(23:30:31.001)  //23:30:31.001000000</code></pre><p class="- topic/p p">同为日期时间型的 DATEHOUR、DATETIME、TIMESTAMP、NANOTIMESTAMP 可以互相转换。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>datehour(2020.01.01 13:30:01)  // 2020.01.01T13
datehour(2020.01.01T13:30:01.001)  //  2020.01.01T13
datehour(2020.01.01T13:30:01.001002003)  // 2020.01.01T13
datetime(datehour(2020.01.01 13:00:01))  // 2020.01.01T13:00:00
datetime(2020.01.01T13:30:01.001)  // 2020.01.01T13:30:01
datetime(2020.01.01T13:30:01.001002003)  //  2020.01.01T13:30:01
timestamp(datehour(2020.01.01 13:00:01))  //  2020.01.01T13:00:00.000
timestamp(2020.01.01 13:00:01)  // 2020.01.01T13:00:01.000
timestamp(2020.01.01T13:30:01.001002003)  // 2020.01.01T13:30:01.001
nanotimestamp(datehour(2020.01.01 13:00:01))  //  2020.01.01T13:00:00.000000000
nanotimestamp(2020.01.01T13:30:01)  //  2020.01.01T13:30:01.000000000
nanotimestamp(2020.01.01T13:30:01.001)  // 2020.01.01T13:30:01.001000000</code></pre><p class="- topic/p p">（2）日期型和日期时间型可以相互转换。</p><p class="- topic/p p">日期型转换为日期时间型，会自动补充时间为0点的信息。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>datehour(2023.01.02)  // 2023.01.02T00
datetime(2023.01.02)  // 2023.01.02T00:00:00
timestamp(2023.01.02)  // 2023.01.02T00:00:00.000
nanotimestamp(2023.01.02)  // 2023.01.02T00:00:00.000000000
datehour(2023.01M)  // 2023.01.01T00
datetime(2023.01M)  // 2023.01.01T00:00:00
timestamp(2023.01M)  //  2023.01.01T00:00:00.000
nanotimestamp(2023.01M)  // 2023.01.01T00:00:00.000000000</code></pre><p class="- topic/p p">日期时间型转换为日期型，会舍弃时间信息。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>date(datehour(2020.01.01 13:00:01)) // 2020.01.01
date(2020.01.01 13:00:01)  // 2020.01.01
date(2020.01.01 13:00:01.001)  // 2020.01.01
date(2020.01.01 13:00:01.001002003)  // 2020.01.01
month(datehour(2020.01.01 13:00:01))  // 2020.01M
month(2020.01.01 13:00:01)  // 2020.01M
month(2020.01.01 13:00:01.001)  // 2020.01M
month(2020.01.01 13:00:01.001002003)  // 2020.01M</code></pre><p class="- topic/p p">（3）日期时间型可以转换为时间型，但时间型不能转换为日期时间型。</p><p class="- topic/p p">日期时间型转换为时间型，会舍弃日期信息；</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>time(2020.01.01 13:00:01.001002003)  // 13:00:01.001
minute(2020.01.01 13:00:01)  // 13:00m</code></pre><p class="- topic/p p">时间型转换为日期时间型，会抛出异常。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>datetime(13:00:01)  // The function datetime does not support second data</code></pre><p class="- topic/p p">（4）日期型和时间型不能相互转换。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>month(13:00:01)  // The function month does not support second data
minute(2020.01.01)  // The function minute does not support date data</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3-常规的时间类型比较"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3. 常规的时间类型比较</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，常规的时间类型比较通常用于数据量比较小的内存表和流表中，或者单纯的只比较两个时间的大小的向量中，例如：对流数据引擎得到的结果根据需要过滤相应时间段的数据。不同时间类型之间可以使用比较运算符（&gt;, &lt;, &gt;=, &lt;=, ==, !=），in 和 between 进行比较。</p><p class="- topic/p p">使用比较运算符对不同时间类型进行比较时，系统会按照第2章中的转换规则，尝试将时间粒度较粗的类型转换成时间粒度较细的类型，如果能够转换，就作比较；如果不能够转换，则抛出异常。例如，表达式 <code class="+ topic/ph pr-d/codeph ph codeph">2023.01.04T13:30:10.001 &gt; 2023.01.04</code> 执行时，会将 <code class="+ topic/ph pr-d/codeph ph codeph">2023.01.04</code> 转换成 <code class="+ topic/ph pr-d/codeph ph codeph">2023.01.04T00:00:00.000</code> 再进行比较，因此返回结果是 true。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2023.01.04T13:30:10.001 &gt; 2023.01.04   // true
2011.01.01T13:00:00 &gt; 2011.01.02   // false
2023.01.04T13:30:10.001 == 2023.01.04   // false
2023.01.04 == 2023.01.04T00:00:00.000  //  true</code></pre><p class="- topic/p p">需要注意的是，</p><ul class="- topic/ul ul"><li class="- topic/li li">MONTH 类型的数据比较特殊，虽然它可以和日期时间型以及同为日期型的 DATE 类型相互转换，但是它们之间不能进行比较。MONTH 只能和 MONTH 类型进行比较。</li><li class="- topic/li li">日期时间型虽然可以转换为时间型，但是它们之间不能比较。</li><li class="- topic/li li">关系运算符 between 和其他比较运算符不同，只有运算符的左右两边的类型一致时，才可以比较。</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2023.01.04T13:30:10.001 between 2023.01.04T13:30:10.003:2023.01.04T13:30:10.004   // false</code></pre><p class="- topic/p p">运算符的左右两边的类型不一致时，会报错 <code class="+ topic/ph pr-d/codeph ph codeph">Temporal data comparison should have the same data type.</code></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>2023.01.04 between 2023.01.04T13:30:10.003:2023.01.04T13:30:10.004
//  between(X, Y). Temporal data comparison should have the same data type.'</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="4-时间类型的分区剪枝"><h2 class="- topic/title title topictitle2" id="ariaid-title5">4. 时间类型的分区剪枝</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 的应用实践中，时序数据的时间戳通常会作为分布式数据库的分区列，按照值或者范围分片存储。当查询语句的过滤条件包含分区列时，系统会进行分区剪枝，以减少扫描分区的数量，提升查询性能。了解时间类型的分区剪枝规则能够帮助我们写出高效的 SQL 语句。</p><p class="- topic/p p">在实际使用中，通常会对时间分区列直接进行过滤查询，或者对时间分区列进行显式类型转换后再进行过滤。这两种情况，DolphinDB 的分区剪枝规则略有不同。下面将分开阐述。</p><p class="- topic/p p">下文介绍中将频繁出现三个名称，在此先介绍它们的概念：</p><ul class="- topic/ul ul"><li class="- topic/li li">分区方案类型：<code class="+ topic/ph pr-d/codeph ph codeph">database</code> 函数的 <em class="+ topic/ph hi-d/i ph i">partitionScheme</em> 参数指定的数据类型。在这个例子中，分区方案的类型是 <code class="+ topic/ph pr-d/codeph ph codeph">[2022.09.01,2022.09.02, 2022.09.03]</code> 的类型，即 DATE 类型：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbName = "dfs://time_comparison"
if(existsDatabase(dbName))
	dropDatabase(dbName)
db = database(dbName, VALUE, [2022.09.01,2022.09.02, 2022.09.03])</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">分区列类型：<code class="+ topic/ph pr-d/codeph ph codeph">createPartitionedTable</code> 函数的 <em class="+ topic/ph hi-d/i ph i">partitionColumns</em> 指定的列类型。在这个例子中，分区列的类型是表 <code class="+ topic/ph pr-d/codeph ph codeph">t</code> 的 <code class="+ topic/ph pr-d/codeph ph codeph">time</code> 列的类型，即 DATETIME 类型：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>n = 6
t = table(n:n,[`time,`value],[DATETIME,DOUBLE])
t[`time] = [2022.09.01T00:00:00, 2022.09.01T12:00:00, 2022.09.02T00:00:00, 2022.09.02T12:00:00, 2022.09.03T00:00:00, 2022.09.03T12:00:00]
t[`value] = 1..6
pt = db.createPartitionedTable(t, `pt, `time).append!(t)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">过滤比较中的时间对象。在这个例子中，分布式表的分区列 <code class="+ topic/ph pr-d/codeph ph codeph">time</code> 和数据 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 进行比较，<code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 则是过滤比较中的时间对象，是 DATE 类型的数据：</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where time == 2022.09.01
time                   value
-----------------------------------
2022.09.01T00:00:00    1.00000000
2022.09.01T12:00:00    2.00000000</code></pre></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="41-对分区列直接过滤"><h3 class="- topic/title title topictitle3" id="ariaid-title6">4.1 对分区列直接过滤</h3><div class="- topic/body body"><p class="- topic/p p">在分布式查询中，当我们使用运算符 &lt;, &lt;=, =, ==, &gt;, &gt;=, in, between 对时间分区列和其他时间类型的数据进行比较时， 比较的规则和在内存表中相同，且系统会进行分区剪枝。但要注意，当分区方案是 DATEHOUR 和 DATETIME 类型时，不支持创建分区表。</p><p class="- topic/p p">下例中，时间列的类型为 DATETIME，按照该列对数据按天进行 VALUE 分区。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbName = "dfs://time_comparison"
if(existsDatabase(dbName))
	dropDatabase(dbName)
	
db = database(dbName, VALUE, [2022.09.01,2022.09.02, 2022.09.03])
n = 6
t = table(n:n,[`time,`value],[DATETIME,DOUBLE])
t[`time] = [2022.09.01T00:00:00, 2022.09.01T12:00:00, 2022.09.02T00:00:00, 2022.09.02T12:00:00, 2022.09.03T00:00:00, 2022.09.03T12:00:00]
t[`value] = 1..6
pt = db.createPartitionedTable(t, `pt, `time).append!(t)</code></pre><p class="- topic/p p">想要查询 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 这一天的数据，可以直接用分区列和 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 进行比较。即使 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 的数据类型和分区列的数据类型不同，依然能够进行分区剪枝，只需扫描 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 这个分区的数据即可。我们可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">sqlDS</code> 来查看分布式查询拆分子查询的情况。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sqlDS(&lt;select * from pt where time == 2022.09.01&gt;)</code></pre><p class="- topic/p p">想要查询 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01T00:00:00.000</code> 这一时刻的数据，也可以直接用分区列和该时刻进行比较，即使两者数据类型不同，依然能进行分区剪枝，只需扫描 <code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01</code> 这个分区的数据即可。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sqlDS(&lt;select * from pt where time == 2022.09.01T00:00:00.000&gt;)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="42-对分区列进行显式类型转换后过滤"><h3 class="- topic/title title topictitle3" id="ariaid-title7">4.2 对分区列进行显式类型转换后过滤</h3><div class="- topic/body body"><p class="- topic/p p">对于显式类型转换的过滤条件中，形如 <code class="+ topic/ph pr-d/codeph ph codeph">convert_func(col) &lt;operator&gt; constant</code> 的表达式，其中 <code class="+ topic/ph pr-d/codeph ph codeph">convert_func</code> 是 date、month 等时间类型转换函数， <code class="+ topic/ph pr-d/codeph ph codeph">col</code> 是分区列，<code class="+ topic/ph pr-d/codeph ph codeph">operator</code> 是运算符，<code class="+ topic/ph pr-d/codeph ph codeph">constant</code> 是比较的值，以下情况可以进行分区剪枝。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="421-使用比较运算符"><h4 class="- topic/title title topictitle4" id="ariaid-title8">4.2.1 使用比较运算符</h4><div class="- topic/body body"><p class="- topic/p p">当 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;operator&gt;</code> 为比较运算符（&lt;, &lt;=, =, ==, &gt;, &gt;=）时，<code class="+ topic/ph pr-d/codeph ph codeph">convert_func</code> 返回的数据类型的精度小于等于 <code class="+ topic/ph pr-d/codeph ph codeph">constant</code> 的精度，并且 <code class="+ topic/ph pr-d/codeph ph codeph">convert_func</code> 返回的数据类型的精度小于等于分区列的精度，可以进行分区剪枝。</p><div class="- topic/p p"><div class="- topic/note note note note_note"><span class="note__title">注：</span> 时间精度由低到高的排序为：MONTH ＜ DATE ＜ DATEHOUR ＜ DATETIME ＜ TIMESTAMP ＜ NANOTIMESTAMP  </div></div><p class="- topic/p p">这里以 VALUE 分区为例，分区方案的类型为 DATE，按照 DATE 进行分区创建分布式表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbName = "dfs://time_comparison"
if(existsDatabase(dbName))
	dropDatabase(dbName)
	
db = database(dbName, VALUE, [2022.09.01,2022.09.30,2022.10.01,2022.10.02,2022.10.31,2022.11.01,2022.11.02,2022.12.31,2023.01.01])
n = 10
t = table(n:n,[`time,`value],[DATE,DOUBLE])
t[`time] = take([2022.09.01,2022.09.30,2022.10.01,2022.10.02,2022.10.31,2022.11.01,2022.11.02,2022.12.31,2023.01.01],n)
t[`value] = rand(100.0,n)
pt = db.createPartitionedTable(t, `pt, `time).append!(t)</code></pre><p class="- topic/p p">想要查询大于某个月的数据时，如果直接用分区列和 MONTH 类型的数据比较，是不支持的；这个时候可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">month</code> 函数，将分区列的类型转换为 MONTH 类型来进行比较。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where month(time) &gt; 2022.10M
time          value
------------------------
2022.11.01  15.00570112
2022.11.02  66.54577804
2022.12.31  48.09958597
2023.01.01  50.57664175</code></pre><p class="- topic/p p">因为运算符左右的类型一致，且 MONTH 类型的精度低于分区列 DATE 类型，系统会将小于 <code class="+ topic/ph pr-d/codeph ph codeph">2022.11M</code> 的分区都"剪枝"。</p><p class="- topic/p p">想要查询等于某一时刻的数据时，可以对分区列使用 <code class="+ topic/ph pr-d/codeph ph codeph">timestamp</code> 函数，和 TIMESTAMP 类型的数据进行比较，比如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where timestamp(time) = 2022.09.30T00:00:00.000
time          value
------------------------
2022.09.30  19.33508650</code></pre><p class="- topic/p p">但这个时候由于转换函数的类型 TIMESTAMP 的精度高于分区列 DATE 的精度，不满足分区剪枝的条件，虽然可以进行比较，但是不能进行分区剪枝。因此在这种情况下，推荐对分区列直接进行过滤的方式进行比较，效率会更高。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title9" id="422-使用-between"><h4 class="- topic/title title topictitle4" id="ariaid-title9">4.2.2 使用 between</h4><div class="- topic/body body"><p class="- topic/p p">当 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;operator&gt;</code> 为 between 时，<code class="+ topic/ph pr-d/codeph ph codeph">convert_func</code> 返回的数据类型必须与 <code class="+ topic/ph pr-d/codeph ph codeph">constant</code> 相同，才能进行分区剪枝。</p><p class="- topic/p p">想要查询在某一连续的月的数据，直接将分区列和 MONTH 类型的数据进行比较，是不支持的：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where time between month(2022.10M:2022.11M)
// between(X, Y). Temporal data comparison should have the same data type.'</code></pre><p class="- topic/p p">可以对分区列使用 <code class="+ topic/ph pr-d/codeph ph codeph">month</code> 函数，和 MONTH 类型的数据进行比较：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where month(time) between month(2022.10M:2022.11M)
time          value
------------------------
2022.10.01  24.45175347
2022.10.02  86.05015869
2022.10.31  78.28769609
2022.11.01  15.00570112
2022.11.02  66.54577804</code></pre><p class="- topic/p p">运算符 between 的左右两边的类型一致，且 MONTH 类型的精度低于分区列 DATE 的精度，满足分区剪枝的条件，系统会从 <code class="+ topic/ph pr-d/codeph ph codeph">2022.10.01, 2022.10.02, 2022.10.31, 2022.11.01, 2022.11.02</code> 这5个分区中过滤数据，其他的分区会被“剪枝”。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="423-使用-in"><h4 class="- topic/title title topictitle4" id="ariaid-title10">4.2.3 使用 in</h4><div class="- topic/body body"><p class="- topic/p p">当 <code class="+ topic/ph pr-d/codeph ph codeph">&lt;operator&gt;</code> 为 in 时，<code class="+ topic/ph pr-d/codeph ph codeph">convert_func</code> 返回的数据类型必须与 <code class="+ topic/ph pr-d/codeph ph codeph">constant</code> 相同，并且 <code class="+ topic/ph pr-d/codeph ph codeph">constant</code> 列表中的连续片段的数量小于16，才能进行分区剪枝。</p><div class="- topic/p p"><div class="- topic/note note note note_note"><span class="note__title">注：</span> 假设列表为<code class="+ topic/ph pr-d/codeph ph codeph">[2020.01.02, 2020.01.03, 2020.01.04, 2020.01.06, 2020.01.07, 2020.01.12]</code>，那么它包含3个连续片段 2020.01.02..2020.01.04，2020.01.06..2020.01.07，2020.01.12。 </div></div><p class="- topic/p p">想要查询在某一不连续的月的数据，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">month</code> 函数，和 MONTH 类型的数据进行比较：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where month(time) in [2022.09M, 2022.11M]
time          value
------------------------
2022.09.01  51.37807030
2022.09.01  50.86722047
2022.09.30  13.91816022
2022.11.01  76.58300183
2022.11.02  74.23354792</code></pre><p class="- topic/p p">运算符 in 的左右两边类型一致，且 MONTH 类型的精度低于分区列 DATE 的精度，<code class="+ topic/ph pr-d/codeph ph codeph">[2022.09M, 2022.11M]</code> 是一个不连续的片段，但是片段的数据小于16，满足分区剪枝的条件，系统会从<code class="+ topic/ph pr-d/codeph ph codeph">2022.09.01, 2022.09.30, 2022.11.01, 2022.11.02</code> 这4个分区中过滤数据，其他的分区会被“剪枝”。</p><p class="- topic/p p">想要查询在某一连续时刻的数据，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">timestamp</code> 函数，和 TIMESTAMP 类型的数据进行比较：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pt where timestamp(time) in timestamp(2022.10.31..2022.11.01)
time          value
------------------------
2022.10.31  78.28769609
2022.11.01  15.00570112</code></pre><p class="- topic/p p">虽然运算符 in 的左右两边的类型一致，但因为 TIMESTAMP 的精度高于分区列 DATE 的精度，因此不能进行分区剪枝。</p></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title11" id="小结"><h2 class="- topic/title title topictitle2" id="ariaid-title11">小结</h2><div class="- topic/body body"><p class="- topic/p p">对时间类型进行比较的规则可以分为两类：涉及分区剪枝时的比较和不涉及分区剪枝时的比较。通常时间类型向量比较，内存表查询和分布式表查询中过滤条件为非分区列时的时间类型比较均不涉及分区剪枝。而分布式表查询中过滤条件为分区列时，时间类型比较会涉及分区剪枝。在实际使用过程中，推荐使用支持分区剪枝的 where 条件来提升查询的效率。尤其针对数据量非常大的分区表进行查询时，分区剪枝能够节省大量时间。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D" data-tocid="1-时间类型介绍">1. 时间类型介绍</a></li><li class="topic-item"><a href="#2-%E6%98%BE%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" data-tocid="2-显式的时间类型转换">2. 显式的时间类型转换</a></li><li class="topic-item"><a href="#3-%E5%B8%B8%E8%A7%84%E7%9A%84%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83" data-tocid="3-常规的时间类型比较">3. 常规的时间类型比较</a></li><li class="topic-item"><a href="#4-%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%86%E5%8C%BA%E5%89%AA%E6%9E%9D" data-tocid="4-时间类型的分区剪枝">4. 时间类型的分区剪枝</a><ul><li class="topic-item"><a href="#41-%E5%AF%B9%E5%88%86%E5%8C%BA%E5%88%97%E7%9B%B4%E6%8E%A5%E8%BF%87%E6%BB%A4" data-tocid="41-对分区列直接过滤">4.1 对分区列直接过滤</a></li><li class="topic-item"><a href="#42-%E5%AF%B9%E5%88%86%E5%8C%BA%E5%88%97%E8%BF%9B%E8%A1%8C%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%90%8E%E8%BF%87%E6%BB%A4" data-tocid="42-对分区列进行显式类型转换后过滤">4.2 对分区列进行显式类型转换后过滤</a><ul><li class="topic-item"><a href="#421-%E4%BD%BF%E7%94%A8%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6" data-tocid="421-使用比较运算符">4.2.1 使用比较运算符</a></li><li class="topic-item"><a href="#422-%E4%BD%BF%E7%94%A8-between" data-tocid="422-使用-between">4.2.2 使用 between</a></li><li class="topic-item"><a href="#423-%E4%BD%BF%E7%94%A8-in" data-tocid="423-使用-in">4.2.3 使用 in</a></li></ul></li></ul></li><li class="topic-item"><a href="#%E5%B0%8F%E7%BB%93" data-tocid="小结">小结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>