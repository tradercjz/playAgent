<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="面向读者 本教程面向已有一定基础的 DophinDB CEP 引擎使用者，意在帮助读者进一步学习 DolphinDB CEP 引擎在量化交易场景下的灵活用法 建议读者首先阅读和掌握以下教程，再阅读本文的内容 CEP 引擎入门：初级高频量价因子策略的实现 扩展材料 除了基础 DolphinDB 概念外，本教程还推荐以下扩展阅读以更好理解本案例的代码： 模拟撮合插件使用教程 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="cep-引擎应用股票中高频-cta-策略实现与并行回测"/><title>CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;cep-引擎应用股票中高频-cta-策略实现与并行回测&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CEP 引擎应用：股票中高频 CTA 策略实现与并行回测&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;面向读者&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本教程面向已有一定基础的 DophinDB CEP 引擎使用者，意在帮助读者进一步学习 DolphinDB CEP 引擎在量化交易场景下的灵活用法&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;6:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;建议读者首先阅读和掌握以下教程，再阅读本文的内容&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;7:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;7:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;getting_started_with_cep_engine.md&#34; xtrc=&#34;xref:1;7:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;CEP 引擎入门：初级高频量价因子策略的实现&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;扩展材料&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;除了基础 DolphinDB 概念外，本教程还推荐以下扩展阅读以更好理解本案例的代码：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;12:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;12:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;matching_engine_simulator.md&#34; xtrc=&#34;xref:2;12:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;模拟撮合插件使用教程&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;13:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;dashboard_tutorial.dita&#34; xtrc=&#34;xref:3;13:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;数据面板（Dashboard）&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;14:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; href=&#34;../funcs/r/replay.dita&#34; xtrc=&#34;xref:4;14:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;数据回放（Replay）&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在上一篇&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;getting_started_with_cep_engine.md&#34; xtrc=&#34;xref:5;16:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;复杂事件处理（Complex Events Processing, CEP）引擎的系列教程&lt;/xref&gt;中，我们详细介绍了 CEP 引擎和它的一些关键概念，如复杂事件和事件监听器等。随后又通过两个初级的 CEP 引擎使用案例介绍了创建并运行一个最简单结构的 CEP 引擎所需的步骤和模块，以及在 CEP 引擎内部调用其他流计算引擎进行实时因子计算的方法。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本文将进一步介绍如何基于 CEP 引擎实现一个股票 CTA 策略，并使用真实市场数据进行回测。为了实现回测，CEP 引擎将联动模拟撮合引擎（Matching Engine Simulator）插件来模拟委托订单的发出与快照行情的撮合。同时将介绍技术指标和买卖信号的实时可视化。在文末，将更进一步介绍如何在 CEP 引擎中实现并行的参数寻优，以最大程度地接近真实的使用场景。文章将提供完整的测试代码和脱敏后的测试数据，供读者在 3.00.1.3 及以上版本的 server 学习，详情见文末&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;18:245&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;附录&lt;/b&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;注：案例中使用的 CEP 引擎和模拟撮合引擎插件均需要相应的 license。欢迎联系 DolphinDB 小助手咨询试用，微信号 13306510479。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:54;79:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1--策略逻辑&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1. 策略逻辑&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本教程中的案例策略是一种典型的趋势策略，基于实时的高频数据进行指标计算，旨在将短时间内量价指标的突变作为趋势开始的信号。该策略利用高频交易的速度优势提前建仓以跟踪趋势，并在指标显示趋势结束时平仓。策略信号将由 MACD、CCI 和成交量三个指标的条件组合所触发，具体信号产生的逻辑如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;当 MACD 出现金叉（DIFF 上穿 DEA）后，出现以下任意情形之一则买入500股：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;27:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;27:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;过去30秒内的 CCI 指标从下向上突破+100线进入超买区间，并且过去30秒的成交量之和大于50000股&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;28:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;过去30秒内的 CCI 指标从下向上突破-100线&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;29:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;当 MACD 出现死叉（DIFF 下穿 DEA）后，对相应标的作清仓操作（若有持仓）&lt;/li&gt;&lt;/ul&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/1-1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;4096&#34; dita-ot:image-height=&#34;1209&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;出现下单信号的场景一共有以下三种：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;35:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;当 MACD 指标出现金叉，且过去 30 秒内 CCI 指标上穿 100，且过去 30 秒内成交量之和超过 50000 时， 触发下单；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;当 MACD 指标出现金叉，且过去30秒内 CCI 指标上穿 -100时，触发下单；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;37:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;当 MACD 指标出现死叉时，触发清仓。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2--主要功能模块&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;2. 主要功能模块&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;39:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;上文中的策略逻辑将通过 CEP 引擎实现，此外，还利用了数据回放（Replay）和模拟撮合引擎（Matching Engine Simulator）插件进行策略回测。大致流程如下图所示。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/2-1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:2;43:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;4096&#34; dita-ot:image-height=&#34;2238&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;45:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CEP 引擎中的事件监听器在监听到策略启动事件后将设置对快照事件、成交事件等事件的监听，这意味着启动整个策略。行情数据通过数据回放（Replay）功能进入引擎后，将被对应的监听器捕获并触发指标计算和后续的策略信号判断逻辑。下面将分模块地介绍它们的主要功能。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-cep-引擎&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;2.1 CEP 引擎&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;49:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CEP 引擎模块是策略中最重要，也是最复杂的部分。在本案例中，采用了动态启动策略的方式：当引擎内的事件监听器（Event Listener）捕获策略启动事件时才会设置其他监听（如监听快照事件和逐笔成交事件）、创建模拟撮合和响应式状态引擎（Reactive State Engine，RSE）和所需的一些共享表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;51:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;策略启动后，行情数据通过数据回放进入 CEP 引擎时，将被反序列化为快照事件和逐笔成交事件。当快照事件和逐笔成交事件被对应的事件监听器所捕捉时，将触发对应的处理函数。一方面把快照数据和逐笔成交数据分别传入两个响应式状态引擎进行指标计算，另一方面将快照数据同步更新到模拟撮合引擎中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;53:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;两个响应式状态引擎将分别利用 ta 模块计算 MACD、CCI 和成交量指标，并将计算结果传递给对应的回调函数。回调函数把因子值写入共享流数据表，以便在数据面板（Dashboard）中进行可视化展示。与此同时，会按照上文中提到的信号判断逻辑进行一系列的信号判断。当产生买入或卖出的信号时构造内部订单事件（InnerOrder），而内部订单事件将被对应的监听器捕获，触发执行下单函数。本例的下单函数中，构造了符合模拟撮合引擎输入格式的委托订单，将其发送给模拟撮合引擎并与行情快照进行撮合。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-数据回放&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;2.2 数据回放&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;数据回放 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;57:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Replay&lt;/codeph&gt; 是 DolphinDB 中常用于高频策略回测场景的方法，它可以根据指定的回放模式，按时间顺序将一个或多个数据表（或由 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;57:74&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replayDS&lt;/codeph&gt; 函数返回的数据源列表）的数据回放到某个数据表或引擎，以模拟实时数据的写入。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;由于行情快照由交易所按固定时间间隔推送，而逐笔成交数据的产生则完全取决于当日实际的交易情况，所以这两种数据的时间戳并不完全一致。 Replay 可以很好地将这两种数据按时间戳排序后输出到流数据表。并且，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;59:102&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Replay&lt;/codeph&gt; 还可以将结构不同的多个表数据序列化后回放到一个异构流数据表中。通过订阅该异构流数据表，就可以向 CEP 引擎按时间顺序输入数据，以模拟事件按时间顺序发生的真实情况。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本案例数据将使用真实的历史行情快照和逐笔成交数据，通过数据回放模拟实时的事件流并进行处理。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-模拟撮合引擎&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;2.3 模拟撮合引擎&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在高频交易中，常有回测表现良好的策略，由于没有考虑到相应的滑点、发送订单的时延等摩擦成本，而在实盘交易中表现不佳。为了使策略研究时更贴近真实的交易情况，可以在回测过程中引入 DolphinDB 的模拟撮合插件来模拟真实交易的情况。模拟撮合引擎可以模拟用户在某个时间点发出订单或取消之前已发出订单的操作，并获取相应的交易结果，其逻辑架构如下图所示。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/2-2.png&#34; width=&#34;80%&#34; xtrc=&#34;image:3;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1307&#34; dita-ot:image-height=&#34;827&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;69:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;模拟撮合引擎以行情（快照数据或逐笔数据）和用户委托订单（买方或卖方）作为输入，根据订单撮合规则模拟撮合，将订单的成交结果（包含部分成交结果、拒绝订单和已撤订单）输出至交易明细输出表，未成交部分等待与后续行情撮合成交或者等待撤单。关于更多引擎运行机制的说明和撮合规则的解释见&lt;xref class=&#34;- topic/xref &#34; href=&#34;../plugins/matchingEngineSimulator/mes.dita&#34; xtrc=&#34;xref:6;69:137&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;官方文档&lt;/xref&gt; 。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在本案例中，当策略启动以后才需要向模拟撮合引擎发送委托订单，因此创建模拟撮合引擎的函数将放在 CEP 引擎内部。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;注：模拟撮合插件需要用户自行从插件仓库下载并加载，代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;login(&#34;admin&#34;, &#34;123456&#34;) //使用 installPlugin 命令完成插件安装 installPlugin(&#34;MatchingEngineSimulator&#34;) //使用 loadPlugin 命令加载插件。 loadPlugin(&#34;MatchingEngineSimulator&#34;)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3--策略代码实现&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3. 策略代码实现&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在本章中我们将具体介绍策略代码的实现，包括定义事件、定义监视器、创建 CEP 引擎、启动策略实例、回放历史数据等功能模块，完整代码见文末附录。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-定义事件类&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.1 定义事件类&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;89:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;首先定义在 CEP 引擎内部会涉及到的事件类，完整的事件定义代码见附件。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;91:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;策略启动（Initiating）、行情快照（Snapshot）和逐笔成交（Transaction）事件均由外部写入 CEP 引擎中。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;93:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;93:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;策略启动事件的成员属性中包含策略实例 id、初始现金、持仓量、股票池和策略参数等与策略初始设置相关的信息。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;95:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;内部订单事件在 CEP 引擎中产生并通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;95:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;routeEvent&lt;/codeph&gt; 接口在引擎内部传递。此事件对于策略实现并不是必须的，仅仅为了在工程上解耦产生买入信号和下单两部分逻辑。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;97:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;97:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;买单事件（BuyOrder）和卖单事件（SellOrder）在 CEP 引擎中产生，并通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;97:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;emitEvent&lt;/codeph&gt; 接口发送到外部。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;99:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;// 策略启动事件 class Initiating { instanceId :: STRING factorParams :: ANY strategyParams :: ANY eventTime :: TIMESTAMP cashAmount :: INT holdingQty :: INT VECTOR stockPool :: STRING VECTOR def Initiating(instanceId_, factorParams_, strategyParams_, time_, cashAmount_,holdingQty_,stockPool_){ instanceId = instanceId_ factorParams = factorParams_ strategyParams = strategyParams_ eventTime = time_ cashAmount = cashAmount_ holdingQty = holdingQty_ stockPool = stockPool_ } } // 行情快照事件 class Snapshot { ... } // 逐笔成交事件 class Transaction { ... } // 内部订单事件 class InnerOrder { ... } // 买单事件 class BuyOrder { ... } // 卖单事件 class SellOrder { ... }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;132:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;​&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-定义监视器&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.2 定义监视器&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;136:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CEP 引擎的创建和其内部监视器的配置是策略实现中最关键的步骤。监视器内封装了整个交易策略，其结构大致如下。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;138:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;use ta class Monitor { securitySelected :: STRING VECTOR instanceId :: STRING factorParams :: ANY strategyParams :: ANY newDiff :: ANY preDiff :: ANY preDea :: ANY pre30cci :: ANY pre30vol :: ANY newCci :: ANY priceJustTraded :: ANY orderState :: ANY availablePos :: ANY initCash :: INT availableCash :: INT initHoldingValue :: INT timestamp :: TIMESTAMP orderCount :: INT def Monitor(){ availablePos = dict(STRING, INT) newDiff = dict(STRING, DOUBLE) preDiff = dict(STRING, DOUBLE) preDea = dict(STRING, DOUBLE) pre30cci = dict(STRING, DOUBLE) pre30vol = dict(STRING, DOUBLE) newCci = dict(STRING, DOUBLE) priceJustTraded = dict(STRING, DOUBLE) orderState = dict(STRING, BOOL) timestamp = 2023.02.01 08:00:00.000 orderCount = 0 } def createMatchingEngine(instanceId){} def emptyPosition(securityid){} def refreshOrderState(orderSecurity){} def buyOrder(innerOrder){} def handleMacdCciOutput(macdCciResult) {} def checkCciAndVol(securityid){} def orderStateCheck(innerOrder){} def checkGoldenCross(securityid, diff, dea) {} def handleVolOutput(volResult){} def updateMatchingEngineQuotes(SnapshotEvent){} def processSnapshot(SnapshotEvent) {} def processTrans(transactionEvent) {} def createCalFactorEngines(instanceId){} def initiatingStrategy(Initiating){} def onload() { addEventListener(handler=initiatingStrategy, eventType=&#34;Initiating&#34;, times=&#34;all&#34;) } }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;下面将按照 CEP 引擎运作的逻辑顺序，依次介绍监视器中各个成员方法的具体内容。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;onload 初始化&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建引擎并实例化监视器后，将首先调用其内部的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;196:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;onload&lt;/codeph&gt; 函数。回顾上文提到的 CEP 模块所负责的功能，其工作流的源头是监听策略启动事件，一旦监听到策略启动事件才进行下一步的操作。因此，在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;196:100&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;onload&lt;/codeph&gt; 函数中，只需考虑设置相关的事件监听器以便启动策略即可。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def onload() {     addEventListener(handler=initiatingStrategy, eventType=&#34;Initiating&#34;, times=&#34;all&#34;) }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;设置了一个事件监听器，监听所有的策略启动事件。目的是当监听到该事件时，下一步将启动整个策略，因此在对应的回调函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;204:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;initiatingStrategy&lt;/codeph&gt; 中需要包含对行情事件的监听器和创建所需要的计算引擎等步骤。从 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;204:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;onload&lt;/codeph&gt; 方法开始，函数调用的流程与实现的功能大致如下图所示。&lt;/li&gt;&lt;/ul&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/3-1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:4;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;4096&#34; dita-ot:image-height=&#34;1823&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;208:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;接下来从策略启动事件对应的回调函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;208:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;initiatingStrategy&lt;/codeph&gt; 开始来介绍具体的代码实现。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;210:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;启动策略&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;212:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def initiatingStrategy(Initiating){ instanceId = Initiating.instanceId factorParams = Initiating.factorParams strategyParams = Initiating.strategyParams initCash = Initiating.cashAmount availableCash = initCash initHoldingQty = Initiating.holdingQty securitySelected = Initiating.stockPool availablePos[securitySelected] = initHoldingQty preCloTable = select SecurityID, PreCloPrice from loadTable(&#34;dfs://testDB&#34;, `snapshot) where date(TradeTime) = 2023.02.02 context by SecurityID limit 1 preCloDict = dict(preCloTable.SecurityID, preCloTable.PreCloPrice) preClo = preCloDict[securitySelected] initHoldingValue = sum(preClo * initHoldingQty) //创建表，统计实时情况 share(table(100:0,[&#34;time&#34;,&#34;changeAmount&#34;,&#34;availableCash&#34;],[TIMESTAMP, INT, INT]), &#34;CashTable&#34;+instanceId) cashTb = objByName(&#34;CashTable&#34;+instanceId) cashTb.tableInsert(timestamp,0,availableCash //创建模拟撮合引擎 createMatchingEngine(instanceId) //创建信号表，dashboard展示 share(streamTable(100:0,`securityid`direction`Time`orderPrice`BS_Signal, `STRING`INT`TIMESTAMP`DOUBLE`DOUBLE),&#34;signalTb&#34;+instanceId) signalTb = objByName(&#34;signalTb&#34;+instanceId) //监听快照 addEventListener(handler=processSnapshot, eventType=&#34;Snapshot&#34;, times=&#34;all&#34;) addEventListener(handler=updateMatchingEngineQuotes, eventType=&#34;Snapshot&#34;, times=&#34;all&#34;) //监听逐笔成交 addEventListener(handler=processTrans, eventType=&#34;Transaction&#34;, times=&#34;all&#34;) //监听内部事件，检查下单状态 addEventListener(handler=orderStateCheck, eventType=&#34;InnerOrder&#34;, condition=&amp;lt;InnerOrder.instanceId=instanceId&amp;gt;, times=&#34;all&#34;) createCalFactorEngines(instanceId) }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;251:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;从监听到的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;251:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Initiating&lt;/codeph&gt; 事件中获取各种策略设定值，如指标计算参数字典、策略参数字典、初始资金和初始持仓等。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;253:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;从数据库中取出对应股票的昨日收盘价，与初始持仓数量一起计算出初始的总持仓价值。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;255:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建并共享一个资金统计表，用于统计策略实时的资金变化，并将初始的现金情况插入表中；创建并共享一个买卖信号表，用于可视化买卖信号。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;257:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;257:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;createMatchingEngine&lt;/codeph&gt; 函数，创建模拟撮合引擎。主要步骤包括配置文件修改、行情表和用户订单表结构定义、列名映射配置、成交明细输出表定义和创建引擎。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;259:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def createMatchingEngine(instanceId){ //撮合引擎cfg config = dict(STRING, DOUBLE); config[&#34;latency&#34;] = 0; config[&#34;depth&#34;] = 10; config[&#34;outputOrderBook&#34;] = 0 //用户订单时延为0 config[&#34;orderBookMatchingRatio&#34;] = 1; //与订单薄匹配时的成交百分比 config[&#34;dataType&#34;] = 1; //行情类别：1表示股票快照 config[&#34;matchingMode&#34;] = 1; //撮合模式一：与最新成交价以及对手方盘口按配置的比例撮合 config[&#34;matchingRatio&#34;] = 0.1; //快照模式下，快照的区间成交百分比 //根据行情表和用户订单表的表结构来创建相应的列名映射字典 //snapshot输入表结构 dummyQuotationTable = table(1:0,`SecurityID`Market`TradeTime`LastPrice `UpLimitPx`DownLimitPx`TotalBidQty`TotalOfferQty`BidPrice`BidOrderQty `OfferPrice`OfferOrderQty,[STRING,STRING,TIMESTAMP,DOUBLE,DOUBLE,DOUBLE,LONG, LONG,DOUBLE[],INT[],DOUBLE[],INT[]]) quotationColMap = dict(`symbol`symbolSource`timestamp`lastPrice`upLimitPrice `downLimitPrice`totalBidQty`totalOfferQty`bidPrice`bidQty`offerPrice`offerQty, `SecurityID`Market`TradeTime`LastPrice`UpLimitPx`DownLimitPx`TotalBidQty `TotalOfferQty`BidPrice`BidOrderQty`OfferPrice`OfferOrderQty) //委托订单结构 dummyUserOrderTable = table(1:0, `symbol`time`orderType`price`qty`BSFlag `orderID, [STRING, TIMESTAMP, INT, DOUBLE, LONG, INT, LONG]) userOrderColMap = dict( `symbol`timestamp`orderType`price`orderQty`direction `orderId, `symbol`time`orderType`price`qty`BSFlag`orderID) //自定义输出表的形式 tradeOutputTable = table(1:0, `orderId`symbol`direction`sendTime`orderPrice `orderQty`tradeTime`tradePrice`tradeQty`orderStatus`sysReceiveTime, [LONG, STRING, INT, TIMESTAMP,DOUBLE,LONG, TIMESTAMP,DOUBLE,LONG, INT, NANOTIMESTAMP]) share(tradeOutputTable,&#34;MatchingResult&#34;+instanceId) matResultTb = objByName(&#34;MatchingResult&#34;+instanceId) //撮合深交所股票 exchange = &#34;XSHE&#34; //创建引擎 name = &#34;MatchingEngine&#34;+instanceId matchingEngine = MatchingEngineSimulator::createMatchEngine(name, exchange, config, dummyQuotationTable, quotationColMap, dummyUserOrderTable, userOrderColMap, matResultTb) } &lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:11;302:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;302:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在加载模拟撮合插件后，可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;302:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;MatchingEngineSimulator::createMatchEngine&lt;/codeph&gt; 函数创建模拟撮合引擎。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;303:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;exchange 参数指定交易所代码，用于明确撮合规则。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;304:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;构造了一个 config 字典，并在字典中配置撮合引擎的撮合设定，如订单时延、输入给撮合引擎的行情类别、撮合模式等。更详细的参数设置和含义见&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;matching_engine_simulator.md&#34; xtrc=&#34;xref:7;304:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;模拟撮合引擎使用教程&lt;/xref&gt;。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;305:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;对于输入表 dummyQuotationTable 和 dummyUserOrderTable，模拟撮合引擎要求它们必须包含指定的字段名称。如果自定义的行情数据表的字段名称与引擎要求不一致，可以通过 quotationColMap 字典进行映射；同样地，如果自定义的用户委托订单数据表的字段名称与引擎要求不一致，可以通过 userOrderColMap 字典进行映射。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;306:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;对于输出表 tradeOutputTable，模拟撮合引擎对它的字段名称没有要求，但其输出的每个字段有特定的含义，所以字段的顺序不能改变。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;309:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;309:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建 4 个事件监听器，其中：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:12;311:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;311:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;监听所有的快照事件，一旦监听到快照事件，将立刻调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;311:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;processSnapshot&lt;/codeph&gt; 函数进行处理。该函数的功能是将快照数据写入响应式状态引擎进行指标的计算。&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;313:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def processSnapshot(SnapshotEvent) { timestamp = SnapshotEvent.snapshotTime macdCciCalEngine = getStreamEngine(&#34;CalMacdCciEngine&#34;+instanceId) insert into macdCciCalEngine values([SnapshotEvent.snapshotTime, SnapshotEvent.securityid, SnapshotEvent.lastPrice, SnapshotEvent.openPrice, SnapshotEvent.highPrice, SnapshotEvent.lowPrice]) } &lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:13;323:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:31;323:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;323:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;监听所有的快照事件，一旦监听到快照事件，将立刻调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;323:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;updateMatchingEngineQuotes&lt;/codeph&gt; 函数进行处理。该函数的功能是将行情数据写入模拟撮合引擎，使模拟撮合引擎中的行情与指标计算、产生信号的操作同步。在本案例中可以看到，在 CEP 引擎中同一个事件可以同时被多个事件监听器监听，触发不同的操作。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;325:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def updateMatchingEngineQuotes(SnapshotEvent){ SecurityID = SnapshotEvent.securityid Market = SnapshotEvent.market TradeTime = SnapshotEvent.snapshotTime LastPrice = SnapshotEvent.lastPrice UplimitPx = SnapshotEvent.upLimitPx DownLimitPx = SnapshotEvent.downLimitPx TotalBidQty = SnapshotEvent.totalBidQty TotalOfferQty = SnapshotEvent.totalOfferQty BidPrice = SnapshotEvent.bidPrice BidOrderQty = SnapshotEvent.bidOrderQty OfferPrice = SnapshotEvent.offerPrice OfferOrderQty = SnapshotEvent.offerOrderQty quoteTable = table(100:0,[&#34;SecurityID&#34;, &#34;Market&#34;,&#34;TradeTime&#34;, &#34;LastPrice&#34;, &#34;UplimitPx&#34;,&#34;DownLimitPx&#34;,&#34;TotalBidQty&#34;,&#34;TotalOfferQty&#34;,&#34;BidPrice&#34;, &#34;BidOrderQty&#34;,&#34;OfferPrice&#34;,&#34;OfferOrderQty&#34;], [STRING, STRING, TIMESTAMP, DOUBLE, DOUBLE, DOUBLE, LONG, LONG, DOUBLE[], INT[], DOUBLE[], INT[]]) quoteTable.tableInsert([SecurityID],[Market],[TradeTime],[LastPrice], [UplimitPx],[DownLimitPx],[TotalBidQty],[TotalOfferQty],[BidPrice], [BidOrderQty],[OfferPrice],[OfferOrderQty]) MatchingEngineSimulator::insertMsg(getStreamEngine(&#34;MatchingEngine&#34;+ instanceId), quoteTable, 1) }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:32;351:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;351:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;监听所有的成交事件，一旦监听到成交事件，将立刻调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;351:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;processTrans&lt;/codeph&gt; 函数进行处理。该函数的功能是将成交数据写入响应式状态引擎进行指标的计算。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;353:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def processTrans(transactionEvent) { if(transactionEvent.tradePrice != 0){ timestamp = transactionEvent.transTime volCalEngine = getStreamEngine(&#34;CalVolEngine&#34;+instanceId) insert into volCalEngine values([transactionEvent.securityid, transactionEvent.tradePrice, transactionEvent.volume, transactionEvent.transTime]) } else{return} }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:33;366:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;366:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;监听所有的内部订单事件，一旦监听到内部订单事件，将立刻调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;366:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;orderStateCheck&lt;/codeph&gt; 函数进行处理，该函数的功能是检查下单状态后下单。该函数由内部订单事件触发，将在后文再做详细介绍。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:34;368:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;368:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;368:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;createCalFactorEngines&lt;/codeph&gt; 函数，创建对应的因子计算引擎（响应式状态引擎）。这是后续一切流程的开始，下面详细介绍该函数的功能实现。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;370:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建响应式状态引擎&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;372:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建两个响应式状态引擎，分别对快照和逐笔数据计算不同的指标。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/3-2.png&#34; placement=&#34;break&#34; xtrc=&#34;image:5;374:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;4096&#34; dita-ot:image-height=&#34;821&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;376:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def createCalFactorEngines(instanceId){ //MACD CCI计算 calDummy = streamTable(1:0, [&#34;snapshotTime&#34;,&#34;securityid&#34;,&#34;LastPrice&#34;,&#34;OpenPrice&#34; ,&#34;HighPrice&#34;,&#34;LowPrice&#34;], [TIMESTAMP, STRING, DOUBLE, DOUBLE , DOUBLE , DOUBLE]) macdFastPeriod = factorParams[`macd][`fastPeriod] macdSlowPeriod = factorParams[`macd][`slowPeriod] macdSignalPeriod = factorParams[`macd][`signalPeriod] cciTimePeriod = factorParams[`cci][`timePeriod] calMetrics = [&amp;lt;snapshotTime&amp;gt;, &amp;lt;ta::macd(LastPrice, macdFastPeriod, macdSlowPeriod, macdSignalPeriod) as `diff`dea`macdHistogram&amp;gt;, &amp;lt;ta::cci(HighPrice, LowPrice, LastPrice, cciTimePeriod) as `cci&amp;gt;] macdCciOutputTable = streamTable(1:0, [&#34;securityid&#34;, &#34;time&#34;, &#34;diff&#34;, &#34;dea&#34;, &#34;macdHistogram&#34;, &#34;cci&#34;], [STRING, TIMESTAMP, DOUBLE, DOUBLE, DOUBLE, DOUBLE]) share(macdCciOutputTable,&#34;MacdAndCci&#34;+instanceId) macdCciOutputTable = objByName(&#34;MacdAndCci&#34;+instanceId) macdCciCalEngine = createReactiveStateEngine(name=&#34;CalMacdCciEngine&#34;+instanceId, metrics=calMetrics, dummyTable=calDummy, outputTable=macdCciOutputTable, outputHandler=handleMacdCciOutput ,keyColumn=`securityid, keepOrder=true, msgAsTable=true) //引擎预热 warmupTable = select TradeTime,SecurityID,LastPrice,OpenPrice,HighPrice, LowPrice from loadTable('dfs://testDB',`snapshot) where (second(TradeTime) &amp;gt;= second(09:30:00.000) and second(TradeTime) &amp;lt;= second(15:00:00.000)) and date(TradeTime) = 2023.02.01 order by TradeTime warmupStreamEngine(macdCciCalEngine, warmupTable) //vol计算 volDummy = streamTable(1:0, [&#34;securityid&#34;, &#34;TradePrice&#34;, &#34;vol&#34;, &#34;transTime&#34;], [STRING, DOUBLE, INT, TIMESTAMP]) volTimePeriod = factorParams[`volume][`timePeriod] volMetrics = [&amp;lt;TradePrice&amp;gt;, &amp;lt;tmsum(transTime, vol, volTimePeriod)&amp;gt;, &amp;lt;transTime&amp;gt;] volOutputTable = streamTable(1:0, [&#34;securityid&#34;, &#34;TradePrice&#34;,&#34;vol&#34;, &#34;time&#34;], [STRING, DOUBLE,INT, TIMESTAMP]) share(volOutputTable,&#34;Vol&#34;+instanceId) volOutputTable = objByName(&#34;Vol&#34;+instanceId) volCalEngine = createReactiveStateEngine(name=&#34;CalVolEngine&#34;+instanceId, metrics=volMetrics, dummyTable=volDummy, outputTable=volOutputTable, outputHandler=handleVolOutput ,keyColumn=`securityid, keepOrder=true, msgAsTable=true) }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:14;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:35;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;为了方便用户使用 TA - Lib 中的技术指标，DolphinDB 提供了以 DolphinScript 实现的 TA-Lib 中包含的指标函数，并封装在 DolphinDB &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;../modules/ta/ta.md&#34; xtrc=&#34;xref:8;418:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;ta 模块&lt;/xref&gt; 中。 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;418:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;createReactiveStateEngine&lt;/codeph&gt; 函数通过 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;418:157&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;metrics&lt;/i&gt; 参数指定计算指标，本案例用到了 ta 模块（已经在创建监视器前声明 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;418:201&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;use ta&lt;/codeph&gt;）来方便地表达指标逻辑，省去了用户编写复杂计算公式的步骤。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:36;419:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;以输入快照数据、计算 MACD 和 CCI 指标的响应式状态引擎为例，引擎计算的结果将交由 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;419:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;handleMacdCciOutput&lt;/codeph&gt; 函数处理。在该函数中将进行下单信号的判断，我们将在后文进行详细介绍。创建计算成交量指标的响应式状态引擎的流程类似，其计算结果交由 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;419:136&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;handleVolOutput&lt;/codeph&gt; 函数处理。注意，设置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;419:165&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;outputHandler&lt;/i&gt; 参数后，引擎不再将每次的计算结果写到输出表 macdCciOutputTable，而是会不断地调用 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;419:231&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;outputHandler&lt;/i&gt; 参数指定的函数处理计算结果。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;421:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在创建计算引擎的函数中，有一段关于引擎预热的代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;warmupTable = select TradeTime,SecurityID,LastPrice,OpenPrice,HighPrice,LowPrice from loadTable('dfs://testDB',`snapshot) where (second(TradeTime) &amp;gt;= second(09:30:00.000) and second(TradeTime) &amp;lt;= second(15:00:00.000)) and date(TradeTime) = 2023.02.01 order by TradeTime warmupStreamEngine(macdCciCalEngine, warmupTable)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:15;431:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:37;431:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;这段代码的目的是对计算 MACD 和 CCI 指标的响应式状态引擎进行预热。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;431:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;warmupStreamEngine&lt;/codeph&gt; 会把前一天的数据写入流数据引擎并进行计算，但是不输出结果。当当日的数据正常写入此流数据引擎后，滑动窗口将包含前一日的快照数据。在本例中 MACD 指标中涉及时间最久的参数 slowPeriod = 520，即 520 个滑动窗口，若不进行预热，则会出现在开盘后近 30 分钟内指标计算结果为空的情况。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;433:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;433:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;处理响应式状态引擎计算结果&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;435:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;435:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;handleVolOutput&lt;/b&gt;&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;437:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def handleVolOutput(volResult){ tableInsert(objByName(&#34;Vol&#34;+instanceId), volResult) priceJustTraded[volResult.securityid[0]] = volResult.TradePrice[0] pre30vol[volResult.securityid[0]] = volResult[`vol][0] }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:16;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:38;445:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;把引擎的计算结果写入对应的输出表中，这与策略逻辑无关，仅供 Dashboard 可视化展示。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:39;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;更新存储最新成交价的字典，字典的键值为股票，之后将用最新的成交价格作为委托买入或卖出的价格。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:40;447:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;更新存储30秒成交量之和的字典 pre30vol，字典的键值为股票。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:9;449:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;handleMacdCciOutput&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;451:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;函数调用流程与大致功能如下图所示。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/3-3.png&#34; placement=&#34;break&#34; xtrc=&#34;image:6;453:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;2740&#34; dita-ot:image-height=&#34;864&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def handleMacdCciOutput(macdCciResult) { tableInsert(macdCciOutputTable, macdCciResult) if(second(macdCciResult.time)&amp;lt;09:30:00 or second(macdCciResult.time) &amp;gt;15:00:00 ){ return } self.checkGoldenCross(macdCciResult.securityid[0], macdCciResult.diff[0], macdCciResult.dea[0]) preDiff[macdCciResult.securityid[0]] = macdCciResult.diff[0] preDea[macdCciResult.securityid[0]] = macdCciResult.dea [0] if (pre30cci[macdCciResult.securityid[0]] == NULL) { pre30cci[macdCciResult.securityid[0]] = macdCciResult.cci[0] } else if(pre30cci[macdCciResult.securityid[0]] != NULL and newCci[macdCciResult.securityid[0]] == NULL){ newCci[macdCciResult.securityid[0]] = macdCciResult.cci[0] } else{pre30cci[macdCciResult.securityid[0]] = newCci[macdCciResult.securityid[0]] newCci[macdCciResult.securityid[0]] = macdCciResult.cci[0]} }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:17;477:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:41;477:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;477:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;同理，先将计算结果插入到对应的共享表中以供 Dashboard 可视化展示。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:42;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;479:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;调用金叉检查函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;479:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;checkGoldenCross&lt;/codeph&gt; 检查是否产生金叉：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;481:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def checkGoldenCross(securityid, diff, dea) { if (self.preDiff[securityid] != NULL and self.preDea[securityid] != NULL) { if (self.preDiff[securityid] &amp;lt; self.preDea[securityid] and diff &amp;gt; dea) { newDiff[securityid] = diff checkCciAndVol(securityid) } if (self.preDiff[securityid] &amp;gt; self.preDea[securityid] and diff &amp;lt; dea){ newDiff[securityid] = diff emptyPosition(securityid) } } }   &lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:18;496:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:43;496:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;496:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;若产生死叉，调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;496:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;emptyPosition&lt;/codeph&gt; 进行清仓：函数将从持仓状态字典中获取死叉股票的现有持仓量，同时获取死叉出现时的时间戳作为委托卖单的时间。若死叉股票有持仓，则一方面构造 SellOrder 事件，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;496:116&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;emitEvent&lt;/codeph&gt; 接口将其向外发送给事件输出队列；一方面按照模拟撮合引擎订单结构，构造相应的委托卖单订单消息，通过对应的插件接口发送给模拟撮合引擎。发出委托消息后，记录卖出信号供 Dashboard 展示使用，并更新死叉股票的持仓数量为0、将卖出的金额加入到可用现金中。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;498:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def emptyPosition(securityid){ availableQty = availablePos[securityid] sellTime = timestamp if (availableQty &amp;gt; 0){ sellPrice = priceJustTraded[securityid] direction = 2 orderType = 5 orderID = long(orderCount) sellAmount = sellPrice * availableQty sellOrder = SellOrder(securityid, sellTime, orderType, sellPrice, availableQty, direction, orderID) emitEvent(sellOrder) t = objByName(&#34;signalTb&#34;+instanceId) insert into t values (securityid, direction, sellTime, sellPrice, newDiff[securityid]) msgBody = (securityid, sellTime, orderType, sellPrice, availableQty, direction, orderID) MatchingEngineSimulator::insertMsg(getStreamEngine(&#34;MatchingEngine&#34;+instanceId), msgBody, 2) orderCount = orderCount + 1 availablePos[securityid] = 0 availableCash += sellAmount cashTb.tableInsert(sellTime,sellAmount,availableCash) } }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:44;522:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;522:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;若产生金叉，则调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;522:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;checkCciAndVol&lt;/codeph&gt;，进一步检查 CCI 和成交量条件是否达成。函数将判断 CCI 指标在最近30秒内是否发生了上穿的情况：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:19;524:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:45;524:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;524:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;若 CCI 上穿 -100 的阈值，则构造内部订单事件（InnerOrder），并通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;524:51&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;routeEvent&lt;/codeph&gt; 将该事件插入到当前 CEP 子引擎的事件队列的队首；&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:46;526:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;526:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;若 CCI 上穿 100 的阈值，并且过去 30 秒的成交量之和大于 50000，则同样将内部订单事件插入到当前 CEP 子引擎的事件队列的队首。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;528:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def checkCciAndVol(securityid){ if(pre30cci[securityid] &amp;lt; strategyParams[`cci][`lowerBoundary] and newCci[securityid] &amp;gt; strategyParams[`cci][`lowerBoundary]){ innerOrderTime = timestamp innerOrder = InnerOrder(securityid, innerOrderTime, priceJustTraded[securityid], strategyParams[`order][`orderQty], instanceId) routeEvent(innerOrder) } else if(pre30cci[securityid] &amp;lt; strategyParams[`cci][`upperBoundary] and newCci[securityid] &amp;gt; strategyParams[`cci][`upperBoundary] and pre30vol[securityid] &amp;gt; strategyParams[`volume][`triggerAmount]){ innerOrderTime = timestamp innerOrder = InnerOrder(securityid, innerOrderTime, priceJustTraded[securityid], strategyParams[`order][`orderQty], instanceId) routeEvent(innerOrder) } }&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:47;550:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;550:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在金叉死叉判断结束后，更新对应的 MACD、CCI 指标字典，作为下一次信号判断的依据，字典的键值均为股票。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;552:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:10;552:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;监听内部订单事件&lt;/b&gt;&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/3-4.png&#34; placement=&#34;break&#34; xtrc=&#34;image:7;554:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;3788&#34; dita-ot:image-height=&#34;604&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;556:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;556:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;initiatingStrategy&lt;/codeph&gt; 函数初始化策略时，已经设置了一个事件监听器对内部订单事件进行监听。当该事件被插入到当前 CEP 子引擎的事件处理队列的队首，将被该监听器捕获，触发对应方法 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;556:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;orderStateCheck&lt;/codeph&gt; 进行下单状态检查。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;558:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def orderStateCheck(innerOrder){     if(orderState[innerOrder.securityid] == 1){return}     else {buyOrder(innerOrder)} }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:20;565:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:48;565:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;565:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;状态检查函数将检查下单状态字典，若状态为 &#34;1&#34; 表示“1s内刚下过单”，则不允许下单，反之允许下单。若允许下单，则调用下单函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;565:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;buyOrder&lt;/codeph&gt;：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;567:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def buyOrder(innerOrder){ orderPrice = innerOrder.priceJustTraded orderQty = innerOrder.quantity buyAmount = orderPrice * orderQty if (availableCash &amp;gt; buyAmount){ orderSecurity = innerOrder.securityid orderTime = innerOrder.timestamp direction = 1 orderType = 5 orderCount = orderCount + 1 orderID = long(orderCount) buyOrder = BuyOrder(orderSecurity, orderTime, orderType, orderPrice, orderQty, direction, orderID) emitEvent(buyOrder) msgBody = (orderSecurity, orderTime, orderType, orderPrice, orderQty, direction, orderID) t = objByName(&#34;signalTb&#34;+instanceId) insert into t values (orderSecurity, direction, orderTime, orderPrice, newDiff[orderSecurity]) MatchingEngineSimulator::insertMsg( getStreamEngine(&#34;MatchingEngine&#34;+instanceId), msgBody, 2) //下单后把下单状态改为1，设置一个定时器1秒后更新下单状态 orderState[orderSecurity] = 1 addEventListener(handler=refreshOrderState{orderSecurity}, times=1, wait=1s) availableCash -= buyAmount cashTb.tableInsert(orderTime, -buyAmount, availableCash) } }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:21;598:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:49;598:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;598:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;首先判断是否有足够的可用现金，随后构造了委托订单消息传递给模拟撮合引擎，并将下单状态修改为 &#34;1&#34;。在可用现金中扣去下单所需的金额。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:50;600:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;600:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;将买入信号写入表中供 Dashboard 展示使用，构造了 BuyOrder 事件并发送到事件输出队列。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:51;602:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;602:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;更新持仓状态字典值，并通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;602:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;addEventListener&lt;/codeph&gt; 设置了一个定时器，令 times=1 且 wait=1s ，即1秒后执行1次回调函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;602:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;refreshOrderState&lt;/codeph&gt;，刷新对应股票的下单状态。这是为了避免出现交易中信号被反复触发，短时间内大量下单的情况。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;604:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def refreshOrderState(orderSecurity){orderState[orderSecurity] = 0}&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-创建-cep-引擎&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;608:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;608:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.3 创建 CEP 引擎&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;608:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;610:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def createCEP(){ cepDummy = table(array(TIMESTAMP,0) as time, array(STRING, 0) as eventType, array(BLOB, 0) as blobs) //在emitOutput表中可以查看cep内部被emitEvent发出来的事件 share(streamTable(array(STRING, 0) as eventType, array(BLOB, 0) as eventBody), &#34;emitOutput&#34;) emitOutput = objByName(&#34;emitOutput&#34;) outputSerializer = streamEventSerializer(name=`serOutput, eventSchema= [BuyOrder, SellOrder], outputTable=emitOutput) engine = createCEPEngine(name='macdCciVol', monitors=&amp;lt;Monitor()&amp;gt;, dummyTable= cepDummy, eventSchema=[Snapshot, Transaction,Initiating], eventQueueDepth=10000000, outputTable=outputSerializer, useSystemTime=false, timeColumn=`time) }&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:22;627:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:52;627:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;定义 CEP 引擎的输入表 cepDummy，使其格式和数据回放的结果表 replayOutput 保持一致。数据回放将在下一小节介绍。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:53;628:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建并共享流数据表 emitOutput 作为序列化的结果表。如果在引擎内部调用了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;628:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;emitEvent&lt;/codeph&gt; 接口，则创建引擎时需要指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;628:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;outputTable&lt;/i&gt; 参数为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;628:89&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;StreamEventSerializer&lt;/codeph&gt; 返回的表对象。因为每个事件类的属性并不相同，需要通过&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;628:139&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;StreamEventSerializer&lt;/codeph&gt;将引擎输出的事件序列化为 BLOB 格式，才能写入到同一个异构流数据表 emitOutput 中。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:54;629:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建 CEP 引擎，指定监视器、输入表、以何种 schema 识别进入引擎的序列化数据等参数。注意，此处指定在引擎内部不使用系统时间，而是使用事件时间（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;629:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;useSystemTime=false, timeColumn=&lt;/codeph&gt;time`）。这将主要影响引擎内部的事件监听器的时间判断。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-启动策略实例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.4 启动策略实例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;631:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;633:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在 CEP 引擎被创建后，引擎随即开始监听策略启动事件。在行情和逐笔数据开始回放前，需要通过向 CEP 引擎输入 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;633:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Initiating&lt;/codeph&gt; 事件正式启动一个策略实例。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;//创建一个表用来记录策略参数 share(table(100:0,[&#34;instanceId&#34;, &#34;CCIThreshold&#34;,&#34;CCITimePeriod&#34;,&#34;VolumeThreshold&#34;, &#34;VolumeTimePeriod&#34;],[STRING, STRING, INT, INT, INT]),&#34;gridParamInfo&#34;) macdPeriodParams = [240, 520, 180] cciUpperBoundarie = [100] cciLowerBoundarie = -cciUpperBoundarie triggerAmount = [50000] cciTimePeriod = [10] volumeTimePeriod = [30 * 1000] cashAmount_ = 300000 stockPool_ = ['111111','222222'] holdingQty_ = take([100,200,300],count(stockPool_)) time_ = 2023.01.30 09:30:00.000 CEPEngine = getStreamEngine(&#34;macdCciVol&#34;) instanceId = 1 factorParams_ = dict(`macd`cci`volume, [ dict(`fastPeriod`slowPeriod`signalPeriod, macdPeriodParams), dict(`timePeriod, cciTimePeriod), dict(`timePeriod, volumeTimePeriod) ] ) strategyParams_ = dict(`cci`volume`order, [ dict(`upperBoundary`lowerBoundary, [cciUpperBoundarie, cciLowerBoundarie]), dict(`triggerAmount, triggerAmount), dict(`orderQty, [500]) ] )                    tmp = objByName(&#34;gridParamInfo&#34;) insert into tmp(instanceId,CCIThreshold,CCITimePeriod,VolumeThreshold, VolumeTimePeriod) values (instanceId, (cciUpperBoundarie.string() +&#34;,&#34; +cciLowerBoundarie.string()), cciTimePeriod, triggerAmount, volumeTimePeriod) initEvent = Initiating(instanceId, factorParams_, strategyParams_, time_, cashAmount_,holdingQty_,stockPool_) appendEvent(CEPEngine, initEvent)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:23;676:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:55;676:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;创建并共享了一个策略参数表，用来记录所使用的策略参数&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:56;677:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;设置了策略的参数，包括指标计算、策略信号触发、初始持仓数量和股票池等参数&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:57;678:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;实例化一个策略启动事件，并通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;678:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;appendEvent&lt;/codeph&gt; 将该事件直接写入 CEP 引擎以正式启动策略。注意，策略启动事件不仅需要在回放开始前写入引擎，并且由于 CEP 引擎设置了使用事件时间，策略启动事件的时间属性值也需要比行情数据的时间早。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-回放历史数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;680:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;680:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.5 回放历史数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;680:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;682:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在本例中，我们使用数据回放 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;682:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replay&lt;/codeph&gt; 功能来模拟真实交易数据按时间顺序发生的情况。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;684:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def createReplayOutputTb(){ share(streamTable(100:0,`timestamp`eventType`blob, [TIMESTAMP, STRING, BLOB]) ,&#34;replayOutput&#34;) subscribeTable(tableName=&#34;replayOutput&#34;, actionName=&#34;replayOutput&#34;, handler=getStreamEngine(`macdCciVol),msgAsTable=true) } createReplayOutputTb()&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:24;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:58;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;首先创建并共享回放功能的输出表 replayOutput，该表将作为 CEP 引擎的输入数据来源表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:59;695:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;订阅 replayOutput 表，将其 handler 设置为 CEP 引擎，即每批数据写入该表时就会写入 CEP 引擎。&lt;/li&gt;&lt;/ul&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;697:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def fromReplayToCEP(stockPool_){ snapshotData = select string(Market) as Market, TradeTime as snapshotTime, string(SecurityID) as securityid, LastPrice, OpenPrice, HighPrice, LowPrice, UpLimitPx, DownLimitPx, long(TotalBidQty) as TotalBidQty, long(TotalOfferQty) as TotalOfferQty, BidPrice, BidOrderQty, OfferPrice, OfferOrderQty from loadTable(&#34;dfs://testDB&#34;,&#34;snapshot&#34;) where (second(TradeTime) &amp;gt;= second(09:30:00.000) and second(TradeTime) &amp;lt;= second(15:00:00.000)) and date(TradeTime) = 2023.02.02 and (SecurityID in stockPool_) order by TradeTime transData = select SecurityID as securityid, TradePrice, TradeQty as volume, TradeTime as transTime from loadTable(&#34;dfs://testDB&#34;,&#34;trade&#34;) where (second(TradeTime) &amp;gt;= second(09:30:00.000) and second(TradeTime) &amp;lt;= second(15:00:00.000)) and date(TradeTime) = 2023.02.02 and (SecurityID in stockPool_) order by TradeTime input_dict=dict([&#34;Snapshot&#34;, &#34;Transaction&#34;], [snapshotData, transData]) time_dict=dict([&#34;Snapshot&#34;, &#34;Transaction&#34;],[`snapshotTime, `transTime]) submitJob(&#34;replayToCEP&#34;, &#34;replayToCEP&#34;, replay, input_dict, objByName(`replayOutput), , time_dict,) } fromReplayToCEP(stockPool_)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:25;720:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:60;720:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;从数据库中选出需要的行情快照数据和逐笔成交数据，然后通过分别指定行情数据和成交数据的时间列组成时间字典 time_dict，作为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;720:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replay&lt;/codeph&gt; 的参数 timeColumn 来实现排序。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:61;721:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;通过调整 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;721:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replay&lt;/codeph&gt; 的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;721:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replayRate&lt;/i&gt; 参数可以设定回放的快慢。本例未指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;721:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;replayRate&lt;/i&gt; 参数，表示进行全速回放。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4--结果检视&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;4. 结果检视&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;723:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;725:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本小节通过可视化指标和信号、查看输出事件、查看模拟撮合结果等方式展示策略运行的结果。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-指标与信号可视化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;727:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;727:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;4.1 指标与信号可视化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;727:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;729:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;DolphinDB Web 端提供了强大的数据可视化和分析工具——数据面板（Dashboard），旨在帮助用户更好地理解和利用数据。在本例中，响应式状态引擎计算完成后和产生买卖信号时都将对应的数据写入了共享流数据表，如此在 Dashboard 中便可以选取需要的数据进行可视化。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;731:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;更为详细的数据面板使用教程见&lt;xref class=&#34;- topic/xref &#34; href=&#34;dashboard_tutorial.dita&#34; xtrc=&#34;xref:9;731:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;官方文档&lt;/xref&gt;，本案例的可视化结果如下（仅选取了一只股票进行展示）。在文末附录中将提供本案例中 Dashboard 的配置文件，导入配置文件即可复现本案例中的图表。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/4-1.png&#34; placement=&#34;break&#34; xtrc=&#34;image:8;733:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1635&#34; dita-ot:image-height=&#34;386&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:26;735:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:62;735:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在上图中：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:27;736:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:63;736:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;黄色与红色线分别为 MACD 指标的 DIFF 和 DEA 线。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:64;737:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;紫色的线为 CCI 指标。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:65;738:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;蓝绿色柱状图为成交量数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:66;739:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;红色与绿色的标点为买入和卖出信号产生的位置。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:67;740:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;水平的三条虚线从上而下分别为 CCI 指标 +100 与 -100 的阈值和 50000 股成交量的阈值。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:68;741:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在数据回放的同时，Dashboard 将实时展示进度，同时在图中可以方便地检验买卖信号是否正确产生。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-输出事件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;4.2 输出事件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;745:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在创建 CEP 引擎时指定了引擎的输出表为事件流序列化器（Stream Event Serializer），序列化器的输出表为异构流数据表 emitOutput。在数据回放后，随着 CEP 引擎不断地处理和向外部发送数据，emitOutput 表的行数也会不断增加。表中 eventType 为事件类型，eventBody 为事件实例序列化后的结果。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/4-2.png&#34; placement=&#34;break&#34; xtrc=&#34;image:9;747:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;535&#34; dita-ot:image-height=&#34;154&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;749:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在实盘中，可以通过 C++、Java、Python 等客户端程序订阅 emitOutput 表，接收到下单事件后向交易柜台发送委托单。 C++ API 订阅事件流的方法见 &lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/cppdoc/event_handling.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:10;749:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;事件处理&lt;/xref&gt; 。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;43-模拟撮合结果&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;751:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;751:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;4.3 模拟撮合结果&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;751:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;753:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在创建模拟撮合引擎时指定了模拟撮合的输出表为 MatchingResult，撮合完成后查看该表结果如下。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/4-3.png&#34; placement=&#34;break&#34; xtrc=&#34;image:10;755:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1194&#34; dita-ot:image-height=&#34;282&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:28;757:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:69;757:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;可以从撮合结果表中看到每一只股票的撮合方向（direction）、发送订单的时间（sendTime）、成交时间（tradeTime）和撮合的量价等信息。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:70;758:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在 orderStatus 一栏中可以看到订单的撮合结果。&#34;4&#34; 为“已报”，&#34;1&#34; 为“订单完全成交”。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-策略参数寻优&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;760:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;760:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;5. 策略参数寻优&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;760:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;762:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在上文中的案例中，我们介绍了如何使用 CEP 引擎运行一个多指标的策略并且进行模拟撮合。虽然我们已经可以计算出该案例策略的收益率，但该收益率很可能并不是策略的最佳表现。在真实的投研场景下，一个策略往往需要经过大量的回测来确定最适合某种市场情况的最优参数。那么，在上面的代码中作出哪些修改和调整，可以实现参数寻优的功能呢？&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;764:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;已知目前策略参数都由 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;764:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Initiating&lt;/codeph&gt; 事件的监听传入，因此如果需要传入多组参数，就需要有多个策略启动事件来传递参数。同时，一个监视器又代表着一个正在运行的策略实例。如果依次向 CEP 引擎输入多个策略启动事件，以目前的代码结构，后一个策略启动事件的参数将总是覆盖前一个事件的参数，无法同时进行计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;766:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;针对这种情况，DolphinDB 的 CEP 引擎中提供了一种方法来动态地生成多个结构相同的监视器实例，使不同参数的策略可以运行在不同的监视器中。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-spawnmonitor-创建监视器的原理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;768:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;768:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;5.1 spawnMonitor 创建监视器的原理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;768:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;770:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在监视器中，可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;770:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor(handler,args..)&lt;/codeph&gt; 函数方便地生成一个子监视器（subMonitor）。该函数将从原监视器中深拷贝所有的成员属性和成员方法，但不会拷贝原监视器中的事件监听器。并且，在子监视器实例化后，立刻执行对应的 handler，初始化该子监视器。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/5-1.png&#34; width=&#34;60%&#34; xtrc=&#34;image:11;772:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1632&#34; dita-ot:image-height=&#34;1724&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-动态生成多个策略实例的代码实现&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;774:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;774:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;5.2 动态生成多个策略实例的代码实现&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;774:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;776:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在了解了通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;776:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 生成监视器实例的原理后，我们可以对原来的代码作简单调整来实现动态生成多个策略实例，进而实现参数寻优。在原来的代码中，监听到策略启动事件后将进行对其他事件的监听、创建必要的引擎和表等操作。而为了同时运行多组参数策略，在监听到策略启动事件后，应立刻复制一个对应的子监视器来运行该参数下的策略实例。因此原代码中的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;776:177&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;initiatingStrategy&lt;/codeph&gt; 函数中的内容，将作为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;776:209&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 函数的 handler 参数。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/5-2.png&#34; width=&#34;90%&#34; xtrc=&#34;image:12;778:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;3408&#34; dita-ot:image-height=&#34;1844&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;780:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;def initiatingSpawn(Initiating) { spawnMonitor(initiatingStrategy, Initiating) } def onload() { addEventListener(handler=initiatingSpawn, eventType=&#34;Initiating&#34;, times=&#34;all&#34;) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;789:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;经过这样的调整，每次向引擎输入策略启动事件 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;789:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Initiating&lt;/codeph&gt; 时，引擎将会通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;789:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 函数生成一个新的监视器实例。并且，通过立即以策略启动事件 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;789:89&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Initiating&lt;/codeph&gt; 为入参调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;789:108&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;initiatingStrategy&lt;/codeph&gt; 函数，完成对该监视器实例的初始化。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:11;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;向引擎输入多个参数不同的策略启动事件&lt;/b&gt;&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;793:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:71;793:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;793:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;首先，增加希望测试的参数组合。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;795:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;cciUpperBoundaries = [50, 100,150] cciLowerBoundaries = -cciUpperBoundaries triggerAmounts = [50000, 150000] cciTimePeriods = [10,20] volumeTimePeriods = [30 * 1000, 60* 1000]&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:72;803:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;803:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;其次，以遍历的方式将这些参数组合成参数字典，并构造对应的策略启动事件输入引擎。同时，把每一个参数组合都记录在 gridParamInfo 表中。下面代码中通过循环一共构造了 3&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;803:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3&lt;/i&gt;2&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;803:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;2&lt;/i&gt;2=72 个策略启动事件，即72组不同的策略参数。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;805:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;for(cciTimePeriod in cciTimePeriods){     for(volumeTimePeriod in volumeTimePeriods){         // 因子计算参数         factorParams_ = dict(`macd`cci`volume,             [             dict(`fastPeriod`slowPeriod`signalPeriod, [240, 520, 180]),             dict(`timePeriod, [cciTimePeriod]),             dict(`timePeriod, [volumeTimePeriod])             ]         )         for(upperBoundary in cciUpperBoundaries){             for(lowerBoundary in cciLowerBoundaries){                 for(triggerAmount in triggerAmounts){                     // 策略参数                     strategyParams_ = dict(`cci`volume`order,                                     [                                     dict(`upperBoundary`lowerBoundary, [upperBoundary, lowerBoundary]),                                     dict(`triggerAmount, [triggerAmount]),                                     dict(`orderAmount, [500])                                     ]                     )                     // 生成并添加事件实例                     instanceId = string(instanceId)                     tmp = objByName(&#34;gridParamInfo&#34;)                     insert into tmp(instanceId,CCIThreshold,CCITimePeriod, VolumeThreshold,VolumeTimePeriod) values (instanceId, (upperBoundary.string() +&#34;,&#34;+lowerBoundary.string()), cciTimePeriod, triggerAmount, volumeTimePeriod)                     initEvent = Initiating(instanceId, factorParams_, strategyParams_, time_, cashAmount_,holdingQty_,stockPool_)                     appendEvent(CEPEngine, initEvent)                     instanceId = int(instanceId)                     instanceId += 1                 }             }         }     } }&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:73;846:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;846:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;注意区分和标注事件“出处”。当同一个 CEP 子引擎（线程）上有多个监视器时，不同的监视器之间可以相互“沟通”，即监听和捕获其他监视器中产生的事件。因此，除非是类似于行情数据事件这样必须被每个监视器完整捕获的事件，都需要在构造和设置监听时设置独特的属性值条件以避免混淆。此外，在对各个共享表和引擎命名时，也需要注意进行区分。在本案例中使用了 instanceId 用来区分不同参数的策略实例。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/5-3.png&#34; width=&#34;60%&#34; xtrc=&#34;image:13;848:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;2872&#34; dita-ot:image-height=&#34;2580&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;850:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在遍历所有的参数组合构造策略启动事件输入引擎后，查看 web 界面可以发现接收事件数等于向 CEP 引擎输入的策略启动事件数量。监视器的数量为73个，来自初始的1个监视器加上 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;850:89&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 方法产生的 72 个子监视器。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/5-4.png&#34; placement=&#34;break&#34; xtrc=&#34;image:14;852:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1715&#34; dita-ot:image-height=&#34;600&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;854:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:12;854:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;计算策略收益率&lt;/b&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;856:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在计算完成后，我们需要统计各个参数组合下的策略实例收益率来挑选出最佳参数。收益率的计算逻辑为：（日末现金+日末持仓价值）/（初始现金+初始持仓股票价值）。为了确保日末的持仓和可用现金的金额准确，需要遍历所有的模拟撮合结果表，查询其中成交情况。同时，也要检查是否有不完全成交或者挂单未成交的情况。例如，若有买入失败的情况，则要将对应金额的现金加回至可用现金。同理，买卖情况都需要根据具体的撮合结果对金额、股数进行调整。收益率计算不是本文的重点，具体的计算损益函数见附件的策略代码。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-利用并行计算加速回测&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;858:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;858:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;6. 利用并行计算加速回测&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;858:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;860:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在上文的代码实现中，无论是 1 个还是 73 个监视器的策略回测过程，都是运行在同一个 CEP 子引擎（线程）上。下图分别是不使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;860:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 仅回测一组参数、使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;860:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 回测多组参数的策略实例示意图。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/6-1.png&#34; width=&#34;60%&#34; xtrc=&#34;image:15;862:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;2976&#34; dita-ot:image-height=&#34;1704&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-设置-dispatchkey-参数创建子引擎线程&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;864:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;864:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;6.1 设置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;864:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;dispatchKey&lt;/i&gt; 参数创建子引擎（线程）&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;864:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;866:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在真实的投研环境中，我们还可以通过并行计算来加速策略回测的过程。CEP 引擎在创建时提供可选参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;866:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;dispatchKey&lt;/i&gt; 来指定事件中的成员属性作为分配线程的依据。引擎将根据该属性中的每个唯一值来创建一个子引擎（线程），各个子引擎之间相互独立且并行地处理数据。若不指定 dispatchKey 参数，则 CEP 引擎只有一个（与 CEP 引擎同名的）子引擎，即只有一个处理线程。此外，还可以辅以 dispatchBucket 参数，实现对 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;866:223&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;dispatchKey&lt;/i&gt; 指定的字段进行哈希分组，本案例未使用 dispatchBucket 参数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;868:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在本案例中，可以通过策略启动事件中的成员属性 instanceId 来区分不同的策略参数组。因此，可以在创建 CEP 引擎时增加 dispatchKey 参数设置，代码和策略实例示意图如下所示。事件分发器根据 instanceId 将不同的策略启动事件发送到了不同的子引擎中。而逐笔成交事件和快照事件的属性值中不包含 instanceId，因此将会被发送到每一个的子引擎中。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/6-2.png&#34; width=&#34;80%&#34; xtrc=&#34;image:16;870:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;4096&#34; dita-ot:image-height=&#34;3789&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:27;872:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;engine = createCEPEngine(name='macdCciVol', monitors=&amp;lt;Monitor()&amp;gt;, dummyTable=cepDummy, eventSchema=[Snapshot, Transaction,Initiating], eventQueueDepth=10000000, outputTable=outputSerializer, useSystemTime=false, timeColumn=`time, dispatchKey=`instanceId)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;879:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;开启并行后，再向 CEP 引擎输入 72 个策略启动事件，在 web 端可以观察到已经自动创建了72个子引擎，并且每个子引擎中都根据策略参数又生成了一个监视器实例来运行策略。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/6-3.png&#34; placement=&#34;break&#34; xtrc=&#34;image:17;881:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1697&#34; dita-ot:image-height=&#34;797&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;883:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;最后可视化的结果如下所示。（具体情况会根据策略参数、股票池选择而不同）&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/cta_strategy_implementation_and_backtesting/6-4.png&#34; placement=&#34;break&#34; xtrc=&#34;image:18;885:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34; dita-ot:image-width=&#34;1632&#34; dita-ot:image-height=&#34;764&#34; dita-ot:horizontal-dpi=&#34;150&#34; dita-ot:vertical-dpi=&#34;150&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62-性能测试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;887:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;887:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;6.2 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;887:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;889:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试数据量：50支股票1天的快照和成交数据，共1522416行。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;891:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试方法：通过多组不同的策略参数启动多个策略实例，通过是否开启 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;891:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;dispatchKey&lt;/i&gt; 参数控制是否并行计算。统计一批策略实例全部完成回测的总耗时。单策略平均耗时=总耗时/策略实例数量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;893:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试环境：单节点部署 DolphinDB server。license 授权内存上限 256G，核数上限 64 核。worknum 设置为 64，具体配置文件见附录。测试使用的服务器配置如下。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:91;895:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;表 6-1 测试服务器配置&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrc=&#34;tgroup:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;897:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:13;897:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;配置项&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;897:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:14;897:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;信息&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;899:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;899:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:3;899:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;OS（操作系统）&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:4;899:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CentOS Linux 7 (Core)&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;900:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:5;900:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;内核&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:6;900:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.10.0-1160.el7.x86_64&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;901:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:7;901:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;CPU&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:8;901:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;Intel(R) Xeon(R) Gold 5220R CPU @ 2.20GHz 96 逻辑 CPU 核心&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;902:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:9;902:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;内存&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:10;902:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;16*32GB RDUNN, 3200MT/s 总共512GB&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:92;904:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试结果如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:29;906:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:74;906:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在不启用并行计算（即并行度为1）时，随着策略实例数量的增加，单策略平均耗时仍然能够保持稳定，总耗时呈线性增加。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:75;907:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在启用并行计算时，随着并行度的增加，单策略平均耗时逐渐降低，系统吞吐量逐渐提高。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:76;908:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;在相同策略实例数量下，并行计算显著降低了回测总耗时。例如，比较策略实例数为 40 的两个测试用例，并行计算提速了约 11.7 倍。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:93;910:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;表 6-2 CEP 引擎性能测试结果&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;5&#34; xtrc=&#34;tgroup:2;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:3;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:4;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:5;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:6;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:7;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:11;912:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:15;912:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;策略实例数量&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:12;912:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:16;912:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;并行度（子引擎数）&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:13;912:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:17;912:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;单策略平均耗时（秒）&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:14;912:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:18;912:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;总耗时（秒）&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:15;912:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:19;912:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;提速（倍，并行度为 1 时的总耗时/总耗时）&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;914:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;914:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:16;914:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:17;914:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:18;914:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;45.0&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:19;914:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;45&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:20;914:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;-&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;915:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:21;915:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;10&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:22;915:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:23;915:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;39.0&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:24;915:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;390&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:25;915:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;-&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:9;916:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:26;916:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:27;916:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:28;916:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;37.5&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:29;916:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;780&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:30;916:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;-&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:10;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:31;917:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;30&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:32;917:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:33;917:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;41.2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:34;917:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1237&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:35;917:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;-&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:11;918:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:36;918:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;40&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:37;918:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:38;918:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;40.2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:39;918:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;1608&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:40;918:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;-&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:12;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:41;919:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;10&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:42;919:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;10&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:43;919:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;6.9&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:44;919:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;69&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:45;919:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;5.7&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:13;920:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:46;920:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:47;920:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:48;920:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;4.2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:49;920:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;84&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:50;920:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;8.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:14;921:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:51;921:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;30&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:52;921:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;30&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:53;921:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.6&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:54;921:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;108&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:55;921:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;11.5&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:15;922:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:56;922:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;40&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:57;922:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;40&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:58;922:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;3.4&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:59;922:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;137&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;10&#34; xtrc=&#34;entry:60;922:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;11.7&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;924:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;924:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;7. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;924:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:94;926:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;本文通过循序渐进的方式，首先介绍了如何使用 CEP 引擎实现一个多指标高频股票策略的回测，其次介绍了通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;926:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;spawnMonitor&lt;/codeph&gt; 实现在一个子引擎中回测多组参数的方法，最后利用 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;926:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;dispatchKey&lt;/i&gt; 参数的设置实现了并行计算以加速参数寻优。此外，还展示了如何将 CEP 引擎与 DolphinDB 中其他的重要插件与功能联动使用，如模拟撮合引擎插件、数据回放功能、 ta 模块和数据面板（Dashboard）等。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;8-附录&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;928:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;928:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;8. 附录&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;928:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:95;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:20;930:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试数据&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:30;932:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:77;932:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;csv&#34; href=&#34;data/cta_strategy_implementation_and_backtesting/CEPExampleData_Snapshot.csv&#34; xtrc=&#34;xref:11;932:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;快照数据（5只股票3个交易日）&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:78;933:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;csv&#34; href=&#34;data/cta_strategy_implementation_and_backtesting/CEPExampleData_Transaction.csv&#34; xtrc=&#34;xref:12;933:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;逐笔成交数据（5只股票2个交易日）&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:96;935:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:21;935:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;测试数据导入脚本&lt;/b&gt;：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:31;936:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:79;936:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/cta_strategy_implementation_and_backtesting/ImportDataToDB.dos&#34; xtrc=&#34;xref:13;936:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;导入脚本&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:97;938:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:22;938:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;策略实现脚本&lt;/b&gt;：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:32;939:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:80;939:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;dos&#34; href=&#34;script/cta_strategy_implementation_and_backtesting/CTAStrategy.dos&#34; xtrc=&#34;xref:14;939:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;策略脚本&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:98;941:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:23;941:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;数据面板（Dashboard）配置文件&lt;/b&gt;：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:33;942:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:81;942:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;json&#34; href=&#34;script/cta_strategy_implementation_and_backtesting/dashboard_CTA.json&#34; xtrc=&#34;xref:15;942:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;Dashboard 配置&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:99;944:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:24;944:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;server 配置文件&lt;/b&gt;：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:34;945:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:82;945:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;cfg&#34; href=&#34;script/cta_strategy_implementation_and_backtesting/dolphindb.cfg&#34; xtrc=&#34;xref:16;945:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/cta_strategy_implementation_and_backtesting.md&#34;&gt;&lt;?ditaot usertext?&gt;server 配置&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/cta_strategy_implementation_and_backtesting.md"/><meta name="wh-out-relpath" content="tutorials/cta_strategy_implementation_and_backtesting.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="cep-引擎应用股票中高频-cta-策略实现与并行回测" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html">流数据</a></div></div></li><li class="active"><div class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测"><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e100449" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="多数据源流式实时关联处理-d9713e100449-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="流数据引擎解析器-d9713e100495" class="topicref" data-id="流数据引擎解析器" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/StreamEngineParser.html" id="流数据引擎解析器-d9713e100495-link">流数据引擎解析器</a></div></div></li><li role="treeitem"><div data-tocid="流数据高可用-d9713e100541" class="topicref" data-id="流数据高可用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haStreaming.html" id="流数据高可用-d9713e100541-link">流数据高可用</a></div></div></li><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e100587" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub_2.html" id="节点启动时的流计算自动订阅-d9713e100587-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎入门初级高频量价因子策略的实现-d9713e100633" class="topicref" data-id="cep-引擎入门初级高频量价因子策略的实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/getting_started_with_cep_engine.html" id="cep-引擎入门初级高频量价因子策略的实现-d9713e100633-link">CEP 引擎入门：初级高频量价因子策略的实现</a></div></div></li><li role="treeitem" class="active"><div data-tocid="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679" class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html" id="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679-link">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li><li role="treeitem"><div data-tocid="流计算时延统计与性能优化-d9713e100725" class="topicref" data-id="流计算时延统计与性能优化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_timer.html" id="流计算时延统计与性能优化-d9713e100725-link">流计算时延统计与性能优化</a></div></div></li><li role="treeitem"><div data-tocid="响应式状态引擎-d9713e100771" class="topicref" data-id="响应式状态引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/reactive_state_engine.html" id="响应式状态引擎-d9713e100771-link">响应式状态引擎</a></div></div></li><li role="treeitem"><div data-tocid="流数据功能应用-d9713e100817" class="topicref" data-id="流数据功能应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_tutorial.html" id="流数据功能应用-d9713e100817-link">流数据功能应用</a></div></div></li><li role="treeitem"><div data-tocid="数据回放-d9713e100863" class="topicref" data-id="数据回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_replay.html" id="数据回放-d9713e100863-link">数据回放</a></div></div></li><li role="treeitem"><div data-tocid="使用-dolphindb-class-来开发流计算状态算子-d9713e100909" class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stateful_stream_operators.html" id="使用-dolphindb-class-来开发流计算状态算子-d9713e100909-link">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</h1><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">面向读者</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">本教程面向已有一定基础的 DophinDB CEP 引擎使用者，意在帮助读者进一步学习 DolphinDB CEP 引擎在量化交易场景下的灵活用法</li><li class="- topic/li li">建议读者首先阅读和掌握以下教程，再阅读本文的内容<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="getting_started_with_cep_engine.html">CEP 引擎入门：初级高频量价因子策略的实现</a></li></ul></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">扩展材料</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">除了基础 DolphinDB 概念外，本教程还推荐以下扩展阅读以更好理解本案例的代码：<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="matching_engine_simulator.html">模拟撮合插件使用教程</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="dashboard_tutorial.html">数据面板（Dashboard）</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="../funcs/r/replay.html">数据回放（Replay）</a></li></ul></li></ul><p class="- topic/p p">在上一篇<a class="- topic/xref xref" href="getting_started_with_cep_engine.html">复杂事件处理（Complex Events Processing, CEP）引擎的系列教程</a>中，我们详细介绍了 CEP 引擎和它的一些关键概念，如复杂事件和事件监听器等。随后又通过两个初级的 CEP 引擎使用案例介绍了创建并运行一个最简单结构的 CEP 引擎所需的步骤和模块，以及在 CEP 引擎内部调用其他流计算引擎进行实时因子计算的方法。</p><p class="- topic/p p">本文将进一步介绍如何基于 CEP 引擎实现一个股票 CTA 策略，并使用真实市场数据进行回测。为了实现回测，CEP 引擎将联动模拟撮合引擎（Matching Engine Simulator）插件来模拟委托订单的发出与快照行情的撮合。同时将介绍技术指标和买卖信号的实时可视化。在文末，将更进一步介绍如何在 CEP 引擎中实现并行的参数寻优，以最大程度地接近真实的使用场景。文章将提供完整的测试代码和脱敏后的测试数据，供读者在 3.00.1.3 及以上版本的 server 学习，详情见文末<strong class="+ topic/ph hi-d/b ph b">附录</strong>。</p><p class="- topic/p p">注：案例中使用的 CEP 引擎和模拟撮合引擎插件均需要相应的 license。欢迎联系 DolphinDB 小助手咨询试用，微信号 13306510479。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1--策略逻辑"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1.  策略逻辑</h2><div class="- topic/body body"><p class="- topic/p p">本教程中的案例策略是一种典型的趋势策略，基于实时的高频数据进行指标计算，旨在将短时间内量价指标的突变作为趋势开始的信号。该策略利用高频交易的速度优势提前建仓以跟踪趋势，并在指标显示趋势结束时平仓。策略信号将由 MACD、CCI 和成交量三个指标的条件组合所触发，具体信号产生的逻辑如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">当 MACD 出现金叉（DIFF 上穿 DEA）后，出现以下任意情形之一则买入500股：<ul class="- topic/ul ul"><li class="- topic/li li">过去30秒内的 CCI 指标从下向上突破+100线进入超买区间，并且过去30秒的成交量之和大于50000股</li><li class="- topic/li li">过去30秒内的 CCI 指标从下向上突破-100线</li></ul></li><li class="- topic/li li">当 MACD 出现死叉（DIFF 下穿 DEA）后，对相应标的作清仓操作（若有持仓）</li></ul><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/1-1.png"/><br/><p class="- topic/p p">出现下单信号的场景一共有以下三种：</p><ul class="- topic/ul ul"><li class="- topic/li li">当 MACD 指标出现金叉，且过去 30 秒内 CCI 指标上穿 100，且过去 30 秒内成交量之和超过 50000 时， 触发下单；</li><li class="- topic/li li">当 MACD 指标出现金叉，且过去30秒内 CCI 指标上穿 -100时，触发下单；</li><li class="- topic/li li">当 MACD 指标出现死叉时，触发清仓。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2--主要功能模块"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2.  主要功能模块</h2><div class="- topic/body body"><p class="- topic/p p">上文中的策略逻辑将通过 CEP 引擎实现，此外，还利用了数据回放（Replay）和模拟撮合引擎（Matching Engine Simulator）插件进行策略回测。大致流程如下图所示。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/2-1.png"/><br/><p class="- topic/p p">CEP 引擎中的事件监听器在监听到策略启动事件后将设置对快照事件、成交事件等事件的监听，这意味着启动整个策略。行情数据通过数据回放（Replay）功能进入引擎后，将被对应的监听器捕获并触发指标计算和后续的策略信号判断逻辑。下面将分模块地介绍它们的主要功能。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="21-cep-引擎"><h3 class="- topic/title title topictitle3" id="ariaid-title4">2.1 CEP 引擎</h3><div class="- topic/body body"><p class="- topic/p p">CEP 引擎模块是策略中最重要，也是最复杂的部分。在本案例中，采用了动态启动策略的方式：当引擎内的事件监听器（Event Listener）捕获策略启动事件时才会设置其他监听（如监听快照事件和逐笔成交事件）、创建模拟撮合和响应式状态引擎（Reactive State Engine，RSE）和所需的一些共享表。</p><p class="- topic/p p">策略启动后，行情数据通过数据回放进入 CEP 引擎时，将被反序列化为快照事件和逐笔成交事件。当快照事件和逐笔成交事件被对应的事件监听器所捕捉时，将触发对应的处理函数。一方面把快照数据和逐笔成交数据分别传入两个响应式状态引擎进行指标计算，另一方面将快照数据同步更新到模拟撮合引擎中。</p><p class="- topic/p p">两个响应式状态引擎将分别利用 ta 模块计算 MACD、CCI 和成交量指标，并将计算结果传递给对应的回调函数。回调函数把因子值写入共享流数据表，以便在数据面板（Dashboard）中进行可视化展示。与此同时，会按照上文中提到的信号判断逻辑进行一系列的信号判断。当产生买入或卖出的信号时构造内部订单事件（InnerOrder），而内部订单事件将被对应的监听器捕获，触发执行下单函数。本例的下单函数中，构造了符合模拟撮合引擎输入格式的委托订单，将其发送给模拟撮合引擎并与行情快照进行撮合。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="22-数据回放"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.2 数据回放</h3><div class="- topic/body body"><p class="- topic/p p">数据回放 <code class="+ topic/ph pr-d/codeph ph codeph">Replay</code> 是 DolphinDB 中常用于高频策略回测场景的方法，它可以根据指定的回放模式，按时间顺序将一个或多个数据表（或由 <code class="+ topic/ph pr-d/codeph ph codeph">replayDS</code> 函数返回的数据源列表）的数据回放到某个数据表或引擎，以模拟实时数据的写入。</p><p class="- topic/p p">由于行情快照由交易所按固定时间间隔推送，而逐笔成交数据的产生则完全取决于当日实际的交易情况，所以这两种数据的时间戳并不完全一致。 Replay 可以很好地将这两种数据按时间戳排序后输出到流数据表。并且，<code class="+ topic/ph pr-d/codeph ph codeph">Replay</code> 还可以将结构不同的多个表数据序列化后回放到一个异构流数据表中。通过订阅该异构流数据表，就可以向 CEP 引擎按时间顺序输入数据，以模拟事件按时间顺序发生的真实情况。</p><p class="- topic/p p">本案例数据将使用真实的历史行情快照和逐笔成交数据，通过数据回放模拟实时的事件流并进行处理。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="23-模拟撮合引擎"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.3 模拟撮合引擎</h3><div class="- topic/body body"><p class="- topic/p p">在高频交易中，常有回测表现良好的策略，由于没有考虑到相应的滑点、发送订单的时延等摩擦成本，而在实盘交易中表现不佳。为了使策略研究时更贴近真实的交易情况，可以在回测过程中引入 DolphinDB 的模拟撮合插件来模拟真实交易的情况。模拟撮合引擎可以模拟用户在某个时间点发出订单或取消之前已发出订单的操作，并获取相应的交易结果，其逻辑架构如下图所示。</p><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/2-2.png"/><br/><p class="- topic/p p">模拟撮合引擎以行情（快照数据或逐笔数据）和用户委托订单（买方或卖方）作为输入，根据订单撮合规则模拟撮合，将订单的成交结果（包含部分成交结果、拒绝订单和已撤订单）输出至交易明细输出表，未成交部分等待与后续行情撮合成交或者等待撤单。关于更多引擎运行机制的说明和撮合规则的解释见<a class="- topic/xref xref" href="../plugins/matchingEngineSimulator/mes.html">官方文档</a> 。</p><p class="- topic/p p">在本案例中，当策略启动以后才需要向模拟撮合引擎发送委托订单，因此创建模拟撮合引擎的函数将放在 CEP 引擎内部。</p><p class="- topic/p p">注：模拟撮合插件需要用户自行从插件仓库下载并加载，代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>login("admin", "123456")
//使用 installPlugin 命令完成插件安装
installPlugin("MatchingEngineSimulator")
//使用 loadPlugin 命令加载插件。
loadPlugin("MatchingEngineSimulator")</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="3--策略代码实现"><h2 class="- topic/title title topictitle2" id="ariaid-title7">3.  策略代码实现</h2><div class="- topic/body body"><p class="- topic/p p">在本章中我们将具体介绍策略代码的实现，包括定义事件、定义监视器、创建 CEP 引擎、启动策略实例、回放历史数据等功能模块，完整代码见文末附录。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="31-定义事件类"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.1 定义事件类</h3><div class="- topic/body body"><p class="- topic/p p">首先定义在 CEP 引擎内部会涉及到的事件类，完整的事件定义代码见附件。</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">策略启动（Initiating）、行情快照（Snapshot）和逐笔成交（Transaction）事件均由外部写入 CEP 引擎中。</p></li><li class="- topic/li li"><p class="- topic/p p">策略启动事件的成员属性中包含策略实例 id、初始现金、持仓量、股票池和策略参数等与策略初始设置相关的信息。</p></li><li class="- topic/li li"><p class="- topic/p p">内部订单事件在 CEP 引擎中产生并通过 <code class="+ topic/ph pr-d/codeph ph codeph">routeEvent</code> 接口在引擎内部传递。此事件对于策略实现并不是必须的，仅仅为了在工程上解耦产生买入信号和下单两部分逻辑。</p></li><li class="- topic/li li"><p class="- topic/p p">买单事件（BuyOrder）和卖单事件（SellOrder）在 CEP 引擎中产生，并通过 <code class="+ topic/ph pr-d/codeph ph codeph">emitEvent</code> 接口发送到外部。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 策略启动事件
class Initiating {
    instanceId :: STRING
    factorParams :: ANY
    strategyParams :: ANY
    eventTime :: TIMESTAMP
    cashAmount :: INT
    holdingQty :: INT VECTOR
    stockPool :: STRING VECTOR
    def Initiating(instanceId_, factorParams_, strategyParams_, time_,
        cashAmount_,holdingQty_,stockPool_){
        instanceId = instanceId_
        factorParams = factorParams_
        strategyParams = strategyParams_
        eventTime = time_
        cashAmount = cashAmount_
        holdingQty = holdingQty_
        stockPool = stockPool_
    }
}
// 行情快照事件
class Snapshot { ... }
// 逐笔成交事件
class Transaction { ... }
// 内部订单事件                     
class InnerOrder { ... }
// 买单事件
class BuyOrder { ... }
// 卖单事件
class SellOrder { ... }</code></pre><p class="- topic/p p">​</p></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="32-定义监视器"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.2 定义监视器</h3><div class="- topic/body body"><p class="- topic/p p">CEP 引擎的创建和其内部监视器的配置是策略实现中最关键的步骤。监视器内封装了整个交易策略，其结构大致如下。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>use ta
class Monitor {
    securitySelected :: STRING VECTOR
    instanceId :: STRING
    factorParams :: ANY 
    strategyParams :: ANY 
    newDiff :: ANY
    preDiff :: ANY
    preDea :: ANY
    pre30cci :: ANY
    pre30vol :: ANY
    newCci :: ANY
    priceJustTraded :: ANY 
    orderState :: ANY      
    availablePos :: ANY
    initCash :: INT
    availableCash :: INT
    initHoldingValue :: INT
    timestamp :: TIMESTAMP
    orderCount :: INT
    def Monitor(){ 
        availablePos = dict(STRING, INT)
        newDiff = dict(STRING, DOUBLE)
        preDiff = dict(STRING, DOUBLE)
        preDea = dict(STRING, DOUBLE)
        pre30cci = dict(STRING, DOUBLE)
        pre30vol = dict(STRING, DOUBLE)
        newCci = dict(STRING, DOUBLE)
        priceJustTraded = dict(STRING, DOUBLE)
        orderState = dict(STRING, BOOL) 
        timestamp = 2023.02.01 08:00:00.000 
        orderCount = 0 
    }
        def createMatchingEngine(instanceId){}    
        def emptyPosition(securityid){}
        def refreshOrderState(orderSecurity){}
        def buyOrder(innerOrder){}
        def handleMacdCciOutput(macdCciResult) {}
        def checkCciAndVol(securityid){}
        def orderStateCheck(innerOrder){}
        def checkGoldenCross(securityid, diff, dea) {}   
        def handleVolOutput(volResult){}   
        def updateMatchingEngineQuotes(SnapshotEvent){}
        def processSnapshot(SnapshotEvent) {}   
        def processTrans(transactionEvent) {}
        def createCalFactorEngines(instanceId){}
        def initiatingStrategy(Initiating){}
        def onload() {
            addEventListener(handler=initiatingStrategy, eventType="Initiating", times="all")
        }
}</code></pre><p class="- topic/p p">下面将按照 CEP 引擎运作的逻辑顺序，依次介绍监视器中各个成员方法的具体内容。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">onload 初始化</strong></p><p class="- topic/p p">创建引擎并实例化监视器后，将首先调用其内部的 <code class="+ topic/ph pr-d/codeph ph codeph">onload</code> 函数。回顾上文提到的 CEP 模块所负责的功能，其工作流的源头是监听策略启动事件，一旦监听到策略启动事件才进行下一步的操作。因此，在 <code class="+ topic/ph pr-d/codeph ph codeph">onload</code> 函数中，只需考虑设置相关的事件监听器以便启动策略即可。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def onload() {
    addEventListener(handler=initiatingStrategy, eventType="Initiating", times="all")
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">设置了一个事件监听器，监听所有的策略启动事件。目的是当监听到该事件时，下一步将启动整个策略，因此在对应的回调函数 <code class="+ topic/ph pr-d/codeph ph codeph">initiatingStrategy</code> 中需要包含对行情事件的监听器和创建所需要的计算引擎等步骤。从 <code class="+ topic/ph pr-d/codeph ph codeph">onload</code> 方法开始，函数调用的流程与实现的功能大致如下图所示。</li></ul><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/3-1.png"/><br/><p class="- topic/p p">接下来从策略启动事件对应的回调函数 <code class="+ topic/ph pr-d/codeph ph codeph">initiatingStrategy</code> 开始来介绍具体的代码实现。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">启动策略</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def initiatingStrategy(Initiating){
    instanceId = Initiating.instanceId
    factorParams = Initiating.factorParams
    strategyParams = Initiating.strategyParams
    initCash = Initiating.cashAmount
    availableCash = initCash
    initHoldingQty = Initiating.holdingQty
    securitySelected = Initiating.stockPool
    availablePos[securitySelected] = initHoldingQty                  
    preCloTable = select SecurityID, PreCloPrice from loadTable("dfs://testDB",
    `snapshot) where date(TradeTime) = 2023.02.02 context by SecurityID limit 1
    preCloDict = dict(preCloTable.SecurityID, preCloTable.PreCloPrice)
    preClo = preCloDict[securitySelected]
    initHoldingValue =  sum(preClo * initHoldingQty)
    //创建表，统计实时情况
    share(table(100:0,["time","changeAmount","availableCash"],[TIMESTAMP, INT, INT]),
    "CashTable"+instanceId) 
    cashTb = objByName("CashTable"+instanceId)
    cashTb.tableInsert(timestamp,0,availableCash
    //创建模拟撮合引擎
    createMatchingEngine(instanceId)
    //创建信号表，dashboard展示
    share(streamTable(100:0,`securityid`direction`Time`orderPrice`BS_Signal,
    `STRING`INT`TIMESTAMP`DOUBLE`DOUBLE),"signalTb"+instanceId)
    signalTb = objByName("signalTb"+instanceId)
    //监听快照
    addEventListener(handler=processSnapshot, eventType="Snapshot", times="all")
    addEventListener(handler=updateMatchingEngineQuotes, eventType="Snapshot",
     times="all")
    //监听逐笔成交
    addEventListener(handler=processTrans, eventType="Transaction", times="all")
    //监听内部事件，检查下单状态
    addEventListener(handler=orderStateCheck, eventType="InnerOrder", 
    condition=&lt;InnerOrder.instanceId=instanceId&gt;, times="all")
    createCalFactorEngines(instanceId)
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">从监听到的 <code class="+ topic/ph pr-d/codeph ph codeph">Initiating</code> 事件中获取各种策略设定值，如指标计算参数字典、策略参数字典、初始资金和初始持仓等。</p></li><li class="- topic/li li"><p class="- topic/p p">从数据库中取出对应股票的昨日收盘价，与初始持仓数量一起计算出初始的总持仓价值。</p></li><li class="- topic/li li"><p class="- topic/p p">创建并共享一个资金统计表，用于统计策略实时的资金变化，并将初始的现金情况插入表中；创建并共享一个买卖信号表，用于可视化买卖信号。</p></li><li class="- topic/li li"><p class="- topic/p p">调用 <code class="+ topic/ph pr-d/codeph ph codeph">createMatchingEngine</code> 函数，创建模拟撮合引擎。主要步骤包括配置文件修改、行情表和用户订单表结构定义、列名映射配置、成交明细输出表定义和创建引擎。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createMatchingEngine(instanceId){
    //撮合引擎cfg
    config = dict(STRING, DOUBLE);
    config["latency"] = 0;
    config["depth"] = 10; 
    config["outputOrderBook"] = 0            //用户订单时延为0
    config["orderBookMatchingRatio"] = 1;    //与订单薄匹配时的成交百分比
    config["dataType"] = 1;                  //行情类别：1表示股票快照
    config["matchingMode"] = 1;  //撮合模式一：与最新成交价以及对手方盘口按配置的比例撮合
    config["matchingRatio"] = 0.1;           //快照模式下，快照的区间成交百分比
    //根据行情表和用户订单表的表结构来创建相应的列名映射字典
    //snapshot输入表结构
    dummyQuotationTable = table(1:0,`SecurityID`Market`TradeTime`LastPrice
    `UpLimitPx`DownLimitPx`TotalBidQty`TotalOfferQty`BidPrice`BidOrderQty
    `OfferPrice`OfferOrderQty,[STRING,STRING,TIMESTAMP,DOUBLE,DOUBLE,DOUBLE,LONG,
    LONG,DOUBLE[],INT[],DOUBLE[],INT[]])
    quotationColMap = dict(`symbol`symbolSource`timestamp`lastPrice`upLimitPrice
    `downLimitPrice`totalBidQty`totalOfferQty`bidPrice`bidQty`offerPrice`offerQty,
     `SecurityID`Market`TradeTime`LastPrice`UpLimitPx`DownLimitPx`TotalBidQty
     `TotalOfferQty`BidPrice`BidOrderQty`OfferPrice`OfferOrderQty)
    //委托订单结构
    dummyUserOrderTable = table(1:0, `symbol`time`orderType`price`qty`BSFlag
    `orderID, [STRING, TIMESTAMP, INT, DOUBLE, LONG, INT, LONG])
    userOrderColMap = dict( `symbol`timestamp`orderType`price`orderQty`direction
    `orderId, `symbol`time`orderType`price`qty`BSFlag`orderID)
    //自定义输出表的形式
    tradeOutputTable  = table(1:0, `orderId`symbol`direction`sendTime`orderPrice
    `orderQty`tradeTime`tradePrice`tradeQty`orderStatus`sysReceiveTime, 
    [LONG, STRING, INT, TIMESTAMP,DOUBLE,LONG, TIMESTAMP,DOUBLE,LONG, INT,
    NANOTIMESTAMP])
    share(tradeOutputTable,"MatchingResult"+instanceId)
    matResultTb = objByName("MatchingResult"+instanceId)
    //撮合深交所股票
    exchange = "XSHE" 
    //创建引擎
    name = "MatchingEngine"+instanceId 
    matchingEngine = MatchingEngineSimulator::createMatchEngine(name, exchange,
    config, dummyQuotationTable, quotationColMap, dummyUserOrderTable, 
    userOrderColMap, matResultTb)
}    </code></pre><ul class="- topic/ul ul"><li class="- topic/li li">在加载模拟撮合插件后，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">MatchingEngineSimulator::createMatchEngine</code> 函数创建模拟撮合引擎。</li><li class="- topic/li li">exchange 参数指定交易所代码，用于明确撮合规则。</li><li class="- topic/li li">构造了一个 config 字典，并在字典中配置撮合引擎的撮合设定，如订单时延、输入给撮合引擎的行情类别、撮合模式等。更详细的参数设置和含义见<a class="- topic/xref xref" href="matching_engine_simulator.html">模拟撮合引擎使用教程</a>。</li><li class="- topic/li li">对于输入表 dummyQuotationTable 和 dummyUserOrderTable，模拟撮合引擎要求它们必须包含指定的字段名称。如果自定义的行情数据表的字段名称与引擎要求不一致，可以通过 quotationColMap 字典进行映射；同样地，如果自定义的用户委托订单数据表的字段名称与引擎要求不一致，可以通过 userOrderColMap 字典进行映射。</li><li class="- topic/li li">对于输出表 tradeOutputTable，模拟撮合引擎对它的字段名称没有要求，但其输出的每个字段有特定的含义，所以字段的顺序不能改变。</li></ul></li><li class="- topic/li li"><p class="- topic/p p">创建 4 个事件监听器，其中：</p><ul class="- topic/ul ul"><li class="- topic/li li">监听所有的快照事件，一旦监听到快照事件，将立刻调用 <code class="+ topic/ph pr-d/codeph ph codeph">processSnapshot</code> 函数进行处理。该函数的功能是将快照数据写入响应式状态引擎进行指标的计算。</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def processSnapshot(SnapshotEvent) {       
    timestamp = SnapshotEvent.snapshotTime
    macdCciCalEngine = getStreamEngine("CalMacdCciEngine"+instanceId) 
    insert into macdCciCalEngine values([SnapshotEvent.snapshotTime, 
    SnapshotEvent.securityid, SnapshotEvent.lastPrice, SnapshotEvent.openPrice, 
    SnapshotEvent.highPrice, SnapshotEvent.lowPrice])
}   </code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">监听所有的快照事件，一旦监听到快照事件，将立刻调用 <code class="+ topic/ph pr-d/codeph ph codeph">updateMatchingEngineQuotes</code> 函数进行处理。该函数的功能是将行情数据写入模拟撮合引擎，使模拟撮合引擎中的行情与指标计算、产生信号的操作同步。在本案例中可以看到，在 CEP 引擎中同一个事件可以同时被多个事件监听器监听，触发不同的操作。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def updateMatchingEngineQuotes(SnapshotEvent){
    SecurityID = SnapshotEvent.securityid
    Market = SnapshotEvent.market
    TradeTime = SnapshotEvent.snapshotTime
    LastPrice = SnapshotEvent.lastPrice
    UplimitPx = SnapshotEvent.upLimitPx
    DownLimitPx = SnapshotEvent.downLimitPx
    TotalBidQty = SnapshotEvent.totalBidQty
    TotalOfferQty = SnapshotEvent.totalOfferQty
    BidPrice = SnapshotEvent.bidPrice
    BidOrderQty = SnapshotEvent.bidOrderQty
    OfferPrice = SnapshotEvent.offerPrice
    OfferOrderQty = SnapshotEvent.offerOrderQty
    quoteTable = table(100:0,["SecurityID", "Market","TradeTime", "LastPrice",
    "UplimitPx","DownLimitPx","TotalBidQty","TotalOfferQty","BidPrice",
    "BidOrderQty","OfferPrice","OfferOrderQty"], [STRING, STRING, TIMESTAMP,
     DOUBLE, DOUBLE, DOUBLE, LONG, LONG, DOUBLE[], INT[], DOUBLE[], INT[]])
    quoteTable.tableInsert([SecurityID],[Market],[TradeTime],[LastPrice],
    [UplimitPx],[DownLimitPx],[TotalBidQty],[TotalOfferQty],[BidPrice],
    [BidOrderQty],[OfferPrice],[OfferOrderQty])
    MatchingEngineSimulator::insertMsg(getStreamEngine("MatchingEngine"+
    instanceId), quoteTable, 1)
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">监听所有的成交事件，一旦监听到成交事件，将立刻调用 <code class="+ topic/ph pr-d/codeph ph codeph">processTrans</code> 函数进行处理。该函数的功能是将成交数据写入响应式状态引擎进行指标的计算。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def processTrans(transactionEvent) {  
    if(transactionEvent.tradePrice != 0){
      timestamp = transactionEvent.transTime
      volCalEngine = getStreamEngine("CalVolEngine"+instanceId)
      insert into volCalEngine values([transactionEvent.securityid, 
      transactionEvent.tradePrice, transactionEvent.volume, 
      transactionEvent.transTime])   
    }     
    else{return}
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">监听所有的内部订单事件，一旦监听到内部订单事件，将立刻调用 <code class="+ topic/ph pr-d/codeph ph codeph">orderStateCheck</code> 函数进行处理，该函数的功能是检查下单状态后下单。该函数由内部订单事件触发，将在后文再做详细介绍。</p></li></ul></li><li class="- topic/li li"><p class="- topic/p p">调用 <code class="+ topic/ph pr-d/codeph ph codeph">createCalFactorEngines</code> 函数，创建对应的因子计算引擎（响应式状态引擎）。这是后续一切流程的开始，下面详细介绍该函数的功能实现。</p></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">创建响应式状态引擎</strong></p><p class="- topic/p p">创建两个响应式状态引擎，分别对快照和逐笔数据计算不同的指标。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/3-2.png"/><br/><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createCalFactorEngines(instanceId){
    //MACD CCI计算
    calDummy = streamTable(1:0, ["snapshotTime","securityid","LastPrice","OpenPrice"
    ,"HighPrice","LowPrice"], [TIMESTAMP, STRING, DOUBLE, DOUBLE , DOUBLE , DOUBLE])
    macdFastPeriod = factorParams[`macd][`fastPeriod]
    macdSlowPeriod = factorParams[`macd][`slowPeriod]
    macdSignalPeriod = factorParams[`macd][`signalPeriod]
    cciTimePeriod = factorParams[`cci][`timePeriod]
    calMetrics = [&lt;snapshotTime&gt;, &lt;ta::macd(LastPrice, macdFastPeriod, macdSlowPeriod,
    macdSignalPeriod) as `diff`dea`macdHistogram&gt;, &lt;ta::cci(HighPrice, LowPrice,
    LastPrice, cciTimePeriod) as `cci&gt;]    
    macdCciOutputTable = streamTable(1:0,  ["securityid", "time", "diff", "dea", 
    "macdHistogram", "cci"],  [STRING, TIMESTAMP, DOUBLE, DOUBLE, DOUBLE, DOUBLE])
    share(macdCciOutputTable,"MacdAndCci"+instanceId) 
    macdCciOutputTable = objByName("MacdAndCci"+instanceId)
    macdCciCalEngine = createReactiveStateEngine(name="CalMacdCciEngine"+instanceId,
    metrics=calMetrics, dummyTable=calDummy, outputTable=macdCciOutputTable, 
    outputHandler=handleMacdCciOutput ,keyColumn=`securityid, keepOrder=true, 
    msgAsTable=true)
    //引擎预热
    warmupTable = select TradeTime,SecurityID,LastPrice,OpenPrice,HighPrice,
    LowPrice from loadTable('dfs://testDB',`snapshot) where (second(TradeTime) 
    &gt;= second(09:30:00.000) and second(TradeTime) &lt;= second(15:00:00.000)) and 
    date(TradeTime) = 2023.02.01 order by TradeTime 
    warmupStreamEngine(macdCciCalEngine, warmupTable)
    //vol计算
    volDummy = streamTable(1:0, ["securityid", "TradePrice", "vol", "transTime"], 
    [STRING, DOUBLE, INT, TIMESTAMP])
    volTimePeriod = factorParams[`volume][`timePeriod]
    volMetrics = [&lt;TradePrice&gt;, &lt;tmsum(transTime, vol, volTimePeriod)&gt;, &lt;transTime&gt;]
    volOutputTable = streamTable(1:0, ["securityid", "TradePrice","vol", "time"], 
    [STRING, DOUBLE,INT, TIMESTAMP])
    share(volOutputTable,"Vol"+instanceId)
    volOutputTable = objByName("Vol"+instanceId)
    volCalEngine = createReactiveStateEngine(name="CalVolEngine"+instanceId, 
    metrics=volMetrics, dummyTable=volDummy, outputTable=volOutputTable, 
    outputHandler=handleVolOutput ,keyColumn=`securityid, keepOrder=true, 
    msgAsTable=true)
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">为了方便用户使用 TA - Lib 中的技术指标，DolphinDB 提供了以 DolphinScript 实现的 TA-Lib 中包含的指标函数，并封装在 DolphinDB <a class="- topic/xref xref" href="../modules/ta/ta.html">ta 模块</a> 中。 <code class="+ topic/ph pr-d/codeph ph codeph">createReactiveStateEngine</code> 函数通过 <em class="+ topic/ph hi-d/i ph i">metrics</em> 参数指定计算指标，本案例用到了 ta 模块（已经在创建监视器前声明 <code class="+ topic/ph pr-d/codeph ph codeph">use ta</code>）来方便地表达指标逻辑，省去了用户编写复杂计算公式的步骤。</li><li class="- topic/li li">以输入快照数据、计算 MACD 和 CCI 指标的响应式状态引擎为例，引擎计算的结果将交由 <code class="+ topic/ph pr-d/codeph ph codeph">handleMacdCciOutput</code> 函数处理。在该函数中将进行下单信号的判断，我们将在后文进行详细介绍。创建计算成交量指标的响应式状态引擎的流程类似，其计算结果交由 <code class="+ topic/ph pr-d/codeph ph codeph">handleVolOutput</code> 函数处理。注意，设置 <em class="+ topic/ph hi-d/i ph i">outputHandler</em> 参数后，引擎不再将每次的计算结果写到输出表 macdCciOutputTable，而是会不断地调用 <em class="+ topic/ph hi-d/i ph i">outputHandler</em> 参数指定的函数处理计算结果。</li></ul><p class="- topic/p p">在创建计算引擎的函数中，有一段关于引擎预热的代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>warmupTable = select TradeTime,SecurityID,LastPrice,OpenPrice,HighPrice,LowPrice 
from loadTable('dfs://testDB',`snapshot) where (second(TradeTime) &gt;= 
second(09:30:00.000) and second(TradeTime) &lt;= second(15:00:00.000)) and 
date(TradeTime) = 2023.02.01 order by TradeTime 
warmupStreamEngine(macdCciCalEngine, warmupTable)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">这段代码的目的是对计算 MACD 和 CCI 指标的响应式状态引擎进行预热。<code class="+ topic/ph pr-d/codeph ph codeph">warmupStreamEngine</code> 会把前一天的数据写入流数据引擎并进行计算，但是不输出结果。当当日的数据正常写入此流数据引擎后，滑动窗口将包含前一日的快照数据。在本例中 MACD 指标中涉及时间最久的参数 slowPeriod = 520，即 520 个滑动窗口，若不进行预热，则会出现在开盘后近 30 分钟内指标计算结果为空的情况。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">处理响应式状态引擎计算结果</strong></p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">handleVolOutput</strong></p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def handleVolOutput(volResult){       
    tableInsert(objByName("Vol"+instanceId), volResult)
    priceJustTraded[volResult.securityid[0]] = volResult.TradePrice[0]
    pre30vol[volResult.securityid[0]] = volResult[`vol][0]
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">把引擎的计算结果写入对应的输出表中，这与策略逻辑无关，仅供 Dashboard 可视化展示。</li><li class="- topic/li li">更新存储最新成交价的字典，字典的键值为股票，之后将用最新的成交价格作为委托买入或卖出的价格。</li><li class="- topic/li li">更新存储30秒成交量之和的字典 pre30vol，字典的键值为股票。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">handleMacdCciOutput</strong></p><p class="- topic/p p">函数调用流程与大致功能如下图所示。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/3-3.png"/><br/><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def handleMacdCciOutput(macdCciResult) {
    tableInsert(macdCciOutputTable, macdCciResult)
    if(second(macdCciResult.time)&lt;09:30:00 or second(macdCciResult.time) &gt;15:00:00 ){
      return
    }    
    self.checkGoldenCross(macdCciResult.securityid[0], macdCciResult.diff[0], 
    macdCciResult.dea[0])
    preDiff[macdCciResult.securityid[0]] = macdCciResult.diff[0]
    preDea[macdCciResult.securityid[0]] = macdCciResult.dea [0]   
    if (pre30cci[macdCciResult.securityid[0]] == NULL) {
      pre30cci[macdCciResult.securityid[0]] = macdCciResult.cci[0]
    }
    else if(pre30cci[macdCciResult.securityid[0]] != NULL and 
    newCci[macdCciResult.securityid[0]] == NULL){
      newCci[macdCciResult.securityid[0]] = macdCciResult.cci[0]
    }
    else{pre30cci[macdCciResult.securityid[0]] = newCci[macdCciResult.securityid[0]]
    newCci[macdCciResult.securityid[0]] = macdCciResult.cci[0]}
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">同理，先将计算结果插入到对应的共享表中以供 Dashboard 可视化展示。</p></li><li class="- topic/li li"><p class="- topic/p p">调用金叉检查函数 <code class="+ topic/ph pr-d/codeph ph codeph">checkGoldenCross</code> 检查是否产生金叉：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def checkGoldenCross(securityid, diff, dea) {
    if (self.preDiff[securityid] != NULL and self.preDea[securityid] != NULL) {
        if (self.preDiff[securityid] &lt; self.preDea[securityid] and diff &gt; dea) {  
            newDiff[securityid] = diff
            checkCciAndVol(securityid) 
        }
        if (self.preDiff[securityid] &gt; self.preDea[securityid] and diff &lt; dea){ 
            newDiff[securityid] = diff
            emptyPosition(securityid)
        }
    }
}    </code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">若产生死叉，调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">emptyPosition</code> 进行清仓：函数将从持仓状态字典中获取死叉股票的现有持仓量，同时获取死叉出现时的时间戳作为委托卖单的时间。若死叉股票有持仓，则一方面构造 SellOrder 事件，通过 <code class="+ topic/ph pr-d/codeph ph codeph">emitEvent</code> 接口将其向外发送给事件输出队列；一方面按照模拟撮合引擎订单结构，构造相应的委托卖单订单消息，通过对应的插件接口发送给模拟撮合引擎。发出委托消息后，记录卖出信号供 Dashboard 展示使用，并更新死叉股票的持仓数量为0、将卖出的金额加入到可用现金中。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def emptyPosition(securityid){ 
    availableQty = availablePos[securityid]
    sellTime = timestamp
    if (availableQty &gt; 0){
        sellPrice = priceJustTraded[securityid]
        direction = 2 
        orderType = 5
        orderID = long(orderCount)
        sellAmount = sellPrice * availableQty
        sellOrder = SellOrder(securityid, sellTime, orderType, sellPrice, availableQty, direction, orderID)  
        emitEvent(sellOrder)            
        t = objByName("signalTb"+instanceId)
        insert into t values (securityid, direction, sellTime, sellPrice, newDiff[securityid])
        msgBody = (securityid, sellTime, orderType, sellPrice, availableQty, direction, orderID)
        MatchingEngineSimulator::insertMsg(getStreamEngine("MatchingEngine"+instanceId), msgBody, 2)
        orderCount = orderCount + 1
        availablePos[securityid] = 0 
        availableCash += sellAmount
        cashTb.tableInsert(sellTime,sellAmount,availableCash)
    }
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">若产生金叉，则调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">checkCciAndVol</code>，进一步检查 CCI 和成交量条件是否达成。函数将判断 CCI 指标在最近30秒内是否发生了上穿的情况：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">若 CCI 上穿 -100 的阈值，则构造内部订单事件（InnerOrder），并通过 <code class="+ topic/ph pr-d/codeph ph codeph">routeEvent</code> 将该事件插入到当前 CEP 子引擎的事件队列的队首；</p></li><li class="- topic/li li"><p class="- topic/p p">若 CCI 上穿 100 的阈值，并且过去 30 秒的成交量之和大于 50000，则同样将内部订单事件插入到当前 CEP 子引擎的事件队列的队首。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def checkCciAndVol(securityid){
    if(pre30cci[securityid] &lt; strategyParams[`cci][`lowerBoundary] and 
    newCci[securityid] &gt; strategyParams[`cci][`lowerBoundary]){
        innerOrderTime = timestamp
        innerOrder = InnerOrder(securityid, innerOrderTime, 
        priceJustTraded[securityid], strategyParams[`order][`orderQty], 
        instanceId)
        routeEvent(innerOrder)
    }
    else if(pre30cci[securityid] &lt; strategyParams[`cci][`upperBoundary] and
     newCci[securityid] &gt; strategyParams[`cci][`upperBoundary] and 
     pre30vol[securityid] &gt; strategyParams[`volume][`triggerAmount]){ 
        innerOrderTime = timestamp
        innerOrder = InnerOrder(securityid, innerOrderTime, 
        priceJustTraded[securityid], strategyParams[`order][`orderQty], 
        instanceId)
        routeEvent(innerOrder)
    }    
}</code></pre></li></ul></li><li class="- topic/li li"><p class="- topic/p p">在金叉死叉判断结束后，更新对应的 MACD、CCI 指标字典，作为下一次信号判断的依据，字典的键值均为股票。</p></li></ul></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">监听内部订单事件</strong></p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/3-4.png"/><br/><p class="- topic/p p">在通过 <code class="+ topic/ph pr-d/codeph ph codeph">initiatingStrategy</code> 函数初始化策略时，已经设置了一个事件监听器对内部订单事件进行监听。当该事件被插入到当前 CEP 子引擎的事件处理队列的队首，将被该监听器捕获，触发对应方法 <code class="+ topic/ph pr-d/codeph ph codeph">orderStateCheck</code> 进行下单状态检查。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def orderStateCheck(innerOrder){
    if(orderState[innerOrder.securityid] == 1){return}
    else {buyOrder(innerOrder)}
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">状态检查函数将检查下单状态字典，若状态为 "1" 表示“1s内刚下过单”，则不允许下单，反之允许下单。若允许下单，则调用下单函数 <code class="+ topic/ph pr-d/codeph ph codeph">buyOrder</code>：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def buyOrder(innerOrder){
    orderPrice = innerOrder.priceJustTraded
    orderQty = innerOrder.quantity
    buyAmount = orderPrice * orderQty
    if (availableCash &gt; buyAmount){           
        orderSecurity = innerOrder.securityid
        orderTime = innerOrder.timestamp
        direction = 1
        orderType = 5
        orderCount = orderCount + 1
        orderID = long(orderCount)
        buyOrder = BuyOrder(orderSecurity, orderTime, orderType, orderPrice, 
        orderQty, direction, orderID)
        emitEvent(buyOrder)
        msgBody = (orderSecurity, orderTime, orderType, orderPrice, orderQty, 
        direction, orderID)
        t = objByName("signalTb"+instanceId)
        insert into t values (orderSecurity, direction, orderTime, orderPrice, 
        newDiff[orderSecurity])
        MatchingEngineSimulator::insertMsg(
        getStreamEngine("MatchingEngine"+instanceId), msgBody, 2)
        //下单后把下单状态改为1，设置一个定时器1秒后更新下单状态
        orderState[orderSecurity] = 1
        addEventListener(handler=refreshOrderState{orderSecurity}, times=1, wait=1s)
        availableCash -= buyAmount
        cashTb.tableInsert(orderTime, -buyAmount, availableCash)
    }
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">首先判断是否有足够的可用现金，随后构造了委托订单消息传递给模拟撮合引擎，并将下单状态修改为 "1"。在可用现金中扣去下单所需的金额。</p></li><li class="- topic/li li"><p class="- topic/p p">将买入信号写入表中供 Dashboard 展示使用，构造了 BuyOrder 事件并发送到事件输出队列。</p></li><li class="- topic/li li"><p class="- topic/p p">更新持仓状态字典值，并通过 <code class="+ topic/ph pr-d/codeph ph codeph">addEventListener</code> 设置了一个定时器，令 times=1 且 wait=1s ，即1秒后执行1次回调函数 <code class="+ topic/ph pr-d/codeph ph codeph">refreshOrderState</code>，刷新对应股票的下单状态。这是为了避免出现交易中信号被反复触发，短时间内大量下单的情况。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def refreshOrderState(orderSecurity){orderState[orderSecurity] = 0}</code></pre></li></ul></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="33-创建-cep-引擎"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.3 创建 CEP 引擎</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createCEP(){
    cepDummy = table(array(TIMESTAMP,0) as time, array(STRING, 0) as eventType, 
    array(BLOB, 0) as blobs)
    //在emitOutput表中可以查看cep内部被emitEvent发出来的事件
    share(streamTable(array(STRING, 0) as eventType, array(BLOB, 0) as eventBody),
     "emitOutput")
    emitOutput = objByName("emitOutput")
    outputSerializer = streamEventSerializer(name=`serOutput, eventSchema=
    [BuyOrder, SellOrder], outputTable=emitOutput)
    engine = createCEPEngine(name='macdCciVol', monitors=&lt;Monitor()&gt;, dummyTable=
    cepDummy, eventSchema=[Snapshot, Transaction,Initiating], 
    eventQueueDepth=10000000, outputTable=outputSerializer, useSystemTime=false,
    timeColumn=`time)
}</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">定义 CEP 引擎的输入表 cepDummy，使其格式和数据回放的结果表 replayOutput 保持一致。数据回放将在下一小节介绍。</li><li class="- topic/li li">创建并共享流数据表 emitOutput 作为序列化的结果表。如果在引擎内部调用了 <code class="+ topic/ph pr-d/codeph ph codeph">emitEvent</code> 接口，则创建引擎时需要指定 <em class="+ topic/ph hi-d/i ph i">outputTable</em> 参数为 <code class="+ topic/ph pr-d/codeph ph codeph">StreamEventSerializer</code> 返回的表对象。因为每个事件类的属性并不相同，需要通过<code class="+ topic/ph pr-d/codeph ph codeph">StreamEventSerializer</code>将引擎输出的事件序列化为 BLOB 格式，才能写入到同一个异构流数据表 emitOutput 中。</li><li class="- topic/li li">创建 CEP 引擎，指定监视器、输入表、以何种 schema 识别进入引擎的序列化数据等参数。注意，此处指定在引擎内部不使用系统时间，而是使用事件时间（<code class="+ topic/ph pr-d/codeph ph codeph">useSystemTime=false, timeColumn=</code>time`）。这将主要影响引擎内部的事件监听器的时间判断。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="34-启动策略实例"><h3 class="- topic/title title topictitle3" id="ariaid-title11">3.4 启动策略实例</h3><div class="- topic/body body"><p class="- topic/p p">在 CEP 引擎被创建后，引擎随即开始监听策略启动事件。在行情和逐笔数据开始回放前，需要通过向 CEP 引擎输入 <code class="+ topic/ph pr-d/codeph ph codeph">Initiating</code> 事件正式启动一个策略实例。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//创建一个表用来记录策略参数
share(table(100:0,["instanceId", "CCIThreshold","CCITimePeriod","VolumeThreshold",
"VolumeTimePeriod"],[STRING, STRING, INT, INT, INT]),"gridParamInfo")
macdPeriodParams = [240, 520, 180]
cciUpperBoundarie = [100]
cciLowerBoundarie = -cciUpperBoundarie
triggerAmount = [50000]
cciTimePeriod = [10]
volumeTimePeriod = [30 * 1000]
cashAmount_ = 300000
stockPool_ = ['111111','222222']
holdingQty_ = take([100,200,300],count(stockPool_))
time_ = 2023.01.30 09:30:00.000
CEPEngine = getStreamEngine("macdCciVol")
instanceId = 1

factorParams_ = dict(`macd`cci`volume,
                [
                dict(`fastPeriod`slowPeriod`signalPeriod, macdPeriodParams), 
                dict(`timePeriod, cciTimePeriod), 
                dict(`timePeriod, volumeTimePeriod)  
                ]
            )
strategyParams_ = dict(`cci`volume`order,
                [
                dict(`upperBoundary`lowerBoundary, [cciUpperBoundarie, cciLowerBoundarie]),
                dict(`triggerAmount, triggerAmount),
                dict(`orderQty, [500])
                ]
            )                    

tmp = objByName("gridParamInfo")
insert into tmp(instanceId,CCIThreshold,CCITimePeriod,VolumeThreshold,
VolumeTimePeriod) values (instanceId, (cciUpperBoundarie.string() +","
+cciLowerBoundarie.string()), cciTimePeriod, triggerAmount, volumeTimePeriod)
initEvent = Initiating(instanceId, factorParams_, strategyParams_, time_,
cashAmount_,holdingQty_,stockPool_)
appendEvent(CEPEngine, initEvent)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">创建并共享了一个策略参数表，用来记录所使用的策略参数</li><li class="- topic/li li">设置了策略的参数，包括指标计算、策略信号触发、初始持仓数量和股票池等参数</li><li class="- topic/li li">实例化一个策略启动事件，并通过 <code class="+ topic/ph pr-d/codeph ph codeph">appendEvent</code> 将该事件直接写入 CEP 引擎以正式启动策略。注意，策略启动事件不仅需要在回放开始前写入引擎，并且由于 CEP 引擎设置了使用事件时间，策略启动事件的时间属性值也需要比行情数据的时间早。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="35-回放历史数据"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.5 回放历史数据</h3><div class="- topic/body body"><p class="- topic/p p">在本例中，我们使用数据回放 <code class="+ topic/ph pr-d/codeph ph codeph">replay</code> 功能来模拟真实交易数据按时间顺序发生的情况。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createReplayOutputTb(){
    share(streamTable(100:0,`timestamp`eventType`blob, [TIMESTAMP, STRING, BLOB])
    ,"replayOutput")
    subscribeTable(tableName="replayOutput", actionName="replayOutput",
    handler=getStreamEngine(`macdCciVol),msgAsTable=true)
}    
createReplayOutputTb()</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">首先创建并共享回放功能的输出表 replayOutput，该表将作为 CEP 引擎的输入数据来源表。</li><li class="- topic/li li">订阅 replayOutput 表，将其 handler 设置为 CEP 引擎，即每批数据写入该表时就会写入 CEP 引擎。</li></ul><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def fromReplayToCEP(stockPool_){
    snapshotData = select string(Market) as Market, TradeTime as snapshotTime, 
    string(SecurityID) as securityid, LastPrice, OpenPrice, HighPrice, LowPrice, 
    UpLimitPx, DownLimitPx, long(TotalBidQty) as TotalBidQty, 
    long(TotalOfferQty) as TotalOfferQty, BidPrice, BidOrderQty, OfferPrice, 
    OfferOrderQty from loadTable("dfs://testDB","snapshot") where 
    (second(TradeTime) &gt;= second(09:30:00.000) and 
    second(TradeTime) &lt;= second(15:00:00.000)) and date(TradeTime) = 2023.02.02 
    and (SecurityID in stockPool_) order by TradeTime 
    transData = select SecurityID as securityid, TradePrice, TradeQty as volume, 
    TradeTime as transTime from loadTable("dfs://testDB","trade")  
    where (second(TradeTime) &gt;= second(09:30:00.000) and 
    second(TradeTime) &lt;= second(15:00:00.000)) and 
    date(TradeTime) = 2023.02.02 and (SecurityID in stockPool_) order by TradeTime 
    input_dict=dict(["Snapshot", "Transaction"], [snapshotData, transData])
    time_dict=dict(["Snapshot", "Transaction"],[`snapshotTime, `transTime])
    submitJob("replayToCEP", "replayToCEP", replay, input_dict, 
    objByName(`replayOutput), , time_dict,)
}
fromReplayToCEP(stockPool_)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">从数据库中选出需要的行情快照数据和逐笔成交数据，然后通过分别指定行情数据和成交数据的时间列组成时间字典 time_dict，作为 <code class="+ topic/ph pr-d/codeph ph codeph">replay</code> 的参数 timeColumn 来实现排序。</li><li class="- topic/li li">通过调整 <code class="+ topic/ph pr-d/codeph ph codeph">replay</code> 的 <em class="+ topic/ph hi-d/i ph i">replayRate</em> 参数可以设定回放的快慢。本例未指定 <em class="+ topic/ph hi-d/i ph i">replayRate</em> 参数，表示进行全速回放。</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="4--结果检视"><h2 class="- topic/title title topictitle2" id="ariaid-title13">4.  结果检视</h2><div class="- topic/body body"><p class="- topic/p p">本小节通过可视化指标和信号、查看输出事件、查看模拟撮合结果等方式展示策略运行的结果。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="41-指标与信号可视化"><h3 class="- topic/title title topictitle3" id="ariaid-title14">4.1 指标与信号可视化</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB Web 端提供了强大的数据可视化和分析工具——数据面板（Dashboard），旨在帮助用户更好地理解和利用数据。在本例中，响应式状态引擎计算完成后和产生买卖信号时都将对应的数据写入了共享流数据表，如此在 Dashboard 中便可以选取需要的数据进行可视化。</p><p class="- topic/p p">更为详细的数据面板使用教程见<a class="- topic/xref xref" href="dashboard_tutorial.html">官方文档</a>，本案例的可视化结果如下（仅选取了一只股票进行展示）。在文末附录中将提供本案例中 Dashboard 的配置文件，导入配置文件即可复现本案例中的图表。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/4-1.png"/><br/><ul class="- topic/ul ul"><li class="- topic/li li">在上图中：<ul class="- topic/ul ul"><li class="- topic/li li">黄色与红色线分别为 MACD 指标的 DIFF 和 DEA 线。</li><li class="- topic/li li">紫色的线为 CCI 指标。</li><li class="- topic/li li">蓝绿色柱状图为成交量数据。</li><li class="- topic/li li">红色与绿色的标点为买入和卖出信号产生的位置。</li><li class="- topic/li li">水平的三条虚线从上而下分别为 CCI 指标 +100 与 -100 的阈值和 50000 股成交量的阈值。</li></ul></li><li class="- topic/li li">在数据回放的同时，Dashboard 将实时展示进度，同时在图中可以方便地检验买卖信号是否正确产生。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="42-输出事件"><h3 class="- topic/title title topictitle3" id="ariaid-title15">4.2 输出事件</h3><div class="- topic/body body"><p class="- topic/p p">在创建 CEP 引擎时指定了引擎的输出表为事件流序列化器（Stream Event Serializer），序列化器的输出表为异构流数据表 emitOutput。在数据回放后，随着 CEP 引擎不断地处理和向外部发送数据，emitOutput 表的行数也会不断增加。表中 eventType 为事件类型，eventBody 为事件实例序列化后的结果。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/4-2.png"/><br/><p class="- topic/p p">在实盘中，可以通过 C++、Java、Python 等客户端程序订阅 emitOutput 表，接收到下单事件后向交易柜台发送委托单。 C++ API 订阅事件流的方法见 <a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/cppdoc/event_handling.html" target="_blank" rel="external noopener">事件处理</a> 。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="43-模拟撮合结果"><h3 class="- topic/title title topictitle3" id="ariaid-title16">4.3 模拟撮合结果</h3><div class="- topic/body body"><p class="- topic/p p">在创建模拟撮合引擎时指定了模拟撮合的输出表为 MatchingResult，撮合完成后查看该表结果如下。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/4-3.png"/><br/><ul class="- topic/ul ul"><li class="- topic/li li">可以从撮合结果表中看到每一只股票的撮合方向（direction）、发送订单的时间（sendTime）、成交时间（tradeTime）和撮合的量价等信息。</li><li class="- topic/li li">在 orderStatus 一栏中可以看到订单的撮合结果。"4" 为“已报”，"1" 为“订单完全成交”。</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="5-策略参数寻优"><h2 class="- topic/title title topictitle2" id="ariaid-title17">5. 策略参数寻优</h2><div class="- topic/body body"><p class="- topic/p p">在上文中的案例中，我们介绍了如何使用 CEP 引擎运行一个多指标的策略并且进行模拟撮合。虽然我们已经可以计算出该案例策略的收益率，但该收益率很可能并不是策略的最佳表现。在真实的投研场景下，一个策略往往需要经过大量的回测来确定最适合某种市场情况的最优参数。那么，在上面的代码中作出哪些修改和调整，可以实现参数寻优的功能呢？</p><p class="- topic/p p">已知目前策略参数都由 <code class="+ topic/ph pr-d/codeph ph codeph">Initiating</code> 事件的监听传入，因此如果需要传入多组参数，就需要有多个策略启动事件来传递参数。同时，一个监视器又代表着一个正在运行的策略实例。如果依次向 CEP 引擎输入多个策略启动事件，以目前的代码结构，后一个策略启动事件的参数将总是覆盖前一个事件的参数，无法同时进行计算。</p><p class="- topic/p p">针对这种情况，DolphinDB 的 CEP 引擎中提供了一种方法来动态地生成多个结构相同的监视器实例，使不同参数的策略可以运行在不同的监视器中。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="51-spawnmonitor-创建监视器的原理"><h3 class="- topic/title title topictitle3" id="ariaid-title18">5.1 spawnMonitor 创建监视器的原理</h3><div class="- topic/body body"><p class="- topic/p p">在监视器中，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor(handler,args..)</code> 函数方便地生成一个子监视器（subMonitor）。该函数将从原监视器中深拷贝所有的成员属性和成员方法，但不会拷贝原监视器中的事件监听器。并且，在子监视器实例化后，立刻执行对应的 handler，初始化该子监视器。</p><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/5-1.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="52-动态生成多个策略实例的代码实现"><h3 class="- topic/title title topictitle3" id="ariaid-title19">5.2 动态生成多个策略实例的代码实现</h3><div class="- topic/body body"><p class="- topic/p p">在了解了通过 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 生成监视器实例的原理后，我们可以对原来的代码作简单调整来实现动态生成多个策略实例，进而实现参数寻优。在原来的代码中，监听到策略启动事件后将进行对其他事件的监听、创建必要的引擎和表等操作。而为了同时运行多组参数策略，在监听到策略启动事件后，应立刻复制一个对应的子监视器来运行该参数下的策略实例。因此原代码中的 <code class="+ topic/ph pr-d/codeph ph codeph">initiatingStrategy</code> 函数中的内容，将作为 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 函数的 handler 参数。</p><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/5-2.png"/><br/><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def initiatingSpawn(Initiating) {
    spawnMonitor(initiatingStrategy, Initiating)
}
def onload() {
    addEventListener(handler=initiatingSpawn, eventType="Initiating", times="all")
}</code></pre><p class="- topic/p p">经过这样的调整，每次向引擎输入策略启动事件 <code class="+ topic/ph pr-d/codeph ph codeph">Initiating</code> 时，引擎将会通过 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 函数生成一个新的监视器实例。并且，通过立即以策略启动事件 <code class="+ topic/ph pr-d/codeph ph codeph">Initiating</code> 为入参调用 <code class="+ topic/ph pr-d/codeph ph codeph">initiatingStrategy</code> 函数，完成对该监视器实例的初始化。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">向引擎输入多个参数不同的策略启动事件</strong></p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">首先，增加希望测试的参数组合。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>cciUpperBoundaries = [50, 100,150]
cciLowerBoundaries = -cciUpperBoundaries
triggerAmounts = [50000, 150000]
cciTimePeriods = [10,20]
volumeTimePeriods = [30 * 1000, 60* 1000]</code></pre></li><li class="- topic/li li"><p class="- topic/p p">其次，以遍历的方式将这些参数组合成参数字典，并构造对应的策略启动事件输入引擎。同时，把每一个参数组合都记录在 gridParamInfo 表中。下面代码中通过循环一共构造了 3<em class="+ topic/ph hi-d/i ph i">3</em>2<em class="+ topic/ph hi-d/i ph i">2</em>2=72 个策略启动事件，即72组不同的策略参数。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>for(cciTimePeriod in cciTimePeriods){
    for(volumeTimePeriod in volumeTimePeriods){
        // 因子计算参数
        factorParams_ = dict(`macd`cci`volume,
            [
            dict(`fastPeriod`slowPeriod`signalPeriod, [240, 520, 180]), 
            dict(`timePeriod, [cciTimePeriod]), 
            dict(`timePeriod, [volumeTimePeriod]) 
            ]
        )
        for(upperBoundary in cciUpperBoundaries){
            for(lowerBoundary in cciLowerBoundaries){
                for(triggerAmount in triggerAmounts){
                    // 策略参数
                    strategyParams_ = dict(`cci`volume`order,
                                    [
                                    dict(`upperBoundary`lowerBoundary, 
[upperBoundary, lowerBoundary]),
                                    dict(`triggerAmount, [triggerAmount]),
                                    dict(`orderAmount, [500])
                                    ]
                    )
                    // 生成并添加事件实例
                    instanceId = string(instanceId)
                    tmp = objByName("gridParamInfo")
                    insert into tmp(instanceId,CCIThreshold,CCITimePeriod,
VolumeThreshold,VolumeTimePeriod) values (instanceId, (upperBoundary.string() 
+","+lowerBoundary.string()), cciTimePeriod, triggerAmount, volumeTimePeriod)
                    initEvent = Initiating(instanceId, factorParams_, 
strategyParams_, time_, cashAmount_,holdingQty_,stockPool_)
                    appendEvent(CEPEngine, initEvent)
                    instanceId = int(instanceId)
                    instanceId += 1
                }
            }
        }
    }
}</code></pre></li><li class="- topic/li li"><p class="- topic/p p">注意区分和标注事件“出处”。当同一个 CEP 子引擎（线程）上有多个监视器时，不同的监视器之间可以相互“沟通”，即监听和捕获其他监视器中产生的事件。因此，除非是类似于行情数据事件这样必须被每个监视器完整捕获的事件，都需要在构造和设置监听时设置独特的属性值条件以避免混淆。此外，在对各个共享表和引擎命名时，也需要注意进行区分。在本案例中使用了 instanceId 用来区分不同参数的策略实例。</p></li></ol><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/5-3.png"/><br/><p class="- topic/p p">在遍历所有的参数组合构造策略启动事件输入引擎后，查看 web 界面可以发现接收事件数等于向 CEP 引擎输入的策略启动事件数量。监视器的数量为73个，来自初始的1个监视器加上 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 方法产生的 72 个子监视器。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/5-4.png"/><br/><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">计算策略收益率</strong></p><p class="- topic/p p">在计算完成后，我们需要统计各个参数组合下的策略实例收益率来挑选出最佳参数。收益率的计算逻辑为：（日末现金+日末持仓价值）/（初始现金+初始持仓股票价值）。为了确保日末的持仓和可用现金的金额准确，需要遍历所有的模拟撮合结果表，查询其中成交情况。同时，也要检查是否有不完全成交或者挂单未成交的情况。例如，若有买入失败的情况，则要将对应金额的现金加回至可用现金。同理，买卖情况都需要根据具体的撮合结果对金额、股数进行调整。收益率计算不是本文的重点，具体的计算损益函数见附件的策略代码。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="6-利用并行计算加速回测"><h2 class="- topic/title title topictitle2" id="ariaid-title20">6. 利用并行计算加速回测</h2><div class="- topic/body body"><p class="- topic/p p">在上文的代码实现中，无论是 1 个还是 73 个监视器的策略回测过程，都是运行在同一个 CEP 子引擎（线程）上。下图分别是不使用 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 仅回测一组参数、使用 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 回测多组参数的策略实例示意图。</p><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/6-1.png"/><br/></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="61-设置-dispatchkey-参数创建子引擎线程"><h3 class="- topic/title title topictitle3" id="ariaid-title21">6.1 设置 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 参数创建子引擎（线程）</h3><div class="- topic/body body"><p class="- topic/p p">在真实的投研环境中，我们还可以通过并行计算来加速策略回测的过程。CEP 引擎在创建时提供可选参数 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 来指定事件中的成员属性作为分配线程的依据。引擎将根据该属性中的每个唯一值来创建一个子引擎（线程），各个子引擎之间相互独立且并行地处理数据。若不指定 dispatchKey 参数，则 CEP 引擎只有一个（与 CEP 引擎同名的）子引擎，即只有一个处理线程。此外，还可以辅以 dispatchBucket 参数，实现对 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 指定的字段进行哈希分组，本案例未使用 dispatchBucket 参数。</p><p class="- topic/p p">在本案例中，可以通过策略启动事件中的成员属性 instanceId 来区分不同的策略参数组。因此，可以在创建 CEP 引擎时增加 dispatchKey 参数设置，代码和策略实例示意图如下所示。事件分发器根据 instanceId 将不同的策略启动事件发送到了不同的子引擎中。而逐笔成交事件和快照事件的属性值中不包含 instanceId，因此将会被发送到每一个的子引擎中。</p><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/6-2.png"/><br/><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>engine = createCEPEngine(name='macdCciVol', monitors=&lt;Monitor()&gt;, dummyTable=cepDummy,
eventSchema=[Snapshot, Transaction,Initiating], eventQueueDepth=10000000, 
outputTable=outputSerializer, useSystemTime=false, timeColumn=`time, 
dispatchKey=`instanceId)</code></pre><p class="- topic/p p">开启并行后，再向 CEP 引擎输入 72 个策略启动事件，在 web 端可以观察到已经自动创建了72个子引擎，并且每个子引擎中都根据策略参数又生成了一个监视器实例来运行策略。</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/6-3.png"/><br/><p class="- topic/p p">最后可视化的结果如下所示。（具体情况会根据策略参数、股票池选择而不同）</p><br/><img class="- topic/image image" src="images/cta_strategy_implementation_and_backtesting/6-4.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title22" id="62-性能测试"><h3 class="- topic/title title topictitle3" id="ariaid-title22">6.2 性能测试</h3><div class="- topic/body body"><p class="- topic/p p">测试数据量：50支股票1天的快照和成交数据，共1522416行。</p><p class="- topic/p p">测试方法：通过多组不同的策略参数启动多个策略实例，通过是否开启 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 参数控制是否并行计算。统计一批策略实例全部完成回测的总耗时。单策略平均耗时=总耗时/策略实例数量。</p><p class="- topic/p p">测试环境：单节点部署 DolphinDB server。license 授权内存上限 256G，核数上限 64 核。worknum 设置为 64，具体配置文件见附录。测试使用的服务器配置如下。</p><p class="- topic/p p">表 6-1 测试服务器配置</p><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__1"><strong class="+ topic/ph hi-d/b ph b">配置项</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__2"><strong class="+ topic/ph hi-d/b ph b">信息</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__1">OS（操作系统）</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__2">CentOS Linux 7 (Core)</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__1">内核</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__2">3.10.0-1160.el7.x86_64</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__1">CPU</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__2">Intel(R) Xeon(R) Gold 5220R CPU @ 2.20GHz 96 逻辑 CPU 核心</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__1">内存</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__2">16*32GB RDUNN, 3200MT/s 总共512GB</td></tr></tbody></table></div><p class="- topic/p p">测试结果如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">在不启用并行计算（即并行度为1）时，随着策略实例数量的增加，单策略平均耗时仍然能够保持稳定，总耗时呈线性增加。</li><li class="- topic/li li">在启用并行计算时，随着并行度的增加，单策略平均耗时逐渐降低，系统吞吐量逐渐提高。</li><li class="- topic/li li">在相同策略实例数量下，并行计算显著降低了回测总耗时。例如，比较策略实例数为 40 的两个测试用例，并行计算提速了约 11.7 倍。</li></ul><p class="- topic/p p">表 6-2 CEP 引擎性能测试结果</p><div class="table-container"><table class="- topic/table table" data-cols="5"><caption></caption><colgroup><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__11"><strong class="+ topic/ph hi-d/b ph b">策略实例数量</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__12"><strong class="+ topic/ph hi-d/b ph b">并行度（子引擎数）</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__13"><strong class="+ topic/ph hi-d/b ph b">单策略平均耗时（秒）</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__14"><strong class="+ topic/ph hi-d/b ph b">总耗时（秒）</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="62-性能测试__entry__15"><strong class="+ topic/ph hi-d/b ph b">提速（倍，并行度为 1 时的总耗时/总耗时）</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">45.0</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">45</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">-</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">10</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">39.0</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">390</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">-</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">37.5</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">780</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">-</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">30</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">41.2</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">1237</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">-</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">40</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">40.2</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">1608</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">-</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">10</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">10</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">6.9</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">69</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">5.7</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">4.2</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">84</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">8.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">30</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">30</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">3.6</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">108</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">11.5</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__11">40</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__12">40</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__13">3.4</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__14">137</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="62-性能测试__entry__15">11.7</td></tr></tbody></table></div></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title23" id="7-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title23">7. 总结</h2><div class="- topic/body body"><p class="- topic/p p">本文通过循序渐进的方式，首先介绍了如何使用 CEP 引擎实现一个多指标高频股票策略的回测，其次介绍了通过 <code class="+ topic/ph pr-d/codeph ph codeph">spawnMonitor</code> 实现在一个子引擎中回测多组参数的方法，最后利用 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 参数的设置实现了并行计算以加速参数寻优。此外，还展示了如何将 CEP 引擎与 DolphinDB 中其他的重要插件与功能联动使用，如模拟撮合引擎插件、数据回放功能、 ta 模块和数据面板（Dashboard）等。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title24" id="8-附录"><h2 class="- topic/title title topictitle2" id="ariaid-title24">8. 附录</h2><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试数据</strong></p><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="data/cta_strategy_implementation_and_backtesting/CEPExampleData_Snapshot.csv">快照数据（5只股票3个交易日）</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="data/cta_strategy_implementation_and_backtesting/CEPExampleData_Transaction.csv">逐笔成交数据（5只股票2个交易日）</a></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试数据导入脚本</strong>：</p><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/cta_strategy_implementation_and_backtesting/ImportDataToDB.dos">导入脚本</a></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">策略实现脚本</strong>：</p><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/cta_strategy_implementation_and_backtesting/CTAStrategy.dos">策略脚本</a></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">数据面板（Dashboard）配置文件</strong>：</p><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/cta_strategy_implementation_and_backtesting/dashboard_CTA.json">Dashboard 配置</a></li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">server 配置文件</strong>：</p><ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/cta_strategy_implementation_and_backtesting/dolphindb.cfg">server 配置</a></li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1--%E7%AD%96%E7%95%A5%E9%80%BB%E8%BE%91" data-tocid="1--策略逻辑">1.  策略逻辑</a></li><li class="topic-item"><a href="#2--%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97" data-tocid="2--主要功能模块">2.  主要功能模块</a><ul><li class="topic-item"><a href="#21-cep-%E5%BC%95%E6%93%8E" data-tocid="21-cep-引擎">2.1 CEP 引擎</a></li><li class="topic-item"><a href="#22-%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%94%BE" data-tocid="22-数据回放">2.2 数据回放</a></li><li class="topic-item"><a href="#23-%E6%A8%A1%E6%8B%9F%E6%92%AE%E5%90%88%E5%BC%95%E6%93%8E" data-tocid="23-模拟撮合引擎">2.3 模拟撮合引擎</a></li></ul></li><li class="topic-item"><a href="#3--%E7%AD%96%E7%95%A5%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" data-tocid="3--策略代码实现">3.  策略代码实现</a><ul><li class="topic-item"><a href="#31-%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E7%B1%BB" data-tocid="31-定义事件类">3.1 定义事件类</a></li><li class="topic-item"><a href="#32-%E5%AE%9A%E4%B9%89%E7%9B%91%E8%A7%86%E5%99%A8" data-tocid="32-定义监视器">3.2 定义监视器</a></li><li class="topic-item"><a href="#33-%E5%88%9B%E5%BB%BA-cep-%E5%BC%95%E6%93%8E" data-tocid="33-创建-cep-引擎">3.3 创建 CEP 引擎</a></li><li class="topic-item"><a href="#34-%E5%90%AF%E5%8A%A8%E7%AD%96%E7%95%A5%E5%AE%9E%E4%BE%8B" data-tocid="34-启动策略实例">3.4 启动策略实例</a></li><li class="topic-item"><a href="#35-%E5%9B%9E%E6%94%BE%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE" data-tocid="35-回放历史数据">3.5 回放历史数据</a></li></ul></li><li class="topic-item"><a href="#4--%E7%BB%93%E6%9E%9C%E6%A3%80%E8%A7%86" data-tocid="4--结果检视">4.  结果检视</a><ul><li class="topic-item"><a href="#41-%E6%8C%87%E6%A0%87%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%8F%AF%E8%A7%86%E5%8C%96" data-tocid="41-指标与信号可视化">4.1 指标与信号可视化</a></li><li class="topic-item"><a href="#42-%E8%BE%93%E5%87%BA%E4%BA%8B%E4%BB%B6" data-tocid="42-输出事件">4.2 输出事件</a></li><li class="topic-item"><a href="#43-%E6%A8%A1%E6%8B%9F%E6%92%AE%E5%90%88%E7%BB%93%E6%9E%9C" data-tocid="43-模拟撮合结果">4.3 模拟撮合结果</a></li></ul></li><li class="topic-item"><a href="#5-%E7%AD%96%E7%95%A5%E5%8F%82%E6%95%B0%E5%AF%BB%E4%BC%98" data-tocid="5-策略参数寻优">5. 策略参数寻优</a><ul><li class="topic-item"><a href="#51-spawnmonitor-%E5%88%9B%E5%BB%BA%E7%9B%91%E8%A7%86%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86" data-tocid="51-spawnmonitor-创建监视器的原理">5.1 spawnMonitor 创建监视器的原理</a></li><li class="topic-item"><a href="#52-%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E5%A4%9A%E4%B8%AA%E7%AD%96%E7%95%A5%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" data-tocid="52-动态生成多个策略实例的代码实现">5.2 动态生成多个策略实例的代码实现</a></li></ul></li><li class="topic-item"><a href="#6-%E5%88%A9%E7%94%A8%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F%E5%9B%9E%E6%B5%8B" data-tocid="6-利用并行计算加速回测">6. 利用并行计算加速回测</a><ul><li class="topic-item"><a href="#61-%E8%AE%BE%E7%BD%AE-dispatchkey-%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B" data-tocid="61-设置-dispatchkey-参数创建子引擎线程">6.1 设置 <em class="+ topic/ph hi-d/i ph i">dispatchKey</em> 参数创建子引擎（线程）</a></li><li class="topic-item"><a href="#62-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="62-性能测试">6.2 性能测试</a></li></ul></li><li class="topic-item"><a href="#7-%E6%80%BB%E7%BB%93" data-tocid="7-总结">7. 总结</a></li><li class="topic-item"><a href="#8-%E9%99%84%E5%BD%95" data-tocid="8-附录">8. 附录</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>