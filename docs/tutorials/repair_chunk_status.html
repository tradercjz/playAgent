<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在 DolphinDB 日常运维时，可能由于误操作或意外情况，造成控制节点与数据节点的分区状态不一致，最终导致数据无法加载和写入。针对这种异常，本教程介绍如何解决 DolphinDB 分区状态不一致的问题以恢复数据库正常加载数据功能。 DolphinDB 利用分布式文件系统 (Distributed File System，DFS) ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="分区状态不一致"/><title>分区状态不一致</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;分区状态不一致&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:1;1:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:1;1:1&#34;&gt;分区状态不一致&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:1;1:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:1;3:1&#34;&gt;在 DolphinDB 日常运维时，可能由于误操作或意外情况，造成控制节点与数据节点的分区状态不一致，最终导致数据无法加载和写入。针对这种异常，本教程介绍如何解决 DolphinDB 分区状态不一致的问题以恢复数据库正常加载数据功能。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;1-基本概念&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:2;5:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:2;5:1&#34;&gt;1. 基本概念&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:2;5:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:2;7:1&#34;&gt;DolphinDB 利用分布式文件系统 (Distributed File System，DFS) 实现数据库的存储和基本事务机制，并采用多副本机制，将相同数据块的副本存储在不同的数据节点上。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:3;9:1&#34;&gt;数据库以分区为单位进行管理，而数据库中的数据包括以下两个部分：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:1;11:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:1;11:1&#34;&gt;元数据。数据库的分区信息，包括每个分区的版本链，大小，存储位置等信息，存储在控制节点(Controller)。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:2;12:1&#34;&gt;分区数据，具体要存储的实际数据，包含多个副本。每一个数据块简称为chunk。副本数据存储在各数据节点(Data Node，又称Chunk Node)&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:4;14:1&#34;&gt;这些数据统一由 DFS 管理。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:5;16:1&#34;&gt;下面分别介绍 Controller 以及 Data Node 中 chunk 的保存内容：&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;11-controller&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:3;18:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:3;18:1&#34;&gt;1.1 Controller&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:3;18:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:2;20:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:3;20:1&#34;&gt;文件命名空间：例如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:1;20:13&#34;&gt;/ff_custom15/YANGXS_YINZI8/202104M_202105M&lt;/codeph&gt;。一个文件命名空间的每一级目录都有属性：{'Normal', 'Partiton', 'Seq'}。其中：&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:3;21:5&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:4;21:5&#34;&gt;Normal：类似于普通的文件系统目录。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:5;22:5&#34;&gt;Partition：数据库的分区目录，Range，List，Value。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:6;23:5&#34;&gt;Seq：将一张表按照 Tablet Chunk 为单位进行顺序分割的目录。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:7;24:1&#34;&gt;File Chunk：普通文件的 chunk。例如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:2;24:29&#34;&gt;/ff_custom3/table_data_3.tbl&lt;/codeph&gt; 是一个 File Chunk。File Chunk 和文件名存在映射关系，一个大文件的 chunk 对应多个小的 chunk 存储。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:8;25:1&#34;&gt;Tablet Chunk：一种特殊的 chunk，可以理解为结构化数据表的一小片，是一个目录，即 Sequential 分区下的Part概念，该目录下存放实际的数据，这种类型的目录必须作为最后一级分区，该目录同样受 chunk 大小限制。例如，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:3;25:125&#34;&gt;/ff_custom15/YANGXS_YINZI8/202104M_202105M&lt;/codeph&gt; 是一个Tablet Chunk。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:9;26:1&#34;&gt;Chunk 位置信息，一般是由 Data Node 汇报到 Controller 合成，包括该 chunk 的位置信息，管理的分区、Tablet Chunk信息、各分区、Tablet Chunk的版本号和负载等信息。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;12-data-node-与-chunk-node&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:4;28:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:4;28:1&#34;&gt;1.2 Data Node 与 Chunk Node&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:4;28:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:6;30:1&#34;&gt;在 DFS 中，Data Node 和 Chunk Node 是两个不同的概念：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:4;32:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:10;32:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:7;32:3&#34;&gt;Data Node 是负责存储和管理整个文件的节点。Data Node 常用于存储整个文件的多个副本，以实现数据的冗余备份和高可用性。Data Node 主要处理 File Chunk 和 Tablet Chunk 两种类型。其中：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:5;34:5&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:11;34:5&#34;&gt;File Chunk 可以是以 chunk id 命名的一个 binary 文件。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:12;35:5&#34;&gt;Tablet Chunk 可以是以 chunk id 命名的一个目录，里面存放Tablet数据。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:13;36:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:8;36:3&#34;&gt;Chunk Node 是负责存储和管理数据块的节点，通常会存储多个数据块。Chunk Node 定时向 Controller 汇报本地存放的 File Chunk 和 Tablet Chunk 信息以及负载信息。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:9;38:1&#34;&gt;一个 Data Node 可以同时担任多个 Chunk Node 的角色，即存储并管理多个数据块。这种分层的架构可以有效地提高 DFS 的性能和可靠性，同时也方便了数据的管理和维护。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:10;41:1&#34;&gt;一个数据库可以包含上百万个分区，分区的多副本之间使用二阶段提交协议实现分区副本的强一致性。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:11;43:1&#34;&gt;下面简要介绍 TID、CID 以及二阶段提交协议流程：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:6;45:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:14;45:1&#34;&gt;事务编号（Transaction Identifier, TID, unsigned long long, 递增）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:15;46:1&#34;&gt;事务提交编号（Commit Identifier, CID，unsigned long long, 递增）&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:16;47:1&#34;&gt;版本号（unsigned int，可以循环利用）&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:12;49:1&#34;&gt;二阶段提交协议的流程如下：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ol:1;51:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:17;51:1&#34;&gt;协调人（提交任务的节点）首先向Controller取得一个事务编号（TID），并在 Controller 的内存中做元数据修改，然后把任务发给每一个 Chunk Node。每一个 Chunk Node 去完成具体任务，如果有错抛出异常给协调人。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:18;52:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:7;52:4&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:19;52:4&#34;&gt;协调人收到异常或者请求超时，认为任务没有完成，决定回滚事务。向各个 Chunk Node 和 Controller 发出回滚请求。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:20;53:5&#34;&gt;协调人如果没有收到异常，也没有任何超时，协调人决定准备提交事务（提交的第一阶段）。协调人从 Controller 获取一个 CID 后，使用 TID 和 CID 向相关的 Chunk Node 和 Controller 发送提交请求。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:21;54:1&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:8;54:4&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:22;54:4&#34;&gt;协调人收到异常或者请求超时，决定回滚事务。向各个 Chunk Node 和 Controller 发出回滚请求。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:23;55:5&#34;&gt;协调人如果没有收到异常，也没有任何超时，协调人决定准备提交事务（提交的第二阶段）。协调人向 Controller 和 Chunk Node 发出 complete 事务请求。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:24;56:1&#34;&gt;在第二阶段（回滚或确认），不管 Chunk Node 和 Controller 发生什么，协调人不作任何处理，都交由集群的版本恢复机制来处理。&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;13-controller-和data-node-上的版本状态说明&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:5;58:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:5;58:1&#34;&gt;1.3 Controller 和Data Node 上的版本状态说明&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:5;58:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:13;60:1&#34;&gt;DolphinDB上版本状态说明分布在 Controller 和 Datanode 上，正常情况都处于完成状态。所有 chunk 的版本以 Controller 的版本为标准，如果一个 Chunk Node 保存的某个 chunk 的版本不等于 Controller 上保存的该 chunk 的版本，那么认为不一致，需要通过 Recovery 机制恢复到最新的版本。事务版本状态说明如下:&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:9;62:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:25;62:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:14;62:3&#34;&gt;查看Controller上所有chunk的版本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:1;64:3&#34;&gt;select * from getClusterChunksStatus()&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:26;68:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:15;68:3&#34;&gt;返回表中重要的列说明&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:10;70:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:27;70:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:4;70:5&#34;&gt;chunkId&lt;/codeph&gt;：chunk的唯一标识&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:28;71:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:5;71:5&#34;&gt;file&lt;/codeph&gt;：分区路径。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:29;72:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:6;72:5&#34;&gt;size&lt;/codeph&gt;：file chunk 占用磁盘空间，单位为 byte。对于 tablet chunk, 返回0，需要使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:7;72:65&#34;&gt;getTabletsMeta&lt;/codeph&gt; 来查看它们实际占用的磁盘空间。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:30;73:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:8;73:5&#34;&gt;version&lt;/codeph&gt;：版本号&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:31;74:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:9;74:5&#34;&gt;VCLength&lt;/codeph&gt;: 版本链长度&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:32;75:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:10;75:5&#34;&gt;VersionChain&lt;/codeph&gt;: 版本链。例如1028:0:1 -&amp;gt; 1028:0:0 -&amp;gt; 标识该 chunk 经历了两个版本，1028:0:1分别表示 chunk 的 Cid、size 以及 version&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:33;76:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:11;76:5&#34;&gt;state&lt;/codeph&gt;： chunk 状态。COMPLETE 表示数据已导入；CONSTRUCTING 表示正在导入数据；RECOVERING 表示正在恢复数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:34;77:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:12;77:5&#34;&gt;replicas&lt;/codeph&gt;：副本的分布信息。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:35;78:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:13;78:5&#34;&gt;replicaCount&lt;/codeph&gt;：副本数&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:16;80:1&#34;&gt;Controller 上版本有3个状态：CONSTRUCTING, RECOVERING, COMPLETE（对应 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:14;80:61&#34;&gt;state&lt;/codeph&gt; 字段）&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:11;82:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:36;82:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:15;82:3&#34;&gt;CONSTRUCTING&lt;/codeph&gt; ： chunk 正在构建中，比如 openchunk 后正在写入，正在删除等，一般是事务中的状态。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:37;83:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:16;83:3&#34;&gt;RECOVERING&lt;/codeph&gt; ： chunk 处于恢复中，当 Controller 刚启动，chunk 都处在这个状态，等待 Data Node 汇报版本，如果版本和 Controller 上的版本一致，则状态由 RECOVERING 变为 COMPLETE 状态。 其次，如果 Data Node 汇报上来的版本不一致，那么 Controller 上的 chunk 会一直处在这种状态，直到 recovery 过程完成，然后版本变为一致，状态变为 COMPLETE。 除了 Controller 刚启动，在正常运行中，也可能出现这种状态。例如，在读数据的时候，检查到数据校验错误，Data Node 会向 Controller 发起 recovery 请求，在 Controller 执行 recovery 的过程中，chunk 的状态也是 RECOVERING。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:38;84:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:17;84:3&#34;&gt;COMPLETE&lt;/codeph&gt; ： chunk 处于完成状态，事务正常完成，重启后版本一致，都将处在这个状态，这个状态是最终正确的状态。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:17;86:1&#34;&gt;当 Controller 重启后，所有文件的最后一个 chunk 被置为 Recovering 状态，随着 chunk 信息汇报上来后，如果副本 chunk version 和 master chunk version 一致且有效副本个数到达阈值，那么 Recovering=&amp;gt; Complete，否则 Controller 将不一致的 chunk 加入待恢复 chunk 队列。对于等待恢复的 chunk，选择一个一致的 chunk 副本作为 primary chunk，执行这个副本过程，如果一个 chunk 的所有副本都和 Controller chunk version 不一致，无法进行恢复。对于正在进行恢复的 chunk 来说，限制该 chunk 无法进行写。对于每个 chunk 的 recovery 过程都分配一个唯一的 recovery id，由 master 生成，用于去重复。所以本篇文章第四节针对无法重启自动恢复 chunk 的问题提出解决方案。Controller 的 chunk 状态如下图所示：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status2.1-1.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:1;88:1&#34; dita-ot:image-width=&#34;711&#34; dita-ot:image-height=&#34;343&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:18;90:1&#34;&gt;查询Controller上版本可能有问题的 chunk：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:2;92:1&#34;&gt;select * from getClusterChunksStatus() where state != 'COMPLETE' select * from rpc(getControllerAlias(), getClusterChunksStatus) where state != 'COMPLETE'&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:12;97:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:39;97:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:19;97:3&#34;&gt;查看 Data Node 上所有 chunk 的版本&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:3;99:3&#34;&gt;select * from pnodeRun(getAllChunks)&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:40;103:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:20;103:3&#34;&gt;返回表中重要的列说明&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:13;105:3&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:41;105:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:18;105:5&#34;&gt;site&lt;/codeph&gt; : chunk所属 Data Node&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:42;106:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:19;106:5&#34;&gt;chunkId&lt;/codeph&gt;：chunk 的唯一标识。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:43;107:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:20;107:5&#34;&gt;path&lt;/codeph&gt;：chunk 物理路径。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:44;108:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:21;108:5&#34;&gt;dfsPath&lt;/codeph&gt;：分区路径。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:45;109:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:22;109:5&#34;&gt;type&lt;/codeph&gt;：分区类型。0表示 file chunk；1表示 tablet chunk。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:46;110:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:23;110:5&#34;&gt;flag&lt;/codeph&gt;：删除标志。若 flag=1，此 chunk 数据不能被查询到，但尚未从磁盘删除。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:47;111:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:24;111:5&#34;&gt;size&lt;/codeph&gt;：file chunk 占用磁盘空间。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:48;112:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:25;112:5&#34;&gt;version&lt;/codeph&gt;：版本号&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:49;113:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:26;113:5&#34;&gt;state&lt;/codeph&gt;：chunk 状态&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:50;114:3&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:27;114:5&#34;&gt;versionList&lt;/codeph&gt;：版本列表，cid : 6,pt=&amp;gt;6:500338; # 表示该分区chunk的cid为6，所属为pt表，其总行数为500338&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:21;116:1&#34;&gt;Data Node上有5个状态：FIN, BCOMM, COMM, WRE, IRE，分别对应 state 字段值 0，1，2，3，4：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:14;118:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:51;118:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:28;118:3&#34;&gt;FIN&lt;/codeph&gt; ：chunk处于终态，包括事务最终正确完成，或者 rollback。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:52;119:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:29;119:3&#34;&gt;BCOMM&lt;/codeph&gt; : before commit, 往一个 chunk 上正在执行事务，在 commit 之前的阶段。比如正在写数据或者删除数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:53;120:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:30;120:3&#34;&gt;COMM&lt;/codeph&gt; ： after commit，事务已经 commit 的状态。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:54;121:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:31;121:3&#34;&gt;WRE &lt;/codeph&gt;： waiting for recovering，等待恢复的状态，比如版本不一致或者数据损坏，向 Controller 发起 recovery 请求后，等待 Controller 发起 recovery 之前，则会处于这种状态。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:55;122:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:32;122:3&#34;&gt;IRE &lt;/codeph&gt;： in recovering 状态，在 recovering 状态中，接受到 Controller 的recovering请求，开始启动recovery，则处于这个状态，recovering 完成后变为 FIN 状态。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:22;124:1&#34;&gt;chunk 的最终状态为 FIN，其他状态都是临时状态，Data Node 启动后，一般处于 FIN 状态，如果有异常需要恢复，则可能处于 WRE 状态。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:23;126:1&#34;&gt;如下图附上 Chunk Node 状态图：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status2.1-2.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:2;128:1&#34; dita-ot:image-width=&#34;772&#34; dita-ot:image-height=&#34;618&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:24;130:1&#34;&gt;查看Data Node上所有非正常的 chunk 的状态：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:4;132:1&#34;&gt;select * from getAllChunks() where state != 0 &lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;14-controller-和-data-node-版本一致性校验&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:6;136:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:6;136:1&#34;&gt;1.4 Controller 和 Data Node 版本一致性校验&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:6;136:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:25;138:1&#34;&gt;Controller 和 Data Node 启动后，正常情况下，所有 chunk 都处于终态，Controller 上状态为 COMPLETE，Data Node 上状态为 FIN。每个 chunk 上所有副本版本一致，和 Controller 也完全一致。以下3个场景将触发 chunk 的恢复机制。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:15;139:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:56;139:1&#34;&gt;Controller 或 Data Node 重启，&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:57;140:1&#34;&gt;Controller 或 Data Node 的事务处于 committed 的状态，但已经 timeout&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:58;141:1&#34;&gt;在客户端读写的过程中发现 Controller 和 Datanode 的版本不一致。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:26;143:1&#34;&gt;正常触发恢复机制后，在半个小时左右都将使得 Controller 或 Datanode 的 Chunk 状态分别变成 COMPLETE 以及 FIN。如果 Chunk 一直处于 Recovering 状态，相关常见场景以及解决方法见下节。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;2-分区状态不一致场景&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:7;145:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:7;145:1&#34;&gt;2. 分区状态不一致场景&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:7;145:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:27;147:1&#34;&gt;典型的版本不一致的场景如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:16;149:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:59;149:1&#34;&gt;(a) Datanode 两个副本一致，但是和 Controller 不一致；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:60;150:1&#34;&gt;(b) Datanode 两个副本不一致，其中一个和 Controller 一致；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:61;151:1&#34;&gt;(c) Datanode 两个副本不一致，并且都和 Controller 不一致；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:62;152:1&#34;&gt;(d) Datanode 两个副本一致，但是 Controller 的 chunk 丢失；&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:28;154:1&#34;&gt;造成这些版本不一致的原因可能有：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:17;156:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:63;156:1&#34;&gt;程序的 bug&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:64;157:1&#34;&gt;人为删除数据文件&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:65;158:1&#34;&gt;配置不当。例如，不同数据节点的 meta 配置到一个目录下。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:66;159:1&#34;&gt;不正常的关机、重启时，集群未准备好写入。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;3-分区状态不一致修复方法与案例&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:8;161:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:8;161:1&#34;&gt;3. 分区状态不一致修复方法与案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:8;161:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:29;163:1&#34;&gt;由于版本不一致的现象多种多样，按照目前 DolphinDB 数据库的恢复机制，如果出现版本不一致，Data Node 上报后，Controller 会启动 recovery 机制进行修复。自动的 recovery 机制只能修复上面的 (b) 场景，也就是两个数据节点的 replica 中有一个和 Controller 的版本相同，这种场景下，recovery 会修复不一致的版本，并且 Controller 和 Data Node 的版本最终会达到一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:30;165:1&#34;&gt;对于其他的版本不一致场景，需要通过一些特殊手段来修复，包括：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:18;167:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:67;167:1&#34;&gt;修改元数据&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:68;168:1&#34;&gt;发起 recovering&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:69;169:1&#34;&gt;指定修复到某个版本&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:70;170:1&#34;&gt;删除/复制 replica&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:71;171:1&#34;&gt;从 Data Node 恢复到 Controller 等&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:31;173:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;b:1;173:1&#34;&gt;注意&lt;/b&gt;：在确认数据本身正确，只是版本或者元数据不正确的话，利用下列函数来强制修改 datanode 元数据。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;31-利用函数-forcecorrectversionbyreplica-修复版本错乱问题&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:9;175:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:9;175:1&#34;&gt;3.1 利用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:33;175:14&#34;&gt;forceCorrectVersionByReplica&lt;/codeph&gt; 修复版本错乱问题&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:9;175:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:32;177:1&#34;&gt;如下场景：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:33;179:1&#34;&gt;查询 Controller 上版本可能有问题的 chunk：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:5;181:1&#34;&gt;select * from rpc(getControllerAlias(), getClusterChunksStatus) where state != 'COMPLETE'&lt;/codeblock&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.1-1.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:3;185:1&#34; dita-ot:image-width=&#34;1198&#34; dita-ot:image-height=&#34;371&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:34;187:1&#34;&gt;如图所示，其中 version 字段对应 Controller 上的 Chunk 版本信息为 270，而 replicas 对应 DataNode 上的 Chunk 版本信息，符合（a）场景，Controller 上版本信息明显低于 Data Node。可以使用下面函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:34;187:137&#34;&gt;forceCorrectVersionByReplica&lt;/codeph&gt; 修复。该函数语法如下：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:35;189:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:35;189:1&#34;&gt;forceCorrectVersionByReplica(chunkID,nodealias)&lt;/codeph&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:19;191:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:72;191:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:36;191:3&#34;&gt;chunkID&lt;/codeph&gt;：chunk 的唯一标识。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:73;192:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:37;192:3&#34;&gt;nodealias&lt;/codeph&gt;：节点别名。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:36;194:1&#34;&gt;该函数强制 chunk 以 nodealias 上的版本和数据为准，Controller 和其他的 Data Node 必须无条件与其同步。该函数背后的实现原理是：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ol:2;196:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:74;196:1&#34;&gt;找到 nodealias 上的 chunk，Controller 先向 Data Node 获取到 chunk 的版本信息&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:75;197:1&#34;&gt;将 nodealias 上该版本的状态转为 FIN&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:76;198:1&#34;&gt;然后 Controller 的版本号按照 Data Node 反馈的更新&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:77;199:1&#34;&gt;发起 recovery，强制其他的 replica 与 nodealias 上该 chunk的数据和版本信息同步&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:37;201:1&#34;&gt;该函数可以解决版本不一致的绝大多数问题，但可能会导致数据部分丢失，所以在选择 nodealias 的时候，尽量选择版本高的 nodealias。示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:6;203:1&#34;&gt;for(chunk in chunkIDs){ nodes = exec top 1 node from pnodeRun(getAllChunks) where chunkId=chunk order by version desc rpc(getControllerAlias(), forceCorrectVersionByReplica{chunk, nodes[0]}) }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:38;210:1&#34;&gt;查看该 Chunk 的状态，如图所示，版本一致，状态变成 COMPLETE。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.1-2.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:4;212:1&#34; dita-ot:image-width=&#34;1154&#34; dita-ot:image-height=&#34;281&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:39;214:1&#34;&gt;在控制节点的状态变成 COMPLETE 之后，也需要检查下数据节点元数据的状态。如果数据节点的 state 为3，则需要通过函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:38;214:66&#34;&gt;triggerNodeReport&lt;/codeph&gt; 去触发下数据节点重新去汇报下状态（这个函数推出于 2.00.8 版本；如果 server 早于 2.00.8 版本，则需要通过重启数据节点触发分区信息的汇报）。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:40;217:1&#34;&gt;比如，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:39;217:7&#34;&gt;select * from pnodeRun(getAllChunks) where chunkId=xxxx&lt;/codeph&gt; 查询数据节点元数据的结果如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.1-3.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:5;219:1&#34; dita-ot:image-width=&#34;1069&#34; dita-ot:image-height=&#34;77&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:41;221:1&#34;&gt;其中的 datanode3 的 state 为3，则需要在控制节点，通过执行以下脚本：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; outputclass=&#34;python&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:7;223:1&#34;&gt;triggerNodeReport(&#34;datanode3&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:42;226:1&#34;&gt;去触发下 datanode3 汇报信息，之后 state 会被重置为0，这时候控制节点元数据和数据节点元数据信息都恢复正常了。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;32-利用函数-imtupdatechunkversionondatanode-和-updatechunkversiononmaster-直接编辑-chunk-的元数据版本信息&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:10;228:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:10;228:1&#34;&gt;3.2 利用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:40;228:14&#34;&gt;imtUpdateChunkVersionOnDataNode&lt;/codeph&gt; 和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:41;228:50&#34;&gt;updateChunkVersionOnMaster&lt;/codeph&gt; 直接编辑 chunk 的元数据版本信息&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:10;228:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:43;230:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:42;230:1&#34;&gt;imtUpdateChunkVersionOnDataNode&lt;/codeph&gt;函数定义如下&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:44;232:1&#34;&gt;imtUpdateChunkVersionOnDataNode(chunkID,version)&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:20;234:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:78;234:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:43;234:3&#34;&gt;chunkID&lt;/codeph&gt;: chunk 的唯一标识。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:79;235:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:44;235:3&#34;&gt;version&lt;/codeph&gt;: 版本号&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:45;237:1&#34;&gt;可以在数据节点上使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:45;237:12&#34;&gt;getClusterMeta&lt;/codeph&gt; 查看当前数据节点上 chunk 对应的版本号。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:46;239:1&#34;&gt;假设 530076e2-c6e9-cf97-8d49-9e5faac17325 为 chunkID, 1 为 version，该函数用法如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:8;241:1&#34;&gt;imtUpdateChunkVersionOnDataNode(&#34;530076e2-c6e9-cf97-8d49-9e5faac17325&#34;, 1)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:47;245:1&#34;&gt;该函数的功能不提供分布式功能，只针对某个 chunkNode 上某个 Chunk，直接修改并持久化改 Chunk 的元数据，使得版本恢复一致。注意：该函数只能在数据节点上使用。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:48;247:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:46;247:1&#34;&gt;updateChunkVersionOnMaster&lt;/codeph&gt;函数定义如下&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:49;249:1&#34;&gt;updateChunkVersionOnMaster(chunkId, version)&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:21;251:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:80;251:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:47;251:3&#34;&gt;chunkID&lt;/codeph&gt;: chunk 的唯一标识。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:81;252:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:48;252:3&#34;&gt;version&lt;/codeph&gt;: 版本号&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:50;254:1&#34;&gt;使用前，可以在控制节点使用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:49;254:17&#34;&gt;getClusterChunksStatus&lt;/codeph&gt; 查询所有节点上 chunk 对应的版本号。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:51;256:1&#34;&gt;该函数的功能，直接修改并持久化改 chunk 的元数据，使得版本恢复一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:52;258:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;b:2;258:1&#34;&gt;注意&lt;/b&gt;：只能在控制节点上使用。1.30.16/2.00.4 及之前的版本在使用之前请咨询技术支持，可能会导致 createCids 列表为空。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:53;260:1&#34;&gt;如图所示&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.1-1.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:6;262:1&#34; dita-ot:image-width=&#34;1198&#34; dita-ot:image-height=&#34;371&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:54;264:1&#34;&gt;Controller 上版本低于 ChunkNode 上版本，使用下列语句修复&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:9;266:1&#34;&gt;updateChunkVersionOnMaster(&#34;deb91fa2-f05a-3096-5941-b80feda42562&#34;,270)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:55;270:1&#34;&gt;注意；这两个函数并不修改除版本号外的其他信息。与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:50;270:26&#34;&gt;forceCorrectVersionByReplica&lt;/codeph&gt; 函数区别是，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:51;270:63&#34;&gt;forceCorrectVersionByReplica&lt;/codeph&gt; 强制 Controller 版本和 datanode 版本一致，适合于 Datanode 上 chunk 版本高于 master 版本的情形。如果 Datanode 上 chunk 版本低于 master 版本，尽量选择高版本信息，可以使用本小节两个函数，将 chunk 信息修改为指定版本。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;33-利用函数-restorecontrollermetafromchunknode-恢复-controller-上的元数据&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:11;272:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:11;272:1&#34;&gt;3.3 利用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:52;272:14&#34;&gt;restoreControllerMetaFromChunkNode&lt;/codeph&gt; 恢复 Controller 上的元数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:11;272:1&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:10;275:1&#34;&gt;select * from rpc(getControllerAlias(), getClusterChunksStatus)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:56;279:1&#34;&gt;执行上述语句时查询到控制节点的元数据为0，且加载 DFS 分布式表报出下图所示错误，可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:53;279:48&#34;&gt;restoreControllerMetaFromChunkNode&lt;/codeph&gt; 函数进行恢复。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.3-1.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:7;281:1&#34; dita-ot:image-width=&#34;781&#34; dita-ot:image-height=&#34;647&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:57;283:1&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:54;283:1&#34;&gt;restoreControllerMetaFromChunkNode&lt;/codeph&gt; 函数主要用于恢复元数据，需要在控制节点上执行；该函数执行时，元数据存储目录下必须为空，所以需要在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;i:1;283:87&#34;&gt;controller.cfg&lt;/i&gt; 中配置元数据存储位置，将用于配置元数据存储路径的参数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:55;283:131&#34;&gt;dfsMetaDir&lt;/codeph&gt; 设置为空。控制节点的元数据文件如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/repair_chunk_status/repair_chunk_status4.3-2.png&#34; placement=&#34;break&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;image:8;285:1&#34; dita-ot:image-width=&#34;821&#34; dita-ot:image-height=&#34;207&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:58;287:1&#34;&gt;元数据恢复过程如下：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ol:3;289:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:82;289:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:59;289:4&#34;&gt;关闭 DolphinDB 集群&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:83;290:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:60;290:4&#34;&gt;备份 data 目录下的 DFSM*元数据文件（为了元数据安全，必须备份）&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:84;291:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:61;291:4&#34;&gt;删除 data 目录下的 DFSM*元数据文件&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:85;292:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:62;292:4&#34;&gt;在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;i:2;292:6&#34;&gt;controller.cfg&lt;/i&gt; 中配置元数据存储位置，即参数“dfsMetaDir=元数据存储路径”&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:63;294:5&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;b:3;294:5&#34;&gt;注意&lt;/b&gt;：该存储路径下必须只有元数据文件，不能同时存储其它文件。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:86;296:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:64;296:4&#34;&gt;重启集群，启动 controller、agent、datanode&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:87;297:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:65;297:4&#34;&gt;连接控制节点，需要等 1 分钟左右（此时数据节点加载 chunk 信息）再执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:56;297:44&#34;&gt;restoreControllerMetaFromDatanode&lt;/codeph&gt; 函数，chunk 信息未加载完毕前执行该函数，会报错：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:57;297:107&#34;&gt;Invalid UUID string&lt;/codeph&gt;&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:88;298:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:66;298:4&#34;&gt;如果反复执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:58;298:11&#34;&gt;restoreControllerMetaFromChunkNode&lt;/codeph&gt; 函数，会报错：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:59;298:55&#34;&gt;File [DFSMasterMetaCheckpoint.23553] is not zero-length, please check.&lt;/codeph&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:67;300:5&#34;&gt;此时说明，元数据文件已经恢复成功；&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:89;302:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:68;302:4&#34;&gt;执行完函数后，重启整个集群，就可以正常查询原有数据了。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;34-利用函数-droppartition-强制删除元数据&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:12;304:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:12;304:1&#34;&gt;3.4 利用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:60;304:14&#34;&gt;dropPartition&lt;/codeph&gt; 强制删除元数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:12;304:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:69;306:1&#34;&gt;如果确实要删除某个 chunk，但如果 chunk 的版本不一致，或者处在 recovering 状态，那么正常删除会删除失败。该函数第四个参数，可以指定是否强制删除，不考虑版本一致性的问题。这种情况下，可以使用该函数，并且将第四个参数设置为 true。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:70;308:1&#34;&gt;示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeblock:11;310:1&#34;&gt;dbName=&#34;/stocks_orderbook&#34; fileCond=dbName + &#34;%&#34; t=exec substr(file,strlen(dbName)) from rpc(getControllerAlias(),getClusterChunksStatus) where file like fileCond, state != &#34;COMPLETE&#34; dropPartition(database(&#34;dfs:/&#34;+dbName),t,,true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:71;317:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;b:4;317:1&#34;&gt;注意&lt;/b&gt;：假设执行查询 能正常返回数据，然后 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:61;317:26&#34;&gt;dropPartition&lt;/codeph&gt; 语句，会报错：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:62;317:49&#34;&gt;Failed to find physical table from Table_Name when delete tablet chunk&lt;/codeph&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:72;319:1&#34;&gt;可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;codeph:63;319:6&#34;&gt;chunkCheckPoint&lt;/codeph&gt; 函数，再重启所有数据节点即可。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; id=&#34;4-总结&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;topic:13;321:1&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;title:13;321:1&#34;&gt;4. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;body:13;321:1&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:73;323:1&#34;&gt;分布式数据库如何保持多副本数据一致性十分复杂，发生元数据异常的情况各有不同，下面有几个场景可能会导致上述情况：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;ul:22;325:1&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:90;325:1&#34;&gt;网络异常：当协调者向参与者发送 commit 请求之后，发生了网络异常，这将导致只有部分参与者收到了 commit 请求。这部分参与者接到 commit 请求之后就会执行 commit 操作，但是其他未接到 commit 请求的参与者则无法执行事务提交，于是整个分布式系统便出现了数据不一致的问题。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;li:91;326:1&#34;&gt;服务器宕机：协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;p:74;328:1&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/repair_chunk_status.md&#34; xtrc=&#34;b:5;328:1&#34;&gt;建议&lt;/b&gt;：避免 sever 在写入数据过程中执行重启机器等操作。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/repair_chunk_status.md"/><meta name="wh-out-relpath" content="tutorials/repair_chunk_status.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="分区状态不一致" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                    
                    <div class="col-lg-10 col-md-10 col-sm-10 col-xs-12" id="wh_topic_body">
                        
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">分区状态不一致</h1><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 日常运维时，可能由于误操作或意外情况，造成控制节点与数据节点的分区状态不一致，最终导致数据无法加载和写入。针对这种异常，本教程介绍如何解决 DolphinDB 分区状态不一致的问题以恢复数据库正常加载数据功能。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-基本概念"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 基本概念</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 利用分布式文件系统 (Distributed File System，DFS) 实现数据库的存储和基本事务机制，并采用多副本机制，将相同数据块的副本存储在不同的数据节点上。</p><p class="- topic/p p">数据库以分区为单位进行管理，而数据库中的数据包括以下两个部分：</p><ul class="- topic/ul ul"><li class="- topic/li li">元数据。数据库的分区信息，包括每个分区的版本链，大小，存储位置等信息，存储在控制节点(Controller)。</li><li class="- topic/li li">分区数据，具体要存储的实际数据，包含多个副本。每一个数据块简称为chunk。副本数据存储在各数据节点(Data Node，又称Chunk Node)</li></ul><p class="- topic/p p">这些数据统一由 DFS 管理。</p><p class="- topic/p p">下面分别介绍 Controller 以及 Data Node 中 chunk 的保存内容：</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-controller"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1 Controller</h3><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li">文件命名空间：例如 <code class="+ topic/ph pr-d/codeph ph codeph">/ff_custom15/YANGXS_YINZI8/202104M_202105M</code>。一个文件命名空间的每一级目录都有属性：{'Normal', 'Partiton', 'Seq'}。其中：<ul class="- topic/ul ul"><li class="- topic/li li">Normal：类似于普通的文件系统目录。</li><li class="- topic/li li">Partition：数据库的分区目录，Range，List，Value。</li><li class="- topic/li li">Seq：将一张表按照 Tablet Chunk 为单位进行顺序分割的目录。</li></ul></li><li class="- topic/li li">File Chunk：普通文件的 chunk。例如 <code class="+ topic/ph pr-d/codeph ph codeph">/ff_custom3/table_data_3.tbl</code> 是一个 File Chunk。File Chunk 和文件名存在映射关系，一个大文件的 chunk 对应多个小的 chunk 存储。</li><li class="- topic/li li">Tablet Chunk：一种特殊的 chunk，可以理解为结构化数据表的一小片，是一个目录，即 Sequential 分区下的Part概念，该目录下存放实际的数据，这种类型的目录必须作为最后一级分区，该目录同样受 chunk 大小限制。例如，<code class="+ topic/ph pr-d/codeph ph codeph">/ff_custom15/YANGXS_YINZI8/202104M_202105M</code> 是一个Tablet Chunk。</li><li class="- topic/li li">Chunk 位置信息，一般是由 Data Node 汇报到 Controller 合成，包括该 chunk 的位置信息，管理的分区、Tablet Chunk信息、各分区、Tablet Chunk的版本号和负载等信息。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-data-node-与-chunk-node"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2 Data Node 与 Chunk Node</h3><div class="- topic/body body"><p class="- topic/p p">在 DFS 中，Data Node 和 Chunk Node 是两个不同的概念：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">Data Node 是负责存储和管理整个文件的节点。Data Node 常用于存储整个文件的多个副本，以实现数据的冗余备份和高可用性。Data Node 主要处理 File Chunk 和 Tablet Chunk 两种类型。其中：</p><ul class="- topic/ul ul"><li class="- topic/li li">File Chunk 可以是以 chunk id 命名的一个 binary 文件。</li><li class="- topic/li li">Tablet Chunk 可以是以 chunk id 命名的一个目录，里面存放Tablet数据。</li></ul></li><li class="- topic/li li"><p class="- topic/p p">Chunk Node 是负责存储和管理数据块的节点，通常会存储多个数据块。Chunk Node 定时向 Controller 汇报本地存放的 File Chunk 和 Tablet Chunk 信息以及负载信息。</p></li></ul><p class="- topic/p p">一个 Data Node 可以同时担任多个 Chunk Node 的角色，即存储并管理多个数据块。这种分层的架构可以有效地提高 DFS 的性能和可靠性，同时也方便了数据的管理和维护。</p><p class="- topic/p p">一个数据库可以包含上百万个分区，分区的多副本之间使用二阶段提交协议实现分区副本的强一致性。</p><p class="- topic/p p">下面简要介绍 TID、CID 以及二阶段提交协议流程：</p><ul class="- topic/ul ul"><li class="- topic/li li">事务编号（Transaction Identifier, TID, unsigned long long, 递增）</li><li class="- topic/li li">事务提交编号（Commit Identifier, CID，unsigned long long, 递增）</li><li class="- topic/li li">版本号（unsigned int，可以循环利用）</li></ul><p class="- topic/p p">二阶段提交协议的流程如下：</p><ol class="- topic/ol ol"><li class="- topic/li li">协调人（提交任务的节点）首先向Controller取得一个事务编号（TID），并在 Controller 的内存中做元数据修改，然后把任务发给每一个 Chunk Node。每一个 Chunk Node 去完成具体任务，如果有错抛出异常给协调人。</li><li class="- topic/li li"><ul class="- topic/ul ul"><li class="- topic/li li">协调人收到异常或者请求超时，认为任务没有完成，决定回滚事务。向各个 Chunk Node 和 Controller 发出回滚请求。</li><li class="- topic/li li">协调人如果没有收到异常，也没有任何超时，协调人决定准备提交事务（提交的第一阶段）。协调人从 Controller 获取一个 CID 后，使用 TID 和 CID 向相关的 Chunk Node 和 Controller 发送提交请求。</li></ul></li><li class="- topic/li li"><ul class="- topic/ul ul"><li class="- topic/li li">协调人收到异常或者请求超时，决定回滚事务。向各个 Chunk Node 和 Controller 发出回滚请求。</li><li class="- topic/li li">协调人如果没有收到异常，也没有任何超时，协调人决定准备提交事务（提交的第二阶段）。协调人向 Controller 和 Chunk Node 发出 complete 事务请求。</li></ul></li><li class="- topic/li li">在第二阶段（回滚或确认），不管 Chunk Node 和 Controller 发生什么，协调人不作任何处理，都交由集群的版本恢复机制来处理。</li></ol></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="13-controller-和data-node-上的版本状态说明"><h3 class="- topic/title title topictitle3" id="ariaid-title5">1.3 Controller 和Data Node 上的版本状态说明</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB上版本状态说明分布在 Controller 和 Datanode 上，正常情况都处于完成状态。所有 chunk 的版本以 Controller 的版本为标准，如果一个 Chunk Node 保存的某个 chunk 的版本不等于 Controller 上保存的该 chunk 的版本，那么认为不一致，需要通过 Recovery 机制恢复到最新的版本。事务版本状态说明如下:</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">查看Controller上所有chunk的版本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from getClusterChunksStatus()</code></pre></li><li class="- topic/li li"><p class="- topic/p p">返回表中重要的列说明</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">chunkId</code>：chunk的唯一标识</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">file</code>：分区路径。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">size</code>：file chunk 占用磁盘空间，单位为 byte。对于 tablet chunk, 返回0，需要使用 <code class="+ topic/ph pr-d/codeph ph codeph">getTabletsMeta</code> 来查看它们实际占用的磁盘空间。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">version</code>：版本号</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">VCLength</code>: 版本链长度</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">VersionChain</code>: 版本链。例如1028:0:1 -&gt; 1028:0:0 -&gt; 标识该 chunk 经历了两个版本，1028:0:1分别表示 chunk 的 Cid、size 以及 version</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">state</code>： chunk 状态。COMPLETE 表示数据已导入；CONSTRUCTING 表示正在导入数据；RECOVERING 表示正在恢复数据。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">replicas</code>：副本的分布信息。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">replicaCount</code>：副本数</li></ul></li></ul><p class="- topic/p p">Controller 上版本有3个状态：CONSTRUCTING,  RECOVERING,  COMPLETE（对应 <code class="+ topic/ph pr-d/codeph ph codeph">state</code> 字段）</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">CONSTRUCTING</code> ： chunk 正在构建中，比如 openchunk 后正在写入，正在删除等，一般是事务中的状态。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">RECOVERING</code> ： chunk 处于恢复中，当 Controller 刚启动，chunk 都处在这个状态，等待 Data Node 汇报版本，如果版本和 Controller 上的版本一致，则状态由 RECOVERING 变为 COMPLETE 状态。 其次，如果 Data Node 汇报上来的版本不一致，那么 Controller 上的 chunk 会一直处在这种状态，直到 recovery 过程完成，然后版本变为一致，状态变为 COMPLETE。 除了 Controller 刚启动，在正常运行中，也可能出现这种状态。例如，在读数据的时候，检查到数据校验错误，Data Node 会向 Controller 发起 recovery 请求，在 Controller 执行 recovery 的过程中，chunk 的状态也是 RECOVERING。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">COMPLETE</code> ： chunk 处于完成状态，事务正常完成，重启后版本一致，都将处在这个状态，这个状态是最终正确的状态。</li></ul><p class="- topic/p p">当 Controller 重启后，所有文件的最后一个 chunk 被置为 Recovering 状态，随着 chunk 信息汇报上来后，如果副本 chunk version 和 master chunk version 一致且有效副本个数到达阈值，那么 Recovering=&gt; Complete，否则 Controller 将不一致的 chunk 加入待恢复 chunk 队列。对于等待恢复的 chunk，选择一个一致的 chunk 副本作为 primary chunk，执行这个副本过程，如果一个 chunk 的所有副本都和 Controller chunk version 不一致，无法进行恢复。对于正在进行恢复的 chunk 来说，限制该 chunk 无法进行写。对于每个 chunk 的 recovery 过程都分配一个唯一的 recovery id，由 master 生成，用于去重复。所以本篇文章第四节针对无法重启自动恢复 chunk 的问题提出解决方案。Controller 的 chunk 状态如下图所示：</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status2.1-1.png"/><br/><p class="- topic/p p">查询Controller上版本可能有问题的 chunk：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from getClusterChunksStatus()  where  state != 'COMPLETE'
select * from rpc(getControllerAlias(), getClusterChunksStatus) where  state != 'COMPLETE'</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">查看 Data Node 上所有 chunk 的版本</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from pnodeRun(getAllChunks)</code></pre></li><li class="- topic/li li"><p class="- topic/p p">返回表中重要的列说明</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">site</code> : chunk所属 Data Node</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">chunkId</code>：chunk 的唯一标识。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">path</code>：chunk 物理路径。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">dfsPath</code>：分区路径。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">type</code>：分区类型。0表示 file chunk；1表示 tablet chunk。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">flag</code>：删除标志。若 flag=1，此 chunk 数据不能被查询到，但尚未从磁盘删除。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">size</code>：file chunk 占用磁盘空间。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">version</code>：版本号</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">state</code>：chunk 状态</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">versionList</code>：版本列表，cid : 6,pt=&gt;6:500338; # 表示该分区chunk的cid为6，所属为pt表，其总行数为500338</li></ul></li></ul><p class="- topic/p p">Data Node上有5个状态：FIN, BCOMM, COMM, WRE, IRE，分别对应 state 字段值 0，1，2，3，4：</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">FIN</code> ：chunk处于终态，包括事务最终正确完成，或者 rollback。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">BCOMM</code> : before commit, 往一个 chunk 上正在执行事务，在 commit 之前的阶段。比如正在写数据或者删除数据。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">COMM</code> ： after commit，事务已经 commit 的状态。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">WRE </code>： waiting for recovering，等待恢复的状态，比如版本不一致或者数据损坏，向 Controller 发起 recovery 请求后，等待 Controller 发起 recovery 之前，则会处于这种状态。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">IRE </code>： in recovering 状态，在 recovering 状态中，接受到 Controller 的recovering请求，开始启动recovery，则处于这个状态，recovering 完成后变为 FIN 状态。</li></ul><p class="- topic/p p">chunk 的最终状态为 FIN，其他状态都是临时状态，Data Node 启动后，一般处于 FIN 状态，如果有异常需要恢复，则可能处于 WRE 状态。</p><p class="- topic/p p">如下图附上 Chunk Node 状态图：</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status2.1-2.png"/><br/><p class="- topic/p p">查看Data Node上所有非正常的 chunk 的状态：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from getAllChunks() where state != 0 </code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="14-controller-和-data-node-版本一致性校验"><h3 class="- topic/title title topictitle3" id="ariaid-title6">1.4 Controller 和 Data Node 版本一致性校验</h3><div class="- topic/body body"><p class="- topic/p p">Controller 和 Data Node 启动后，正常情况下，所有 chunk 都处于终态，Controller 上状态为 COMPLETE，Data Node 上状态为 FIN。每个 chunk 上所有副本版本一致，和 Controller 也完全一致。以下3个场景将触发 chunk 的恢复机制。</p><ul class="- topic/ul ul"><li class="- topic/li li">Controller 或 Data Node 重启，</li><li class="- topic/li li">Controller 或 Data Node 的事务处于 committed 的状态，但已经 timeout</li><li class="- topic/li li">在客户端读写的过程中发现 Controller 和 Datanode 的版本不一致。</li></ul><p class="- topic/p p">正常触发恢复机制后，在半个小时左右都将使得 Controller 或 Datanode 的 Chunk 状态分别变成 COMPLETE 以及 FIN。如果 Chunk 一直处于 Recovering 状态，相关常见场景以及解决方法见下节。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="2-分区状态不一致场景"><h2 class="- topic/title title topictitle2" id="ariaid-title7">2. 分区状态不一致场景</h2><div class="- topic/body body"><p class="- topic/p p">典型的版本不一致的场景如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">(a) Datanode 两个副本一致，但是和 Controller 不一致；</li><li class="- topic/li li">(b) Datanode 两个副本不一致，其中一个和 Controller 一致；</li><li class="- topic/li li">(c) Datanode 两个副本不一致，并且都和 Controller 不一致；</li><li class="- topic/li li">(d) Datanode 两个副本一致，但是 Controller 的 chunk 丢失；</li></ul><p class="- topic/p p">造成这些版本不一致的原因可能有：</p><ul class="- topic/ul ul"><li class="- topic/li li">程序的 bug</li><li class="- topic/li li">人为删除数据文件</li><li class="- topic/li li">配置不当。例如，不同数据节点的 meta 配置到一个目录下。</li><li class="- topic/li li">不正常的关机、重启时，集群未准备好写入。</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title8" id="3-分区状态不一致修复方法与案例"><h2 class="- topic/title title topictitle2" id="ariaid-title8">3. 分区状态不一致修复方法与案例</h2><div class="- topic/body body"><p class="- topic/p p">由于版本不一致的现象多种多样，按照目前 DolphinDB 数据库的恢复机制，如果出现版本不一致，Data Node 上报后，Controller 会启动 recovery 机制进行修复。自动的 recovery 机制只能修复上面的 (b) 场景，也就是两个数据节点的 replica 中有一个和 Controller 的版本相同，这种场景下，recovery 会修复不一致的版本，并且 Controller 和 Data Node 的版本最终会达到一致。</p><p class="- topic/p p">对于其他的版本不一致场景，需要通过一些特殊手段来修复，包括：</p><ul class="- topic/ul ul"><li class="- topic/li li">修改元数据</li><li class="- topic/li li">发起 recovering</li><li class="- topic/li li">指定修复到某个版本</li><li class="- topic/li li">删除/复制 replica</li><li class="- topic/li li">从 Data Node 恢复到 Controller 等</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：在确认数据本身正确，只是版本或者元数据不正确的话，利用下列函数来强制修改 datanode 元数据。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="31-利用函数-forcecorrectversionbyreplica-修复版本错乱问题"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.1 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica</code> 修复版本错乱问题</h3><div class="- topic/body body"><p class="- topic/p p">如下场景：</p><p class="- topic/p p">查询 Controller 上版本可能有问题的 chunk：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from rpc(getControllerAlias(), getClusterChunksStatus) where  state != 'COMPLETE'</code></pre><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.1-1.png"/><br/><p class="- topic/p p">如图所示，其中 version 字段对应 Controller 上的 Chunk 版本信息为 270，而 replicas 对应 DataNode 上的 Chunk 版本信息，符合（a）场景，Controller 上版本信息明显低于 Data Node。可以使用下面函数 <code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica</code> 修复。该函数语法如下：</p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica(chunkID,nodealias)</code></p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">chunkID</code>：chunk 的唯一标识。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">nodealias</code>：节点别名。</li></ul><p class="- topic/p p">该函数强制 chunk 以 nodealias 上的版本和数据为准，Controller 和其他的 Data Node 必须无条件与其同步。该函数背后的实现原理是：</p><ol class="- topic/ol ol"><li class="- topic/li li">找到 nodealias 上的 chunk，Controller 先向 Data Node 获取到 chunk 的版本信息</li><li class="- topic/li li">将 nodealias 上该版本的状态转为 FIN</li><li class="- topic/li li">然后 Controller 的版本号按照 Data Node 反馈的更新</li><li class="- topic/li li">发起 recovery，强制其他的 replica 与 nodealias 上该 chunk的数据和版本信息同步</li></ol><p class="- topic/p p">该函数可以解决版本不一致的绝大多数问题，但可能会导致数据部分丢失，所以在选择 nodealias 的时候，尽量选择版本高的 nodealias。示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python"><strong class="hl-keyword">for</strong>(chunk <strong class="hl-keyword">in</strong> chunkIDs){          
    nodes = <strong class="hl-keyword">exec</strong>  top <span class="hl-number">1</span> node <strong class="hl-keyword">from</strong> pnodeRun(getAllChunks) where chunkId=chunk order by version desc
    rpc(getControllerAlias(), forceCorrectVersionByReplica{chunk, nodes[<span class="hl-number">0</span>]})
}</pre><p class="- topic/p p">查看该 Chunk 的状态，如图所示，版本一致，状态变成 COMPLETE。</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.1-2.png"/><br/><p class="- topic/p p">在控制节点的状态变成 COMPLETE 之后，也需要检查下数据节点元数据的状态。如果数据节点的 state 为3，则需要通过函数 <code class="+ topic/ph pr-d/codeph ph codeph">triggerNodeReport</code> 去触发下数据节点重新去汇报下状态（这个函数推出于 2.00.8 版本；如果 server 早于 2.00.8 版本，则需要通过重启数据节点触发分区信息的汇报）。</p><p class="- topic/p p">比如，通过 <code class="+ topic/ph pr-d/codeph ph codeph">select * from pnodeRun(getAllChunks) where chunkId=xxxx</code> 查询数据节点元数据的结果如下：</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.1-3.png"/><br/><p class="- topic/p p">其中的 datanode3 的 state 为3，则需要在控制节点，通过执行以下脚本：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock python">triggerNodeReport(<span class="hl-string">"datanode3"</span>)</pre><p class="- topic/p p">去触发下 datanode3 汇报信息，之后 state 会被重置为0，这时候控制节点元数据和数据节点元数据信息都恢复正常了。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="32-利用函数-imtupdatechunkversionondatanode-和-updatechunkversiononmaster-直接编辑-chunk-的元数据版本信息"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.2 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">imtUpdateChunkVersionOnDataNode</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">updateChunkVersionOnMaster</code> 直接编辑 chunk 的元数据版本信息</h3><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">imtUpdateChunkVersionOnDataNode</code>函数定义如下</p><p class="- topic/p p">imtUpdateChunkVersionOnDataNode(chunkID,version)</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">chunkID</code>: chunk 的唯一标识。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">version</code>: 版本号</li></ul><p class="- topic/p p">可以在数据节点上使用 <code class="+ topic/ph pr-d/codeph ph codeph">getClusterMeta</code> 查看当前数据节点上 chunk 对应的版本号。</p><p class="- topic/p p">假设 530076e2-c6e9-cf97-8d49-9e5faac17325 为 chunkID, 1 为 version，该函数用法如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>imtUpdateChunkVersionOnDataNode("530076e2-c6e9-cf97-8d49-9e5faac17325", 1)</code></pre><p class="- topic/p p">该函数的功能不提供分布式功能，只针对某个 chunkNode 上某个 Chunk，直接修改并持久化改 Chunk 的元数据，使得版本恢复一致。注意：该函数只能在数据节点上使用。</p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">updateChunkVersionOnMaster</code>函数定义如下</p><p class="- topic/p p">updateChunkVersionOnMaster(chunkId, version)</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">chunkID</code>: chunk 的唯一标识。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">version</code>: 版本号</li></ul><p class="- topic/p p">使用前，可以在控制节点使用函数 <code class="+ topic/ph pr-d/codeph ph codeph">getClusterChunksStatus</code> 查询所有节点上 chunk 对应的版本号。</p><p class="- topic/p p">该函数的功能，直接修改并持久化改 chunk 的元数据，使得版本恢复一致。</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：只能在控制节点上使用。1.30.16/2.00.4 及之前的版本在使用之前请咨询技术支持，可能会导致 createCids 列表为空。</p><p class="- topic/p p">如图所示</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.1-1.png"/><br/><p class="- topic/p p">Controller 上版本低于 ChunkNode 上版本，使用下列语句修复</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>updateChunkVersionOnMaster("deb91fa2-f05a-3096-5941-b80feda42562",270)</code></pre><p class="- topic/p p">注意；这两个函数并不修改除版本号外的其他信息。与 <code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica</code> 函数区别是，<code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica</code> 强制 Controller 版本和 datanode 版本一致，适合于 Datanode 上 chunk 版本高于 master 版本的情形。如果 Datanode 上 chunk 版本低于 master 版本，尽量选择高版本信息，可以使用本小节两个函数，将 chunk 信息修改为指定版本。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="33-利用函数-restorecontrollermetafromchunknode-恢复-controller-上的元数据"><h3 class="- topic/title title topictitle3" id="ariaid-title11">3.3 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromChunkNode</code> 恢复 Controller 上的元数据</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from rpc(getControllerAlias(), getClusterChunksStatus)</code></pre><p class="- topic/p p">执行上述语句时查询到控制节点的元数据为0，且加载 DFS 分布式表报出下图所示错误，可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromChunkNode</code> 函数进行恢复。</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.3-1.png"/><br/><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromChunkNode</code> 函数主要用于恢复元数据，需要在控制节点上执行；该函数执行时，元数据存储目录下必须为空，所以需要在 <em class="+ topic/ph hi-d/i ph i">controller.cfg</em> 中配置元数据存储位置，将用于配置元数据存储路径的参数 <code class="+ topic/ph pr-d/codeph ph codeph">dfsMetaDir</code> 设置为空。控制节点的元数据文件如下：</p><br/><img class="- topic/image image" src="images/repair_chunk_status/repair_chunk_status4.3-2.png"/><br/><p class="- topic/p p">元数据恢复过程如下：</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p">关闭 DolphinDB 集群</p></li><li class="- topic/li li"><p class="- topic/p p">备份 data 目录下的 DFSM*元数据文件（为了元数据安全，必须备份）</p></li><li class="- topic/li li"><p class="- topic/p p">删除 data 目录下的 DFSM*元数据文件</p></li><li class="- topic/li li"><p class="- topic/p p">在 <em class="+ topic/ph hi-d/i ph i">controller.cfg</em> 中配置元数据存储位置，即参数“dfsMetaDir=元数据存储路径”</p><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：该存储路径下必须只有元数据文件，不能同时存储其它文件。</p></li><li class="- topic/li li"><p class="- topic/p p">重启集群，启动 controller、agent、datanode</p></li><li class="- topic/li li"><p class="- topic/p p">连接控制节点，需要等 1 分钟左右（此时数据节点加载 chunk 信息）再执行 <code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromDatanode</code> 函数，chunk 信息未加载完毕前执行该函数，会报错：<code class="+ topic/ph pr-d/codeph ph codeph">Invalid UUID string</code></p></li><li class="- topic/li li"><p class="- topic/p p">如果反复执行 <code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromChunkNode</code> 函数，会报错：<code class="+ topic/ph pr-d/codeph ph codeph">File [DFSMasterMetaCheckpoint.23553] is not zero-length, please check.</code></p><p class="- topic/p p">此时说明，元数据文件已经恢复成功；</p></li><li class="- topic/li li"><p class="- topic/p p">执行完函数后，重启整个集群，就可以正常查询原有数据了。</p></li></ol></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="34-利用函数-droppartition-强制删除元数据"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.4 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">dropPartition</code> 强制删除元数据</h3><div class="- topic/body body"><p class="- topic/p p">如果确实要删除某个 chunk，但如果 chunk 的版本不一致，或者处在 recovering 状态，那么正常删除会删除失败。该函数第四个参数，可以指定是否强制删除，不考虑版本一致性的问题。这种情况下，可以使用该函数，并且将第四个参数设置为 true。</p><p class="- topic/p p">示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dbName="/stocks_orderbook"
fileCond=dbName + "%"
t=exec substr(file,strlen(dbName)) from rpc(getControllerAlias(),getClusterChunksStatus) where file like fileCond, state != "COMPLETE"
dropPartition(database("dfs:/"+dbName),t,,true)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：假设执行查询 能正常返回数据，然后 <code class="+ topic/ph pr-d/codeph ph codeph">dropPartition</code> 语句，会报错：<code class="+ topic/ph pr-d/codeph ph codeph">Failed to find physical table from Table_Name when delete tablet chunk</code></p><p class="- topic/p p">可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">chunkCheckPoint</code> 函数，再重启所有数据节点即可。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="4-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title13">4. 总结</h2><div class="- topic/body body"><p class="- topic/p p">分布式数据库如何保持多副本数据一致性十分复杂，发生元数据异常的情况各有不同，下面有几个场景可能会导致上述情况：</p><ul class="- topic/ul ul"><li class="- topic/li li">网络异常：当协调者向参与者发送 commit 请求之后，发生了网络异常，这将导致只有部分参与者收到了 commit 请求。这部分参与者接到 commit 请求之后就会执行 commit 操作，但是其他未接到 commit 请求的参与者则无法执行事务提交，于是整个分布式系统便出现了数据不一致的问题。</li><li class="- topic/li li">服务器宕机：协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">建议</strong>：避免 sever 在写入数据过程中执行重启机器等操作。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" data-tocid="1-基本概念">1. 基本概念</a><ul><li class="topic-item"><a href="#11-controller" data-tocid="11-controller">1.1 Controller</a></li><li class="topic-item"><a href="#12-data-node-%E4%B8%8E-chunk-node" data-tocid="12-data-node-与-chunk-node">1.2 Data Node 与 Chunk Node</a></li><li class="topic-item"><a href="#13-controller-%E5%92%8Cdata-node-%E4%B8%8A%E7%9A%84%E7%89%88%E6%9C%AC%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E" data-tocid="13-controller-和data-node-上的版本状态说明">1.3 Controller 和Data Node 上的版本状态说明</a></li><li class="topic-item"><a href="#14-controller-%E5%92%8C-data-node-%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7%E6%A0%A1%E9%AA%8C" data-tocid="14-controller-和-data-node-版本一致性校验">1.4 Controller 和 Data Node 版本一致性校验</a></li></ul></li><li class="topic-item"><a href="#2-%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81%E4%B8%8D%E4%B8%80%E8%87%B4%E5%9C%BA%E6%99%AF" data-tocid="2-分区状态不一致场景">2. 分区状态不一致场景</a></li><li class="topic-item"><a href="#3-%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81%E4%B8%8D%E4%B8%80%E8%87%B4%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%B3%95%E4%B8%8E%E6%A1%88%E4%BE%8B" data-tocid="3-分区状态不一致修复方法与案例">3. 分区状态不一致修复方法与案例</a><ul><li class="topic-item"><a href="#31-%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0-forcecorrectversionbyreplica-%E4%BF%AE%E5%A4%8D%E7%89%88%E6%9C%AC%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98" data-tocid="31-利用函数-forcecorrectversionbyreplica-修复版本错乱问题">3.1 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">forceCorrectVersionByReplica</code> 修复版本错乱问题</a></li><li class="topic-item"><a href="#32-%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0-imtupdatechunkversionondatanode-%E5%92%8C-updatechunkversiononmaster-%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%BE%91-chunk-%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%89%88%E6%9C%AC%E4%BF%A1%E6%81%AF" data-tocid="32-利用函数-imtupdatechunkversionondatanode-和-updatechunkversiononmaster-直接编辑-chunk-的元数据版本信息">3.2 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">imtUpdateChunkVersionOnDataNode</code> 和 <code class="+ topic/ph pr-d/codeph ph codeph">updateChunkVersionOnMaster</code> 直接编辑 chunk 的元数据版本信息</a></li><li class="topic-item"><a href="#33-%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0-restorecontrollermetafromchunknode-%E6%81%A2%E5%A4%8D-controller-%E4%B8%8A%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE" data-tocid="33-利用函数-restorecontrollermetafromchunknode-恢复-controller-上的元数据">3.3 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">restoreControllerMetaFromChunkNode</code> 恢复 Controller 上的元数据</a></li><li class="topic-item"><a href="#34-%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0-droppartition-%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4%E5%85%83%E6%95%B0%E6%8D%AE" data-tocid="34-利用函数-droppartition-强制删除元数据">3.4 利用函数 <code class="+ topic/ph pr-d/codeph ph codeph">dropPartition</code> 强制删除元数据</a></li></ul></li><li class="topic-item"><a href="#4-%E6%80%BB%E7%BB%93" data-tocid="4-总结">4. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>