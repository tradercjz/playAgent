<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在实时计算中，端到端的响应延迟是衡量计算性能时最重要的指标。DolphinDB 内置的流数据框架支持流数据的发布与订阅、流式增量计算、实时关联等，用户能够快速实现复杂的实时计算任务，达到毫秒级甚至亚毫秒级的效果，而无需编写大量代码。 本文介绍如何对 DolphinDB 流计算任务进行全链路的时延统计，以及如何优化脚本以实现更低时延的实时计算： ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="流计算时延统计与性能优化"/><title>流计算时延统计与性能优化</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;流计算时延统计与性能优化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;流计算时延统计与性能优化&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在实时计算中，端到端的响应延迟是衡量计算性能时最重要的指标。DolphinDB 内置的流数据框架支持流数据的发布与订阅、流式增量计算、实时关联等，用户能够快速实现复杂的实时计算任务，达到毫秒级甚至亚毫秒级的效果，而无需编写大量代码。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;本文介绍如何对 DolphinDB 流计算任务进行全链路的时延统计，以及如何优化脚本以实现更低时延的实时计算：&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:55;80:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-耗时统计&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;1. 耗时统计&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在关键链路上记录处理的时刻，可以反映流计算各个环节的时延。此外，DolphinDB 流计算引擎本身还内置了耗时统计功能，可提供更详细的耗时情况，帮助进行分析与进一步性能优化。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;11-使用-now-函数记录数据处理时刻&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;1.1. 使用 now 函数记录数据处理时刻&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在数据发布、接收以及计算结果输出时，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;13:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数获取当前时刻，并在数据表中记录数据到达各个环节的时刻。示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;// create engine and subscribe share streamTable(1:0, `sym`time`qty`SendTime, [STRING, TIME, DOUBLE, NANOTIMESTAMP]) as tickStream result = table(1000:0, `sym`time`factor1`SendTime`ReceiveTime`HandleTime, [STRING, TIME, DOUBLE, NANOTIMESTAMP, NANOTIMESTAMP, NANOTIMESTAMP]) dummyTable = table(1:0, tickStream.schema().colDefs.name join `ReceiveTime, tickStream.schema().colDefs.typeString join `NANOTIMESTAMP) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =[&amp;lt;time&amp;gt;, &amp;lt;cumsum(qty)&amp;gt;, &amp;lt;SendTime&amp;gt;, &amp;lt;ReceiveTime&amp;gt;, &amp;lt;now(true)&amp;gt;], dummyTable=dummyTable, outputTable=result, keyColumn=&#34;sym&#34;) def addHandleTime(mutable msg){ update msg set ReceiveTime = now(true) getStreamEngine(&#34;reactiveDemo&#34;).append!(msg) } subscribeTable(tableName=&#34;tickStream&#34;, actionName=&#34;addTimestampDemo&#34;, offset=-1, handler=addHandleTime, msgAsTable=true) // generate input data data1 = table(take(&#34;000001.SZ&#34;, 5) as sym, 09:30:00.000 + [0, 1, 5, 6, 7] * 100 as time, take(10, 5) as qty) data2 = table(take(&#34;000002.SZ&#34;, 3) as sym, 09:30:00.000 + [2, 3, 8] * 100 as time, take(100, 3) as qty) data3 = table(take(&#34;000003.SZ&#34;, 2) as sym, 09:30:00.000 + [4, 9] * 100 as time, take(1000, 2) as qty) data = data1.unionAll(data2).unionAll(data3).sortBy!(`time) // insert data into engine update data set SendTime = now(true) tickStream.append!(data)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;结果表 result 如下，SendTime 是数据注入发布端流数据表的时刻，ReceiveTime 是订阅端接收到输入数据的时刻，HandleTime 是响应式状态引擎进行因子计算结束的时刻。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming_timer/01.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; dita-ot:image-width=&#34;777&#34; dita-ot:image-height=&#34;229&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;01&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在流计算引擎的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;40:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 参数中使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;40:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数需要注意以下几点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;41:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 参数中指定最后一个元素为 now()，表示引擎对该条输出结果计算完成的时刻，不包含将计算结果注入输出表的写入耗时。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;42:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;对于时序聚合引擎、会话窗口引擎等时间窗口聚合引擎(&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;42:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createTimeSeriesEngine&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;42:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createDailyTimeSeriesEngine&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;42:83&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createSessionWindowEngine&lt;/codeph&gt;)，需要注意：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;43:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;43:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在时间窗口聚合引擎的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;43:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 参数中可以直接使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;43:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数，注意，不要在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;43:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数外层嵌套聚合函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;44:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在 2.00.10、1.30.23 之前的版本中，若同时触发了多个分组的结果输出（例如 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;44:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;useSystemTime&lt;/i&gt;=true ），时间窗口聚合引擎中使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;44:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数时对每一个分组都依次获取一次当前时刻。在之后的版本中，优化后的时间窗口聚合引擎使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;44:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;now&lt;/codeph&gt; 函数时会对同一批输出的全部分组只获取一次当前时刻。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;12-使用-timer-语句快速验证流计算引擎性能&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;1.2. 使用 timer 语句快速验证流计算引擎性能&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;48:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;将一批数据批量注入引擎，通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;48:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;timer&lt;/codeph&gt; 语句统计从数据注入引擎到本批数据全部计算结束的总耗时。本方法适用于在因子开发和优化阶段快速验证引擎的计算性能。具体实践请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;str_comp_fin_quant.md&#34; xtrc=&#34;xref:1;48:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;金融因子流式实现教程：性能测试&lt;/xref&gt; ，文中用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;48:133&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;timer&lt;/codeph&gt; 语句比较了同一个因子的 4 种不同的实现对应的性能。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;50:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;timer getStreamEngine(&#34;reactiveDemo&#34;).append!(data)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;54:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;timer&lt;/codeph&gt; 语句用于计算一条命令的执行时间。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;55:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;对引擎进行 append 操作是同步返回的，即 append 语句执行结束时表示这一批数据在引擎里的处理已经全部结束，因此结合 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;55:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;timer&lt;/codeph&gt; 语法可以统计出这一批数据的总计算耗时。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;值得注意的是，使用本方法时，建议注入批量数据来考察总耗时。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;若注入少量数据如仅一条数据，则需要考虑输入数据的特征和不同引擎的特性差异。响应式状态引擎由于是逐条触发输出的因此，注入任意一条数据即会触发并输出对应结果条输出，可以反应响应式状态引擎的单次响应时延。但是，若使用时序聚合引擎且选择用非系统事件（&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;57:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;useSystemTime&lt;/i&gt;=false）触发的话，并不是任意一批数据都会触发输出的，单次响应时延需要注入能够触发输出的那一条特定时间戳的数据来测定。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;完整的示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;// create engine def sumDiff(x, y) { return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sumDiff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sumDiff(ema(price, 20), ema(price, 40)), 20)&amp;gt; share streamTable(1:0, `sym`time`price, [STRING, TIME, DOUBLE]) as tickStream result = table(1000:0, `sym`time`factor1, [STRING, TIME, DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =[&amp;lt;time&amp;gt;, factor1], dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;) // generate input data data1 = table(take(&#34;000001.SZ&#34;, 100) as sym, 09:30:00 + 1..100 *3 as time, 10+cumsum(rand(0.1, 100)-0.05) as price) data2 = table(take(&#34;000002.SZ&#34;, 100) as sym, 09:30:00 + 1..100 *3 as time, 20+cumsum(rand(0.2, 100)-0.1) as price) data3 = table(take(&#34;000003.SZ&#34;, 100) as sym, 09:30:00 + 1..100 *3 as time, 30+cumsum(rand(0.3, 100)-0.15) as price) data.append!(data1.unionAll(data2).unionAll(data3).sortBy!(`time)) // test perfomance timer getStreamEngine(&#34;reactiveDemo&#34;).append!(data)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;79:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在 GUI 中耗时统计如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming_timer/02.png&#34; placement=&#34;break&#34; xtrc=&#34;image:2;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; dita-ot:image-width=&#34;360&#34; dita-ot:image-height=&#34;128&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:2;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;02&lt;/alt&gt;&lt;/image&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;13-使用-outputelapsedmicroseconds-参数统计流计算引擎的耗时明细&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;1.3. 使用 outputElapsedMicroseconds 参数统计流计算引擎的耗时明细&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;83:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;85:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在 2.00.9、1.30.21 及以上版本中，流计算引擎新增了 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;85:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;outputElapsedMicroseconds&lt;/i&gt; 参数，该参数设置为 true 时表示开启对引擎内部计算耗时明细的统计，统计结果将作为两列输出到结果表中。目前支持该参数的引擎包括&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;85:126&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createTimeSeriesEngine&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;85:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createDailyTimeSeriesEngine&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;85:181&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createReactiveStateEngine&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;85:209&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createWindowJoinEngine&lt;/codeph&gt;。示例脚本如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;// create engine share streamTable(1:0, `sym`time`qty, [STRING, TIME, LONG]) as tickStream result = table(1000:0, `sym`cost`batchSize`time`factor1`outputTime, [STRING, LONG, INT, TIME, LONG, NANOTIMESTAMP]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =[&amp;lt;time&amp;gt;, &amp;lt;cumsum(qty)&amp;gt;, &amp;lt;now(true)&amp;gt;], dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;, outputElapsedMicroseconds=true) // generate input data data1 = table(take(&#34;000001.SZ&#34;, 5) as sym, 09:30:00.000 + [0, 1, 5, 6, 7] * 100 as time, take(10, 5) as qty) data2 = table(take(&#34;000002.SZ&#34;, 3) as sym, 09:30:00.000 + [2, 3, 8] * 100 as time, take(100, 3) as qty) data3 = table(take(&#34;000003.SZ&#34;, 2) as sym, 09:30:00.000 + [4, 9] * 100 as time, take(1000, 2) as qty) data = data1.unionAll(data2).unionAll(data3).sortBy!(`time) // insert data into engine getStreamEngine(&#34;reactiveDemo&#34;).append!(data)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;101:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;结果表 result 如下，cost 列和 batchSize 列为耗时明细，cost 列为引擎内部处理时每一个批次的计算耗时（单位：微秒），batchSize 列为同一批次处理的总记录数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;103:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;本例向响应式状态引擎注入了一批共 10 条数据，在引擎内部实际上分为了 5 个小的批次处理， 这是响应式状态引擎的特性和输入数据之间的顺序决定的。在同一个分组内响应式状态引擎逐条处理输入数据，同时，不同分组会放到同一批做向量化处理，因此可以看到，第一条分组列为 000001.SZ 的记录单独是一个批次，之后第二条 000001.SZ 和随后的 000002.SZ 在同一批中进行了计算输出。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming_timer/03.png&#34; placement=&#34;break&#34; xtrc=&#34;image:3;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; dita-ot:image-width=&#34;513&#34; dita-ot:image-height=&#34;229&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:3;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;03&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;本次 10 条输入数据注入引擎的总计算耗时：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;109:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;select sum(cost\batchSize) as totalCost from result&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-性能优化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2. 性能优化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在 DolphinDB 流计算框架中，实时数据首先注入到流数据表中，之后基于发布-订阅-消费模型，由发布端主动推送增量的输入数据至消费端，通过回调的方式在消息处理线程上不断执行指定好的消息处理函数进行计算，并将计算结果再写入到表中。纵观整个计算链路，我们发现可以从写入、计算和框架等三个方面进行流计算任务的性能优化。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-写入&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.1. 写入&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;DolphinDB 流计算框架的核心之一是流数据表，在整个计算链路中往往涉及到多次对流数据表的写入：比如从外部设备或者交易系统等源源不断产生的记录会实时写入流数据表，以作为之后实时计算的输入；此外，流计算引擎的计算结果也需要输出到表中。总之，对表的写入耗时会体现在整体的计算时延上，通过以下方式可以优化写入耗时。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;211-创建表时预分配内存&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.1.1. 创建表时预分配内存&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;122:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;122:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;普通共享流数据表&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;124:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;创建时指定足够大的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;124:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 参数。比如对于股票行情数据可以根据历史数据预估好一天的数据总量，将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;124:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 设置为略大于该数值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;126:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity = 1000000 share(streamTable(capacity:0, `sym`time`price, [STRING,DATETIME,DOUBLE]), `tickStream)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;131:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;streamTable&lt;/codeph&gt; 函数的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;131:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 参数是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数首次超过 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;131:71&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 时，系统会首先分配 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;131:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 的1.2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存，再写入新的数据。当记录数继续增加并超过被分配的内存空间时，会再次进行类似的扩容操作。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;133:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;从时延统计上看，由于扩容涉及到内存分配和复制等较为耗时的操作，因此若某一批数据写入时触发了扩容则会出现一次写入时延的峰值。可以想象，如果 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;133:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 仅仅设置为 1 ，在持续写入的过程中则会发生多次动态扩容，每次的峰值耗时将随总数据量增加而逐渐增高，因为需要拷贝的数据越来越多。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;135:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;135:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;持久化流数据表&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;创建时指定合理的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;137:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:14;137:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 参数。在内存充足的情况下，对于股票行情数据可以根据历史数据预估好一天的数据总量，将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:15;137:77&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:16;137:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;capacity&lt;/i&gt; 设置为略大于该数值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize = 1000000 enableTableShareAndPersistence(table=streamTable(cacheSize:0, `sym`time`price, [STRING,DATETIME,DOUBLE]), tableName=&#34;tickStream&#34;, asynWrite=true, compress=true, cacheSize=cacheSize, retentionMinutes=1440, flushMode=0, preCache=10000)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;enableTableShareAndPersistence&lt;/codeph&gt; 函数的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:17;144:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 参数是长整型数据类型（long）的整数，表示该表在内存中最多保留多少行，当内存中的行数超过 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:18;144:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 且确认目前的所有数据都已经保存到磁盘后，系统会申请新的内存空间，将内存中后 50% 的数据拷贝到新的内存空间，并释放掉原来的内存。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;从时延统计上看，由于清理内存中的过期数据涉及到内存分配、复制等较为耗时的操作，因此若某一批数据写入时触发了清理则会出现一次写入的时延峰值。若内存充足，则可以考虑设置足够大的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:19;146:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 将全部数据都保留在内存里，不触发清理操作。若需要进行内存控制，则设置合理 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:20;146:137&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 以平衡峰值出现的频率和单次峰值的大小，因为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:21;146:171&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cacheSize&lt;/i&gt; 的大小决定了拷贝的数据量进而会影响单次的耗时。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.2. 计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;流计算引擎是 DolphinDB 中专门用于处理实时流计算的模块，不同的流计算引擎对应不同的计算场景，如窗口聚合、事件驱动等。创建流计算引擎需要指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:22;150:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 参数，其为以元代码的形式表示计算公式，引擎的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:23;150:109&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 为实时指标在 DolphinDB 脚本中的实现。针对不同场景选择合适的流计算引擎后，实现高效的实时指标则是降低流计算时延的关键，因此，本章前三小节介绍在流式指标实现上的优化方法，最后一小节介绍在部分计算场景中不必使用流计算引擎的建议。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;221-内置状态函数与增量计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.2.1. 内置状态函数与增量计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;假设我们接收实时逐笔成交数据，并对每条成交记录逐条响应，累计最新的当日成交总量，如果每一次计算都是用截止当前的全量成交数据，则会响应性能不佳，而通过增量的流式实现则可以大大提升性能。具体的，最新的累计成交总量可以在上一次计算出的成交总量的基础上加上最新的一条成交记录的成交量得到，可以看到，这里的增量计算需要用到历史状态（上一次计算出的成交总量），我们称之为有状态计算。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;DolphinDB 在响应式状态引擎、时序聚合引擎、窗口连接引擎中，提供了大量的内置状态函数，在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:24;156:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 中使用内置状态函数即可以实现上述的增量有状态计算，而历史状态由引擎内部自动维护。比如，在响应式状态引擎中使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;156:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;cumsum&lt;/codeph&gt; 函数可以实现增量的累加。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;158:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;各个引擎已经支持的状态函数请参考用户手册 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;158:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createTimeSeriesEngine&lt;/codeph&gt;、 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;158:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createReactiveStateEngine&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;158:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createWindowJoinEngine&lt;/codeph&gt;，建议优先选择内置状态函数以增量算法实现实时指标。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;222-即时编译-jit&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.2.2. 即时编译 (JIT)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;即时编译 (英文: Just-in-time compilation, 缩写: JIT)，又译及时编译或实时编译，是动态编译的一种形式，可提高程序运行效率。DolphinDB 的编程语言是解释执行，运行程序时首先对程序进行语法分析生成语法树，然后递归执行。在不能使用向量化的情况下，解释成本会比较高。这是由于 DolphinDB 底层由 C++ 实现，脚本中的一次函数调用会转化为多次 C++ 内的虚拟函数调用。JIT 具体介绍请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;jit.md&#34; xtrc=&#34;xref:2;163:219&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB JIT 教程&lt;/xref&gt; 。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;流计算任务由于不断地被触发计算，因此会反复地调用函数，以 1.3 小节响应式状态引擎的计算为例，仅仅注入 10 条数据便会触发 5 次对 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:25;165:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;metrics&lt;/i&gt; 中函数的调用。解释耗时也会反应到整体的计算耗时中，尤其对于响应式状态引擎，在某些场景下总计算耗时中可能大部分为解释耗时，因此，建议通过实现 JIT 版本的函数来减少解释成本 。具体实践请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;jit.md&#34; xtrc=&#34;xref:3;165:176&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;金融因子流式实现教程：即时编译 (JIT)&lt;/xref&gt; ，文中使用 JIT 优化了移动平均买卖压力指标的性能。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;223-数组向量-array-vector&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.2.3. 数组向量 (array vector)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;171:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;DolphinDB 中的数组向量 (array vector) 是一种特殊的向量，用于存储可变长度的二维数组。这种存储方式可以显著简化某些常用的查询与计算。array vector 具体介绍请参考 DolphinDB array vector 教程。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming_timer/04.png&#34; placement=&#34;break&#34; xtrc=&#34;image:4;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; dita-ot:image-width=&#34;1150&#34; dita-ot:image-height=&#34;153&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:4;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;04&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;十档量价是行情快照中最重要的信息，实现高频因子时为了让十档量价数据能够方便地实现向量化计算，在 DolphinDB 中可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;175:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;fixedLengthArrayVector&lt;/codeph&gt; 函数组合十档数据。针对这个特点，建议直接使用数组向量 (array vector) 来存储 level 2 行情快照中的十档量价字段，以省去函数实现过程中组装十档数据的步骤，来降低计算延时。具体实践请参考请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;Array_Vector.md&#34; xtrc=&#34;xref:4;175:196&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;金融因子流式实现教程：数组向量 (array vector)&lt;/xref&gt; ，文中使用 array vector 优化了移动买卖压力指标的性能。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;224-自定义函数作为-handler-与无状态计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;177:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;177:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.2.4. 自定义函数作为 handler 与无状态计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;177:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;179:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;并不是所有的计算都需要通过流计算引擎进行，一些简单的无状态计算建议在自定义函数中实现。比如，下例希望在引擎中仅对 9:30 之后的数据进行计算，则可以在 handler 函数中首先对输入数据进行过滤再注入计算引擎。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;def filterTime(msg){ tmp = select * from msg where time &amp;gt; 09:30:00.000 getStreamEngine(&#34;reactiveDemo&#34;).append!(tmp) } subscribeTable(tableName=&#34;tickStream&#34;, actionName=&#34;demo&#34;, offset=-1, handler=filterTime, msgAsTable=true)&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;通过多加一层响应式状态引擎也可以实现同样的过滤，但是由于流计算引擎内部计算时进行分组以及维护状态等开销，在这种无状态计算的场景下，自定义函数是比流计算引擎更高效的实现方式。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;190:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;注意，handler 函数每次处理的是增量的数据，即以上脚本中的 msg 变量是订阅端收到的新增的数据，而不是最新的 tickStream 表的全量快照。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-框架&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.3. 框架&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;192:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在某些场景下，对单个指标的实现已经优化到了极致，但是由于输入数据流量极大，仍然可能导致系统来不及处理，也会表现为相当大的响应时延。若单位时间内输入数据的流量总是大于系统能够处理的流量，则会看到在订阅端的消息处理线程监控表（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;194:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;getStreamingStat().subWorkers&lt;/codeph&gt;）中的 queueDepth 数值不断上升，这是流计算任务不健康的表现，需要停止任务并优化。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;196:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;DolphinDB 流计算任务是通过流数据表、流计算引擎、消息处理线程等不同模块的组合来构建的。流计算任务可以被简单理解为后台线程在反复执行一个计算函数，流计算引擎以及其他自定义函数可以被指定为计算函数，流数据表以发布订阅的方式不断地触发后台线程调用对应的计算函数，每次函数调用的入参是流数据表中新增的一批记录。本小节从搭建流计算任务的框架方面介绍优化方法。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;231-微批处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.3.1. 微批处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;200:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 时设置适当的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:26;200:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:27;200:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数，可以达到微批处理的效果，以此来提升吞吐避免阻塞，进而降低时延。这是基于单次处理的耗时并不是随着单次处理的数据量而线性增长的，最典型的场景是实时写入分布式数据库，一次写入 1000 条数据和写入 10 条数据的耗时可能相差无几，那么发挥数据批处理的性能优势则可以降低整体的时延。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;202:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:28;202:2&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:29;202:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数均表示了触发消费的条件，这两个条件之间是或的关系。订阅队列中的数据积累到 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:30;202:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 设置的量时会触发消费，但是考虑到实际场景中，流量在不同时刻的波动，某些时候可能会长时间达不到 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:31;202:125&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 而不能被消费，因此需要设置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:32;202:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数，通过等待达到一定的时长来触发消费，消费会对队列中未处理的全部数据进行处理。 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:33;202:203&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:34;202:217&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数建议综合考虑输入数据的流量和数据处理的速度进行调整。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;此外，请注意以下两点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;修改系统配置项（dolphindb.cfg 或者 cluster.cfg）中 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:35;206:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subThrottle&lt;/i&gt;=1 后，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:36;206:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 才可以被设置为小于1秒。若不修改，则即使在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;206:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 函数中指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:37;206:116&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 为 0.001，实际值仍为 1 秒。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;207:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 时一定要指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:38;207:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:39;207:45&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数。若不指定，则每次处理的数据量为到达订阅队列的一块数据块的大小，而不是队列里的全部数据。举个例子，假设此时订阅队列里的仍未处理的数据有 10 条，它们分别是以 2 条、3 条、5 条的大小分三批到达订阅队列的，那么消息处理线程会依次分三批处理这 10 条数据，而不是批处理一次。因此，若输入数据频繁插入，但是每次插入的记录数较少，则未设置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:40;207:228&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;batchSize&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:41;207:242&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;throttle&lt;/i&gt; 参数的订阅可能会表现较差。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;232-并行计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.3.2. 并行计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;211:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 时设置适当的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:42;211:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;hash&lt;/i&gt; 参数，以提升并行度来降低时延。执行 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;211:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 函数相当于为其 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:43;211:78&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;handler&lt;/i&gt; 参数对应的计算函数分配了一个固定的消息处理线程，合理的分配消息处理线程可以尽可能充分里利用 CPU 资源。大致分为以下两类优化建议：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;将多个不同的流计算任务指定到不同的处理线程&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;214:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;214:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;尽量将不同的任务指定到不同的消息处理线程。假设系统中有 3 个流计算任务，若在提交&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;214:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 函数时均指定同一个 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:44;214:73&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;hash&lt;/i&gt; 值，则它们会被分配到同一个处理线程中，当同时都有新的消息需要处理时会通过轮转的方式执行计算，这种对计算资源的竞争会影响每一个任务的响应时延。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;215:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;若任务数过多，超过了消息处理线程数量的上限，则建议至少将复杂任务分配到不同的线程，复杂任务指需要长时间占用线程进行计算的任务。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;将某一个流计算任务拆分到多个线程上并行处理&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;217:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;217:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;若输入数据流量过大，一个线程处理不过来，则建议将数据分发到多个线程上并行处理。实现脚本请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;streaming_tutorial.md#并行处理&#34; xtrc=&#34;xref:5;217:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 流计算教程：并行处理&lt;/xref&gt; ，注意，若多个线程均将结果写到同一张共享内存表，那么同时写入时会等待写锁而带来一定的耗时，为了避免这部分等待可以将结果也写入到不同的数据表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;218:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;218:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;dispatchStreamEngine&lt;/codeph&gt; 进行流数据分发和并行计算，是替代 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;218:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 的更轻量级的数据分发方式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;233-流计算引擎级联&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.3.3. 流计算引擎级联&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;222:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;DolphinDB 中实现复杂计算指标的思路是把指标分解成多个阶段，每一个阶段由一个计算引擎来完成。如果两个引擎之间由一张中间表来承接中间的计算结果，并且由中间表的发布订阅来串联两个引擎，则会存在一定的内存和耗时的开销。因此，DolphinDB 内置的流计算引擎均实现了数据表（table）的接口，允许将后一个引擎作为前一个引擎的输出，称为流计算引擎级联，与通过多个流数据表与多次订阅串联引擎相比，有更好的性能表现。实现脚本请参考 &lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;streaming_tutorial.md#流水线处理&#34; xtrc=&#34;xref:6;222:217&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 流计算教程：流水线处理&lt;/xref&gt;&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;234-使用流数据分发引擎进行数据分发&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;2.3.4. 使用流数据分发引擎进行数据分发&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;226:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;前文介绍了将某一个流计算任务拆分到多个线程上并行处理的优化建议，但是通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;226:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 进行发布端过滤并提交多个并行任务的方式，可能会因为订阅的客户端太多而导致发布瓶颈，使得并发处理带来的优化受发布瓶颈的影响而减弱，因为在同一个节点上只有一个发布线程。在 1.30.22、2.00.9 以及之后的版本中，新增了流数据分发引擎（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;226:174&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;createStreamDispatchEngine&lt;/codeph&gt;），支持将输入的数据分发到不同的线程，并且在该线程中完成将增量的输入数据注入到对应的输出表的操作，这里的输出表可以指定为流计算引擎。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;以下脚本中进行了一次发布订阅，在订阅端的消息处理线程中将数据写入到一个分发引擎中，由该分发引擎将数据按 sym 字段哈希分组后分发到 3 个不同的线程进行实际的计算，计算逻辑由响应式状态引擎定义。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;// create engine share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream share streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream rseArr = array(ANY, 0) for(i in 0..2){ rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;+string(i), metrics =&amp;lt;cumavg(price)&amp;gt;, dummyTable=tickStream, outputTable=resultStream, keyColumn=&#34;sym&#34;) rseArr.append!(rse) } dispatchEngine=createStreamDispatchEngine(name=&#34;dispatchDemo&#34;, dummyTable=tickStream, keyColumn=`sym, outputTable=rseArr, mode=&#34;buffer&#34;, dispatchType=&#34;uniform&#34;) // subscribe subscribeTable(tableName=&#34;tickStream&#34;, actionName=&#34;dispatch&#34;, handler=dispatchEngine, msgAsTable=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;流数据分发引擎的原理：&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:11;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;分发引擎的参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:45;246:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;outputTable&lt;/i&gt; 是一个表（或流计算引擎）组成的列表，创建引擎时会创建与之数量相等的多个线程以及多个缓冲队列（或表）。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;引擎内部的每个线程会负责将缓冲队列中的增量数据注入到对应的输出表（或流计算引擎）。若分发引擎输出到流计算引擎，则此时的计算在分发引擎分配的该线程上进行。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;248:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;分发引擎分配的线程与 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;248:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subscribeTable&lt;/codeph&gt; 函数分配的消息处理线程是两个独立的概念，即分发引擎分配的线程不属于由系统配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:46;248:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;subExecutor&lt;/i&gt; 规定的订阅处理线程。&lt;/li&gt;&lt;/ul&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/streaming_timer/05.png&#34; placement=&#34;break&#34; xtrc=&#34;image:5;250:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34; dita-ot:image-width=&#34;1467&#34; dita-ot:image-height=&#34;798&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:5;250:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;05&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;252:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;252:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;流数据分发引擎的使用注意事项：&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:12;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;建议参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:47;254:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;mode&lt;/i&gt; 使用默认设置 ”buffer”，在 ”buffer”模式下，总是把缓存表里未处理的全部数据进行批量计算，符合 2.3.1 小节建议的微批处理方式。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;在某些情况下，参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:48;255:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;dispatchType&lt;/i&gt; 设置为 “hash” 时，可能因为哈希分配不均匀而造成数据倾斜，即某一个线程上处理的数据量过大而成为性能瓶颈。这时，为了优化性能建议使用 “uniform” 分配模式，其会将 key 均匀分配到各个输出表中。&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:13;256:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;256:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;“hash” 分配规则的效果等同于使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;256:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;hashBucket&lt;/codeph&gt; 函数进行分桶，总的桶数确定后，任意一个 key 值经过哈希取模后总是属于固定的一个桶。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;257:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;“uniform” 分配规则是动态分配的，某一个 key 属于哪一个桶受到达引擎的先后顺序影响，每收到一个新的 key 都依次分配其对应的桶。假设一共分 2 个桶，key 值到来的顺序为 A、B、C，则 A 和 C 属于桶1，B 属于桶2。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;建议分发引擎的线程数不要超过可用的逻辑 CPU 核数，否则频繁的线程切换将会带来一定的开销。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;3. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;本文详细介绍了 DolphinDB 流计算中进行时延统计与性能优化的方法，以期帮助用户更好地分析和优化自己的流计算任务。流计算性能优化的大致思路如下：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:14;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;264:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;首先，确保消息处理线程没有堆积，即消费的速率大于上游数据输入的速率。观察订阅端的消息处理线程监控表（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;264:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;getStreamingStat().subWorkers&lt;/codeph&gt;）中的 queueDepth 数值，使用各种优化手段提高消息处理的效率，以保证队列深度不会出现持续的增长。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/streaming_timer.md&#34;&gt;其次，在订阅队列没有堆积的前提下，可以通过预分配内存来降低时延的峰值，通过优化算子实现和框架来降低时延的均值。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/streaming_timer.md"/><meta name="wh-out-relpath" content="tutorials/streaming_timer.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="流计算时延统计与性能优化" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html">流数据</a></div></div></li><li class="active"><div class="topicref" data-id="流计算时延统计与性能优化"><div class="title"><a href="../tutorials/streaming_timer.html">流计算时延统计与性能优化</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e100449" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="多数据源流式实时关联处理-d9713e100449-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="流数据引擎解析器-d9713e100495" class="topicref" data-id="流数据引擎解析器" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/StreamEngineParser.html" id="流数据引擎解析器-d9713e100495-link">流数据引擎解析器</a></div></div></li><li role="treeitem"><div data-tocid="流数据高可用-d9713e100541" class="topicref" data-id="流数据高可用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haStreaming.html" id="流数据高可用-d9713e100541-link">流数据高可用</a></div></div></li><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e100587" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub_2.html" id="节点启动时的流计算自动订阅-d9713e100587-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎入门初级高频量价因子策略的实现-d9713e100633" class="topicref" data-id="cep-引擎入门初级高频量价因子策略的实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/getting_started_with_cep_engine.html" id="cep-引擎入门初级高频量价因子策略的实现-d9713e100633-link">CEP 引擎入门：初级高频量价因子策略的实现</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679" class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html" id="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679-link">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li><li role="treeitem" class="active"><div data-tocid="流计算时延统计与性能优化-d9713e100725" class="topicref" data-id="流计算时延统计与性能优化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_timer.html" id="流计算时延统计与性能优化-d9713e100725-link">流计算时延统计与性能优化</a></div></div></li><li role="treeitem"><div data-tocid="响应式状态引擎-d9713e100771" class="topicref" data-id="响应式状态引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/reactive_state_engine.html" id="响应式状态引擎-d9713e100771-link">响应式状态引擎</a></div></div></li><li role="treeitem"><div data-tocid="流数据功能应用-d9713e100817" class="topicref" data-id="流数据功能应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_tutorial.html" id="流数据功能应用-d9713e100817-link">流数据功能应用</a></div></div></li><li role="treeitem"><div data-tocid="数据回放-d9713e100863" class="topicref" data-id="数据回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_replay.html" id="数据回放-d9713e100863-link">数据回放</a></div></div></li><li role="treeitem"><div data-tocid="使用-dolphindb-class-来开发流计算状态算子-d9713e100909" class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stateful_stream_operators.html" id="使用-dolphindb-class-来开发流计算状态算子-d9713e100909-link">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">流计算时延统计与性能优化</h1><div class="- topic/body body"><p class="- topic/p p">在实时计算中，端到端的响应延迟是衡量计算性能时最重要的指标。DolphinDB 内置的流数据框架支持流数据的发布与订阅、流式增量计算、实时关联等，用户能够快速实现复杂的实时计算任务，达到毫秒级甚至亚毫秒级的效果，而无需编写大量代码。</p><p class="- topic/p p">本文介绍如何对 DolphinDB 流计算任务进行全链路的时延统计，以及如何优化脚本以实现更低时延的实时计算：</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-耗时统计"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 耗时统计</h2><div class="- topic/body body"><p class="- topic/p p">在关键链路上记录处理的时刻，可以反映流计算各个环节的时延。此外，DolphinDB 流计算引擎本身还内置了耗时统计功能，可提供更详细的耗时情况，帮助进行分析与进一步性能优化。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-使用-now-函数记录数据处理时刻"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1. 使用 now 函数记录数据处理时刻</h3><div class="- topic/body body"><p class="- topic/p p">在数据发布、接收以及计算结果输出时，通过 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数获取当前时刻，并在数据表中记录数据到达各个环节的时刻。示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create engine and subscribe
share streamTable(1:0, `sym`time`qty`SendTime, [STRING, TIME, DOUBLE, NANOTIMESTAMP]) as tickStream
result = table(1000:0, `sym`time`factor1`SendTime`ReceiveTime`HandleTime, [STRING, TIME, DOUBLE, NANOTIMESTAMP, NANOTIMESTAMP, NANOTIMESTAMP])
dummyTable = table(1:0, tickStream.schema().colDefs.name join `ReceiveTime, tickStream.schema().colDefs.typeString join `NANOTIMESTAMP) 
rse = createReactiveStateEngine(name="reactiveDemo", metrics =[&lt;time&gt;, &lt;cumsum(qty)&gt;, &lt;SendTime&gt;, &lt;ReceiveTime&gt;, &lt;now(true)&gt;], dummyTable=dummyTable, outputTable=result, keyColumn="sym")
def addHandleTime(mutable msg){
	update msg set ReceiveTime = now(true)
	getStreamEngine("reactiveDemo").append!(msg) 
}
subscribeTable(tableName="tickStream", actionName="addTimestampDemo", offset=-1, handler=addHandleTime, msgAsTable=true)
// generate input data
data1 = table(take("000001.SZ", 5) as sym, 09:30:00.000 + [0, 1, 5, 6, 7] * 100 as time, take(10, 5) as qty)
data2 = table(take("000002.SZ", 3) as sym, 09:30:00.000 + [2, 3, 8] * 100 as time, take(100, 3) as qty)
data3 = table(take("000003.SZ", 2) as sym, 09:30:00.000 + [4, 9] * 100 as time, take(1000, 2) as qty)
data = data1.unionAll(data2).unionAll(data3).sortBy!(`time)
// insert data into engine
update data set SendTime = now(true)
tickStream.append!(data)</code></pre><p class="- topic/p p">结果表 result 如下，SendTime 是数据注入发布端流数据表的时刻，ReceiveTime 是订阅端接收到输入数据的时刻，HandleTime 是响应式状态引擎进行因子计算结束的时刻。</p><br/><img class="- topic/image image" src="images/streaming_timer/01.png" alt="01"/><br/><p class="- topic/p p">在流计算引擎的 <em class="+ topic/ph hi-d/i ph i">metrics</em> 参数中使用 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数需要注意以下几点：</p><ul class="- topic/ul ul"><li class="- topic/li li">在 <em class="+ topic/ph hi-d/i ph i">metrics</em> 参数中指定最后一个元素为 now()，表示引擎对该条输出结果计算完成的时刻，不包含将计算结果注入输出表的写入耗时。</li><li class="- topic/li li">对于时序聚合引擎、会话窗口引擎等时间窗口聚合引擎(<code class="+ topic/ph pr-d/codeph ph codeph">createTimeSeriesEngine</code>/<code class="+ topic/ph pr-d/codeph ph codeph">createDailyTimeSeriesEngine</code>/<code class="+ topic/ph pr-d/codeph ph codeph">createSessionWindowEngine</code>)，需要注意：<ul class="- topic/ul ul"><li class="- topic/li li">在时间窗口聚合引擎的 <em class="+ topic/ph hi-d/i ph i">metrics</em> 参数中可以直接使用 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数，注意，不要在 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数外层嵌套聚合函数。</li><li class="- topic/li li">在 2.00.10、1.30.23 之前的版本中，若同时触发了多个分组的结果输出（例如 <em class="+ topic/ph hi-d/i ph i">useSystemTime</em>=true ），时间窗口聚合引擎中使用 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数时对每一个分组都依次获取一次当前时刻。在之后的版本中，优化后的时间窗口聚合引擎使用 <code class="+ topic/ph pr-d/codeph ph codeph">now</code> 函数时会对同一批输出的全部分组只获取一次当前时刻。</li></ul></li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-使用-timer-语句快速验证流计算引擎性能"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2. 使用 timer 语句快速验证流计算引擎性能</h3><div class="- topic/body body"><p class="- topic/p p">将一批数据批量注入引擎，通过 <code class="+ topic/ph pr-d/codeph ph codeph">timer</code> 语句统计从数据注入引擎到本批数据全部计算结束的总耗时。本方法适用于在因子开发和优化阶段快速验证引擎的计算性能。具体实践请参考 <a class="- topic/xref xref" href="str_comp_fin_quant.html">金融因子流式实现教程：性能测试</a> ，文中用 <code class="+ topic/ph pr-d/codeph ph codeph">timer</code> 语句比较了同一个因子的 4 种不同的实现对应的性能。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>timer getStreamEngine("reactiveDemo").append!(data)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">timer</code> 语句用于计算一条命令的执行时间。</li><li class="- topic/li li">对引擎进行 append 操作是同步返回的，即 append 语句执行结束时表示这一批数据在引擎里的处理已经全部结束，因此结合 <code class="+ topic/ph pr-d/codeph ph codeph">timer</code> 语法可以统计出这一批数据的总计算耗时。</li><li class="- topic/li li">值得注意的是，使用本方法时，建议注入批量数据来考察总耗时。</li><li class="- topic/li li">若注入少量数据如仅一条数据，则需要考虑输入数据的特征和不同引擎的特性差异。响应式状态引擎由于是逐条触发输出的因此，注入任意一条数据即会触发并输出对应结果条输出，可以反应响应式状态引擎的单次响应时延。但是，若使用时序聚合引擎且选择用非系统事件（<em class="+ topic/ph hi-d/i ph i">useSystemTime</em>=false）触发的话，并不是任意一批数据都会触发输出的，单次响应时延需要注入能够触发输出的那一条特定时间戳的数据来测定。</li></ul><p class="- topic/p p">完整的示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create engine
def sumDiff(x, y) {
	return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sumDiff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sumDiff(ema(price, 20), ema(price, 40)), 20)&gt;
share streamTable(1:0, `sym`time`price, [STRING, TIME, DOUBLE]) as tickStream
result = table(1000:0, `sym`time`factor1, [STRING, TIME, DOUBLE])
rse = createReactiveStateEngine(name="reactiveDemo", metrics =[&lt;time&gt;, factor1], dummyTable=tickStream, outputTable=result, keyColumn="sym")
// generate input data
data1 = table(take("000001.SZ", 100) as sym, 09:30:00 + 1..100 *3 as time, 10+cumsum(rand(0.1, 100)-0.05) as price)
data2 = table(take("000002.SZ", 100) as sym, 09:30:00 + 1..100 *3 as time, 20+cumsum(rand(0.2, 100)-0.1) as price)
data3 = table(take("000003.SZ", 100) as sym, 09:30:00 + 1..100 *3 as time, 30+cumsum(rand(0.3, 100)-0.15) as price)
data.append!(data1.unionAll(data2).unionAll(data3).sortBy!(`time))
// test perfomance
timer getStreamEngine("reactiveDemo").append!(data)</code></pre><p class="- topic/p p">在 GUI 中耗时统计如下：</p><br/><img class="- topic/image image" src="images/streaming_timer/02.png" alt="02"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="13-使用-outputelapsedmicroseconds-参数统计流计算引擎的耗时明细"><h3 class="- topic/title title topictitle3" id="ariaid-title5">1.3. 使用 outputElapsedMicroseconds 参数统计流计算引擎的耗时明细</h3><div class="- topic/body body"><p class="- topic/p p">在 2.00.9、1.30.21 及以上版本中，流计算引擎新增了 <em class="+ topic/ph hi-d/i ph i">outputElapsedMicroseconds</em> 参数，该参数设置为 true 时表示开启对引擎内部计算耗时明细的统计，统计结果将作为两列输出到结果表中。目前支持该参数的引擎包括<code class="+ topic/ph pr-d/codeph ph codeph">createTimeSeriesEngine</code>、<code class="+ topic/ph pr-d/codeph ph codeph">createDailyTimeSeriesEngine</code>、<code class="+ topic/ph pr-d/codeph ph codeph">createReactiveStateEngine</code>、<code class="+ topic/ph pr-d/codeph ph codeph">createWindowJoinEngine</code>。示例脚本如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// create engine
share streamTable(1:0, `sym`time`qty, [STRING, TIME, LONG]) as tickStream
result = table(1000:0, `sym`cost`batchSize`time`factor1`outputTime, [STRING, LONG, INT, TIME, LONG, NANOTIMESTAMP])
rse = createReactiveStateEngine(name="reactiveDemo", metrics =[&lt;time&gt;, &lt;cumsum(qty)&gt;, &lt;now(true)&gt;], dummyTable=tickStream, outputTable=result, keyColumn="sym", outputElapsedMicroseconds=true)
// generate input data
data1 = table(take("000001.SZ", 5) as sym, 09:30:00.000 + [0, 1, 5, 6, 7] * 100 as time, take(10, 5) as qty)
data2 = table(take("000002.SZ", 3) as sym, 09:30:00.000 + [2, 3, 8] * 100 as time, take(100, 3) as qty)
data3 = table(take("000003.SZ", 2) as sym, 09:30:00.000 + [4, 9] * 100 as time, take(1000, 2) as qty)
data = data1.unionAll(data2).unionAll(data3).sortBy!(`time)
// insert data into engine
getStreamEngine("reactiveDemo").append!(data)</code></pre><p class="- topic/p p">结果表 result 如下，cost 列和 batchSize 列为耗时明细，cost 列为引擎内部处理时每一个批次的计算耗时（单位：微秒），batchSize 列为同一批次处理的总记录数。</p><p class="- topic/p p">本例向响应式状态引擎注入了一批共 10 条数据，在引擎内部实际上分为了 5 个小的批次处理， 这是响应式状态引擎的特性和输入数据之间的顺序决定的。在同一个分组内响应式状态引擎逐条处理输入数据，同时，不同分组会放到同一批做向量化处理，因此可以看到，第一条分组列为 000001.SZ 的记录单独是一个批次，之后第二条 000001.SZ 和随后的 000002.SZ 在同一批中进行了计算输出。</p><br/><img class="- topic/image image" src="images/streaming_timer/03.png" alt="03"/><br/><p class="- topic/p p">本次 10 条输入数据注入引擎的总计算耗时：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select sum(cost\batchSize) as totalCost from result</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title6" id="2-性能优化"><h2 class="- topic/title title topictitle2" id="ariaid-title6">2. 性能优化</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 流计算框架中，实时数据首先注入到流数据表中，之后基于发布-订阅-消费模型，由发布端主动推送增量的输入数据至消费端，通过回调的方式在消息处理线程上不断执行指定好的消息处理函数进行计算，并将计算结果再写入到表中。纵观整个计算链路，我们发现可以从写入、计算和框架等三个方面进行流计算任务的性能优化。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="21-写入"><h3 class="- topic/title title topictitle3" id="ariaid-title7">2.1. 写入</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB 流计算框架的核心之一是流数据表，在整个计算链路中往往涉及到多次对流数据表的写入：比如从外部设备或者交易系统等源源不断产生的记录会实时写入流数据表，以作为之后实时计算的输入；此外，流计算引擎的计算结果也需要输出到表中。总之，对表的写入耗时会体现在整体的计算时延上，通过以下方式可以优化写入耗时。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title8" id="211-创建表时预分配内存"><h4 class="- topic/title title topictitle4" id="ariaid-title8">2.1.1. 创建表时预分配内存</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li">普通共享流数据表</li></ul><p class="- topic/p p">创建时指定足够大的 <em class="+ topic/ph hi-d/i ph i">capacity</em> 参数。比如对于股票行情数据可以根据历史数据预估好一天的数据总量，将 <em class="+ topic/ph hi-d/i ph i">capacity</em> 设置为略大于该数值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>capacity = 1000000
share(streamTable(capacity:0, `sym`time`price, [STRING,DATETIME,DOUBLE]), `tickStream)</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">streamTable</code> 函数的 <em class="+ topic/ph hi-d/i ph i">capacity</em> 参数是正整数，表示建表时系统为该表分配的内存（以记录数为单位）。当记录数首次超过 <em class="+ topic/ph hi-d/i ph i">capacity</em> 时，系统会首先分配 <em class="+ topic/ph hi-d/i ph i">capacity</em> 的1.2倍的新的内存空间，然后复制数据到新的内存空间，最后释放原来的内存，再写入新的数据。当记录数继续增加并超过被分配的内存空间时，会再次进行类似的扩容操作。</p><p class="- topic/p p">从时延统计上看，由于扩容涉及到内存分配和复制等较为耗时的操作，因此若某一批数据写入时触发了扩容则会出现一次写入时延的峰值。可以想象，如果 <em class="+ topic/ph hi-d/i ph i">capacity</em> 仅仅设置为 1 ，在持续写入的过程中则会发生多次动态扩容，每次的峰值耗时将随总数据量增加而逐渐增高，因为需要拷贝的数据越来越多。</p><ul class="- topic/ul ul"><li class="- topic/li li">持久化流数据表</li></ul><p class="- topic/p p">创建时指定合理的 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 和 <em class="+ topic/ph hi-d/i ph i">capacity</em> 参数。在内存充足的情况下，对于股票行情数据可以根据历史数据预估好一天的数据总量，将 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 和 <em class="+ topic/ph hi-d/i ph i">capacity</em> 设置为略大于该数值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>cacheSize = 1000000
enableTableShareAndPersistence(table=streamTable(cacheSize:0, `sym`time`price, [STRING,DATETIME,DOUBLE]), tableName="tickStream", asynWrite=true, compress=true, cacheSize=cacheSize, retentionMinutes=1440, flushMode=0, preCache=10000)</code></pre><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">enableTableShareAndPersistence</code> 函数的 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 参数是长整型数据类型（long）的整数，表示该表在内存中最多保留多少行，当内存中的行数超过 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 且确认目前的所有数据都已经保存到磁盘后，系统会申请新的内存空间，将内存中后 50% 的数据拷贝到新的内存空间，并释放掉原来的内存。</p><p class="- topic/p p">从时延统计上看，由于清理内存中的过期数据涉及到内存分配、复制等较为耗时的操作，因此若某一批数据写入时触发了清理则会出现一次写入的时延峰值。若内存充足，则可以考虑设置足够大的 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 将全部数据都保留在内存里，不触发清理操作。若需要进行内存控制，则设置合理 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 以平衡峰值出现的频率和单次峰值的大小，因为 <em class="+ topic/ph hi-d/i ph i">cacheSize</em> 的大小决定了拷贝的数据量进而会影响单次的耗时。</p></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="22-计算"><h3 class="- topic/title title topictitle3" id="ariaid-title9">2.2. 计算</h3><div class="- topic/body body"><p class="- topic/p p">流计算引擎是 DolphinDB 中专门用于处理实时流计算的模块，不同的流计算引擎对应不同的计算场景，如窗口聚合、事件驱动等。创建流计算引擎需要指定 <em class="+ topic/ph hi-d/i ph i">metrics</em> 参数，其为以元代码的形式表示计算公式，引擎的 <em class="+ topic/ph hi-d/i ph i">metrics</em> 为实时指标在 DolphinDB 脚本中的实现。针对不同场景选择合适的流计算引擎后，实现高效的实时指标则是降低流计算时延的关键，因此，本章前三小节介绍在流式指标实现上的优化方法，最后一小节介绍在部分计算场景中不必使用流计算引擎的建议。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="221-内置状态函数与增量计算"><h4 class="- topic/title title topictitle4" id="ariaid-title10">2.2.1. 内置状态函数与增量计算</h4><div class="- topic/body body"><p class="- topic/p p">假设我们接收实时逐笔成交数据，并对每条成交记录逐条响应，累计最新的当日成交总量，如果每一次计算都是用截止当前的全量成交数据，则会响应性能不佳，而通过增量的流式实现则可以大大提升性能。具体的，最新的累计成交总量可以在上一次计算出的成交总量的基础上加上最新的一条成交记录的成交量得到，可以看到，这里的增量计算需要用到历史状态（上一次计算出的成交总量），我们称之为有状态计算。</p><p class="- topic/p p">DolphinDB 在响应式状态引擎、时序聚合引擎、窗口连接引擎中，提供了大量的内置状态函数，在 <em class="+ topic/ph hi-d/i ph i">metrics</em> 中使用内置状态函数即可以实现上述的增量有状态计算，而历史状态由引擎内部自动维护。比如，在响应式状态引擎中使用 <code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code> 函数可以实现增量的累加。</p><p class="- topic/p p">各个引擎已经支持的状态函数请参考用户手册 <code class="+ topic/ph pr-d/codeph ph codeph">createTimeSeriesEngine</code>、 <code class="+ topic/ph pr-d/codeph ph codeph">createReactiveStateEngine</code>、<code class="+ topic/ph pr-d/codeph ph codeph">createWindowJoinEngine</code>，建议优先选择内置状态函数以增量算法实现实时指标。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="222-即时编译-jit"><h4 class="- topic/title title topictitle4" id="ariaid-title11">2.2.2. 即时编译 (JIT)</h4><div class="- topic/body body"><p class="- topic/p p">即时编译 (英文: Just-in-time compilation, 缩写: JIT)，又译及时编译或实时编译，是动态编译的一种形式，可提高程序运行效率。DolphinDB 的编程语言是解释执行，运行程序时首先对程序进行语法分析生成语法树，然后递归执行。在不能使用向量化的情况下，解释成本会比较高。这是由于 DolphinDB 底层由 C++ 实现，脚本中的一次函数调用会转化为多次 C++ 内的虚拟函数调用。JIT 具体介绍请参考 <a class="- topic/xref xref" href="jit.html">DolphinDB JIT 教程</a> 。</p><p class="- topic/p p">流计算任务由于不断地被触发计算，因此会反复地调用函数，以 1.3 小节响应式状态引擎的计算为例，仅仅注入 10 条数据便会触发 5 次对 <em class="+ topic/ph hi-d/i ph i">metrics</em> 中函数的调用。解释耗时也会反应到整体的计算耗时中，尤其对于响应式状态引擎，在某些场景下总计算耗时中可能大部分为解释耗时，因此，建议通过实现 JIT 版本的函数来减少解释成本 。具体实践请参考 <a class="- topic/xref xref" href="jit.html">金融因子流式实现教程：即时编译 (JIT)</a> ，文中使用 JIT 优化了移动平均买卖压力指标的性能。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title12" id="223-数组向量-array-vector"><h4 class="- topic/title title topictitle4" id="ariaid-title12">2.2.3. 数组向量 (array vector)</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 中的数组向量 (array vector) 是一种特殊的向量，用于存储可变长度的二维数组。这种存储方式可以显著简化某些常用的查询与计算。array vector 具体介绍请参考 DolphinDB array vector 教程。</p><br/><img class="- topic/image image" src="images/streaming_timer/04.png" alt="04"/><br/><p class="- topic/p p">十档量价是行情快照中最重要的信息，实现高频因子时为了让十档量价数据能够方便地实现向量化计算，在 DolphinDB 中可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">fixedLengthArrayVector</code> 函数组合十档数据。针对这个特点，建议直接使用数组向量 (array vector) 来存储 level 2 行情快照中的十档量价字段，以省去函数实现过程中组装十档数据的步骤，来降低计算延时。具体实践请参考请参考 <a class="- topic/xref xref" href="Array_Vector.html">金融因子流式实现教程：数组向量 (array vector)</a> ，文中使用 array vector 优化了移动买卖压力指标的性能。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title13" id="224-自定义函数作为-handler-与无状态计算"><h4 class="- topic/title title topictitle4" id="ariaid-title13">2.2.4. 自定义函数作为 handler 与无状态计算</h4><div class="- topic/body body"><p class="- topic/p p">并不是所有的计算都需要通过流计算引擎进行，一些简单的无状态计算建议在自定义函数中实现。比如，下例希望在引擎中仅对 9:30 之后的数据进行计算，则可以在 handler 函数中首先对输入数据进行过滤再注入计算引擎。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def filterTime(msg){
	tmp = select * from msg where time &gt; 09:30:00.000
	getStreamEngine("reactiveDemo").append!(tmp) 
}
subscribeTable(tableName="tickStream", actionName="demo", offset=-1, handler=filterTime, msgAsTable=true)</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">通过多加一层响应式状态引擎也可以实现同样的过滤，但是由于流计算引擎内部计算时进行分组以及维护状态等开销，在这种无状态计算的场景下，自定义函数是比流计算引擎更高效的实现方式。</li><li class="- topic/li li">注意，handler 函数每次处理的是增量的数据，即以上脚本中的 msg 变量是订阅端收到的新增的数据，而不是最新的 tickStream 表的全量快照。</li></ul></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="23-框架"><h3 class="- topic/title title topictitle3" id="ariaid-title14">2.3. 框架</h3><div class="- topic/body body"><p class="- topic/p p">在某些场景下，对单个指标的实现已经优化到了极致，但是由于输入数据流量极大，仍然可能导致系统来不及处理，也会表现为相当大的响应时延。若单位时间内输入数据的流量总是大于系统能够处理的流量，则会看到在订阅端的消息处理线程监控表（<code class="+ topic/ph pr-d/codeph ph codeph">getStreamingStat().subWorkers</code>）中的 queueDepth 数值不断上升，这是流计算任务不健康的表现，需要停止任务并优化。</p><p class="- topic/p p">DolphinDB 流计算任务是通过流数据表、流计算引擎、消息处理线程等不同模块的组合来构建的。流计算任务可以被简单理解为后台线程在反复执行一个计算函数，流计算引擎以及其他自定义函数可以被指定为计算函数，流数据表以发布订阅的方式不断地触发后台线程调用对应的计算函数，每次函数调用的入参是流数据表中新增的一批记录。本小节从搭建流计算任务的框架方面介绍优化方法。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="231-微批处理"><h4 class="- topic/title title topictitle4" id="ariaid-title15">2.3.1. 微批处理</h4><div class="- topic/body body"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 时设置适当的 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数，可以达到微批处理的效果，以此来提升吞吐避免阻塞，进而降低时延。这是基于单次处理的耗时并不是随着单次处理的数据量而线性增长的，最典型的场景是实时写入分布式数据库，一次写入 1000 条数据和写入 10 条数据的耗时可能相差无几，那么发挥数据批处理的性能优势则可以降低整体的时延。</p><p class="- topic/p p"><em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数均表示了触发消费的条件，这两个条件之间是或的关系。订阅队列中的数据积累到 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 设置的量时会触发消费，但是考虑到实际场景中，流量在不同时刻的波动，某些时候可能会长时间达不到 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 而不能被消费，因此需要设置 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数，通过等待达到一定的时长来触发消费，消费会对队列中未处理的全部数据进行处理。 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数建议综合考虑输入数据的流量和数据处理的速度进行调整。</p><p class="- topic/p p">此外，请注意以下两点：</p><ul class="- topic/ul ul"><li class="- topic/li li">修改系统配置项（dolphindb.cfg 或者 cluster.cfg）中 <em class="+ topic/ph hi-d/i ph i">subThrottle</em>=1 后，<em class="+ topic/ph hi-d/i ph i">throttle</em> 才可以被设置为小于1秒。若不修改，则即使在 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 函数中指定 <em class="+ topic/ph hi-d/i ph i">throttle</em> 为 0.001，实际值仍为 1 秒。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 时一定要指定 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数。若不指定，则每次处理的数据量为到达订阅队列的一块数据块的大小，而不是队列里的全部数据。举个例子，假设此时订阅队列里的仍未处理的数据有 10 条，它们分别是以 2 条、3 条、5 条的大小分三批到达订阅队列的，那么消息处理线程会依次分三批处理这 10 条数据，而不是批处理一次。因此，若输入数据频繁插入，但是每次插入的记录数较少，则未设置 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 和 <em class="+ topic/ph hi-d/i ph i">throttle</em> 参数的订阅可能会表现较差。</li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="232-并行计算"><h4 class="- topic/title title topictitle4" id="ariaid-title16">2.3.2. 并行计算</h4><div class="- topic/body body"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 时设置适当的 <em class="+ topic/ph hi-d/i ph i">hash</em> 参数，以提升并行度来降低时延。执行 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 函数相当于为其 <em class="+ topic/ph hi-d/i ph i">handler</em> 参数对应的计算函数分配了一个固定的消息处理线程，合理的分配消息处理线程可以尽可能充分里利用 CPU 资源。大致分为以下两类优化建议：</p><ul class="- topic/ul ul"><li class="- topic/li li">将多个不同的流计算任务指定到不同的处理线程<ul class="- topic/ul ul"><li class="- topic/li li">尽量将不同的任务指定到不同的消息处理线程。假设系统中有 3 个流计算任务，若在提交<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 函数时均指定同一个 <em class="+ topic/ph hi-d/i ph i">hash</em> 值，则它们会被分配到同一个处理线程中，当同时都有新的消息需要处理时会通过轮转的方式执行计算，这种对计算资源的竞争会影响每一个任务的响应时延。</li><li class="- topic/li li">若任务数过多，超过了消息处理线程数量的上限，则建议至少将复杂任务分配到不同的线程，复杂任务指需要长时间占用线程进行计算的任务。</li></ul></li><li class="- topic/li li">将某一个流计算任务拆分到多个线程上并行处理<ul class="- topic/ul ul"><li class="- topic/li li">若输入数据流量过大，一个线程处理不过来，则建议将数据分发到多个线程上并行处理。实现脚本请参考 <a class="- topic/xref xref" href="streaming_tutorial.html#%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86">DolphinDB 流计算教程：并行处理</a> ，注意，若多个线程均将结果写到同一张共享内存表，那么同时写入时会等待写锁而带来一定的耗时，为了避免这部分等待可以将结果也写入到不同的数据表。</li><li class="- topic/li li">使用 <code class="+ topic/ph pr-d/codeph ph codeph">dispatchStreamEngine</code> 进行流数据分发和并行计算，是替代 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 的更轻量级的数据分发方式。</li></ul></li></ul></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title17" id="233-流计算引擎级联"><h4 class="- topic/title title topictitle4" id="ariaid-title17">2.3.3. 流计算引擎级联</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB 中实现复杂计算指标的思路是把指标分解成多个阶段，每一个阶段由一个计算引擎来完成。如果两个引擎之间由一张中间表来承接中间的计算结果，并且由中间表的发布订阅来串联两个引擎，则会存在一定的内存和耗时的开销。因此，DolphinDB 内置的流计算引擎均实现了数据表（table）的接口，允许将后一个引擎作为前一个引擎的输出，称为流计算引擎级联，与通过多个流数据表与多次订阅串联引擎相比，有更好的性能表现。实现脚本请参考 <a class="- topic/xref xref" href="streaming_tutorial.html#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86">DolphinDB 流计算教程：流水线处理</a></p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="234-使用流数据分发引擎进行数据分发"><h4 class="- topic/title title topictitle4" id="ariaid-title18">2.3.4. 使用流数据分发引擎进行数据分发</h4><div class="- topic/body body"><p class="- topic/p p">前文介绍了将某一个流计算任务拆分到多个线程上并行处理的优化建议，但是通过 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 进行发布端过滤并提交多个并行任务的方式，可能会因为订阅的客户端太多而导致发布瓶颈，使得并发处理带来的优化受发布瓶颈的影响而减弱，因为在同一个节点上只有一个发布线程。在 1.30.22、2.00.9 以及之后的版本中，新增了流数据分发引擎（<code class="+ topic/ph pr-d/codeph ph codeph">createStreamDispatchEngine</code>），支持将输入的数据分发到不同的线程，并且在该线程中完成将增量的输入数据注入到对应的输出表的操作，这里的输出表可以指定为流计算引擎。</p><p class="- topic/p p">以下脚本中进行了一次发布订阅，在订阅端的消息处理线程中将数据写入到一个分发引擎中，由该分发引擎将数据按 sym 字段哈希分组后分发到 3 个不同的线程进行实际的计算，计算逻辑由响应式状态引擎定义。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//  create engine
share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream
share streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream
rseArr = array(ANY, 0)
for(i in 0..2){
	rse = createReactiveStateEngine(name="reactiveDemo"+string(i), metrics =&lt;cumavg(price)&gt;, dummyTable=tickStream, outputTable=resultStream, keyColumn="sym")
	rseArr.append!(rse)
}
dispatchEngine=createStreamDispatchEngine(name="dispatchDemo", dummyTable=tickStream, keyColumn=`sym, outputTable=rseArr, mode="buffer", dispatchType="uniform")
//  subscribe
subscribeTable(tableName="tickStream", actionName="dispatch", handler=dispatchEngine, msgAsTable=true)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">流数据分发引擎的原理：</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">分发引擎的参数 <em class="+ topic/ph hi-d/i ph i">outputTable</em> 是一个表（或流计算引擎）组成的列表，创建引擎时会创建与之数量相等的多个线程以及多个缓冲队列（或表）。</li><li class="- topic/li li">引擎内部的每个线程会负责将缓冲队列中的增量数据注入到对应的输出表（或流计算引擎）。若分发引擎输出到流计算引擎，则此时的计算在分发引擎分配的该线程上进行。</li><li class="- topic/li li">分发引擎分配的线程与 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 函数分配的消息处理线程是两个独立的概念，即分发引擎分配的线程不属于由系统配置参数 <em class="+ topic/ph hi-d/i ph i">subExecutor</em> 规定的订阅处理线程。</li></ul><br/><img class="- topic/image image" src="images/streaming_timer/05.png" alt="05"/><br/><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">流数据分发引擎的使用注意事项：</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">建议参数 <em class="+ topic/ph hi-d/i ph i">mode</em> 使用默认设置 ”buffer”，在 ”buffer”模式下，总是把缓存表里未处理的全部数据进行批量计算，符合 2.3.1 小节建议的微批处理方式。</li><li class="- topic/li li">在某些情况下，参数 <em class="+ topic/ph hi-d/i ph i">dispatchType</em> 设置为 “hash” 时，可能因为哈希分配不均匀而造成数据倾斜，即某一个线程上处理的数据量过大而成为性能瓶颈。这时，为了优化性能建议使用 “uniform” 分配模式，其会将 key 均匀分配到各个输出表中。<ul class="- topic/ul ul"><li class="- topic/li li">“hash” 分配规则的效果等同于使用 <code class="+ topic/ph pr-d/codeph ph codeph">hashBucket</code> 函数进行分桶，总的桶数确定后，任意一个 key 值经过哈希取模后总是属于固定的一个桶。</li><li class="- topic/li li">“uniform” 分配规则是动态分配的，某一个 key 属于哪一个桶受到达引擎的先后顺序影响，每收到一个新的 key 都依次分配其对应的桶。假设一共分 2 个桶，key 值到来的顺序为 A、B、C，则 A 和 C 属于桶1，B 属于桶2。</li></ul></li><li class="- topic/li li">建议分发引擎的线程数不要超过可用的逻辑 CPU 核数，否则频繁的线程切换将会带来一定的开销。</li></ul></div></article></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title19" id="3-总结"><h2 class="- topic/title title topictitle2" id="ariaid-title19">3. 总结</h2><div class="- topic/body body"><p class="- topic/p p">本文详细介绍了 DolphinDB 流计算中进行时延统计与性能优化的方法，以期帮助用户更好地分析和优化自己的流计算任务。流计算性能优化的大致思路如下：</p><ul class="- topic/ul ul"><li class="- topic/li li">首先，确保消息处理线程没有堆积，即消费的速率大于上游数据输入的速率。观察订阅端的消息处理线程监控表（<code class="+ topic/ph pr-d/codeph ph codeph">getStreamingStat().subWorkers</code>）中的 queueDepth 数值，使用各种优化手段提高消息处理的效率，以保证队列深度不会出现持续的增长。</li><li class="- topic/li li">其次，在订阅队列没有堆积的前提下，可以通过预分配内存来降低时延的峰值，通过优化算子实现和框架来降低时延的均值。</li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E8%80%97%E6%97%B6%E7%BB%9F%E8%AE%A1" data-tocid="1-耗时统计">1. 耗时统计</a><ul><li class="topic-item"><a href="#11-%E4%BD%BF%E7%94%A8-now-%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%97%B6%E5%88%BB" data-tocid="11-使用-now-函数记录数据处理时刻">1.1. 使用 now 函数记录数据处理时刻</a></li><li class="topic-item"><a href="#12-%E4%BD%BF%E7%94%A8-timer-%E8%AF%AD%E5%8F%A5%E5%BF%AB%E9%80%9F%E9%AA%8C%E8%AF%81%E6%B5%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E6%80%A7%E8%83%BD" data-tocid="12-使用-timer-语句快速验证流计算引擎性能">1.2. 使用 timer 语句快速验证流计算引擎性能</a></li><li class="topic-item"><a href="#13-%E4%BD%BF%E7%94%A8-outputelapsedmicroseconds-%E5%8F%82%E6%95%B0%E7%BB%9F%E8%AE%A1%E6%B5%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E7%9A%84%E8%80%97%E6%97%B6%E6%98%8E%E7%BB%86" data-tocid="13-使用-outputelapsedmicroseconds-参数统计流计算引擎的耗时明细">1.3. 使用 outputElapsedMicroseconds 参数统计流计算引擎的耗时明细</a></li></ul></li><li class="topic-item"><a href="#2-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" data-tocid="2-性能优化">2. 性能优化</a><ul><li class="topic-item"><a href="#21-%E5%86%99%E5%85%A5" data-tocid="21-写入">2.1. 写入</a><ul><li class="topic-item"><a href="#211-%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E9%A2%84%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98" data-tocid="211-创建表时预分配内存">2.1.1. 创建表时预分配内存</a></li></ul></li><li class="topic-item"><a href="#22-%E8%AE%A1%E7%AE%97" data-tocid="22-计算">2.2. 计算</a><ul><li class="topic-item"><a href="#221-%E5%86%85%E7%BD%AE%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A2%9E%E9%87%8F%E8%AE%A1%E7%AE%97" data-tocid="221-内置状态函数与增量计算">2.2.1. 内置状态函数与增量计算</a></li><li class="topic-item"><a href="#222-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91-jit" data-tocid="222-即时编译-jit">2.2.2. 即时编译 (JIT)</a></li><li class="topic-item"><a href="#223-%E6%95%B0%E7%BB%84%E5%90%91%E9%87%8F-array-vector" data-tocid="223-数组向量-array-vector">2.2.3. 数组向量 (array vector)</a></li><li class="topic-item"><a href="#224-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA-handler-%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%A1%E7%AE%97" data-tocid="224-自定义函数作为-handler-与无状态计算">2.2.4. 自定义函数作为 handler 与无状态计算</a></li></ul></li><li class="topic-item"><a href="#23-%E6%A1%86%E6%9E%B6" data-tocid="23-框架">2.3. 框架</a><ul><li class="topic-item"><a href="#231-%E5%BE%AE%E6%89%B9%E5%A4%84%E7%90%86" data-tocid="231-微批处理">2.3.1. 微批处理</a></li><li class="topic-item"><a href="#232-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" data-tocid="232-并行计算">2.3.2. 并行计算</a></li><li class="topic-item"><a href="#233-%E6%B5%81%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E%E7%BA%A7%E8%81%94" data-tocid="233-流计算引擎级联">2.3.3. 流计算引擎级联</a></li><li class="topic-item"><a href="#234-%E4%BD%BF%E7%94%A8%E6%B5%81%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91%E5%BC%95%E6%93%8E%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E5%8F%91" data-tocid="234-使用流数据分发引擎进行数据分发">2.3.4. 使用流数据分发引擎进行数据分发</a></li></ul></li></ul></li><li class="topic-item"><a href="#3-%E6%80%BB%E7%BB%93" data-tocid="3-总结">3. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>