<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="DolphinDB 是一款高性能分布式时序数据库。与传统的关系数据库和常见的时序数据库不同，DolphinDB 不仅提供了高速存取时序数据的基本功能，而且内置了向量化的多范式编程语言与强大的计算引擎。DolphinDB 的计算引擎不仅可以用于量化金融的回测和研发，也可以用于生产环境的实时计算，譬如高频因子的计算。请使用 DolphinDB 1.20.0 或更高版本运行本教程中的例子。 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../stream/str_intro.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="实时计算高频因子"/><title>实时计算高频因子</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;实时计算高频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;实时计算高频因子&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;DolphinDB 是一款高性能分布式时序数据库。与传统的关系数据库和常见的时序数据库不同，DolphinDB 不仅提供了高速存取时序数据的基本功能，而且内置了向量化的多范式编程语言与强大的计算引擎。DolphinDB 的计算引擎不仅可以用于量化金融的回测和研发，也可以用于生产环境的实时计算，譬如高频因子的计算。请使用 DolphinDB 1.20.0 或更高版本运行本教程中的例子。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;运行本教程中的代码例子前，请先根据“本教程中流数据配置”进行流数据系统的配置。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:62;100:82&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../stream/str_intro.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_stream.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;流数据&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 流数据引擎及流数据计算的基本概念&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-概述&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;1. 概述&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;8:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;与其它流计算处理框架类似，DolphinDB 的流计算系统也包括消息发布、消息代理和消息订阅三个部分。消息发布端与消息订阅端均可为本地的数据节点、另一个数据节点，或第三方的 API（例如 Python, C++, Java, C# 等 API）。DolphinDB 数据节点上的流数据表（stream table）充当消息代理的角色，发布端向流数据表插入记录即实现了消息发布的功能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;12:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;高频因子的计算，以交易和报价数据作为主要的流数据输入，亦可配合使用其它数据。高频因子的计算结果通常输出到一个流数据表或内存表。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;14:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;DolphinDB 流计算中使用的消息可以采用两种格式：表（table）和元组（tuple），由&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;14:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;函数的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;14:69&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;msgAsTable&lt;/i&gt; 参数指定。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;本教程中所用的 csv 数据文件，可由&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;https://www.dolphindb.cn/downloads/tutorial/hfFactorsSampleData.zip&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;16:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;?ditaot usertext?&gt;此处&lt;/xref&gt;下载，并存于文件夹 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;16:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;YOURDIR&lt;/i&gt; 中。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-无状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;2. 无状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;所谓无状态因子计算，即因子的计算不需要回溯历史数据，仅根据最新的一条消息即可生成因子。无状态因子计算场景下，建议使用表作为消息的格式，并使用 SQL 语句计算因子。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;假设消息数据表包含以下列：symbol, date, time, askPrice1..askPrice5, bidPrice1..bidPrice5, askVolume1..askVolume5, bidVolume1..bidVolume5。其中 askPrice1..askPrice5 以及 askVolume1..askVolume5 为前5档卖方出价以及对应的量；bidPrice1..bidPrice5 以及 bidVolume1..bidVolume5 为前5档买方出价以及对应的量。计算以下两个状态因子：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;因子1：根据每一条最新报价，计算因子 (askVolume1-bidVolume1)/(askVolume1+bidVolume1)。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;因子2：对买档与卖档，分别计算最新5挡成交量加权累计之和，然后计算两者之比例。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;上述无状态因子，可分别使用以下脚本计算：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;29:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;29:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;29:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;因子1：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;31:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt; select symbol,time(now()) as time, (askVolume1-bidVolume1)/(askVolume1+bidVolume1) as factorValue from msg&lt;/codeblock&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;34:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;因子2：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;36:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt; w = exp(-1 * 0..4) select symbol, time(now()) as time, 0.5*log(rowSum([bidVolume1,bidVolume2,bidVolume3,bidVolume4,bidVolume5]*w)/rowSum([askVolume1,askVolume2,askVolume3,askVolume4,askVolume5]*w)) as factorValue from msg&lt;/codeblock&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;41:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;要实时计算上述无状态因子，把上述脚本封装成函数并在&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;41:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;函数中指定其为 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;41:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;handler&lt;/i&gt; 参数（消息处理函数）即可。消息处理函数必须是单目函数，且唯一的参数就是本批次订阅到的消息。以因子2为例:&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;42:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;quotesData = loadText(yourDIR + &#34;sampleQuotes.csv&#34;) def factorHandler(mutable factor1, msg){ w = exp(-1 * 0..4) x=select symbol, datetime(now()) as datetime, 0.5*log(rowSum([bidVolume1,bidVolume2,bidVolume3,bidVolume4,bidVolume5]*w)/rowSum([askVolume1,askVolume2,askVolume3,askVolume4,askVolume5]*w)) as factorValue from msg factor1.tableInsert(x) } share table(1000000:0, `symbol`datetime`factorValue, [SYMBOL,DATETIME,DOUBLE]) as factor1 x=quotesData.schema().colDefs share(streamTable(1000000:0, x.name, x.typeString), &#34;quotes&#34;) subscribeTable(tableName=&#34;quotes&#34;, actionName=&#34;hfFactor&#34;, handler=factorHandler{factor1}, msgAsTable=true) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;然后使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;57:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;replay&lt;/codeph&gt;函数将样本数据 quotesData 写入流数据表 quotes 触发计算。本教程的所有例子均使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;57:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;replay&lt;/codeph&gt;函数将历史数据进行回放以模拟实时数据。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;replay(inputTables=quotesData, outputTables=quotes, dateColumn=`date, timeColumn=`time)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;最后在数据表 factor1 中查看计算结果。本例计算结果中的时间为计算发生时间，也可以根据业务要求调整为数据时间，即直接取消息中的 date 与 time 列。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-滑动窗口因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;3. 滑动窗口因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;流数据计算中，有一类典型的计算是根据滑动的时间窗口计算聚合值，连续的两个窗口可以重叠或不重叠。这类计算统称为滑动窗口计算。DolphinDB 内置的时间序列聚合引擎用于解决滑动窗口计算。DolphinDB 针对某些聚合函数在流数据时序引擎中的使用进行了优化，在计算每个窗口时充分利用上一个窗口的计算结果，尽可能避免重复计算，显著提高运行速度。已优化的聚合函数包括：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;65:183&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;sum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;65:190&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;sum2&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;65:198&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;min&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;65:205&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;max&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;65:212&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;first&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;65:221&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;last&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;65:229&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;avg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;65:236&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;count&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;65:245&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;std&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;65:252&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;var&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;65:259&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;med&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;65:266&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;percentile&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;65:280&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;covar&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;65:289&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;corr&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;65:297&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;beta&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;65:305&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;wavg&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;65:313&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;wsum&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;65:321&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;prod&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;65:329&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;rank&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;65:337&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;stdp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;65:345&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;varp&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;65:353&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;kurtosis&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;65:365&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;skew&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;65:373&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;ifirstNot&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;65:386&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;ilastNot&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;65:398&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;imax&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;65:406&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;imin&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;65:414&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;mad&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;65:421&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;maxPositiveStreak&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;65:442&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;se&lt;/codeph&gt;, &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;65:448&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;slr&lt;/codeph&gt;。聚合引擎可以接受的指标除了单个聚合函数使用消息中的一个或两个列作为参数外，还可以进行两个方向的扩展：（1）多个聚合函数构成新的表达式；（2）聚合函数的参数可以是消息中多个字段的表达式。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;下例使用时间序列聚合引擎计算分钟级K线。Trade 表是一个流数据表，这里为了方便，假定 Trade 表与订阅端在同一个节点上。实际使用中，两者也可处于不同的节点。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;68:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;tradesData = loadText(yourDIR + &#34;sampleTrades1.csv&#34;) //定义流数据表Trade x=tradesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as Trade //定义OHLC输出表 share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC //定义实时聚合引擎：每分钟计算过去5分钟K线 tsAggrOHLC = createTimeSeriesAggregator(name=&#34;aggr_ohlc&#34;, windowSize=300000, step=60000, metrics=&amp;lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&amp;gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol) //订阅流数据写入聚合引擎 subscribeTable(tableName=&#34;Trade&#34;, actionName=&#34;minuteOHLC1&#34;, offset=0, handler=append!{tsAggrOHLC}, msgAsTable=true) replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;87:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from OHLC&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;上面的例子中，流数据表 Trade 的消息直接作为聚合引擎的输入。某些场景下，需要对流数据表中的数据进行预处理后再输入到聚合引擎。若 Trade 表中的 Volume 是从开盘到当前的累计交易量，下例中定义函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;90:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;calcVolume&lt;/codeph&gt;作为数据订阅的消息处理函数（即 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;90:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;handler&lt;/i&gt; 参数），将累计交易量转化为当前交易量之后，再输入聚合引擎。使用字典 dictVol 保存每只股票上一条消息中的累计交易量，以计算当前交易量。由于若 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;90:218&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;handler&lt;/i&gt; 参数是函数时，必须仅有一个参数，即本批次订阅到的消息，所以&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;90:257&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;calcVolume&lt;/codeph&gt;必须包括 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;90:274&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;msg&lt;/i&gt; 这样一个代表本批次订阅数据的参数，且在&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;90:299&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;函数中使用时，使用“部分应用”将其它参数固化。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;def calcVolume(mutable dictVolume, mutable tsAggrOHLC, msg){ t = select Symbol, DateTime, Price, Volume from msg context by Symbol limit -1 update t set prevVolume = dictVolume[Symbol] dictVolume[t.Symbol] = t.Volume tsAggrOHLC.append!(t.update!(&#34;Volume&#34;, &amp;lt;Volume - prevVolume&amp;gt;).dropColumns!(&#34;prevVolume&#34;)) } tradesData = loadText(yourDIR + &#34;sampleTrades2.csv&#34;) //定义流数据表Trade x=tradesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as Trade //定义OHLC输出表 share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC //定义实时聚合引擎：每分钟计算过去5分钟K线 tsAggrOHLC = createTimeSeriesAggregator(name=&#34;aggr_ohlc&#34;, windowSize=300000, step=60000, metrics=&amp;lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&amp;gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol) //订阅流数据写入聚合引擎 dictVol = dict(STRING, DOUBLE) subscribeTable(tableName=&#34;Trade&#34;, actionName=&#34;minuteOHLC2&#34;, offset=0, handler=calcVolume{dictVol,tsAggrOHLC}, msgAsTable=true) replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;117:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;最后查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;118:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from OHLC &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;121:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;响应式状态引擎支持一部分优化过的序列处理函数，因此除了通过定义函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;121:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;calcVolume&lt;/codeph&gt;来将累计交易量转化为当前交易量以外，可以通过响应式状态引擎和时间序列聚合引擎串联来实现同样的效果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;123:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;tradesData = loadText(yourDIR + &#34;sampleTrades2.csv&#34;) //定义流数据表Trade x=tradesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as Trade //定义OHLC输出表 share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC //定义实时聚合引擎：每分钟计算过去5分钟K线 tsAggrOHLC = createTimeSeriesAggregator(name=&#34;aggr_ohlc&#34;, windowSize=300000, step=60000, metrics=&amp;lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&amp;gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol) //定义响应式状态引擎：预处理Volume数据 rsAggrOHLC = createReactiveStateEngine(name=&#34;calc_vol&#34;, metrics=&amp;lt;[Datetime, Price, deltas(Volume)]&amp;gt;, dummyTable=Trade, outputTable=tsAggrOHLC, keyColumn=`Symbol) //订阅流数据写入聚合引擎 subscribeTable(tableName=&#34;Trade&#34;, actionName=&#34;minuteOHLC2&#34;, offset=0, handler=append!{rsAggrOHLC}, msgAsTable=true) replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;145:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;最后查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;147:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from OHLC &lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;4. 状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;151:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;153:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;有状态的因子，即因子的计算不仅用到当前数据，还会用到历史数据。实现状态因子的计算，一般包括这几个步骤：（1）保存本批次的消息数据到历史记录；（2）根据更新后的历史记录，计算因子，（3）将因子计算结果写入输出表中。如有必要，删除未来不再需要的的历史记录。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;由于 DolphinDB 的消息处理函数必须是单目函数，且唯一的参数就是当前的消息。要保存历史状态并且可以在消息处理函数中引用它，可以使用部分应用，定义一个多个参数的消息处理函数，其中一个参数用于接收消息，其它所有参数被固化，用于保存历史状态。这些固化参数只对消息处理函数可见，不受其他应用的影响。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;历史状态可保存在内存表，字典或分区内存表中。本节的三个例子分别演示如何使用这三种方法来保存历史状态并计算因子。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-使用内存表计算状态因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;4.1. 使用内存表计算状态因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;本例中因子为当前第一档卖价与30个报价之前的第一档卖价的比值。因此，对于每只股票，至少需要保留30个历史报价。为此，可以定义一个内存表 history 用于保存所有股票的历史状态。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;核心代码如下所示。其中，自定义聚合函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;163:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorAskPriceRatio&lt;/codeph&gt;用于计算因子。消息处理函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;163:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;中：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;第一行将本批次消息保存到内存表 history 中。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;第二行用于提取本批次消息的股票代码。每次计算仅针对本批次消息所包含的股票。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;第三行计算每只股票的因子。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;最后一行将生成的因子输出到 factors 表中。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;169:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;消息订阅函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;169:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;的核心参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;169:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;handler&lt;/i&gt; 是&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;169:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;的一个部分应用，其中两个固定的参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;169:73&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;history&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;169:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factors&lt;/i&gt; 分别用于保存历史状态和输出生成的因子。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;quotesData = loadText(yourDIR + &#34;sampleQuotes.csv&#34;) defg factorAskPriceRatio(x){ cnt = x.size() if(cnt &amp;lt; 31) return double() else return x[cnt - 1]/x[cnt - 31] } def factorHandler(mutable history, mutable factors, msg){ history.append!(select symbol, askPrice1 from msg) syms = msg.symbol t = select factorAskPriceRatio(askPrice1) as factor from history where symbol in syms group by symbol factors.append!(t.update!(&#34;timestamp&#34;, now()).reorderColumns!(&#34;timestamp&#34;)) } x=quotesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as quotes1 history = table(1000000:0, `symbol`askPrice1, [SYMBOL,DOUBLE]) share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors subscribeTable(tableName = &#34;quotes1&#34;, offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize = 3000, throttle=0.005) replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;194:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;195:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from factors where isValid(factor)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-基于分区内存表的状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;4.2. 基于分区内存表的状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;使用普通内存表计算因子，是单线程操作，不能并行计算。使用分区内存表计算因子，可以并行计算以提高效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;对内存表执行 SQL 语句时，只有一个子任务。对分区内存表执行 SQL 语句时，会产生与分区数量一致的子任务，由当前的流数据执行线程和系统的执行线程池来完成。系统的线程池的大小由配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;202:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;workerNum&lt;/i&gt; 决定。因此执行一个分区内存表的SQL语句，在分区数量大于 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;202:136&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;workerNum&lt;/i&gt; 的情况下，最大的并行度是 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;202:161&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;workerNum&lt;/i&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;内存表与分区内存表在数据插入和SQL查询方面，大部分情况下没有语法上的区别。因此“使用内存表计算有状态因子”一节中的代码仍然适用于分区内存表。唯一需要修改的是 history 表的创建和初始化。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;history_model = table(1000000:0, `symbol`askPrice1, [SYMBOL,DOUBLE]) syms = format(600000..601000, &#34;000000&#34;) db = database(partitionType=VALUE, partitionScheme=syms) history = db.createPartitionedTable(table=history_model, tableName=`history, partitionColumns=`symbol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;注意&lt;/b&gt;：syms 仅包括样本数据中的 1001 个股票代码。实际使用时请根据具体情况进行调整。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;当分区内存表的分区机制是值分区，而且因子比较简单时，除了使用 SQL 语句，亦可直接在每个分区中计算因子。在大量的小表上使用 SQL 的成本较高，直接在每个分区中进行计算可能提高效率。下面的代码中改写了&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;213:102&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;的定义。通过系统内置函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;213:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;getTablet&lt;/codeph&gt;获取消息中所有股票对应的分区子表，然后循环计算每只股票的因子，最后把因子写入 factors 表中。该计算方案虽然实际上使用了单线程，但是耗时却只有 SQL 方案的三分之一左右。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;214:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;def factorHandler(mutable history, mutable factors, msg){ history.append!(select symbol, askPrice1 from msg) syms = msg.symbol tables = getTablet(history, syms) cnt = syms.size() v = array(DOUBLE, cnt) for(i in 0:cnt){ v[i] = factorAskPriceRatio(tables[i].askPrice1) } factors.tableInsert([take(now(), cnt), syms, v]) }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;43-基于字典的状态因子计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;4.3. 基于字典的状态因子计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;创建一个键值为 STRING 类型，值为元组（tuple）类型的字典。该字典中，每只股票对应一个数组，以存储卖价的历史数据。使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;230:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;dictUpdate!&lt;/codeph&gt;函数更新该字典，然后循环计算每只股票的因子。由于每只股票的历史数据分别存储，计算因子时不再需要对数据分组，因而有更高的效率。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;231:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;defg factorAskPriceRatio(x){ cnt = x.size() if(cnt &amp;lt; 31) return double() else return x[cnt - 1]/x[cnt - 31] } def factorHandler(mutable historyDict, mutable factors, msg){ historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&amp;gt;array(x.type(), 0, 512).append!(x)) syms = msg.symbol.distinct() cnt = syms.size() v = array(DOUBLE, cnt) for(i in 0:cnt){ v[i] = factorAskPriceRatio(historyDict[syms[i]]) } factors.tableInsert([take(now(), cnt), syms, v]) } x=quotesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as quotes1 history = dict(STRING, ANY) share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors subscribeTable(tableName = &#34;quotes1&#34;, offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize=3000, throttle=0.005) replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from factors where isValid(factor)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;这三种方法各有优缺点。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;内存表简单易用，计算可以使用简单的 SQL 语句完成，缺点是计算性能较低，尤其是每只股票的消息单独处理时，性能尤为低下。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;262:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;字典方法的数据结构最为简单，当因子较为简单时，无论大量股票批量处理，还是每只股票单独处理，效率均为最高。字典方法的缺点是如果因子计算较为复杂时，逐个处理的效率不高。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;分区内存表方法居于两者之间。可以使用 SQL 语句来完成复杂或简单的因子计算，但与未分区的内存表相比，可以通过分区来实现并行计算，以提高效率。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-因子计算流水线&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;5. 因子计算流水线&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;267:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;一些较为复杂的因子可能需要使用流水线处理（或者链式处理）。一种常见场景为：先根据输入的行情数据使用时间序列聚合引擎生成分钟级K线，然后根据分钟级K线生成状态因子。可将消息处理函数的输出指向另一个流数据表，以实现流水线处理。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;269:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;下例演示因子计算的流水线处理。首先计算每只股票分钟级的K线，然后根据最近的10个K线记录计算前面5个时间段的资金净流入量与后面5个时间段的资金净流入量的比例。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;271:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;tradesData = loadText(yourDIR + &#34;sampleTrades1.csv&#34;) defg factorMoneyFlowRatio(x){ n = x.size() if(n &amp;lt; 9) return double() else return x.subarray((n-9):(n-5)).sum()\x.subarray((n-4):n).sum() } def factorHandler2(mutable historyDict, mutable factors, msg){ netAmount = exec volume * iif(close&amp;gt;=open, 1, -1) from msg dictUpdate!(historyDict, append!, msg.symbol, netAmount, x-&amp;gt;array(x.type(), 0, 500).append!(x)) syms = msg.symbol.distinct() cnt = syms.size() v = array(DOUBLE, cnt) for(i in 0:cnt){ v[i] = factorMoneyFlowRatio(historyDict[syms[i]]) } factors.tableInsert([take(now(), cnt), syms, v]) } //定义流数据表Trade x=tradesData.schema().colDefs share streamTable(100:0, x.name, x.typeString) as Trade //定义OHLC输出表 share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC //定义实时聚合引擎：每分钟计算过去1分钟K线 tsAggrOHLC = createTimeSeriesAggregator(name=&#34;aggr_ohlc&#34;, windowSize=60000, step=60000, metrics=&amp;lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&amp;gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol) //订阅流数据写入聚合引擎 subscribeTable(tableName=&#34;Trade&#34;, actionName=&#34;minuteOHLC3&#34;, offset=0, handler=append!{tsAggrOHLC}, msgAsTable=true) //订阅流数据表OHLC，计算指标，并输出到流数据表factors dictHistory = dict(STRING, ANY) share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors subscribeTable(tableName=&#34;OHLC&#34;, actionName=&#34;calcMoneyFlowRatio&#34;, offset=0, handler=factorHandler2{dictHistory,factors}, msgAsTable=true) replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;312:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;查看结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;313:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;select top 10 * from factors where isValid(factor)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;316:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;使用流水线计算因子时，需要合理安排消息的执行线程。最理想的情况是每一个环节由不同的线程来完成，以降低延迟。流数据消息的默认执行模式是为每一个线程分配一个消息队列，订阅的消息进入了不同的队列，就由相应的线程来执行。那如何为一个订阅指定执行线程或队列呢？可以使用函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;316:132&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;的可选参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;316:154&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;hash&lt;/i&gt; 。如果订阅的执行线程总数为N，那么分配的线程序号（从0开始）为 N 除以 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:14;316:198&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;hash&lt;/i&gt; 的余数。订阅的执行线程总数可以通过配置变量 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:15;316:227&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subExecutors&lt;/i&gt; 来设置，默认值为1。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-提高计算效率的方法&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6. 提高计算效率的方法&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-使用字典或分区内存表分组存储数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.1. 使用字典或分区内存表分组存储数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;323:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;实时计算时，通常需要对每只股票分别计算。如果事先按股票分组存储数据，可显著缩短计算耗时。分组存储可使用字典和分区内存表这两种方法。我们测试了“有状态因子计算”章节中提到的三种方法，假定4000个股票，每个股票有300条历史记录，4000条消息（每个股票1条）的批量处理时间（包括数据插入，因子计算和因子结果插入）分别为180毫秒（内存表），32毫秒（分区内存表）和20毫秒（字典）。可见字典和分区内存表可显著提升因子计算效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;325:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;使用字典或分区内存表分组存储数据有可能遇到两个问题。第一个问题关于新股。初始化的时候没有考虑到后续出现的股票，但是日内流计算的时候出现了新的股票。若使用字典，只需在使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;325:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;dictUpdate!&lt;/codeph&gt;函数时指定初始化函数参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:16;325:111&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;initFunc&lt;/i&gt; 即可。如“基于字典的有状态因子计算”小节的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;325:143&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;定义中，可使用字典值的初始化函数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;x-&amp;gt;array(x.type(), 0, 512).append!(x)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;这是一个单目的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;329:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;lambda&lt;/codeph&gt;函数，当输入为标量或向量时，创建一个新的向量，预先分配512个元素的内存，然后将当前值扩展到新创建的数组中，最后返回这个数组。如果使用值分区的内存表，创建之后不允许动态增加分区。如果出现新股票数据，这部分数据无法插入分区内存表，也不会报异常。这种情况下，若要处理当天开始交易的新股票，只能每天交易开始前初始化流数据系统。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;第二个问题是根据多个字段分组。目前字典的键值和分区内存表的分区尚不支持组合字段，解决的办法是将多个字段拼接成单个字符串字段。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62-平衡延时和吞吐量&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.2. 平衡延时和吞吐量&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;334:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;众所周知，在其它条件给定的情况下，延时和吞吐是一对矛盾。高频因子实时计算追求消息处理的低延迟，但是如果逐条处理消息，会降低整体的吞吐量。在实践中，可以找到一个延时和吞吐量之间的平衡点。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;336:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;函数提供了两个可选参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:17;336:121&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;throttle&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:18;336:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;batchSize&lt;/i&gt; ，用于调节延时和吞吐量。 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:19;336:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;throttle&lt;/i&gt; 为每个消息批次处理之前最长等待时间，单位为秒，最短可设为1毫秒，用0.001表示。 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:20;336:212&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;batchSize&lt;/i&gt; 为每个消息批次处理之前最多的消息条数。当 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:21;336:245&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;throttle&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:22;336:258&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;batchSize&lt;/i&gt; 两个条件中有一个满足时，系统就会把尚未处理的消息合并成一个表或元组（根据参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:23;336:309&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;msgAsTable&lt;/i&gt; 的设定），发送到任务队列，由&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;336:336&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;函数指定的message handler来处理。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;63-并行计算&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.3. 并行计算&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;338:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;340:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;并行计算可提升系统的吞吐量，单位时间内处理更多的消息。流计算使用并行计算可分为两种情况：使用订阅系统的线程和使用 DolphinDB 进程全局的执行线程。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;631-使用订阅系统的线程池&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.3.1. 使用订阅系统的线程池&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;342:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;通过配置变量 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:24;344:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subExecutors&lt;/i&gt; ，可以指定一定数量的线程来处理订阅的消息。默认的线程数量是1个，也即所有订阅的消息都是通过这个线程来处理。当订阅线程有多个时，如何并行处理消息又有两种方式。默认的方式是按订阅来分配线程，一个订阅分配给一个线程，一个线程可以处理多个订阅。如果需要精确指定哪个线程来处理哪个订阅，可以在&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;344:164&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subscribeTable&lt;/codeph&gt;中指定 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:25;344:184&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;hash&lt;/i&gt; 参数。这种方式的优点是一个订阅的消息处理函数只被一个线程执行，不存在线程安全的问题，也不存在线程同步的问题，有很高的效率。缺点是如果各个订阅的消息数量和处理复杂度极不平衡，那么某些订阅会成为瓶颈。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;346:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;订阅线程的另一种使用模式是线程池模式。在线程池模式下，所有的消息处理任务都进入同一个队列，随机分配给空闲的线程去执行。因此，同一个订阅的消息处理函数可能同时被多个线程执行，必须确保：（1）消息处理函数是线程安全的，（2）各个消息的处理在业务上是独立的。DolphinDB 的所有数据结构中，只有同步字典（synchronized dictionary）和共享表（shared table）是线程安全的。如果某个数据结构可能被多个线程并发读写，必须选择上述同步字典或共享表。要启用线程池模式，需将配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:26;346:253&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subExecutorPooling&lt;/i&gt; 设置为true。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;632-使用全局的线程池&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.3.2. 使用全局的线程池&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;在消息处理函数内部，如果要处理的股票比较多或者要计算的因子比较多，通过任务分解和多线程并行可以缩短处理时间。多线程并行使用当前的订阅线程和 DolphinDB 进程全局的线程池。全局的线程池通过配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:27;350:103&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;workerNum&lt;/i&gt; 设置。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;下例对&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;352:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;进行并行计算改造，将因子计算和写入 factors 表这两个步骤封装到了一个内嵌函数中，并按照要处理的股票来进行任务划分。如果股票数目小于400，在一个任务中完成，否则分成2个任务来完成。原先4000个股票计算一次耗时约20ms，两个任务并行后耗时13ms左右。使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;352:152&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;cut&lt;/codeph&gt;函数将股票切割为多个部分，并用高阶函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;352:176&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;ploop&lt;/codeph&gt;实现多任务的并行。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;def factorHandler(mutable historyDict, mutable factors, msg){ historyDict.dictUpdate!(append!, msg.symbol, msg.ap, x-&amp;gt;array(x.type(), 0, 512).append!(x)) syms = msg.symbol.distinct() cnt = syms.size() f = def(syms, d, mutable factors){ cnt = syms.size() signals = array(DOUBLE, cnt) for(i in 0:cnt) signals[i] = factorAskPriceRatio(d[syms[i]]) factors.tableInsert([take(now(), cnt), syms, signals]) } if(cnt &amp;lt; 400) f(syms, historyDict, factors) else ploop(f{,historyDict, factors}, syms.cut(ceil(cnt/2.0))) }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;64-即时编译&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;6.4. 即时编译&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;369:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;消息处理函数若逻辑较复杂，需要用到&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;371:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;for&lt;/codeph&gt;循环，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;371:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;while&lt;/codeph&gt;循环和&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;371:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;if-else&lt;/codeph&gt;等语句，无法使用向量化运算但又对运行速度有极高要求，可使用 DolphinDB 中的即时编译（JIT）功能，以显著提升性能。关于即时编译功能的更多介绍，请参考&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;jit.md&#34; xtrc=&#34;xref:2;371:124&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB即时编译教程&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;373:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;下例中的因子，在每行数据中，需要使用前5档的报价及对应的盘口数据进行计算，且根据设定条件进行更进一步的计算。这个过 程无法向量化运算，可使用即时编译以提升性能。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;@jit def sum_diff(x, y){ return 1.0 * (x-y)/(x+y) } @jit def wbvol(bp, bv, price, jump) { return exp(0.6*(bp-price)/jump) * bv } @jit def wavol(ap, av, price, jump) { return exp(0.6 * (price - ap)/jump) * av } @jit def factor1(ap1, ap2, ap3, ap4, ap5, av1, av2, av3, av4, av5, bp1, bp2, bp3, bp4, bp5, bv1, bv2, bv3, bv4, bv5, mp, initMP, delta){ n = ap1.size() re = array(DOUBLE, n) for(i in 0:n){ jump = ceil(initMP[i] * 15.0 / 100.0) / 100.0 w_av1 = 0.0 w_bv1 = 0.0 w_av1 = wavol(ap1[i], av1[i], mp[i], jump) + wavol(ap2[i], av2[i], mp[i], jump) + wavol(ap3[i], av3[i], mp[i], jump) + wavol(ap4[i], av4[i], mp[i], jump) + wavol(ap5[i], av5[i], mp[i], jump) w_bv1 = wbvol(bp1[i], bv1[i], mp[i], jump) + wbvol(bp2[i], bv2[i], mp[i], jump) + wbvol(bp3[i], bv3[i], mp[i], jump) + wbvol(bp4[i], bv4[i], mp[i],jump) + wbvol(bp5[i], bv5[i], mp[i], jump) if(delta[i]&amp;gt;0){ re[i] = sum_diff(w_bv1*1.1, w_av1) }else{ re[i] = sum_diff(w_bv1, w_av1 * 1.1) } } return re } //---------------------------------------------------------订阅处理函数----------------------------------------------------- def factor1_handler(mutable d, mutable factor, msg){ start = now(true) n = msg.size() mp = (msg.bidPrice1+msg.askPrice1)/2 dictUpdate!(d,append!, msg.symbol, mp) delta = array(DOUBLE, n) initMP = array(DOUBLE, n) sym = msg.symbol for(i in 0:n){ &amp;amp;his_mp = d[sym[i]] initMP[i] = his_mp[0] delta[i] = nullFill(his_mp.tail()-his_mp.tail(5).avg(), 0) } factorValue = factor1(msg.askPrice1, msg.askPrice2, msg.askPrice3, msg.askPrice4, msg.askPrice5, msg.askVolume1, msg.askVolume2, msg.askVolume3, msg.askVolume4, msg.askVolume5, msg.bidPrice1, msg.bidPrice2, msg.bidPrice3, msg.bidPrice4, msg.bidPrice5, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, mp, initMP, delta) factor.tableInsert(take(start,n), take(now(true), n), sym, take(&#34;factor1&#34;, n), factorValue) } def clear(){ try{ unsubscribeTable(, `Trade, `act_factor) undef(`Trade, SHARED) undef(`factor_result, SHARED) }catch(ex){} } login(&#34;admin&#34;,&#34;123456&#34;) clear() go quotesData = loadText(yourDIR + &#34;sampleQuotes.csv&#34;) x=quotesData.schema().colDefs share(streamTable(1000000:0, x.name, x.typeString), &#34;quotes&#34;) d = dict(STRING, ANY) for(id in quotesData[`symbol].distinct()) d[id]= array(DOUBLE,0,0) dictUpdate!(d,append!, quotesData.symbol, (quotesData.bidPrice1+quotesData.askPrice1)/2) share streamTable(100:0,`starttime`endtime`symbol`factorName`orderbook_factor_15, [LONG,LONG,SYMBOL,SYMBOL,DOUBLE]) as factor_result subscribeTable(tableName=&#34;quotes&#34;, actionName=&#34;act_factor&#34;, offset=-1, handler=factor1_handler{d, factor_result}, msgAsTable=true); replay(inputTables=quotesData, outputTables=quotes, dateColumn=`date, timeColumn=`time)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-流计算调试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;7. 流计算调试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;455:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;71-调试消息处理函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;7.1. 调试消息处理函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;457:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;459:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;消息处理函数是流计算的核心。调试消息处理函数通常有两种方法：（1）单独调试消息处理函数；（2）在函数中打印日志。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;461:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;消息处理函数的核心输入是消息。消息在 DolphinDB 中的两种形式是 table 或 tuple。只要构造消息，就可以调试消息处理函数。如果消息处理函数比较复杂，希望单行执行，一个推荐的做法是，构造与函数参数相同名称的变量，然后逐条运行消息处理函数体内的语句。以“基于字典的有状态因子计算”中的&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;461:150&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factorHandler&lt;/codeph&gt;函数为例，可以构造三个变量 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:28;461:179&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;historyDict&lt;/i&gt; ，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:29;461:194&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;factors&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:30;461:206&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;msg&lt;/i&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;462:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;k=4000 syms = string(1..k) n = 1200000 min_history = table(take(syms, n) as symbol, rand(10.0, n) as ap) msg = table(string(1..k) as symbol, rand(10.0, k) as ap) historyDict = dict(STRING, ANY) historyDict.dictUpdate!(append!, min_history.symbol, min_history.ap, x-&amp;gt;array(x.type(), 0, 512).append!(x)) factors = streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;473:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;另一个方法是在消息函数中打印日志，可通过函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;473:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;writeLog&lt;/codeph&gt;实现。从 DolphinDB server 的系统日志中，能够看到 writeLog 输出的日志。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;72-历史数据回测&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;475:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;475:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;7.2. 历史数据回测&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;475:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;477:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;本教程中使用了少量数据。在投入 production 前，建议使用大量真实的历史数据，来回测消息处理函数，这有助于发现程序逻辑，业务逻辑，以及系统性能方面的问题。DolphinDB 提供了函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;477:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;replay&lt;/codeph&gt;与&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;477:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;replayDS&lt;/codeph&gt;以回放历史数据库中的tick数据。请参考用户手册以获取更多信息。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;8-本教程中流数据配置&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;8. 本教程中流数据配置&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;481:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;本教程中使用了单机模式的 DolphinDB Server。配置文件（dolphindb.cfg）的内容如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;482:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;mode=single workerNum=4 maxPubConnections=8 subPort=20001 persistenceDir=dbCache subThrottle=1 subExecutors=2&lt;/codeblock&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;492:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;492:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;单机模式下，本节点既是发布端又是订阅端。作为发布端的必需参数是 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:31;492:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;maxPubConnections&lt;/i&gt;；作为订阅端的必需参数是 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:32;492:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subPort&lt;/i&gt;，指定订阅线程监听的端口号。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;493:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;通常情况下，流数据表的数据量会随时间不断增长。为了避免内存被耗尽，生产环境下建议设定配置参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:33;493:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;persistenceDir&lt;/i&gt; 以启用流数据表持久化。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;494:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;鉴于“有状态因子计算”一节使用了毫秒级别的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:34;494:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;throttle&lt;/i&gt;，需要配置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:35;494:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subThrottle&lt;/i&gt; = 1。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;495:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;鉴于“因子计算流水线”和“提高计算效率的方法”提到使用订阅系统的线程池和全局线程池，配置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:36;495:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;subExecutors&lt;/i&gt; 和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:37;495:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/hf_factor_streaming.md&#34;&gt;workerNum&lt;/i&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/hf_factor_streaming.md"/><meta name="wh-out-relpath" content="tutorials/hf_factor_streaming.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="实时计算高频因子" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="chap7_tutorials_streaming"><div class="title"><a href="../stream/str_intro.html"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming_auto_sub.html">金融场景应用案例</a></div></div></li><li class="active"><div class="topicref" data-id="实时计算高频因子"><div class="title"><a href="../tutorials/hf_factor_streaming.html">实时计算高频因子</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="streamfunctions-d9713e3813" class="topicref" data-id="streamfunctions" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamfunctions-d9713e3813-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_funcs.html" id="streamfunctions-d9713e3813-link">功能简介</a></div></div></li><li role="treeitem"><div data-tocid="入门示例-01实时计算买卖价差-d9713e4044" class="topicref" data-id="入门示例-01实时计算买卖价差" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/try_example1.html" id="入门示例-01实时计算买卖价差-d9713e4044-link">入门示例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="内置流式计算算子-d9713e4090" class="topicref" data-id="内置流式计算算子" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 内置流式计算算子-d9713e4090-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_operator.html" id="内置流式计算算子-d9713e4090-link"><span class="keyword label">流式计算算子</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="streamingEngineTopic-d9713e4229" class="topicref" data-id="streamingEngineTopic" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action streamingEngineTopic-d9713e4229-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/themes/streamingEngine.html" id="streamingEngineTopic-d9713e4229-link"><span class="keyword label">流计算引擎</span></a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e4506" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e4506-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_join_engine.html" id="chap7_tutorials_streaming-d9713e4506-link"><span class="keyword label">内置多数据源流式关联引擎</span></a></div></div></li><li role="treeitem"><div data-tocid="streamha-d9713e4783" class="topicref" data-id="streamha" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_ha.html" id="streamha-d9713e4783-link"><span class="keyword label">流数据高可用</span></a></div></div></li><li role="treeitem"><div data-tocid="流计算状态监控-d9713e4830" class="topicref" data-id="流计算状态监控" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_monitor.html" id="流计算状态监控-d9713e4830-link">流计算状态监控</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="replay-d9713e4876" class="topicref" data-id="replay" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action replay-d9713e4876-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_replay.html" id="replay-d9713e4876-link"><span class="keyword label">历史数据回放</span></a></div></div></li><li role="treeitem"><div data-tocid="流批一体功能-d9713e5061" class="topicref" data-id="流批一体功能" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_batch.html" id="流批一体功能-d9713e5061-link"><span class="keyword label">流批一体</span></a></div></div></li><li role="treeitem"><div data-tocid="streamengineparser-解析原理介绍-d9713e5108" class="topicref" data-id="streamengineparser-解析原理介绍" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_eng_parser.html" id="streamengineparser-解析原理介绍-d9713e5108-link">StreamEngineParser 解析原理</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="realtime_data_acces-d9713e5155" class="topicref" data-id="realtime_data_acces" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action realtime_data_acces-d9713e5155-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/realtime_data_acces.html" id="realtime_data_acces-d9713e5155-link">实时流数据接入</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="cep-d9713e5617" class="topicref" data-id="cep" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action cep-d9713e5617-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/cep.html" id="cep-d9713e5617-link">复杂事件处理（CEP）引擎</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6123" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6123-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/local_sub.html" id="tocId-d9713e6123-link">流处理结果交互方式</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e6312" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e6312-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_altair.html" id="tocId-d9713e6312-link">数据可视化工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e6405" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e6405-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="tocId-d9713e6405-link">金融场景应用案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e6406" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub.html" id="节点启动时的流计算自动订阅-d9713e6406-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="k-线计算-d9713e6452" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC.html" id="k-线计算-d9713e6452-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e6498" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant.html" id="金融因子流式实现-d9713e6498-link">金融因子流式实现</a></div></div></li><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e6544" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing.html" id="多数据源流式实时关联处理-d9713e6544-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem" class="active"><div data-tocid="实时计算高频因子-d9713e6590" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming.html" id="实时计算高频因子-d9713e6590-link">实时计算高频因子</a></div></div></li><li role="treeitem"><div data-tocid="股票行情回放-d9713e6636" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay.html" id="股票行情回放-d9713e6636-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e6682" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility.html" id="金融实时实际波动率预测-d9713e6682-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e6728" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e6728-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e6774" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily.html" id="实时计算日累计逐单资金流-d9713e6774-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e6820" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order.html" id="实时计算分钟资金流-d9713e6820-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e6866" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e6866-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e6913-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e6959" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc.html" id="处理-level-2-行情数据实例-d9713e6959-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e7005" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc.html" id="实时计算涨幅榜-d9713e7005-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e7051" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV.html" id="基金份额参考价值-iopv-计算-d9713e7051-link">基金份额参考价值 IOPV 计算</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7097" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7097-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_str_app_iot.html" id="tocId-d9713e7097-link">物联网场景应用案例</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">实时计算高频因子</h1><div class="- topic/body body"><p class="- topic/p p">DolphinDB 是一款高性能分布式时序数据库。与传统的关系数据库和常见的时序数据库不同，DolphinDB 不仅提供了高速存取时序数据的基本功能，而且内置了向量化的多范式编程语言与强大的计算引擎。DolphinDB 的计算引擎不仅可以用于量化金融的回测和研发，也可以用于生产环境的实时计算，譬如高频因子的计算。请使用 DolphinDB 1.20.0 或更高版本运行本教程中的例子。</p><p class="- topic/p p">运行本教程中的代码例子前，请先根据“本教程中流数据配置”进行流数据系统的配置。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-概述"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 概述</h2><div class="- topic/body body"><p class="- topic/p p">与其它流计算处理框架类似，DolphinDB 的流计算系统也包括消息发布、消息代理和消息订阅三个部分。消息发布端与消息订阅端均可为本地的数据节点、另一个数据节点，或第三方的 API（例如 Python, C++, Java, C# 等 API）。DolphinDB 数据节点上的流数据表（stream table）充当消息代理的角色，发布端向流数据表插入记录即实现了消息发布的功能。</p><p class="- topic/p p">高频因子的计算，以交易和报价数据作为主要的流数据输入，亦可配合使用其它数据。高频因子的计算结果通常输出到一个流数据表或内存表。</p><p class="- topic/p p">DolphinDB 流计算中使用的消息可以采用两种格式：表（table）和元组（tuple），由<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>函数的 <em class="+ topic/ph hi-d/i ph i">msgAsTable</em> 参数指定。</p><p class="- topic/p p">本教程中所用的 csv 数据文件，可由<a class="- topic/xref xref" href="https://www.dolphindb.cn/downloads/tutorial/hfFactorsSampleData.zip" target="_blank" rel="external noopener">此处</a>下载，并存于文件夹 <em class="+ topic/ph hi-d/i ph i">YOURDIR</em> 中。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-无状态因子计算"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 无状态因子计算</h2><div class="- topic/body body"><p class="- topic/p p">所谓无状态因子计算，即因子的计算不需要回溯历史数据，仅根据最新的一条消息即可生成因子。无状态因子计算场景下，建议使用表作为消息的格式，并使用 SQL 语句计算因子。</p><p class="- topic/p p">假设消息数据表包含以下列：symbol, date, time, askPrice1..askPrice5, bidPrice1..bidPrice5, askVolume1..askVolume5, bidVolume1..bidVolume5。其中 askPrice1..askPrice5 以及 askVolume1..askVolume5 为前5档卖方出价以及对应的量；bidPrice1..bidPrice5 以及 bidVolume1..bidVolume5 为前5档买方出价以及对应的量。计算以下两个状态因子：</p><ul class="- topic/ul ul"><li class="- topic/li li">因子1：根据每一条最新报价，计算因子 (askVolume1-bidVolume1)/(askVolume1+bidVolume1)。</li><li class="- topic/li li">因子2：对买档与卖档，分别计算最新5挡成交量加权累计之和，然后计算两者之比例。</li></ul><p class="- topic/p p">上述无状态因子，可分别使用以下脚本计算：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">因子1：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>    select symbol,time(now()) as time, (askVolume1-bidVolume1)/(askVolume1+bidVolume1) as factorValue from msg</code></pre></li><li class="- topic/li li"><p class="- topic/p p">因子2：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>    w = exp(-1 * 0..4)
    select symbol, time(now()) as time, 0.5*log(rowSum([bidVolume1,bidVolume2,bidVolume3,bidVolume4,bidVolume5]*w)/rowSum([askVolume1,askVolume2,askVolume3,askVolume4,askVolume5]*w)) as factorValue from msg</code></pre></li></ul><p class="- topic/p p">要实时计算上述无状态因子，把上述脚本封装成函数并在<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>函数中指定其为 <em class="+ topic/ph hi-d/i ph i">handler</em> 参数（消息处理函数）即可。消息处理函数必须是单目函数，且唯一的参数就是本批次订阅到的消息。以因子2为例:</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>quotesData = loadText(yourDIR + "sampleQuotes.csv")

def factorHandler(mutable factor1, msg){
    w = exp(-1 * 0..4)
    x=select symbol, datetime(now()) as datetime, 0.5*log(rowSum([bidVolume1,bidVolume2,bidVolume3,bidVolume4,bidVolume5]*w)/rowSum([askVolume1,askVolume2,askVolume3,askVolume4,askVolume5]*w)) as factorValue from msg
    factor1.tableInsert(x)
}
share table(1000000:0, `symbol`datetime`factorValue, [SYMBOL,DATETIME,DOUBLE]) as factor1
x=quotesData.schema().colDefs
share(streamTable(1000000:0, x.name, x.typeString), "quotes")

subscribeTable(tableName="quotes", actionName="hfFactor", handler=factorHandler{factor1}, msgAsTable=true)
</code></pre><p class="- topic/p p">然后使用<code class="+ topic/ph pr-d/codeph ph codeph">replay</code>函数将样本数据 quotesData 写入流数据表 quotes 触发计算。本教程的所有例子均使用<code class="+ topic/ph pr-d/codeph ph codeph">replay</code>函数将历史数据进行回放以模拟实时数据。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>replay(inputTables=quotesData, outputTables=quotes, dateColumn=`date, timeColumn=`time)</code></pre><p class="- topic/p p">最后在数据表 factor1 中查看计算结果。本例计算结果中的时间为计算发生时间，也可以根据业务要求调整为数据时间，即直接取消息中的 date 与 time 列。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3-滑动窗口因子计算"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3. 滑动窗口因子计算</h2><div class="- topic/body body"><p class="- topic/p p">流数据计算中，有一类典型的计算是根据滑动的时间窗口计算聚合值，连续的两个窗口可以重叠或不重叠。这类计算统称为滑动窗口计算。DolphinDB 内置的时间序列聚合引擎用于解决滑动窗口计算。DolphinDB 针对某些聚合函数在流数据时序引擎中的使用进行了优化，在计算每个窗口时充分利用上一个窗口的计算结果，尽可能避免重复计算，显著提高运行速度。已优化的聚合函数包括：<code class="+ topic/ph pr-d/codeph ph codeph">sum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">sum2</code>, <code class="+ topic/ph pr-d/codeph ph codeph">min</code>, <code class="+ topic/ph pr-d/codeph ph codeph">max</code>, <code class="+ topic/ph pr-d/codeph ph codeph">first</code>, <code class="+ topic/ph pr-d/codeph ph codeph">last</code>, <code class="+ topic/ph pr-d/codeph ph codeph">avg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">count</code>, <code class="+ topic/ph pr-d/codeph ph codeph">std</code>, <code class="+ topic/ph pr-d/codeph ph codeph">var</code>, <code class="+ topic/ph pr-d/codeph ph codeph">med</code>, <code class="+ topic/ph pr-d/codeph ph codeph">percentile</code>, <code class="+ topic/ph pr-d/codeph ph codeph">covar</code>, <code class="+ topic/ph pr-d/codeph ph codeph">corr</code>, <code class="+ topic/ph pr-d/codeph ph codeph">beta</code>, <code class="+ topic/ph pr-d/codeph ph codeph">wavg</code>, <code class="+ topic/ph pr-d/codeph ph codeph">wsum</code>, <code class="+ topic/ph pr-d/codeph ph codeph">prod</code>, <code class="+ topic/ph pr-d/codeph ph codeph">rank</code>, <code class="+ topic/ph pr-d/codeph ph codeph">stdp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">varp</code>, <code class="+ topic/ph pr-d/codeph ph codeph">kurtosis</code>, <code class="+ topic/ph pr-d/codeph ph codeph">skew</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ifirstNot</code>, <code class="+ topic/ph pr-d/codeph ph codeph">ilastNot</code>, <code class="+ topic/ph pr-d/codeph ph codeph">imax</code>, <code class="+ topic/ph pr-d/codeph ph codeph">imin</code>, <code class="+ topic/ph pr-d/codeph ph codeph">mad</code>, <code class="+ topic/ph pr-d/codeph ph codeph">maxPositiveStreak</code>, <code class="+ topic/ph pr-d/codeph ph codeph">se</code>, <code class="+ topic/ph pr-d/codeph ph codeph">slr</code>。聚合引擎可以接受的指标除了单个聚合函数使用消息中的一个或两个列作为参数外，还可以进行两个方向的扩展：（1）多个聚合函数构成新的表达式；（2）聚合函数的参数可以是消息中多个字段的表达式。</p><p class="- topic/p p">下例使用时间序列聚合引擎计算分钟级K线。Trade 表是一个流数据表，这里为了方便，假定 Trade 表与订阅端在同一个节点上。实际使用中，两者也可处于不同的节点。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tradesData = loadText(yourDIR + "sampleTrades1.csv")

//定义流数据表Trade
x=tradesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as Trade

//定义OHLC输出表
share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC

//定义实时聚合引擎：每分钟计算过去5分钟K线
tsAggrOHLC = createTimeSeriesAggregator(name="aggr_ohlc", windowSize=300000, step=60000, metrics=&lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol)

//订阅流数据写入聚合引擎
subscribeTable(tableName="Trade", actionName="minuteOHLC1", offset=0, handler=append!{tsAggrOHLC}, msgAsTable=true)

replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)</code></pre><p class="- topic/p p">查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from OHLC</code></pre><p class="- topic/p p">上面的例子中，流数据表 Trade 的消息直接作为聚合引擎的输入。某些场景下，需要对流数据表中的数据进行预处理后再输入到聚合引擎。若 Trade 表中的 Volume 是从开盘到当前的累计交易量，下例中定义函数<code class="+ topic/ph pr-d/codeph ph codeph">calcVolume</code>作为数据订阅的消息处理函数（即 <em class="+ topic/ph hi-d/i ph i">handler</em> 参数），将累计交易量转化为当前交易量之后，再输入聚合引擎。使用字典 dictVol 保存每只股票上一条消息中的累计交易量，以计算当前交易量。由于若 <em class="+ topic/ph hi-d/i ph i">handler</em> 参数是函数时，必须仅有一个参数，即本批次订阅到的消息，所以<code class="+ topic/ph pr-d/codeph ph codeph">calcVolume</code>必须包括 <em class="+ topic/ph hi-d/i ph i">msg</em> 这样一个代表本批次订阅数据的参数，且在<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>函数中使用时，使用“部分应用”将其它参数固化。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def calcVolume(mutable dictVolume, mutable tsAggrOHLC, msg){
	t = select Symbol, DateTime, Price, Volume from msg context by Symbol limit -1 
	update t set prevVolume = dictVolume[Symbol]
	dictVolume[t.Symbol] = t.Volume
	tsAggrOHLC.append!(t.update!("Volume", &lt;Volume - prevVolume&gt;).dropColumns!("prevVolume"))
}

tradesData = loadText(yourDIR + "sampleTrades2.csv")

//定义流数据表Trade
x=tradesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as Trade

//定义OHLC输出表
share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC

//定义实时聚合引擎：每分钟计算过去5分钟K线
tsAggrOHLC = createTimeSeriesAggregator(name="aggr_ohlc", windowSize=300000, step=60000, metrics=&lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol)

//订阅流数据写入聚合引擎
dictVol = dict(STRING, DOUBLE)
subscribeTable(tableName="Trade", actionName="minuteOHLC2", offset=0, handler=calcVolume{dictVol,tsAggrOHLC}, msgAsTable=true)

replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)</code></pre><p class="- topic/p p">最后查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from OHLC </code></pre><p class="- topic/p p">响应式状态引擎支持一部分优化过的序列处理函数，因此除了通过定义函数<code class="+ topic/ph pr-d/codeph ph codeph">calcVolume</code>来将累计交易量转化为当前交易量以外，可以通过响应式状态引擎和时间序列聚合引擎串联来实现同样的效果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tradesData = loadText(yourDIR + "sampleTrades2.csv")

//定义流数据表Trade
x=tradesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as Trade

//定义OHLC输出表
share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC

//定义实时聚合引擎：每分钟计算过去5分钟K线
tsAggrOHLC = createTimeSeriesAggregator(name="aggr_ohlc", windowSize=300000, step=60000, metrics=&lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol)

//定义响应式状态引擎：预处理Volume数据
rsAggrOHLC = createReactiveStateEngine(name="calc_vol", metrics=&lt;[Datetime, Price, deltas(Volume)]&gt;, dummyTable=Trade, outputTable=tsAggrOHLC, keyColumn=`Symbol)

//订阅流数据写入聚合引擎
subscribeTable(tableName="Trade", actionName="minuteOHLC2", offset=0, handler=append!{rsAggrOHLC}, msgAsTable=true)

replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)</code></pre><p class="- topic/p p">最后查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from OHLC </code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="4-状态因子计算"><h2 class="- topic/title title topictitle2" id="ariaid-title5">4. 状态因子计算</h2><div class="- topic/body body"><p class="- topic/p p">有状态的因子，即因子的计算不仅用到当前数据，还会用到历史数据。实现状态因子的计算，一般包括这几个步骤：（1）保存本批次的消息数据到历史记录；（2）根据更新后的历史记录，计算因子，（3）将因子计算结果写入输出表中。如有必要，删除未来不再需要的的历史记录。</p><p class="- topic/p p">由于 DolphinDB 的消息处理函数必须是单目函数，且唯一的参数就是当前的消息。要保存历史状态并且可以在消息处理函数中引用它，可以使用部分应用，定义一个多个参数的消息处理函数，其中一个参数用于接收消息，其它所有参数被固化，用于保存历史状态。这些固化参数只对消息处理函数可见，不受其他应用的影响。</p><p class="- topic/p p">历史状态可保存在内存表，字典或分区内存表中。本节的三个例子分别演示如何使用这三种方法来保存历史状态并计算因子。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="41-使用内存表计算状态因子"><h3 class="- topic/title title topictitle3" id="ariaid-title6">4.1. 使用内存表计算状态因子</h3><div class="- topic/body body"><p class="- topic/p p">本例中因子为当前第一档卖价与30个报价之前的第一档卖价的比值。因此，对于每只股票，至少需要保留30个历史报价。为此，可以定义一个内存表 history 用于保存所有股票的历史状态。</p><p class="- topic/p p">核心代码如下所示。其中，自定义聚合函数<code class="+ topic/ph pr-d/codeph ph codeph">factorAskPriceRatio</code>用于计算因子。消息处理函数<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>中：</p><ul class="- topic/ul ul"><li class="- topic/li li">第一行将本批次消息保存到内存表 history 中。</li><li class="- topic/li li">第二行用于提取本批次消息的股票代码。每次计算仅针对本批次消息所包含的股票。</li><li class="- topic/li li">第三行计算每只股票的因子。</li><li class="- topic/li li">最后一行将生成的因子输出到 factors 表中。</li></ul><p class="- topic/p p">消息订阅函数<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>的核心参数 <em class="+ topic/ph hi-d/i ph i">handler</em> 是<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>的一个部分应用，其中两个固定的参数 <em class="+ topic/ph hi-d/i ph i">history</em> 和 <em class="+ topic/ph hi-d/i ph i">factors</em> 分别用于保存历史状态和输出生成的因子。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>quotesData = loadText(yourDIR + "sampleQuotes.csv")

defg factorAskPriceRatio(x){
	cnt = x.size()
	if(cnt &lt; 31) return double()
	else return x[cnt - 1]/x[cnt - 31]
}

def factorHandler(mutable history, mutable factors, msg){
	history.append!(select symbol, askPrice1 from msg)
	syms = msg.symbol
	t = select factorAskPriceRatio(askPrice1) as factor from history where symbol in syms group by symbol
	factors.append!(t.update!("timestamp", now()).reorderColumns!("timestamp"))
}

x=quotesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as quotes1
history = table(1000000:0, `symbol`askPrice1, [SYMBOL,DOUBLE])
share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors
subscribeTable(tableName = "quotes1", offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize = 3000, throttle=0.005)

replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)</code></pre><p class="- topic/p p">查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from factors where isValid(factor)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="42-基于分区内存表的状态因子计算"><h3 class="- topic/title title topictitle3" id="ariaid-title7">4.2. 基于分区内存表的状态因子计算</h3><div class="- topic/body body"><p class="- topic/p p">使用普通内存表计算因子，是单线程操作，不能并行计算。使用分区内存表计算因子，可以并行计算以提高效率。</p><p class="- topic/p p">对内存表执行 SQL 语句时，只有一个子任务。对分区内存表执行 SQL 语句时，会产生与分区数量一致的子任务，由当前的流数据执行线程和系统的执行线程池来完成。系统的线程池的大小由配置参数 <em class="+ topic/ph hi-d/i ph i">workerNum</em> 决定。因此执行一个分区内存表的SQL语句，在分区数量大于 <em class="+ topic/ph hi-d/i ph i">workerNum</em> 的情况下，最大的并行度是 <em class="+ topic/ph hi-d/i ph i">workerNum</em>。</p><p class="- topic/p p">内存表与分区内存表在数据插入和SQL查询方面，大部分情况下没有语法上的区别。因此“使用内存表计算有状态因子”一节中的代码仍然适用于分区内存表。唯一需要修改的是 history 表的创建和初始化。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>history_model = table(1000000:0, `symbol`askPrice1, [SYMBOL,DOUBLE])
syms = format(600000..601000, "000000")
db = database(partitionType=VALUE, partitionScheme=syms)
history = db.createPartitionedTable(table=history_model, tableName=`history, partitionColumns=`symbol)</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">注意</strong>：syms 仅包括样本数据中的 1001 个股票代码。实际使用时请根据具体情况进行调整。</p><p class="- topic/p p">当分区内存表的分区机制是值分区，而且因子比较简单时，除了使用 SQL 语句，亦可直接在每个分区中计算因子。在大量的小表上使用 SQL 的成本较高，直接在每个分区中进行计算可能提高效率。下面的代码中改写了<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>的定义。通过系统内置函数<code class="+ topic/ph pr-d/codeph ph codeph">getTablet</code>获取消息中所有股票对应的分区子表，然后循环计算每只股票的因子，最后把因子写入 factors 表中。该计算方案虽然实际上使用了单线程，但是耗时却只有 SQL 方案的三分之一左右。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def factorHandler(mutable history, mutable factors, msg){
	history.append!(select symbol, askPrice1 from msg)
	syms = msg.symbol
	tables = getTablet(history, syms)
	cnt = syms.size()
	v = array(DOUBLE, cnt)
	for(i in 0:cnt){
		v[i] = factorAskPriceRatio(tables[i].askPrice1)
	}
	factors.tableInsert([take(now(), cnt), syms, v])
}</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="43-基于字典的状态因子计算"><h3 class="- topic/title title topictitle3" id="ariaid-title8">4.3. 基于字典的状态因子计算</h3><div class="- topic/body body"><p class="- topic/p p">创建一个键值为 STRING 类型，值为元组（tuple）类型的字典。该字典中，每只股票对应一个数组，以存储卖价的历史数据。使用<code class="+ topic/ph pr-d/codeph ph codeph">dictUpdate!</code>函数更新该字典，然后循环计算每只股票的因子。由于每只股票的历史数据分别存储，计算因子时不再需要对数据分组，因而有更高的效率。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>defg factorAskPriceRatio(x){
	cnt = x.size()
	if(cnt &lt; 31) return double()
	else return x[cnt - 1]/x[cnt - 31]
}
def factorHandler(mutable historyDict, mutable factors, msg){
	historyDict.dictUpdate!(function=append!, keys=msg.symbol, parameters=msg.askPrice1, initFunc=x-&gt;array(x.type(), 0, 512).append!(x))
	syms = msg.symbol.distinct()
	cnt = syms.size()
	v = array(DOUBLE, cnt)
	for(i in 0:cnt){
	    v[i] = factorAskPriceRatio(historyDict[syms[i]])
	}
	factors.tableInsert([take(now(), cnt), syms, v])
}

x=quotesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as quotes1
history = dict(STRING, ANY)
share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors
subscribeTable(tableName = "quotes1", offset=0, handler=factorHandler{history, factors}, msgAsTable=true, batchSize=3000, throttle=0.005)

replay(inputTables=quotesData, outputTables=quotes1, dateColumn=`date, timeColumn=`time)</code></pre><p class="- topic/p p">查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from factors where isValid(factor)</code></pre><p class="- topic/p p">这三种方法各有优缺点。</p><ul class="- topic/ul ul"><li class="- topic/li li">内存表简单易用，计算可以使用简单的 SQL 语句完成，缺点是计算性能较低，尤其是每只股票的消息单独处理时，性能尤为低下。</li><li class="- topic/li li">字典方法的数据结构最为简单，当因子较为简单时，无论大量股票批量处理，还是每只股票单独处理，效率均为最高。字典方法的缺点是如果因子计算较为复杂时，逐个处理的效率不高。</li><li class="- topic/li li">分区内存表方法居于两者之间。可以使用 SQL 语句来完成复杂或简单的因子计算，但与未分区的内存表相比，可以通过分区来实现并行计算，以提高效率。</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title9" id="5-因子计算流水线"><h2 class="- topic/title title topictitle2" id="ariaid-title9">5. 因子计算流水线</h2><div class="- topic/body body"><p class="- topic/p p">一些较为复杂的因子可能需要使用流水线处理（或者链式处理）。一种常见场景为：先根据输入的行情数据使用时间序列聚合引擎生成分钟级K线，然后根据分钟级K线生成状态因子。可将消息处理函数的输出指向另一个流数据表，以实现流水线处理。</p><p class="- topic/p p">下例演示因子计算的流水线处理。首先计算每只股票分钟级的K线，然后根据最近的10个K线记录计算前面5个时间段的资金净流入量与后面5个时间段的资金净流入量的比例。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tradesData = loadText(yourDIR + "sampleTrades1.csv")

defg factorMoneyFlowRatio(x){
	n = x.size()
	if(n &lt; 9) return double()
	else return x.subarray((n-9):(n-5)).sum()\x.subarray((n-4):n).sum()
}

def factorHandler2(mutable historyDict, mutable factors, msg){
	netAmount = exec volume * iif(close&gt;=open, 1, -1) from msg
	dictUpdate!(historyDict, append!, msg.symbol, netAmount, x-&gt;array(x.type(), 0, 500).append!(x))
	syms = msg.symbol.distinct()
	cnt = syms.size()
	v = array(DOUBLE, cnt)
	for(i in 0:cnt){
	    v[i] = factorMoneyFlowRatio(historyDict[syms[i]])
	}
	factors.tableInsert([take(now(), cnt), syms, v])
}

//定义流数据表Trade
x=tradesData.schema().colDefs
share streamTable(100:0, x.name, x.typeString) as Trade

//定义OHLC输出表
share streamTable(100:0, `datetime`symbol`open`high`low`close`volume`updatetime,[TIMESTAMP,SYMBOL,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,TIMESTAMP]) as OHLC

//定义实时聚合引擎：每分钟计算过去1分钟K线
tsAggrOHLC = createTimeSeriesAggregator(name="aggr_ohlc", windowSize=60000, step=60000, metrics=&lt;[first(Price),max(Price),min(Price),last(Price),sum(Volume),now()]&gt;, dummyTable=Trade, outputTable=OHLC, timeColumn=`Datetime, keyColumn=`Symbol)

//订阅流数据写入聚合引擎
subscribeTable(tableName="Trade", actionName="minuteOHLC3", offset=0, handler=append!{tsAggrOHLC}, msgAsTable=true)

//订阅流数据表OHLC，计算指标，并输出到流数据表factors
dictHistory = dict(STRING, ANY)
share streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE]) as factors
subscribeTable(tableName="OHLC", actionName="calcMoneyFlowRatio", offset=0, handler=factorHandler2{dictHistory,factors}, msgAsTable=true)

replay(inputTables=tradesData, outputTables=Trade, dateColumn=`Datetime)</code></pre><p class="- topic/p p">查看结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select top 10 * from factors where isValid(factor)</code></pre><p class="- topic/p p">使用流水线计算因子时，需要合理安排消息的执行线程。最理想的情况是每一个环节由不同的线程来完成，以降低延迟。流数据消息的默认执行模式是为每一个线程分配一个消息队列，订阅的消息进入了不同的队列，就由相应的线程来执行。那如何为一个订阅指定执行线程或队列呢？可以使用函数<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>的可选参数 <em class="+ topic/ph hi-d/i ph i">hash</em> 。如果订阅的执行线程总数为N，那么分配的线程序号（从0开始）为 N 除以 <em class="+ topic/ph hi-d/i ph i">hash</em> 的余数。订阅的执行线程总数可以通过配置变量 <em class="+ topic/ph hi-d/i ph i">subExecutors</em> 来设置，默认值为1。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title10" id="6-提高计算效率的方法"><h2 class="- topic/title title topictitle2" id="ariaid-title10">6. 提高计算效率的方法</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="61-使用字典或分区内存表分组存储数据"><h3 class="- topic/title title topictitle3" id="ariaid-title11">6.1. 使用字典或分区内存表分组存储数据</h3><div class="- topic/body body"><p class="- topic/p p">实时计算时，通常需要对每只股票分别计算。如果事先按股票分组存储数据，可显著缩短计算耗时。分组存储可使用字典和分区内存表这两种方法。我们测试了“有状态因子计算”章节中提到的三种方法，假定4000个股票，每个股票有300条历史记录，4000条消息（每个股票1条）的批量处理时间（包括数据插入，因子计算和因子结果插入）分别为180毫秒（内存表），32毫秒（分区内存表）和20毫秒（字典）。可见字典和分区内存表可显著提升因子计算效率。</p><p class="- topic/p p">使用字典或分区内存表分组存储数据有可能遇到两个问题。第一个问题关于新股。初始化的时候没有考虑到后续出现的股票，但是日内流计算的时候出现了新的股票。若使用字典，只需在使用<code class="+ topic/ph pr-d/codeph ph codeph">dictUpdate!</code>函数时指定初始化函数参数 <em class="+ topic/ph hi-d/i ph i">initFunc</em> 即可。如“基于字典的有状态因子计算”小节的<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>定义中，可使用字典值的初始化函数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>x-&gt;array(x.type(), 0, 512).append!(x)</code></pre><p class="- topic/p p">这是一个单目的<code class="+ topic/ph pr-d/codeph ph codeph">lambda</code>函数，当输入为标量或向量时，创建一个新的向量，预先分配512个元素的内存，然后将当前值扩展到新创建的数组中，最后返回这个数组。如果使用值分区的内存表，创建之后不允许动态增加分区。如果出现新股票数据，这部分数据无法插入分区内存表，也不会报异常。这种情况下，若要处理当天开始交易的新股票，只能每天交易开始前初始化流数据系统。</p><p class="- topic/p p">第二个问题是根据多个字段分组。目前字典的键值和分区内存表的分区尚不支持组合字段，解决的办法是将多个字段拼接成单个字符串字段。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="62-平衡延时和吞吐量"><h3 class="- topic/title title topictitle3" id="ariaid-title12">6.2. 平衡延时和吞吐量</h3><div class="- topic/body body"><p class="- topic/p p">众所周知，在其它条件给定的情况下，延时和吞吐是一对矛盾。高频因子实时计算追求消息处理的低延迟，但是如果逐条处理消息，会降低整体的吞吐量。在实践中，可以找到一个延时和吞吐量之间的平衡点。<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>函数提供了两个可选参数 <em class="+ topic/ph hi-d/i ph i">throttle</em> 和 <em class="+ topic/ph hi-d/i ph i">batchSize</em> ，用于调节延时和吞吐量。 <em class="+ topic/ph hi-d/i ph i">throttle</em> 为每个消息批次处理之前最长等待时间，单位为秒，最短可设为1毫秒，用0.001表示。 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 为每个消息批次处理之前最多的消息条数。当 <em class="+ topic/ph hi-d/i ph i">throttle</em> 和 <em class="+ topic/ph hi-d/i ph i">batchSize</em> 两个条件中有一个满足时，系统就会把尚未处理的消息合并成一个表或元组（根据参数 <em class="+ topic/ph hi-d/i ph i">msgAsTable</em> 的设定），发送到任务队列，由<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>函数指定的message handler来处理。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="63-并行计算"><h3 class="- topic/title title topictitle3" id="ariaid-title13">6.3. 并行计算</h3><div class="- topic/body body"><p class="- topic/p p">并行计算可提升系统的吞吐量，单位时间内处理更多的消息。流计算使用并行计算可分为两种情况：使用订阅系统的线程和使用 DolphinDB 进程全局的执行线程。</p></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title14" id="631-使用订阅系统的线程池"><h4 class="- topic/title title topictitle4" id="ariaid-title14">6.3.1. 使用订阅系统的线程池</h4><div class="- topic/body body"><p class="- topic/p p">通过配置变量 <em class="+ topic/ph hi-d/i ph i">subExecutors</em> ，可以指定一定数量的线程来处理订阅的消息。默认的线程数量是1个，也即所有订阅的消息都是通过这个线程来处理。当订阅线程有多个时，如何并行处理消息又有两种方式。默认的方式是按订阅来分配线程，一个订阅分配给一个线程，一个线程可以处理多个订阅。如果需要精确指定哪个线程来处理哪个订阅，可以在<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>中指定 <em class="+ topic/ph hi-d/i ph i">hash</em> 参数。这种方式的优点是一个订阅的消息处理函数只被一个线程执行，不存在线程安全的问题，也不存在线程同步的问题，有很高的效率。缺点是如果各个订阅的消息数量和处理复杂度极不平衡，那么某些订阅会成为瓶颈。</p><p class="- topic/p p">订阅线程的另一种使用模式是线程池模式。在线程池模式下，所有的消息处理任务都进入同一个队列，随机分配给空闲的线程去执行。因此，同一个订阅的消息处理函数可能同时被多个线程执行，必须确保：（1）消息处理函数是线程安全的，（2）各个消息的处理在业务上是独立的。DolphinDB 的所有数据结构中，只有同步字典（synchronized dictionary）和共享表（shared table）是线程安全的。如果某个数据结构可能被多个线程并发读写，必须选择上述同步字典或共享表。要启用线程池模式，需将配置参数 <em class="+ topic/ph hi-d/i ph i">subExecutorPooling</em> 设置为true。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="632-使用全局的线程池"><h4 class="- topic/title title topictitle4" id="ariaid-title15">6.3.2. 使用全局的线程池</h4><div class="- topic/body body"><p class="- topic/p p">在消息处理函数内部，如果要处理的股票比较多或者要计算的因子比较多，通过任务分解和多线程并行可以缩短处理时间。多线程并行使用当前的订阅线程和 DolphinDB 进程全局的线程池。全局的线程池通过配置参数 <em class="+ topic/ph hi-d/i ph i">workerNum</em> 设置。</p><p class="- topic/p p">下例对<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>进行并行计算改造，将因子计算和写入 factors 表这两个步骤封装到了一个内嵌函数中，并按照要处理的股票来进行任务划分。如果股票数目小于400，在一个任务中完成，否则分成2个任务来完成。原先4000个股票计算一次耗时约20ms，两个任务并行后耗时13ms左右。使用<code class="+ topic/ph pr-d/codeph ph codeph">cut</code>函数将股票切割为多个部分，并用高阶函数<code class="+ topic/ph pr-d/codeph ph codeph">ploop</code>实现多任务的并行。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def factorHandler(mutable historyDict, mutable factors, msg){
	historyDict.dictUpdate!(append!, msg.symbol, msg.ap, x-&gt;array(x.type(), 0, 512).append!(x))
	syms = msg.symbol.distinct()
	cnt = syms.size()
	f = def(syms, d, mutable factors){
		cnt = syms.size()
		signals = array(DOUBLE, cnt)
		for(i in 0:cnt)	signals[i] = factorAskPriceRatio(d[syms[i]])
		factors.tableInsert([take(now(), cnt), syms, signals])
	}
	if(cnt &lt; 400) f(syms, historyDict, factors)
	else ploop(f{,historyDict, factors}, syms.cut(ceil(cnt/2.0)))
}</code></pre></div></article></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="64-即时编译"><h3 class="- topic/title title topictitle3" id="ariaid-title16">6.4. 即时编译</h3><div class="- topic/body body"><p class="- topic/p p">消息处理函数若逻辑较复杂，需要用到<code class="+ topic/ph pr-d/codeph ph codeph">for</code>循环，<code class="+ topic/ph pr-d/codeph ph codeph">while</code>循环和<code class="+ topic/ph pr-d/codeph ph codeph">if-else</code>等语句，无法使用向量化运算但又对运行速度有极高要求，可使用 DolphinDB 中的即时编译（JIT）功能，以显著提升性能。关于即时编译功能的更多介绍，请参考<a class="- topic/xref xref" href="jit.html">DolphinDB即时编译教程</a>。</p><p class="- topic/p p">下例中的因子，在每行数据中，需要使用前5档的报价及对应的盘口数据进行计算，且根据设定条件进行更进一步的计算。这个过 程无法向量化运算，可使用即时编译以提升性能。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@jit
 def sum_diff(x, y){
     return 1.0 * (x-y)/(x+y) 
 }
 
 @jit
 def wbvol(bp, bv, price, jump) {
     return exp(0.6*(bp-price)/jump) * bv
 }
 
 @jit
 def wavol(ap, av, price, jump) {
     return exp(0.6 * (price - ap)/jump) * av
 }
 
 @jit
 def factor1(ap1, ap2, ap3, ap4, ap5, av1, av2, av3, av4, av5, bp1, bp2, bp3, bp4, bp5, bv1, bv2, bv3, bv4, bv5, mp, initMP, delta){
     n = ap1.size()
     re = array(DOUBLE, n)
     for(i in 0:n){
         jump = ceil(initMP[i] * 15.0 / 100.0) / 100.0
         w_av1 = 0.0  
         w_bv1 = 0.0  
         w_av1 = wavol(ap1[i], av1[i], mp[i], jump) + wavol(ap2[i], av2[i], mp[i], jump) + wavol(ap3[i], av3[i], mp[i], jump) + wavol(ap4[i], av4[i], mp[i], jump) + wavol(ap5[i], av5[i], mp[i], jump)
         w_bv1 = wbvol(bp1[i], bv1[i], mp[i], jump) + wbvol(bp2[i], bv2[i], mp[i], jump) + wbvol(bp3[i], bv3[i], mp[i], jump) + wbvol(bp4[i], bv4[i], mp[i],jump) + wbvol(bp5[i], bv5[i], mp[i], jump)
         if(delta[i]&gt;0){
             re[i] = sum_diff(w_bv1*1.1, w_av1)
         }else{
             re[i] = sum_diff(w_bv1, w_av1 * 1.1)
         }		
     }
     return re
 }

//---------------------------------------------------------订阅处理函数-----------------------------------------------------
def factor1_handler(mutable d, mutable factor, msg){
     start = now(true)
     n = msg.size()
     mp = (msg.bidPrice1+msg.askPrice1)/2
     dictUpdate!(d,append!, msg.symbol, mp)
     delta = array(DOUBLE, n)
     initMP = array(DOUBLE, n)
     sym = msg.symbol
     for(i in 0:n){
         &amp;his_mp = d[sym[i]]
         initMP[i] = his_mp[0]
         delta[i] = nullFill(his_mp.tail()-his_mp.tail(5).avg(), 0)
     }
     factorValue = factor1(msg.askPrice1, msg.askPrice2, msg.askPrice3, msg.askPrice4, msg.askPrice5, msg.askVolume1, msg.askVolume2, msg.askVolume3, msg.askVolume4, msg.askVolume5, msg.bidPrice1, msg.bidPrice2, msg.bidPrice3, msg.bidPrice4, msg.bidPrice5, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, msg.bidVolume1, mp, initMP, delta)
     factor.tableInsert(take(start,n), take(now(true), n), sym, take("factor1", n), factorValue)
}

def clear(){
	try{
	unsubscribeTable(, `Trade, `act_factor)
	undef(`Trade, SHARED)
	undef(`factor_result, SHARED)
	}catch(ex){}
}

login("admin","123456")
clear()
go

quotesData = loadText(yourDIR + "sampleQuotes.csv")

x=quotesData.schema().colDefs
share(streamTable(1000000:0, x.name, x.typeString), "quotes")

d = dict(STRING, ANY)
for(id in quotesData[`symbol].distinct())
     d[id]= array(DOUBLE,0,0)
dictUpdate!(d,append!, quotesData.symbol, (quotesData.bidPrice1+quotesData.askPrice1)/2)
share streamTable(100:0,`starttime`endtime`symbol`factorName`orderbook_factor_15, [LONG,LONG,SYMBOL,SYMBOL,DOUBLE]) as factor_result
subscribeTable(tableName="quotes", actionName="act_factor", offset=-1, handler=factor1_handler{d, factor_result}, msgAsTable=true);

replay(inputTables=quotesData, outputTables=quotes, dateColumn=`date, timeColumn=`time)</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="7-流计算调试"><h2 class="- topic/title title topictitle2" id="ariaid-title17">7. 流计算调试</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="71-调试消息处理函数"><h3 class="- topic/title title topictitle3" id="ariaid-title18">7.1. 调试消息处理函数</h3><div class="- topic/body body"><p class="- topic/p p">消息处理函数是流计算的核心。调试消息处理函数通常有两种方法：（1）单独调试消息处理函数；（2）在函数中打印日志。</p><p class="- topic/p p">消息处理函数的核心输入是消息。消息在 DolphinDB 中的两种形式是 table 或 tuple。只要构造消息，就可以调试消息处理函数。如果消息处理函数比较复杂，希望单行执行，一个推荐的做法是，构造与函数参数相同名称的变量，然后逐条运行消息处理函数体内的语句。以“基于字典的有状态因子计算”中的<code class="+ topic/ph pr-d/codeph ph codeph">factorHandler</code>函数为例，可以构造三个变量 <em class="+ topic/ph hi-d/i ph i">historyDict</em> ，<em class="+ topic/ph hi-d/i ph i">factors</em> 和 <em class="+ topic/ph hi-d/i ph i">msg</em>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>k=4000
syms = string(1..k)
n = 1200000
min_history = table(take(syms, n) as symbol, rand(10.0, n) as ap)
msg = table(string(1..k) as symbol, rand(10.0, k) as ap)
historyDict = dict(STRING, ANY)
historyDict.dictUpdate!(append!, min_history.symbol, min_history.ap, x-&gt;array(x.type(), 0, 512).append!(x))
factors = streamTable(100000:0, `timestamp`symbol`factor, [TIMESTAMP,SYMBOL,DOUBLE])</code></pre><p class="- topic/p p">另一个方法是在消息函数中打印日志，可通过函数<code class="+ topic/ph pr-d/codeph ph codeph">writeLog</code>实现。从 DolphinDB server 的系统日志中，能够看到 writeLog 输出的日志。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="72-历史数据回测"><h3 class="- topic/title title topictitle3" id="ariaid-title19">7.2. 历史数据回测</h3><div class="- topic/body body"><p class="- topic/p p">本教程中使用了少量数据。在投入 production 前，建议使用大量真实的历史数据，来回测消息处理函数，这有助于发现程序逻辑，业务逻辑，以及系统性能方面的问题。DolphinDB 提供了函数<code class="+ topic/ph pr-d/codeph ph codeph">replay</code>与<code class="+ topic/ph pr-d/codeph ph codeph">replayDS</code>以回放历史数据库中的tick数据。请参考用户手册以获取更多信息。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="8-本教程中流数据配置"><h2 class="- topic/title title topictitle2" id="ariaid-title20">8. 本教程中流数据配置</h2><div class="- topic/body body"><p class="- topic/p p">本教程中使用了单机模式的 DolphinDB Server。配置文件（dolphindb.cfg）的内容如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>mode=single
workerNum=4
maxPubConnections=8
subPort=20001
persistenceDir=dbCache
subThrottle=1
subExecutors=2</code></pre><ul class="- topic/ul ul"><li class="- topic/li li">单机模式下，本节点既是发布端又是订阅端。作为发布端的必需参数是 <em class="+ topic/ph hi-d/i ph i">maxPubConnections</em>；作为订阅端的必需参数是 <em class="+ topic/ph hi-d/i ph i">subPort</em>，指定订阅线程监听的端口号。</li><li class="- topic/li li">通常情况下，流数据表的数据量会随时间不断增长。为了避免内存被耗尽，生产环境下建议设定配置参数 <em class="+ topic/ph hi-d/i ph i">persistenceDir</em> 以启用流数据表持久化。</li><li class="- topic/li li">鉴于“有状态因子计算”一节使用了毫秒级别的 <em class="+ topic/ph hi-d/i ph i">throttle</em>，需要配置 <em class="+ topic/ph hi-d/i ph i">subThrottle</em> = 1。</li><li class="- topic/li li">鉴于“因子计算流水线”和“提高计算效率的方法”提到使用订阅系统的线程池和全局线程池，配置 <em class="+ topic/ph hi-d/i ph i">subExecutors</em> 和 <em class="+ topic/ph hi-d/i ph i">workerNum</em>。</li></ul></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E6%A6%82%E8%BF%B0" data-tocid="1-概述">1. 概述</a></li><li class="topic-item"><a href="#2-%E6%97%A0%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="2-无状态因子计算">2. 无状态因子计算</a></li><li class="topic-item"><a href="#3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="3-滑动窗口因子计算">3. 滑动窗口因子计算</a></li><li class="topic-item"><a href="#4-%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="4-状态因子计算">4. 状态因子计算</a><ul><li class="topic-item"><a href="#41-%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E8%A1%A8%E8%AE%A1%E7%AE%97%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90" data-tocid="41-使用内存表计算状态因子">4.1. 使用内存表计算状态因子</a></li><li class="topic-item"><a href="#42-%E5%9F%BA%E4%BA%8E%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E8%A1%A8%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="42-基于分区内存表的状态因子计算">4.2. 基于分区内存表的状态因子计算</a></li><li class="topic-item"><a href="#43-%E5%9F%BA%E4%BA%8E%E5%AD%97%E5%85%B8%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97" data-tocid="43-基于字典的状态因子计算">4.3. 基于字典的状态因子计算</a></li></ul></li><li class="topic-item"><a href="#5-%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97%E6%B5%81%E6%B0%B4%E7%BA%BF" data-tocid="5-因子计算流水线">5. 因子计算流水线</a></li><li class="topic-item"><a href="#6-%E6%8F%90%E9%AB%98%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95" data-tocid="6-提高计算效率的方法">6. 提高计算效率的方法</a><ul><li class="topic-item"><a href="#61-%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E6%88%96%E5%88%86%E5%8C%BA%E5%86%85%E5%AD%98%E8%A1%A8%E5%88%86%E7%BB%84%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" data-tocid="61-使用字典或分区内存表分组存储数据">6.1. 使用字典或分区内存表分组存储数据</a></li><li class="topic-item"><a href="#62-%E5%B9%B3%E8%A1%A1%E5%BB%B6%E6%97%B6%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F" data-tocid="62-平衡延时和吞吐量">6.2. 平衡延时和吞吐量</a></li><li class="topic-item"><a href="#63-%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97" data-tocid="63-并行计算">6.3. 并行计算</a><ul><li class="topic-item"><a href="#631-%E4%BD%BF%E7%94%A8%E8%AE%A2%E9%98%85%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0" data-tocid="631-使用订阅系统的线程池">6.3.1. 使用订阅系统的线程池</a></li><li class="topic-item"><a href="#632-%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0" data-tocid="632-使用全局的线程池">6.3.2. 使用全局的线程池</a></li></ul></li><li class="topic-item"><a href="#64-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91" data-tocid="64-即时编译">6.4. 即时编译</a></li></ul></li><li class="topic-item"><a href="#7-%E6%B5%81%E8%AE%A1%E7%AE%97%E8%B0%83%E8%AF%95" data-tocid="7-流计算调试">7. 流计算调试</a><ul><li class="topic-item"><a href="#71-%E8%B0%83%E8%AF%95%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0" data-tocid="71-调试消息处理函数">7.1. 调试消息处理函数</a></li><li class="topic-item"><a href="#72-%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%B5%8B" data-tocid="72-历史数据回测">7.2. 历史数据回测</a></li></ul></li><li class="topic-item"><a href="#8-%E6%9C%AC%E6%95%99%E7%A8%8B%E4%B8%AD%E6%B5%81%E6%95%B0%E6%8D%AE%E9%85%8D%E7%BD%AE" data-tocid="8-本教程中流数据配置">8. 本教程中流数据配置</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>