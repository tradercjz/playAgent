<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content=" ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="响应式状态引擎"/><title>响应式状态引擎</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;响应式状态引擎&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;量化金融的研究和实盘中，越来越多的机构需要根据高频的行情数据（L1/L2以及逐笔委托数据）来计算量价因子，每只股票的每一条新数据的注入都会更新该只股票的所有因子值。这些因子通常是有状态的：不仅与当前的多个指标有关，而且与多个指标的历史状态相关。以国内的股票市场为例，每3秒收到一个快照，每个股票每天4800个快照，计算因子时可能会用到之前若干个快照的数据，甚至之前若干天的数据。绝大多数机构的研发环境系统（例如Python）与生产环境系统（例如C++）不同，要维护两套代码，是非常沉重的负担。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;本教程介绍如何使用DolphinDB 1.30.3版本发布的响应式状态引擎（Reactive State Engine），实现流批统一计算带有状态的高频因子。状态引擎接受在历史数据批量处理（研发阶段）中编写的表达式或函数作为输入进行流式计算，并确保流式计算的结果与批量计算完全一致。只要在历史数据的批量计算中验证正确，即可保证流数据的实时计算正确。这避免了在生产环境中重写研发代码的高额成本，以及维护研发和生产两套代码的负担。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:56;81:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-金融高频因子计算示例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;1. 金融高频因子计算示例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;本节通过一个金融高频因子计算的示例，介绍高频因子计算中的挑战。以下的因子表达式以DolphinDB脚本语言编写，使用了用户自定义函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;9:67&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;sum\_diff&lt;/codeph&gt;和内置函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;9:83&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;ema&lt;/codeph&gt; (exponential moving average)。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;9:118&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;sum_diff&lt;/codeph&gt;是一个无状态函数，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;9:137&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;ema&lt;/codeph&gt;是一个有状态的函数，依赖历史数据。更为棘手的是，如以下计算分解图所示，需要使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;9:181&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;ema&lt;/codeph&gt;函数的多重嵌套。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&lt;/codeblock&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/hf_factor_demo.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34; dita-ot:image-width=&#34;809&#34; dita-ot:image-height=&#34;671&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;&gt;&lt;alt class=&#34;- topic/alt &#34; xtrc=&#34;alt:1;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;image&lt;/alt&gt;&lt;/image&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;20:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;面对此类场景，我们需要解决以下几个问题：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;投研阶段能否使用历史数据快速为每只股票计算100~1000个类似的因子？&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;实盘阶段能否在每个行情tick数据到来时为每只股票计算100~1000个类似的因子？&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;批处理和流计算的代码实现是否高效？批和流能否统一代码？正确性校验是否便捷？&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-现有解决方案的优缺点&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;2. 现有解决方案的优缺点&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;Python pandas/numpy目前是研究阶段最常用的高频因子解决方案。pandas对历史面板数据处理有非常成熟的解决方案，而且内置了大部分高频因子计算需要用到的算子，可快速开发高频因子。但pandas无论对历史数据计算，还是对实时数据计算的性能都较差。对历史数据计算时，单线程的计算性能也存在较大提升空间，此外，由于python的Global interpreter lock的限制，无法进行并行计算；对实时数据进行计算时，由于python仅支持全量计算，不支持增量计算，所以无法达到实时计算的性能要求。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;为生产环境中的性能考虑，很多机构会用C++重新实现研究（历史数据）代码。不过，这种方法需要维护两套代码，开发成本（时间和人力）会大幅增加。此外，还要耗费大量精力确保两套系统的结果完全一致。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;33:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;Flink是一种批流统一的解决方案。Flink支持SQL和窗口函数，高频因子用到的基本算子在Flink中已经内置实现。因此，简单的因子用Flink实现比较高效，运行性能也较好。但Flink最大的问题是无法实现复杂的高频因子计算。如前一章中提到的例子，需要多个窗口函数的嵌套，无法直接用Flink实现。这也正是DolphinDB开发响应式状态引擎的动机所在。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-响应式状态引擎reactive-state-engine&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3. 响应式状态引擎（Reactive State Engine)&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;38:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎实际上是一个计算黑盒，输入在历史数据上已经验证的DolphinDB因子代码（表达式或函数）以及实时行情数据，输出实时因子值。由于在静态的历史数据集上开发和验证高频因子远比在流数据上开发更为简单，响应式状态引擎显著降低了流式高频因子的开发成本和难度。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;40:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&amp;gt; share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream result = table(1000:0, `sym`factor1, [STRING,DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics=factor1, dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;) subscribeTable(tableName=`tickStream, actionName=&#34;factors&#34;, handler=tableInsert{rse})&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;52:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;以上代码在DolphinDB中实现前述因子的流式计算。factor1是前述因子在历史数据上的实现，不做任何改变，直接传递给响应式状态引擎rse，即可实现流式计算。通过订阅函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;52:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;subscribeTable&lt;/codeph&gt;，将流数据表tickStream与状态引擎rse进行关联。每一批次实时数据的注入，都会触发状态引擎的计算，并输出因子值到结果表result。以下代码产生随机数据，并注入到流数据表。结果与通过SQL语句计算的结果完全相同。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;data = table(take(&#34;A&#34;, 100) as sym, rand(10.0, 100) as price) tickStream.append!(data) factor1Hist = select sym, ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20) as factor1 from data context by sym assert each(eqObj, result.values(), factor1Hist.values())&lt;/codeblock&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-工作原理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.1. 工作原理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;61:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;63:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;如图1所示，一个有状态的高频因子计算过程可以分解成有一个有向无环图（DAG）。图中的节点有3种：（1）数据源，如price（2）有状态的算子，如a, b, d, e （3）无状态的算子，如c和result。从数据源节点开始，按照既定的路径，层层推进，得到最后的因子输出。这非常类似excel中的单元格链式计算。当一个单元格的数据发生变化时，相关联的单元格依次发生变化。响应式状态引擎的名称也是从这一点引申出来的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;65:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;无状态的算子比较简单，使用DolphinDB已有的脚本引擎，就可以表示和计算。因此，问题转化为两点：（1）如何解析得到一个优化的DAG，（2）如何优化每个有状态的算子的计算。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-解析和优化&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.2. 解析和优化&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;67:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;69:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;DolphinDB的脚本语言是支持向量化和函数化的多范式编程语言。通过函数的调用关系，不难得到计算步骤的DAG。在解析的时候，因为输入消息的schema是已知的，我们可以快速推断出每一个节点的输入数据类型和输出数据类型。输入参数类型确定，函数名称确定，每个状态算子的具体实例就可以创建出来。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;每一个算子（有状态和无状态）在DolphinDB中都可以转化为一个唯一的字符串序列。据此，我们可以删除重复的算子，提高计算效率。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-内置的状态函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.3. 内置的状态函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;状态算子计算时需要用到历史状态。如果每一次计算都使用全量数据，性能不佳。状态函数的优化，也就是增量方式的流式实现非常关键。下列状态函数在 DolphinDB 的响应式状态引擎中的实现均得到了优化。目前，状态引擎不允许使用未经优化的状态函数，且需避免使用聚合函数。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;77:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;77:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;累计窗口函数：cumavg, cumsum, cumprod, cumcount, cummin, cummax, cumvar, cumvarp, cumstd, cumstdp, cumcorr, cumcovar, cumbeta, cumwsum, cumwavg, cumfirstNot, cumlastNot, cummed, cumpercentile, cumPositiveStreak&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;78:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;滑动窗口函数：ema, mavg, msum, mcount, mprod, mvar, mvarp, mstd, mstdp, mskew, mkurtosis, mmin, mmax, mimin, mimax, mmed, mpercentile, mrank, mcorr, mcovar, mbeta, mwsum, mwavg, mmad, mfirst, mlast, mmaxPositiveStreak, mslr, tmove, tmfirst, tmlast, tmsum, tmavg, tmcount, tmvar, tmvarp, tmstd, tmstdp, tmprod, tmskew, tmkurtosis, tmmin, tmmax, tmmed, tmpercentile, tmrank, tmcovar, tmbeta, tmcorr, tmwavg, tmwsum, tmoving, moving, sma,wma, dema, tema, trima, linearTimeTrend, talib, t3, ma, mmaxPostiveStreak&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;79:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;序列相关函数：deltas, ratios, ffill, move, prev, iterate, ewmMean, ewmVar, ewmStd, ewmCov, ewmCorr, prevState&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;80:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;topN相关函数：msumTopN, mavgTopN, mstdpTopN, mstdTopN, mvarpTopN, mvarTopN, mcorrTopN, mbetaTopN, mcovarTopN, mwsumTopN&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;81:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;高阶函数：segmentby(参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;81:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;func&lt;/i&gt; 暂支持 cumsum, cummax, cummin, cumcount, cumavg, cumstd, cumvar, cumstdp, cumvarp)&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;82:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;其他函数：talibNull, dynamicGroupCumsum, dynamicGroupCumcount, topRange, lowRange, trueRange&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;84:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;注意，talib 作为状态函数时，第一个参数 func 只能是响应式状态引擎支持的状态函数。在后续的版本中，DolphinDB将允许用户用插件来开发自己的状态函数，注册后即可在状态引擎中使用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-自定义状态函数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.4. 自定义状态函数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;86:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎中可使用自定义状态函数。需要注意以下几点：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;函数定义前，使用 @state 表示函数是自定义的状态函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;91:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;自定义状态函数中只能使用赋值语句和return语句。return语句必须是最后一个语句，可返回多个值。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;使用iif函数表示if...else的逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;94:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;如果仅允许使用一个表达式来表示一个因子，会带来很多局限性。首先，在某些情况下，仅使用表达式，无法实现一个完整的因子。下面的例子返回线性回归的alpha，beta和residual。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;96:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;@state def slr(y, x){ alpha, beta = mslr(y, x, 12) residual = mavg(y, 12) - beta * mavg(x, 12) - alpha return alpha, beta, residual }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;105:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;其次，很多因子可能会使用共同的中间结果，定义多个因子时，代码会更简洁。自定义函数可以同时返回多个结果。下面的函数multiFactors定义了5个因子。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;107:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;@state def multiFactors(lowPrice, highPrice, volumeTrade, closePrice, buy_active, sell_active, tradePrice, askPrice1, bidPrice1, askPrice10, agg_vol, agg_amt){ a = ema(askPrice10, 30) term0 = ema((lowPrice - a) / (ema(highPrice, 30) - a), 50) term1 = mrank((highPrice - a) / (ema(highPrice, 5) - a), true, 15) term2 = mcorr(askPrice10, volumeTrade, 10) * mrank(mstd(closePrice, 20, 20), true, 10) buy_vol_ma = mavg(buy_active, 6) sell_vol_ma = mavg(sell_active, 6) zero_free_vol = iif(agg_vol==0, 1, agg_vol) stl_prc = ffill(agg_amt \ zero_free_vol \ 20).nullFill(tradePrice) buy_prop = stl_prc spd = askPrice1 - bidPrice1 spd_ma = round(mavg(iif(spd &amp;lt; 0, 0, spd), 6), 5) term3 = buy_prop * spd_ma term4 = iif(spd_ma == 0, 0, buy_prop / spd_ma) return term0, term1, term2, term3, term4 }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;128:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;最后，某些表达式冗长，缺乏可读性。第一节中的因子表达式改为下面的自定义状态函数factor1后，计算逻辑简洁明了。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;130:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;@state def factor1(price) { a = ema(price, 20) b = ema(price, 40) c = 1000 * sum_diff(a, b) return ema(c, 10) - ema(c, 20) }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-输出结果过滤&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.5. 输出结果过滤&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;140:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;142:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;状态引擎会对输入的每一条消息做出计算响应，产生一条记录作为结果，计算的结果在默认情况下都会输出到结果表，也就是说输入n个消息，输出n条记录。如果希望仅输出一部分结果，可以启用过滤条件，只有满足条件的结果才会输出。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;下面的例子检查股票价格是否有变化，只有价格变化的记录才会输出。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;145:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream result = table(1000:0, `sym`price, [STRING,DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveFilter&#34;, metrics =[&amp;lt;price&amp;gt;], dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;, filter=&amp;lt;prev(price) != price&amp;gt;) subscribeTable(tableName=`tickStream, actionName=&#34;filter&#34;, handler=tableInsert{rse})&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;36-快照机制&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.6. 快照机制&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;为了满足生产环境业务持续性的需要，DolphinDB内置的流式计算引擎包括响应式状态引擎均支持快照（snapshot）输出。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;156:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎的快照包括已处理的最后一条消息的ID以及引擎当前的状态（中间计算结果）。当系统出现异常，重新初始化状态引擎时，可恢复到最后一个快照的状态，并且从已处理的消息的下一条开始订阅。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&amp;gt; share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream result = table(1000:0, `sym`factor1, [STRING,DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;, snapshotDir= &#34;/home/data/snapshot&#34;, snapshotIntervalInMsgCount=400000) msgId = getSnapshotMsgId(rse) if(msgId &amp;gt;= 0) msgId += 1 subscribeTable(tableName=`tickStream, actionName=&#34;factors&#34;, offset=msgId, handler=appendMsg{rse}, handlerNeedMsgId=true)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;171:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎要启用快照机制，创建时需要指定两个额外的参数snapshotDir和snapshotIntervalInMsgCount。snapshotDir用于指定存储快照的目录。snapshotIntervalInMsgCount指定处理多少条消息后产生一个快照。引擎初始化时，系统会检查快照目录下是否存在一个以引擎名称命名，后缀为snapshot的文件。以上面的代码为例，如果存在文件/home/data/snapshot/reactiveDemo.snapshot，加载这个快照。函数getSnapshotMsgId可以获取最近一个快照对应的msgId。如果不存在快照，返回-1。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;状态引擎要启用快照机制，调用subscribeTable函数也需相应的修改：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;首先必须指定消息的offset。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;其次，handler必须使用appendMsg函数。appendMsg函数接受两个参数，msgBody和msgId。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;再次，参数handlerNeedMsgId必须指定为true。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;37-并行处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;179:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;179:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;3.7. 并行处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;179:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;181:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;当需要处理大量消息时，可在DolphinDB消息订阅函数&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;181:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;subscribeTable&lt;/codeph&gt;中指定可选参数filter与hash，让多个订阅客户端并行处理消息。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;参数filter用于指定消息过滤逻辑。目前支持三种过滤方式，分别为值过滤，范围过滤和哈希过滤。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;183:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;参数hash可以指定一个哈希值，确定这个订阅由哪个线程来执行。例如，配置参数subExecutors为4，用户指定了哈希值5，那么该订阅的计算任务将由第二个线程来执行。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;185:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;下面是响应式状态引擎并行计算因子的例子。假设配置参数subExecutors=4，创建4个状态引擎，每个状态引擎根据流表的股票代码的哈希值来订阅不同股票的数据，并且指定不同的订阅线程来处理，最终将结果输出到同一个输出表中。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;187:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&amp;gt; share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream setStreamTableFilterColumn(tickStream, `sym) share streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream for(i in 0..3){ rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;+string(i), metrics =factor1, dummyTable=tickStream, outputTable=resultStream, keyColumn=&#34;sym&#34;) subscribeTable(tableName=`tickStream, actionName=&#34;sub&#34;+string(i), handler=tableInsert{rse}, msgAsTable = true, hash = i, filter = (4,i)) } n=2000000 tmp = table(take(&#34;A&#34;+string(1..4000), n) as sym, rand(10.0, n) as price) tickStream.append!(tmp)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;需要注意的是，如果多个状态引擎是同一个输出表，该输出表必须是一个共享表。没有共享的表不是线程安全的，并行写入可能会导致系统崩溃。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-流批统一解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;4. 流批统一解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;金融高频因子的流批统一处理在DolphinDB中有两种实现方法。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;第一种方法，使用函数或表达式实现金融高频因子，代入不同的计算引擎进行历史数据或流数据的计算。代入SQL引擎，可以实现对历史数据的计算；代入响应式状态引擎，可以实现对流数据的计算。这在第3章的序言部分已经举例说明。在这种模式下用DolphinDB脚本语言表示的表达式或函数实际上是对因子语义的一种描述，而不是具体的实现。因子计算的具体实现交由相应的计算引擎来完成，从而实现不同场景下的最佳性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;第二种方法，历史数据通过回放，转变成流数据，然后使用流数据计算引擎来完成计算。我们仍然以教程开始部分的因子为例，唯一的区别是流数据表tickStream的数据源来自于历史数据库的replay。使用这种方法计算历史数据的因子值，效率不高是一个缺点。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;216:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;def sum_diff(x, y){ return (x-y)/(x+y) } factor1 = &amp;lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) - ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&amp;gt; share streamTable(1:0, `sym`date`time`price, [STRING,DATE,TIME,DOUBLE]) as tickStream result = table(1000:0, `sym`factor1, [STRING,DOUBLE]) rse = createReactiveStateEngine(name=&#34;reactiveDemo&#34;, metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn=&#34;sym&#34;) subscribeTable(tableName=`tickStream, actionName=&#34;factors&#34;, handler=tableInsert{rse}) //从历史数据库dfs://TAQ的trades表中加载一天的数据，回放到流数据表tickStream中 inputDS = replayDS(&amp;lt;select sym, date, time, price from loadTable(&#34;dfs://TAQ&#34;, &#34;trades&#34;) where date=2021.03.08&amp;gt;, `date, `time, 08:00:00.000 + (1..10) * 3600000) replay(inputDS, tickStream, `date, `time, 1000, true, 2)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-性能测试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;5. 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;234:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;我们测试了响应式状态引擎计算因子的性能。测试使用模拟数据，并使用warmupStreamEngine函数模拟状态引擎已经处理部分数据的情况。测试共包括20个不同复杂度度的因子，其中两个自定义状态函数分别返回3个和5个因子。为方便测试，计算仅使用单线程处理。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;@state def slr(y, x){ alpha, beta = mslr(y, x, 12) residual = mavg(y, 12) - beta * mavg(x, 12) - alpha return alpha, beta, residual } @state def multiFactors(lowPrice, highPrice, volumeTrade, closePrice, buy_active, sell_active, tradePrice, askPrice1, bidPrice1, askPrice10, agg_vol, agg_amt){ a = ema(askPrice10, 30) term0 = ema((lowPrice - a) / (ema(highPrice, 30) - a), 50) term1 = mrank((highPrice - a) / (ema(highPrice, 5) - a), true, 15) term2 = mcorr(askPrice10, volumeTrade, 10) * mrank(mstd(closePrice, 20, 20), true, 10) buy_vol_ma = mavg(buy_active, 6) sell_vol_ma = mavg(sell_active, 6) zero_free_vol = iif(agg_vol==0, 1, agg_vol) stl_prc = ffill(agg_amt \ zero_free_vol \ 20).nullFill(tradePrice) buy_prop = stl_prc spd = askPrice1 - bidPrice1 spd_ma = round(mavg(iif(spd &amp;lt; 0, 0, spd), 6), 5) term3 = buy_prop * spd_ma term4 = iif(spd_ma == 0, 0, buy_prop / spd_ma) return term0, term1, term2, term3, term4 } metrics = array(ANY, 14) metrics[0] = &amp;lt;ema(1000 * sum_diff(ema(close, 20), ema(close, 40)),10) - ema(1000 * sum_diff(ema(close, 20), ema(close, 40)), 20)&amp;gt; metrics[1] = &amp;lt;mslr(high, volume, 8)[1]&amp;gt; metrics[2] = &amp;lt;mcorr(low, high, 11)&amp;gt; metrics[3] = &amp;lt;mstdp(low, 15)&amp;gt; metrics[4] = &amp;lt;mbeta(high, value, 63)&amp;gt; metrics[5] = &amp;lt;mcovar(low, value, 71)&amp;gt; metrics[6] = &amp;lt;(close/mavg(close, 1..6)-1)*100&amp;gt; metrics[7] = &amp;lt;mmin(high, 15)&amp;gt; metrics[8] = &amp;lt;mavg(((high+low)/2+(mavg(high, 2)+mavg(low, 2))/2)*(high-low)/volume, 7, 2)&amp;gt; metrics[9] = &amp;lt;mslr(mavg(close, 14), volume, 63)[1]&amp;gt; metrics[10] = &amp;lt;mcorr(mavg(open, 25), volume, 71)&amp;gt; metrics[11] = &amp;lt;mbeta(high, mstdp(close, 8), 77)&amp;gt; metrics[12] = &amp;lt;slr(close, volume)&amp;gt; metrics[13] = &amp;lt;multiFactors(low, high, volume, close, numTrade, numTrade, close, value, close, open, volume, numTrade)&amp;gt; dummy = streamTable(10000:0, `symbol`market`date`time`quote_type`preclose`open`high`low`close`numTrade`volume`value`position`recvtime,[SYMBOL,SHORT,DATE,TIME,SHORT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,LONG,TIMESTAMP]) def prepareData(tickNum, batch){ total = tickNum*batch data=table(total:total, `symbol`market`date`time`quote_type`preclose`open`high`low`close`numTrade`volume`value`position`recvtime,[SYMBOL,SHORT,DATE,TIME,SHORT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,LONG,TIMESTAMP]) data[`market]=rand(10, total) data[`date]=take(date(now()), total) data[`time]=take(time(now()), total) data[`symbol]=take(&#34;A&#34;+string(1..tickNum), total) data[`open]=rand(100.0, total) data[`high]=rand(100.0, total) data[`low]=rand(100.0, total) data[`close]=rand(100.0, total) data[`numTrade]=rand(100, total) data[`volume]=rand(100, total) data[`value]=rand(100.0, total) data[`recvtime]=take(now(), total) return data } dropStreamEngine(&#34;demo1&#34;) dropStreamEngine(&#34;demo2&#34;) dropStreamEngine(&#34;demo3&#34;) dropStreamEngine(&#34;demo4&#34;) //4000个股票，20个因子 hisData = prepareData(4000, 100) realData = prepareData(4000, 1) colNames = [&#34;symbol&#34;].append!(&#34;factor&#34;+string(0..19)) colTypes = [SYMBOL].append!(take(DOUBLE, 20)) resultTable = streamTable(10000:0, colNames, colTypes) engine1 = createReactiveStateEngine(name=&#34;demo1&#34;, metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn=&#34;symbol&#34;) warmupStreamEngine(engine1, hisData) timer(10) engine1.append!(realData) dropAggregator(&#34;demo1&#34;) //1个股票，20个因子 hisData = prepareData(1, 100) realData = prepareData(1, 1) colNames = [&#34;symbol&#34;].append!(&#34;factor&#34;+string(0..19)) colTypes = [SYMBOL].append!(take(DOUBLE, 20)) resultTable = streamTable(10000:0, colNames, colTypes) engine2 = createReactiveStateEngine(name=&#34;demo2&#34;, metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn=&#34;symbol&#34;) warmupStreamEngine(engine2, hisData) timer(10) engine2.append!(realData) dropAggregator(&#34;demo2&#34;) //4000个股票，1个因子 hisData = prepareData(4000, 100) realData = prepareData(4000, 1) metrics3 = metrics[0] colNames = [&#34;symbol&#34;, &#34;factor0&#34;] colTypes = [SYMBOL, DOUBLE] resultTable = streamTable(10000:0, colNames, colTypes) engine3 = createReactiveStateEngine(name=&#34;demo3&#34;, metrics=metrics3, dummyTable=dummy, outputTable=resultTable, keyColumn=&#34;symbol&#34;) warmupStreamEngine(engine3, hisData) timer(10) engine3.append!(realData) //200个股票，20个因子 hisData = prepareData(200, 100) realData = prepareData(200, 1) colNames = [&#34;symbol&#34;].append!(&#34;factor&#34;+string(0..19)) colTypes = [SYMBOL].append!(take(DOUBLE, 20)) resultTable = streamTable(10000:0, colNames, colTypes) engine4 = createReactiveStateEngine(name=&#34;demo4&#34;, metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn=&#34;symbol&#34;) warmupStreamEngine(engine4, hisData) timer(10) engine4.append!(realData) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;349:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;我们统计了10次的总耗时，取平均值作为单次的耗时。测试使用的服务器CPU为Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz。单线程情况下，测试结果如下：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;3&#34; xtrc=&#34;tgroup:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;351:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;股票个数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;351:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;因子个数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;351:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;耗时(单位:ms)&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:4;353:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;4000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:5;353:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:6;353:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;6&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:7;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:8;354:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:9;354:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;0.07&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;355:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:10;355:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;4000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:11;355:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;1&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:12;355:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;0.8&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:13;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;200&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:14;356:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;20&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:15;356:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;0.2&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-多个引擎的流水线处理&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;6. 多个引擎的流水线处理&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;360:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;DolphinDB内置的流计算引擎包括响应式状态引擎，时间序列聚合引擎，横截面引擎和异常检测引擎。这些引擎均实现了数据表（table）的接口，因此多个引擎流水线处理变得异常简单，只要将后一个引擎作为前一个引擎的输出即可。引入流水线处理，可以解决更为复杂的因子计算问题。譬如，因子计算经常需要使用面板数据，完成时间序列和横截面两个维度的计算，只要把响应式状态引擎和横截面两个引擎串联处理即可完成。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;362:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;下面的例子是World Quant 101个Alpha因子中的1号因子公式的流数据实现。rank函数是一个横截面操作。rank的参数部分用响应式状态引擎实现。rank函数本身用横截面引擎实现。横截面引擎作为状态引擎的输出。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;363:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;Alpha#001公式：rank(Ts_ArgMax(SignedPower((returns&amp;lt;0?stddev(returns,20):close), 2), 5))-0.5 //创建横截面引擎，计算每个股票的rank dummy = table(1:0, `sym`time`maxIndex, [SYMBOL, TIMESTAMP, DOUBLE]) resultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE]) ccsRank = createCrossSectionalAggregator(name=&#34;alpha1CCS&#34;, metrics=&amp;lt;[sym, rank(maxIndex, percent=true) - 0.5]&amp;gt;, dummyTable=dummy, outputTable=resultTable, keyColumn=`sym, triggeringPattern='keyCount', triggeringInterval=3000, timeColumn=`time) @state def wqAlpha1TS(close){ ret = ratios(close) - 1 v = iif(ret &amp;lt; 0, mstd(ret, 20), close) return mimax(signum(v)*v*v, 5) } //创建响应式状态引擎，输出到前面的横截面引擎ccsRank input = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE]) rse = createReactiveStateEngine(name=&#34;alpha1&#34;, metrics=&amp;lt;[time, wqAlpha1TS(close)]&amp;gt;, dummyTable=input, outputTable=ccsRank, keyColumn=&#34;sym&#34;) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;383:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;流水线处理（也称为引擎多级级联）和多个流数据表的级联处理有很大的区别。两者可以完成相同的任务，但是效率上有很大的区别。后者涉及多个流数据表与多次订阅。前者实际上只有一次订阅，所有的计算均在一个线程中依次顺序完成，因而有更好的性能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;385:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;上面的例子是由用户来区分哪一部分是横截面操作，哪一部分是时间序列操作以实现多个引擎的流水线。在1.30.16/2.00.4及之后的版本中，新增函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;385:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;streamEngineParser&lt;/codeph&gt;，支持将metrics自动分解成多个内置流计算引擎的流水线。在&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;385:126&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;streamEngineParser&lt;/codeph&gt;中以行函数（rowRank，rowSum等）表示横截面操作的语义，以rolling函数表示时间序列操作，从而系统能够自动识别一个因子中的横截面操作和时间序列操作，进一步自动构建引擎流水线。因此，上述因子可以用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;385:250&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;streamEngineParser&lt;/codeph&gt;更简洁的实现，metrics几乎等同于因子的数学公式表达，而不需要考虑不同类型引擎的选择：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;387:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;@state def wqAlpha1TS(close){ ret = ratios(close) - 1 v = iif(ret &amp;lt; 0, mstd(ret, 20), close) return mimax(signum(v)*v*v, 5) } //构建计算因子 metrics=&amp;lt;[sym, rowRank(wqAlpha1TS(close), percent=true)- 0.5]&amp;gt; streamEngine=streamEngineParser(name=&#34;alpha1_parser&#34;, metrics=metrics, dummyTable=input, outputTable=resultTable, keyColumn=`sym, timeColumn=`time, triggeringPattern='keyCount', triggeringInterval=3000)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-展望&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;401:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;401:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;7. 展望&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;401:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;403:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;响应式状态引擎内置了大量常用的状态算子，支持自定义状态函数，也可与其他流式计算引擎以流水线的方式任意组合，方便开发人员快速实现复杂的金融高频因子。后续的版本中，将开放接口允许用户用C++插件开发状态函数，满足定制的需要。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;405:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/reactive_state_engine.md&#34;&gt;内置的状态算子全部使用C++开发实现，算法上经过了大量的优化，以增量方式实现状态算子的流式计算，因而在单个线程上的计算达到了非常好的性能。对于规模较大的任务，可以通过订阅过滤的方式，拆分成多个子订阅，由多个节点以及每个节点的多个CPU并行完成订阅计算。后续的版本将完善计算子作业的创建、管理和监控功能，从手动转变为自动。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/reactive_state_engine.md"/><meta name="wh-out-relpath" content="tutorials/reactive_state_engine.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="响应式状态引擎" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html">流数据</a></div></div></li><li class="active"><div class="topicref" data-id="响应式状态引擎"><div class="title"><a href="../tutorials/reactive_state_engine.html">响应式状态引擎</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e100449" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="多数据源流式实时关联处理-d9713e100449-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="流数据引擎解析器-d9713e100495" class="topicref" data-id="流数据引擎解析器" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/StreamEngineParser.html" id="流数据引擎解析器-d9713e100495-link">流数据引擎解析器</a></div></div></li><li role="treeitem"><div data-tocid="流数据高可用-d9713e100541" class="topicref" data-id="流数据高可用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haStreaming.html" id="流数据高可用-d9713e100541-link">流数据高可用</a></div></div></li><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e100587" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub_2.html" id="节点启动时的流计算自动订阅-d9713e100587-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎入门初级高频量价因子策略的实现-d9713e100633" class="topicref" data-id="cep-引擎入门初级高频量价因子策略的实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/getting_started_with_cep_engine.html" id="cep-引擎入门初级高频量价因子策略的实现-d9713e100633-link">CEP 引擎入门：初级高频量价因子策略的实现</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679" class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html" id="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679-link">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li><li role="treeitem"><div data-tocid="流计算时延统计与性能优化-d9713e100725" class="topicref" data-id="流计算时延统计与性能优化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_timer.html" id="流计算时延统计与性能优化-d9713e100725-link">流计算时延统计与性能优化</a></div></div></li><li role="treeitem" class="active"><div data-tocid="响应式状态引擎-d9713e100771" class="topicref" data-id="响应式状态引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/reactive_state_engine.html" id="响应式状态引擎-d9713e100771-link">响应式状态引擎</a></div></div></li><li role="treeitem"><div data-tocid="流数据功能应用-d9713e100817" class="topicref" data-id="流数据功能应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_tutorial.html" id="流数据功能应用-d9713e100817-link">流数据功能应用</a></div></div></li><li role="treeitem"><div data-tocid="数据回放-d9713e100863" class="topicref" data-id="数据回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_replay.html" id="数据回放-d9713e100863-link">数据回放</a></div></div></li><li role="treeitem"><div data-tocid="使用-dolphindb-class-来开发流计算状态算子-d9713e100909" class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stateful_stream_operators.html" id="使用-dolphindb-class-来开发流计算状态算子-d9713e100909-link">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">响应式状态引擎</h1><div class="- topic/body body"><p class="- topic/p p">量化金融的研究和实盘中，越来越多的机构需要根据高频的行情数据（L1/L2以及逐笔委托数据）来计算量价因子，每只股票的每一条新数据的注入都会更新该只股票的所有因子值。这些因子通常是有状态的：不仅与当前的多个指标有关，而且与多个指标的历史状态相关。以国内的股票市场为例，每3秒收到一个快照，每个股票每天4800个快照，计算因子时可能会用到之前若干个快照的数据，甚至之前若干天的数据。绝大多数机构的研发环境系统（例如Python）与生产环境系统（例如C++）不同，要维护两套代码，是非常沉重的负担。</p><p class="- topic/p p">本教程介绍如何使用DolphinDB 1.30.3版本发布的响应式状态引擎（Reactive State Engine），实现流批统一计算带有状态的高频因子。状态引擎接受在历史数据批量处理（研发阶段）中编写的表达式或函数作为输入进行流式计算，并确保流式计算的结果与批量计算完全一致。只要在历史数据的批量计算中验证正确，即可保证流数据的实时计算正确。这避免了在生产环境中重写研发代码的高额成本，以及维护研发和生产两套代码的负担。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-金融高频因子计算示例"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 金融高频因子计算示例</h2><div class="- topic/body body"><p class="- topic/p p">本节通过一个金融高频因子计算的示例，介绍高频因子计算中的挑战。以下的因子表达式以DolphinDB脚本语言编写，使用了用户自定义函数<code class="+ topic/ph pr-d/codeph ph codeph">sum\_diff</code>和内置函数<code class="+ topic/ph pr-d/codeph ph codeph">ema</code> (exponential moving average)。<code class="+ topic/ph pr-d/codeph ph codeph">sum_diff</code>是一个无状态函数，<code class="+ topic/ph pr-d/codeph ph codeph">ema</code>是一个有状态的函数，依赖历史数据。更为棘手的是，如以下计算分解图所示，需要使用<code class="+ topic/ph pr-d/codeph ph codeph">ema</code>函数的多重嵌套。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}

ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)</code></pre><br/><img class="- topic/image image" src="images/hf_factor_demo.png" alt="image"/><br/><p class="- topic/p p">面对此类场景，我们需要解决以下几个问题：</p><ul class="- topic/ul ul"><li class="- topic/li li">投研阶段能否使用历史数据快速为每只股票计算100~1000个类似的因子？</li><li class="- topic/li li">实盘阶段能否在每个行情tick数据到来时为每只股票计算100~1000个类似的因子？</li><li class="- topic/li li">批处理和流计算的代码实现是否高效？批和流能否统一代码？正确性校验是否便捷？</li></ul></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="2-现有解决方案的优缺点"><h2 class="- topic/title title topictitle2" id="ariaid-title3">2. 现有解决方案的优缺点</h2><div class="- topic/body body"><p class="- topic/p p">Python pandas/numpy目前是研究阶段最常用的高频因子解决方案。pandas对历史面板数据处理有非常成熟的解决方案，而且内置了大部分高频因子计算需要用到的算子，可快速开发高频因子。但pandas无论对历史数据计算，还是对实时数据计算的性能都较差。对历史数据计算时，单线程的计算性能也存在较大提升空间，此外，由于python的Global interpreter lock的限制，无法进行并行计算；对实时数据进行计算时，由于python仅支持全量计算，不支持增量计算，所以无法达到实时计算的性能要求。</p><p class="- topic/p p">为生产环境中的性能考虑，很多机构会用C++重新实现研究（历史数据）代码。不过，这种方法需要维护两套代码，开发成本（时间和人力）会大幅增加。此外，还要耗费大量精力确保两套系统的结果完全一致。</p><p class="- topic/p p">Flink是一种批流统一的解决方案。Flink支持SQL和窗口函数，高频因子用到的基本算子在Flink中已经内置实现。因此，简单的因子用Flink实现比较高效，运行性能也较好。但Flink最大的问题是无法实现复杂的高频因子计算。如前一章中提到的例子，需要多个窗口函数的嵌套，无法直接用Flink实现。这也正是DolphinDB开发响应式状态引擎的动机所在。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="3-响应式状态引擎reactive-state-engine"><h2 class="- topic/title title topictitle2" id="ariaid-title4">3. 响应式状态引擎（Reactive State Engine)</h2><div class="- topic/body body"><p class="- topic/p p">响应式状态引擎实际上是一个计算黑盒，输入在历史数据上已经验证的DolphinDB因子代码（表达式或函数）以及实时行情数据，输出实时因子值。由于在静态的历史数据集上开发和验证高频因子远比在流数据上开发更为简单，响应式状态引擎显著降低了流式高频因子的开发成本和难度。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&gt;

share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream
result = table(1000:0, `sym`factor1, [STRING,DOUBLE])
rse = createReactiveStateEngine(name="reactiveDemo", metrics=factor1, dummyTable=tickStream, outputTable=result, keyColumn="sym")
subscribeTable(tableName=`tickStream, actionName="factors", handler=tableInsert{rse})</code></pre><p class="- topic/p p">以上代码在DolphinDB中实现前述因子的流式计算。factor1是前述因子在历史数据上的实现，不做任何改变，直接传递给响应式状态引擎rse，即可实现流式计算。通过订阅函数<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>，将流数据表tickStream与状态引擎rse进行关联。每一批次实时数据的注入，都会触发状态引擎的计算，并输出因子值到结果表result。以下代码产生随机数据，并注入到流数据表。结果与通过SQL语句计算的结果完全相同。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>data = table(take("A", 100) as sym, rand(10.0, 100) as price)
tickStream.append!(data)
factor1Hist = select sym, ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20) as factor1 from data context by sym
assert each(eqObj, result.values(), factor1Hist.values())</code></pre></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="31-工作原理"><h3 class="- topic/title title topictitle3" id="ariaid-title5">3.1. 工作原理</h3><div class="- topic/body body"><p class="- topic/p p">如图1所示，一个有状态的高频因子计算过程可以分解成有一个有向无环图（DAG）。图中的节点有3种：（1）数据源，如price（2）有状态的算子，如a, b, d, e （3）无状态的算子，如c和result。从数据源节点开始，按照既定的路径，层层推进，得到最后的因子输出。这非常类似excel中的单元格链式计算。当一个单元格的数据发生变化时，相关联的单元格依次发生变化。响应式状态引擎的名称也是从这一点引申出来的。</p><p class="- topic/p p">无状态的算子比较简单，使用DolphinDB已有的脚本引擎，就可以表示和计算。因此，问题转化为两点：（1）如何解析得到一个优化的DAG，（2）如何优化每个有状态的算子的计算。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="32-解析和优化"><h3 class="- topic/title title topictitle3" id="ariaid-title6">3.2. 解析和优化</h3><div class="- topic/body body"><p class="- topic/p p">DolphinDB的脚本语言是支持向量化和函数化的多范式编程语言。通过函数的调用关系，不难得到计算步骤的DAG。在解析的时候，因为输入消息的schema是已知的，我们可以快速推断出每一个节点的输入数据类型和输出数据类型。输入参数类型确定，函数名称确定，每个状态算子的具体实例就可以创建出来。</p><p class="- topic/p p">每一个算子（有状态和无状态）在DolphinDB中都可以转化为一个唯一的字符串序列。据此，我们可以删除重复的算子，提高计算效率。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="33-内置的状态函数"><h3 class="- topic/title title topictitle3" id="ariaid-title7">3.3. 内置的状态函数</h3><div class="- topic/body body"><p class="- topic/p p">状态算子计算时需要用到历史状态。如果每一次计算都使用全量数据，性能不佳。状态函数的优化，也就是增量方式的流式实现非常关键。下列状态函数在 DolphinDB 的响应式状态引擎中的实现均得到了优化。目前，状态引擎不允许使用未经优化的状态函数，且需避免使用聚合函数。</p><ul class="- topic/ul ul"><li class="- topic/li li">累计窗口函数：cumavg, cumsum, cumprod, cumcount, cummin, cummax, cumvar, cumvarp, cumstd, cumstdp, cumcorr, cumcovar, cumbeta, cumwsum, cumwavg, cumfirstNot, cumlastNot, cummed, cumpercentile, cumPositiveStreak</li><li class="- topic/li li">滑动窗口函数：ema, mavg, msum, mcount, mprod, mvar, mvarp, mstd, mstdp, mskew, mkurtosis, mmin, mmax, mimin, mimax, mmed, mpercentile, mrank, mcorr, mcovar, mbeta, mwsum, mwavg, mmad, mfirst, mlast, mmaxPositiveStreak, mslr, tmove, tmfirst, tmlast, tmsum, tmavg, tmcount, tmvar, tmvarp, tmstd, tmstdp, tmprod, tmskew, tmkurtosis, tmmin, tmmax, tmmed, tmpercentile, tmrank, tmcovar, tmbeta, tmcorr, tmwavg, tmwsum, tmoving, moving, sma,wma, dema, tema, trima, linearTimeTrend, talib, t3, ma, mmaxPostiveStreak</li><li class="- topic/li li">序列相关函数：deltas, ratios, ffill, move, prev, iterate, ewmMean, ewmVar, ewmStd, ewmCov, ewmCorr, prevState</li><li class="- topic/li li">topN相关函数：msumTopN, mavgTopN, mstdpTopN, mstdTopN, mvarpTopN, mvarTopN, mcorrTopN, mbetaTopN, mcovarTopN, mwsumTopN</li><li class="- topic/li li">高阶函数：segmentby(参数 <em class="+ topic/ph hi-d/i ph i">func</em> 暂支持 cumsum, cummax, cummin, cumcount, cumavg, cumstd, cumvar, cumstdp, cumvarp)</li><li class="- topic/li li">其他函数：talibNull, dynamicGroupCumsum, dynamicGroupCumcount, topRange, lowRange, trueRange</li></ul><p class="- topic/p p">注意，talib 作为状态函数时，第一个参数 func 只能是响应式状态引擎支持的状态函数。在后续的版本中，DolphinDB将允许用户用插件来开发自己的状态函数，注册后即可在状态引擎中使用。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="34-自定义状态函数"><h3 class="- topic/title title topictitle3" id="ariaid-title8">3.4. 自定义状态函数</h3><div class="- topic/body body"><p class="- topic/p p">响应式状态引擎中可使用自定义状态函数。需要注意以下几点：</p><ul class="- topic/ul ul"><li class="- topic/li li">函数定义前，使用 @state 表示函数是自定义的状态函数。</li><li class="- topic/li li">自定义状态函数中只能使用赋值语句和return语句。return语句必须是最后一个语句，可返回多个值。</li><li class="- topic/li li">使用iif函数表示if...else的逻辑。</li></ul><p class="- topic/p p">如果仅允许使用一个表达式来表示一个因子，会带来很多局限性。首先，在某些情况下，仅使用表达式，无法实现一个完整的因子。下面的例子返回线性回归的alpha，beta和residual。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def slr(y, x){
    alpha, beta = mslr(y, x, 12)
    residual = mavg(y, 12) - beta * mavg(x, 12) - alpha
    return alpha, beta, residual
}</code></pre><p class="- topic/p p">其次，很多因子可能会使用共同的中间结果，定义多个因子时，代码会更简洁。自定义函数可以同时返回多个结果。下面的函数multiFactors定义了5个因子。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def multiFactors(lowPrice, highPrice, volumeTrade, closePrice, buy_active, sell_active, tradePrice, askPrice1, bidPrice1, askPrice10, agg_vol, agg_amt){
    a = ema(askPrice10, 30)
    term0 = ema((lowPrice - a) / (ema(highPrice, 30) - a), 50)
    term1 = mrank((highPrice - a) / (ema(highPrice, 5) - a), true,  15)
    term2 = mcorr(askPrice10, volumeTrade, 10) * mrank(mstd(closePrice, 20, 20), true, 10)
    buy_vol_ma = mavg(buy_active, 6)
    sell_vol_ma = mavg(sell_active, 6)
    zero_free_vol = iif(agg_vol==0, 1, agg_vol)
    stl_prc = ffill(agg_amt \ zero_free_vol \ 20).nullFill(tradePrice)
    buy_prop = stl_prc
	
    spd = askPrice1 - bidPrice1
    spd_ma = round(mavg(iif(spd &lt; 0, 0, spd), 6), 5)
    term3 = buy_prop * spd_ma
    term4 = iif(spd_ma == 0, 0, buy_prop / spd_ma)
    return term0, term1, term2, term3, term4
}</code></pre><p class="- topic/p p">最后，某些表达式冗长，缺乏可读性。第一节中的因子表达式改为下面的自定义状态函数factor1后，计算逻辑简洁明了。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def factor1(price) {
    a = ema(price, 20)
    b = ema(price, 40)
    c = 1000 * sum_diff(a, b)
    return  ema(c, 10) - ema(c, 20)
}</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="35-输出结果过滤"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.5. 输出结果过滤</h3><div class="- topic/body body"><p class="- topic/p p">状态引擎会对输入的每一条消息做出计算响应，产生一条记录作为结果，计算的结果在默认情况下都会输出到结果表，也就是说输入n个消息，输出n条记录。如果希望仅输出一部分结果，可以启用过滤条件，只有满足条件的结果才会输出。</p><p class="- topic/p p">下面的例子检查股票价格是否有变化，只有价格变化的记录才会输出。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream
result = table(1000:0, `sym`price, [STRING,DOUBLE])
rse = createReactiveStateEngine(name="reactiveFilter", metrics =[&lt;price&gt;], dummyTable=tickStream, outputTable=result, keyColumn="sym", filter=&lt;prev(price) != price&gt;)
subscribeTable(tableName=`tickStream, actionName="filter", handler=tableInsert{rse})</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="36-快照机制"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.6. 快照机制</h3><div class="- topic/body body"><p class="- topic/p p">为了满足生产环境业务持续性的需要，DolphinDB内置的流式计算引擎包括响应式状态引擎均支持快照（snapshot）输出。</p><p class="- topic/p p">响应式状态引擎的快照包括已处理的最后一条消息的ID以及引擎当前的状态（中间计算结果）。当系统出现异常，重新初始化状态引擎时，可恢复到最后一个快照的状态，并且从已处理的消息的下一条开始订阅。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&gt;

share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream
result = table(1000:0, `sym`factor1, [STRING,DOUBLE])
rse = createReactiveStateEngine(name="reactiveDemo", metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn="sym", snapshotDir= "/home/data/snapshot", snapshotIntervalInMsgCount=400000)
msgId = getSnapshotMsgId(rse)
if(msgId &gt;= 0) msgId += 1
subscribeTable(tableName=`tickStream, actionName="factors", offset=msgId, handler=appendMsg{rse}, handlerNeedMsgId=true)</code></pre><p class="- topic/p p">响应式状态引擎要启用快照机制，创建时需要指定两个额外的参数snapshotDir和snapshotIntervalInMsgCount。snapshotDir用于指定存储快照的目录。snapshotIntervalInMsgCount指定处理多少条消息后产生一个快照。引擎初始化时，系统会检查快照目录下是否存在一个以引擎名称命名，后缀为snapshot的文件。以上面的代码为例，如果存在文件/home/data/snapshot/reactiveDemo.snapshot，加载这个快照。函数getSnapshotMsgId可以获取最近一个快照对应的msgId。如果不存在快照，返回-1。</p><p class="- topic/p p">状态引擎要启用快照机制，调用subscribeTable函数也需相应的修改：</p><ul class="- topic/ul ul"><li class="- topic/li li">首先必须指定消息的offset。</li><li class="- topic/li li">其次，handler必须使用appendMsg函数。appendMsg函数接受两个参数，msgBody和msgId。</li><li class="- topic/li li">再次，参数handlerNeedMsgId必须指定为true。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="37-并行处理"><h3 class="- topic/title title topictitle3" id="ariaid-title11">3.7. 并行处理</h3><div class="- topic/body body"><p class="- topic/p p">当需要处理大量消息时，可在DolphinDB消息订阅函数<code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code>中指定可选参数filter与hash，让多个订阅客户端并行处理消息。</p><ul class="- topic/ul ul"><li class="- topic/li li">参数filter用于指定消息过滤逻辑。目前支持三种过滤方式，分别为值过滤，范围过滤和哈希过滤。</li><li class="- topic/li li">参数hash可以指定一个哈希值，确定这个订阅由哪个线程来执行。例如，配置参数subExecutors为4，用户指定了哈希值5，那么该订阅的计算任务将由第二个线程来执行。</li></ul><p class="- topic/p p">下面是响应式状态引擎并行计算因子的例子。假设配置参数subExecutors=4，创建4个状态引擎，每个状态引擎根据流表的股票代码的哈希值来订阅不同股票的数据，并且指定不同的订阅线程来处理，最终将结果输出到同一个输出表中。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&gt;

share streamTable(1:0, `sym`price, [STRING,DOUBLE]) as tickStream
setStreamTableFilterColumn(tickStream, `sym)
share streamTable(1000:0, `sym`factor1, [STRING,DOUBLE]) as resultStream

for(i in 0..3){
    rse = createReactiveStateEngine(name="reactiveDemo"+string(i), metrics =factor1, dummyTable=tickStream, outputTable=resultStream, keyColumn="sym")
    subscribeTable(tableName=`tickStream, actionName="sub"+string(i), handler=tableInsert{rse}, msgAsTable = true, hash = i, filter = (4,i))
}

n=2000000
tmp = table(take("A"+string(1..4000), n) as sym, rand(10.0, n) as price)
tickStream.append!(tmp)</code></pre><p class="- topic/p p">需要注意的是，如果多个状态引擎是同一个输出表，该输出表必须是一个共享表。没有共享的表不是线程安全的，并行写入可能会导致系统崩溃。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title12" id="4-流批统一解决方案"><h2 class="- topic/title title topictitle2" id="ariaid-title12">4. 流批统一解决方案</h2><div class="- topic/body body"><p class="- topic/p p">金融高频因子的流批统一处理在DolphinDB中有两种实现方法。</p><p class="- topic/p p">第一种方法，使用函数或表达式实现金融高频因子，代入不同的计算引擎进行历史数据或流数据的计算。代入SQL引擎，可以实现对历史数据的计算；代入响应式状态引擎，可以实现对流数据的计算。这在第3章的序言部分已经举例说明。在这种模式下用DolphinDB脚本语言表示的表达式或函数实际上是对因子语义的一种描述，而不是具体的实现。因子计算的具体实现交由相应的计算引擎来完成，从而实现不同场景下的最佳性能。</p><p class="- topic/p p">第二种方法，历史数据通过回放，转变成流数据，然后使用流数据计算引擎来完成计算。我们仍然以教程开始部分的因子为例，唯一的区别是流数据表tickStream的数据源来自于历史数据库的replay。使用这种方法计算历史数据的因子值，效率不高是一个缺点。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def sum_diff(x, y){
    return (x-y)/(x+y)
}
factor1 = &lt;ema(1000 * sum_diff(ema(price, 20), ema(price, 40)),10) -  ema(1000 * sum_diff(ema(price, 20), ema(price, 40)), 20)&gt;

share streamTable(1:0, `sym`date`time`price, [STRING,DATE,TIME,DOUBLE]) as tickStream
result = table(1000:0, `sym`factor1, [STRING,DOUBLE])
rse = createReactiveStateEngine(name="reactiveDemo", metrics =factor1, dummyTable=tickStream, outputTable=result, keyColumn="sym")
subscribeTable(tableName=`tickStream, actionName="factors", handler=tableInsert{rse})

//从历史数据库dfs://TAQ的trades表中加载一天的数据，回放到流数据表tickStream中
inputDS = replayDS(&lt;select sym, date, time, price from loadTable("dfs://TAQ", "trades") where date=2021.03.08&gt;, `date, `time, 08:00:00.000 + (1..10) * 3600000)
replay(inputDS, tickStream, `date, `time, 1000, true, 2)</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="5-性能测试"><h2 class="- topic/title title topictitle2" id="ariaid-title13">5. 性能测试</h2><div class="- topic/body body"><p class="- topic/p p">我们测试了响应式状态引擎计算因子的性能。测试使用模拟数据，并使用warmupStreamEngine函数模拟状态引擎已经处理部分数据的情况。测试共包括20个不同复杂度度的因子，其中两个自定义状态函数分别返回3个和5个因子。为方便测试，计算仅使用单线程处理。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def slr(y, x){
    alpha, beta = mslr(y, x, 12)
    residual = mavg(y, 12) - beta * mavg(x, 12) - alpha
    return alpha, beta, residual
}

@state
def multiFactors(lowPrice, highPrice, volumeTrade, closePrice, buy_active, sell_active, tradePrice, askPrice1, bidPrice1, askPrice10, agg_vol, agg_amt){
    a = ema(askPrice10, 30)
    term0 = ema((lowPrice - a) / (ema(highPrice, 30) - a), 50)
    term1 = mrank((highPrice - a) / (ema(highPrice, 5) - a), true,  15)
    term2 = mcorr(askPrice10, volumeTrade, 10) * mrank(mstd(closePrice, 20, 20), true, 10)
    buy_vol_ma = mavg(buy_active, 6)
    sell_vol_ma = mavg(sell_active, 6)
    zero_free_vol = iif(agg_vol==0, 1, agg_vol)
    stl_prc = ffill(agg_amt \ zero_free_vol \ 20).nullFill(tradePrice)
    buy_prop = stl_prc
	
    spd = askPrice1 - bidPrice1
    spd_ma = round(mavg(iif(spd &lt; 0, 0, spd), 6), 5)
    term3 = buy_prop * spd_ma
    term4 = iif(spd_ma == 0, 0, buy_prop / spd_ma)
    return term0, term1, term2, term3, term4
}

metrics = array(ANY, 14)
metrics[0] = &lt;ema(1000 * sum_diff(ema(close, 20), ema(close, 40)),10) -  ema(1000 * sum_diff(ema(close, 20), ema(close, 40)), 20)&gt;
metrics[1] = &lt;mslr(high, volume, 8)[1]&gt;
metrics[2] = &lt;mcorr(low, high, 11)&gt;
metrics[3] = &lt;mstdp(low, 15)&gt;
metrics[4] = &lt;mbeta(high, value, 63)&gt;
metrics[5] = &lt;mcovar(low, value, 71)&gt;
metrics[6] = &lt;(close/mavg(close, 1..6)-1)*100&gt;
metrics[7] = &lt;mmin(high, 15)&gt;
metrics[8] = &lt;mavg(((high+low)/2+(mavg(high, 2)+mavg(low, 2))/2)*(high-low)/volume, 7, 2)&gt;
metrics[9] = &lt;mslr(mavg(close, 14), volume, 63)[1]&gt;
metrics[10] = &lt;mcorr(mavg(open, 25), volume, 71)&gt;
metrics[11] = &lt;mbeta(high, mstdp(close, 8), 77)&gt;
metrics[12] = &lt;slr(close, volume)&gt;
metrics[13] = &lt;multiFactors(low, high, volume, close, numTrade, numTrade, close, value, close, open, volume, numTrade)&gt;

dummy = streamTable(10000:0, `symbol`market`date`time`quote_type`preclose`open`high`low`close`numTrade`volume`value`position`recvtime,[SYMBOL,SHORT,DATE,TIME,SHORT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,LONG,TIMESTAMP])

def prepareData(tickNum, batch){
    total = tickNum*batch
    data=table(total:total, `symbol`market`date`time`quote_type`preclose`open`high`low`close`numTrade`volume`value`position`recvtime,[SYMBOL,SHORT,DATE,TIME,SHORT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,DOUBLE,LONG,TIMESTAMP])
    data[`market]=rand(10, total)
    data[`date]=take(date(now()), total)
    data[`time]=take(time(now()), total)
    data[`symbol]=take("A"+string(1..tickNum), total)
    data[`open]=rand(100.0, total)
    data[`high]=rand(100.0, total)
    data[`low]=rand(100.0, total)
    data[`close]=rand(100.0, total)
    data[`numTrade]=rand(100, total)
    data[`volume]=rand(100, total)
    data[`value]=rand(100.0, total)
    data[`recvtime]=take(now(), total)
    return data
}

dropStreamEngine("demo1")
dropStreamEngine("demo2")
dropStreamEngine("demo3")
dropStreamEngine("demo4")

//4000个股票，20个因子
hisData = prepareData(4000, 100)
realData = prepareData(4000, 1)
colNames = ["symbol"].append!("factor"+string(0..19))
colTypes = [SYMBOL].append!(take(DOUBLE, 20))
resultTable = streamTable(10000:0, colNames, colTypes)
engine1 = createReactiveStateEngine(name="demo1", metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn="symbol")
warmupStreamEngine(engine1, hisData)
timer(10) engine1.append!(realData)
dropAggregator("demo1")

//1个股票，20个因子
hisData = prepareData(1, 100)
realData = prepareData(1, 1)
colNames = ["symbol"].append!("factor"+string(0..19))
colTypes = [SYMBOL].append!(take(DOUBLE, 20))
resultTable = streamTable(10000:0, colNames, colTypes)
engine2 = createReactiveStateEngine(name="demo2", metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn="symbol")
warmupStreamEngine(engine2, hisData)
timer(10) engine2.append!(realData)
dropAggregator("demo2")

//4000个股票，1个因子
hisData = prepareData(4000, 100)
realData = prepareData(4000, 1)
metrics3 = metrics[0]
colNames = ["symbol", "factor0"]
colTypes = [SYMBOL, DOUBLE]
resultTable = streamTable(10000:0, colNames, colTypes)
engine3 = createReactiveStateEngine(name="demo3", metrics=metrics3, dummyTable=dummy, outputTable=resultTable, keyColumn="symbol")
warmupStreamEngine(engine3, hisData)
timer(10) engine3.append!(realData)

//200个股票，20个因子
hisData = prepareData(200, 100)
realData = prepareData(200, 1)
colNames = ["symbol"].append!("factor"+string(0..19))
colTypes = [SYMBOL].append!(take(DOUBLE, 20))
resultTable = streamTable(10000:0, colNames, colTypes)
engine4 = createReactiveStateEngine(name="demo4", metrics=metrics, dummyTable=dummy, outputTable=resultTable, keyColumn="symbol")
warmupStreamEngine(engine4, hisData)
timer(10) engine4.append!(realData)
</code></pre><p class="- topic/p p">我们统计了10次的总耗时，取平均值作为单次的耗时。测试使用的服务器CPU为Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz。单线程情况下，测试结果如下：</p><div class="table-container"><table class="- topic/table table" data-cols="3"><caption></caption><colgroup><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="5-性能测试__entry__1">股票个数</th><th class="- topic/entry entry colsep-0 rowsep-0" id="5-性能测试__entry__2">因子个数</th><th class="- topic/entry entry colsep-0 rowsep-0" id="5-性能测试__entry__3">耗时(单位:ms)</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__1">4000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__2">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__3">6</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__1">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__2">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__3">0.07</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__1">4000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__2">1</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__3">0.8</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__1">200</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__2">20</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="5-性能测试__entry__3">0.2</td></tr></tbody></table></div></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title14" id="6-多个引擎的流水线处理"><h2 class="- topic/title title topictitle2" id="ariaid-title14">6. 多个引擎的流水线处理</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB内置的流计算引擎包括响应式状态引擎，时间序列聚合引擎，横截面引擎和异常检测引擎。这些引擎均实现了数据表（table）的接口，因此多个引擎流水线处理变得异常简单，只要将后一个引擎作为前一个引擎的输出即可。引入流水线处理，可以解决更为复杂的因子计算问题。譬如，因子计算经常需要使用面板数据，完成时间序列和横截面两个维度的计算，只要把响应式状态引擎和横截面两个引擎串联处理即可完成。</p><p class="- topic/p p">下面的例子是World Quant 101个Alpha因子中的1号因子公式的流数据实现。rank函数是一个横截面操作。rank的参数部分用响应式状态引擎实现。rank函数本身用横截面引擎实现。横截面引擎作为状态引擎的输出。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>Alpha#001公式：rank(Ts_ArgMax(SignedPower((returns&lt;0?stddev(returns,20):close), 2), 5))-0.5

//创建横截面引擎，计算每个股票的rank
dummy = table(1:0, `sym`time`maxIndex, [SYMBOL, TIMESTAMP, DOUBLE])
resultTable = streamTable(10000:0, `time`sym`factor1, [TIMESTAMP, SYMBOL, DOUBLE])
ccsRank = createCrossSectionalAggregator(name="alpha1CCS", metrics=&lt;[sym, rank(maxIndex, percent=true) - 0.5]&gt;,  dummyTable=dummy, outputTable=resultTable,  keyColumn=`sym, triggeringPattern='keyCount', triggeringInterval=3000, timeColumn=`time)

@state
def wqAlpha1TS(close){
    ret = ratios(close) - 1
    v = iif(ret &lt; 0, mstd(ret, 20), close)
    return mimax(signum(v)*v*v, 5)
}

//创建响应式状态引擎，输出到前面的横截面引擎ccsRank
input = table(1:0, `sym`time`close, [SYMBOL, TIMESTAMP, DOUBLE])
rse = createReactiveStateEngine(name="alpha1", metrics=&lt;[time, wqAlpha1TS(close)]&gt;, dummyTable=input, outputTable=ccsRank, keyColumn="sym")
</code></pre><p class="- topic/p p">流水线处理（也称为引擎多级级联）和多个流数据表的级联处理有很大的区别。两者可以完成相同的任务，但是效率上有很大的区别。后者涉及多个流数据表与多次订阅。前者实际上只有一次订阅，所有的计算均在一个线程中依次顺序完成，因而有更好的性能。</p><p class="- topic/p p">上面的例子是由用户来区分哪一部分是横截面操作，哪一部分是时间序列操作以实现多个引擎的流水线。在1.30.16/2.00.4及之后的版本中，新增函数 <code class="+ topic/ph pr-d/codeph ph codeph">streamEngineParser</code>，支持将metrics自动分解成多个内置流计算引擎的流水线。在<code class="+ topic/ph pr-d/codeph ph codeph">streamEngineParser</code>中以行函数（rowRank，rowSum等）表示横截面操作的语义，以rolling函数表示时间序列操作，从而系统能够自动识别一个因子中的横截面操作和时间序列操作，进一步自动构建引擎流水线。因此，上述因子可以用<code class="+ topic/ph pr-d/codeph ph codeph">streamEngineParser</code>更简洁的实现，metrics几乎等同于因子的数学公式表达，而不需要考虑不同类型引擎的选择：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>@state
def wqAlpha1TS(close){
	ret = ratios(close) - 1
	v = iif(ret &lt; 0, mstd(ret, 20), close)
	return mimax(signum(v)*v*v, 5)
}

//构建计算因子
metrics=&lt;[sym, rowRank(wqAlpha1TS(close), percent=true)- 0.5]&gt;

streamEngine=streamEngineParser(name="alpha1_parser", metrics=metrics, dummyTable=input, outputTable=resultTable, keyColumn=`sym, timeColumn=`time, triggeringPattern='keyCount', triggeringInterval=3000)</code></pre></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title15" id="7-展望"><h2 class="- topic/title title topictitle2" id="ariaid-title15">7. 展望</h2><div class="- topic/body body"><p class="- topic/p p">响应式状态引擎内置了大量常用的状态算子，支持自定义状态函数，也可与其他流式计算引擎以流水线的方式任意组合，方便开发人员快速实现复杂的金融高频因子。后续的版本中，将开放接口允许用户用C++插件开发状态函数，满足定制的需要。</p><p class="- topic/p p">内置的状态算子全部使用C++开发实现，算法上经过了大量的优化，以增量方式实现状态算子的流式计算，因而在单个线程上的计算达到了非常好的性能。对于规模较大的任务，可以通过订阅过滤的方式，拆分成多个子订阅，由多个节点以及每个节点的多个CPU并行完成订阅计算。后续的版本将完善计算子作业的创建、管理和监控功能，从手动转变为自动。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E9%87%91%E8%9E%8D%E9%AB%98%E9%A2%91%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B" data-tocid="1-金融高频因子计算示例">1. 金融高频因子计算示例</a></li><li class="topic-item"><a href="#2-%E7%8E%B0%E6%9C%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" data-tocid="2-现有解决方案的优缺点">2. 现有解决方案的优缺点</a></li><li class="topic-item"><a href="#3-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E5%BC%95%E6%93%8Ereactive-state-engine" data-tocid="3-响应式状态引擎reactive-state-engine">3. 响应式状态引擎（Reactive State Engine)</a><ul><li class="topic-item"><a href="#31-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" data-tocid="31-工作原理">3.1. 工作原理</a></li><li class="topic-item"><a href="#32-%E8%A7%A3%E6%9E%90%E5%92%8C%E4%BC%98%E5%8C%96" data-tocid="32-解析和优化">3.2. 解析和优化</a></li><li class="topic-item"><a href="#33-%E5%86%85%E7%BD%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0" data-tocid="33-内置的状态函数">3.3. 内置的状态函数</a></li><li class="topic-item"><a href="#34-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0" data-tocid="34-自定义状态函数">3.4. 自定义状态函数</a></li><li class="topic-item"><a href="#35-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4" data-tocid="35-输出结果过滤">3.5. 输出结果过滤</a></li><li class="topic-item"><a href="#36-%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6" data-tocid="36-快照机制">3.6. 快照机制</a></li><li class="topic-item"><a href="#37-%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86" data-tocid="37-并行处理">3.7. 并行处理</a></li></ul></li><li class="topic-item"><a href="#4-%E6%B5%81%E6%89%B9%E7%BB%9F%E4%B8%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="4-流批统一解决方案">4. 流批统一解决方案</a></li><li class="topic-item"><a href="#5-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="5-性能测试">5. 性能测试</a></li><li class="topic-item"><a href="#6-%E5%A4%9A%E4%B8%AA%E5%BC%95%E6%93%8E%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86" data-tocid="6-多个引擎的流水线处理">6. 多个引擎的流水线处理</a></li><li class="topic-item"><a href="#7-%E5%B1%95%E6%9C%9B" data-tocid="7-展望">7. 展望</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>