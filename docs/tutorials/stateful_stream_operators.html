<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="随着实时数据流处理需求的不断增长，高效、可扩展的流计算框架变得愈发重要。DolphinDB 作为一款高性能分布式时间序列数据库，不仅在数据存储和查询上表现出色，还通过引入面向对象编程（OOP）编程范式，使得开发者能够通过封装、继承、多态等特性，提升代码的灵活性、可维护性和复用性。本文通过两个实际应用案例，详细介绍如何利用 OOP 在 DolphinDB 中开发状态引擎算子，展示 OOP ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="使用-dolphindb-class-来开发流计算状态算子"/><title>使用 DolphinDB Class 来开发流计算状态算子</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;使用-dolphindb-class-来开发流计算状态算子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;使用 DolphinDB Class 来开发流计算状态算子&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;/&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:59;85:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;前言&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;前言&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;随着实时数据流处理需求的不断增长，高效、可扩展的流计算框架变得愈发重要。DolphinDB 作为一款高性能分布式时间序列数据库，不仅在数据存储和查询上表现出色，还通过引入面向对象编程（OOP）编程范式，使得开发者能够通过封装、继承、多态等特性，提升代码的灵活性、可维护性和复用性。本文通过两个实际应用案例，详细介绍如何利用 OOP 在 DolphinDB 中开发状态引擎算子，展示 OOP 在流计算中的应用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-关于oop&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;1. 关于OOP&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;DolphinDB 从 3.00.0 版本开始支持面向对象编程。面向对象编程（OOP）是非常重要的编程范式，其通过封装、继承、多态等特性，提升代码的灵活性、可维护性和复用性，提升代码的模块化，实现低耦合高内聚。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;在 DolphinDB 中，OOP 可应用于多种场景，例如：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;用于开发流计算状态引擎中的状态算子。在未提供 OOP 时，某些状态算子的开发过程中需要使用复杂的高阶函数，不便于理解代码；某些状态算子需要通过状态函数插件进行开发，开发成本过高。而通过 OOP 编程自定义算子则可以使代码结构清晰，容易理解。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;16:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;在复杂事件处理（CEP）引擎中，可以利用 OOP 定义事件和编写 Monitor。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;18:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;本教程将主要介绍 OOP 在状态引擎中的应用。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-dolphindb-oop-编程概要&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2. DolphinDB OOP 编程概要&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;22:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-类的定义&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2.1 类的定义&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;类的定义格式如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;class 类名 { 属性1 :: 类型1 属性2 :: 类型2 // ... // 和类名同名的方法成为构造函数，有且只有一个 def 类名(arg1, arg2 /*,...*/) { 属性1 = arg1 属性2 = arg2 // ... } // 需要注意，成员变量和成员函数不能同名。 def 方法(arg1, arg2 /*, ...*/) { // ... } }&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;46:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;例如，我们要定义一个 Person 类，包含两个成员变量：name 和 age。其中，name 是字符串，age 是整数。该类还包含了一个构造函数和 name 成员变量的 getter/setter。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;48:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;定义如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;50:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;class Person { // 变量声明在方法声明之前 name :: STRING age :: INT // 定义构造函数 def Person(name_, age_) { // 参数名不能和属性名相同，否则会覆盖属性名 name = name_ age = age_ } def setName(newName) { name = newName } def getName() { return name } }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-对象的使用&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2.2 对象的使用&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;71:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;73:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;可以通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;73:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;object.method()&lt;/codeph&gt; 的形式调用对象的成员函数；通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;73:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;object.member&lt;/codeph&gt; 的形式访问对象的属性。需要注意，和 Python 等脚本语言不同，无法直接通过对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;73:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;object.member &lt;/codeph&gt;赋值修改成员变量。如果需要为成员变量赋值，需要创建并使用相应的 setter 方法进行赋值。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;75:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;p = Person(&#34;Zhang San&#34;, 30) print(p.getName()) // 调用对象的方法 p.setName(&#34;Li Si&#34;) print(p.getName()) // 引用对象的属性 print(p.name) p.name = &#34;Wang Wu&#34; // 报错：禁止对对象的属性直接赋值&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-对象属性类型标注&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2.3 对象属性类型标注&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;定义成员变量的格式为：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;90:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;成员变量名 :: 类型标注&lt;/codeph&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;其中类型标注可以是：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;94:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;94:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;标量：包括所有的基本类型，如 INT, DOUBLE, STRING，以及时间类型。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;95:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;向量：如 DOUBLE VECTOR, STRING VECTOR 或者 Array Vector：INT[] VECTOR。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;96:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;其他形式/类型不限：如果是其他类型（如字典、函数等），或者不希望限定变量类型，可以把类型标注写成 ANY。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;98:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;例如：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;100:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;a :: INT b :: DOUBLE VECTOR handler :: ANY&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;24-变量解析&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2.4 变量解析&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;108:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;110:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;方法中使用到的变量的解析顺序：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;112:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;方法参数&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;对象属性&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;共享变量&lt;/li&gt;&lt;/ol&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;share table(1:0, `sym`val, [SYMBOL, INT]) as tbl go class Test2 { a :: INT b :: DOUBLE def Test2() { a = 1 b = 2.0 } def method(b) { print(b) // 解析为函数参数 b；如果需要访问成员变量 b，需要使用 self，见下一小节 print(a) // 解析为对象属性 a print(tbl) // 解析为共享变量 tbl print(qwert) // 变量不存在，报错 } }&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;25-self-语法&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;2.5 self 语法&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;137:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;139:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;通过 “self” 变量在类的方法中获取对象本身，其类似于 Python 中的 self，或者 Java、C++ 中的 this。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;141:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;def doSomething(a) { // ... } class A{ a :: INT b :: INT def A() { a = 1 b = 2 } def createCallback() { return doSomething{self} } def nameShadow(b) { print(b) print(self.b) } } a = A() handler = a.createCallback() a.nameShadow(3)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-应用案例&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;3. 应用案例&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;Reactive State Engine（RSE）是DolphinDB中的一个高性能、可扩展的计算框架，专门用于处理实时流数据。RSE 通过状态算子在数据流中捕捉并维护状态，从而实现增量计算和复杂事件处理。下面我们通过两个案例介绍一下如何利用 OOP 来开发状态引擎算子。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-累计求和算子mycumsum&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;3.1 累计求和算子：MyCumSum&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;在状态引擎内部，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;176:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;cumsum&lt;/codeph&gt; 算子实现了累计求和的功能。这个功能在状态引擎内的实现非常简单，本节不展开说明，仅说明如何利用 OOP 重新实现该算子。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;首先，定义一个类 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;178:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;MyCumSum&lt;/codeph&gt;，并将算子的状态定义为类的成员变量。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;其次，在类中实现 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;180:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;append&lt;/codeph&gt; 方法，用于实现累计求和的功能。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;180:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;append&lt;/codeph&gt; 的参数是逐行输入的数据，返回的结果将作为计算结果输出。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;182:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;最后，定义一个状态引擎，并指定 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;182:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;MyCumSum.append()&lt;/codeph&gt; 为引擎的算子。向引擎中输入数据，并查看计算结果。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;184:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;186:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;class MyCumSum { sum :: DOUBLE def MyCumSum() { sum = 0.0 } def append(value) { sum = sum + value return sum } } inputTable = table(1:0, `sym`val, [SYMBOL, DOUBLE]) result = table(1000:0, `sym`res, [SYMBOL, DOUBLE]) rse = createReactiveStateEngine( name=&#34;reactiveDemo&#34;, metrics = [&amp;lt;MyCumSum().append(val)&amp;gt;], dummyTable=inputTable, outputTable=result, keyColumn=&#34;sym&#34;) data = table(take(`A, 100) as sym, rand(100.0, 100) as val) rse.append!(data) select * from data select * from result&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;进行一次运行，随机生成出来的输入数据和对应输出为：&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stateful_stream_operators/1.png&#34; xtrc=&#34;image:1;217:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34; dita-ot:image-width=&#34;106&#34; dita-ot:image-height=&#34;255&#34;/&gt; 输入数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/stateful_stream_operators/2.png&#34; xtrc=&#34;image:2;220:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34; dita-ot:image-width=&#34;112&#34; dita-ot:image-height=&#34;257&#34;/&gt; 输出数据&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;224:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;可以看到，我们编写的 OOP 算子实现了分组的累加求和，与状态引擎内置的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;224:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;cumsum&lt;/codeph&gt; 算子的功能一致。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-线性递归&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;3.2 线性递归&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;在未提供 OOP 时，状态引擎计算线性递归时需要通过内置函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;230:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate&lt;/codeph&gt; 实现。使用&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;230:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate&lt;/codeph&gt; 需要指定用于迭代计算的函数，迭代结果和 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;230:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;X&lt;/i&gt; 的关联系数，使用的输入数据列，以及初始化窗口的长度，并最终在指定的输出列中输出结果。&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;230:134&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate&lt;/codeph&gt; 的计算规则参考文档：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/funcs/s/stateIterate&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;230:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;?ditaot usertext?&gt;statelterate&lt;/xref&gt;。实现代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;trade = table(take(&#34;A&#34;, 6) join take(&#34;B&#34;, 6) as sym, 1..12 as val0, take(10, 12) as val1) inputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT]) outputTable = table(100:0, `sym`factor, [STRING, DOUBLE]) engine = createReactiveStateEngine( name=&#34;rsTest&#34;, metrics=&amp;lt;[stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])]&amp;gt;, dummyTable=inputTable, outputTable=outputTable, keyColumn=[&#34;sym&#34;], keepOrder=true) engine.append!(trade) select * from outputTable&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;上例中的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;249:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])&lt;/codeph&gt; 基于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;249:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate&lt;/codeph&gt; 的计算规则，实现了线性递归，但仅从这一行代码无法理解其中的计算规则，对用户的使用可能造成困扰。如果通过 OOP 改写此函数的实现逻辑，则代码结构会清晰很多：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;trade = table(take(&#34;A&#34;, 6) join take(&#34;B&#34;, 6) as sym, 1..12 as val0, take(10, 12) as val1) inputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT]) outputTable = table(100:0, `sym`factor, [STRING, DOUBLE]) class MyIterateOperator { movingWindow :: DOUBLE VECTOR k :: INT def MyIterateOperator() { k = 0 movingWindow = double([]) } def append(X, initial) { if (k &amp;lt; 3) { k = k + 1 movingWindow = movingWindow join initial return double(initial) } result = 0.5 * X + 0.5 * sum(movingWindow) movingWindow = movingWindow[1:] join result return double(result) } } engine2 = createReactiveStateEngine( name=&#34;rsTest2&#34;, metrics=&amp;lt;[MyIterateOperator().append(val0, val1)]&amp;gt;, dummyTable=inputTable, outputTable=outputTable, keyColumn=[&#34;sym&#34;], keepOrder=true) engine2.append!(trade) select * from outputTable&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;可以看到，当窗口长度小于3时，算子直接返回init中的结果；当窗口长度大于等于3时，算子的append方法将长度为3的窗口中数据的和与X中的值做加权平均；最终实现了和 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;287:85&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])&lt;/codeph&gt; 相同的功能。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;289:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;虽然通过 OOP 实现线性递归的代码行数有所增加，但它结构清晰，提高了代码的可读性，同时简化了调试过程。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-小结和展望&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;4. 小结和展望&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;293:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;295:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;通过本教程的两个应用案例，我们可以看到如何在 DolphinDB 中利用 OOP（面向对象编程）开发状态引擎算子。这种方式相比直接调用引擎提供的算子，具有可读性强、结构清晰的优点。在当前实现中，DolphinDB的 OOP 仍然采用解释执行的方式，相比原生 C++ 实现速度较慢。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;297:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/stateful_stream_operators.md&#34;&gt;目前，在响应式状态引擎中，一些有状态的高阶函数迭代算子和无状态的自定义函数算子已经可以通过即时编译（JIT）技术优化，用脚本编写的自定义函数算子的性能可以达到原生 C++ 实现的水平；但是，目前状态引擎中使用 OOP 编写的有状态的算子还没有支持 JIT 。未来，我们计划使用 JIT 技术进一步优化响应式状态引擎中的 OOP 的应用，直接将类中定义的有状态算子编译为机器码运行，以期望实现在当前较高的开发效率下也不会损失运行时的效率。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/stateful_stream_operators.md"/><meta name="wh-out-relpath" content="tutorials/stateful_stream_operators.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="使用-dolphindb-class-来开发流计算状态算子" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html">流数据</a></div></div></li><li class="active"><div class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子"><div class="title"><a href="../tutorials/stateful_stream_operators.html">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="多数据源流式实时关联处理-d9713e100449" class="topicref" data-id="多数据源流式实时关联处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="多数据源流式实时关联处理-d9713e100449-link">多数据源流式实时关联处理</a></div></div></li><li role="treeitem"><div data-tocid="流数据引擎解析器-d9713e100495" class="topicref" data-id="流数据引擎解析器" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/StreamEngineParser.html" id="流数据引擎解析器-d9713e100495-link">流数据引擎解析器</a></div></div></li><li role="treeitem"><div data-tocid="流数据高可用-d9713e100541" class="topicref" data-id="流数据高可用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/haStreaming.html" id="流数据高可用-d9713e100541-link">流数据高可用</a></div></div></li><li role="treeitem"><div data-tocid="节点启动时的流计算自动订阅-d9713e100587" class="topicref" data-id="节点启动时的流计算自动订阅" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_auto_sub_2.html" id="节点启动时的流计算自动订阅-d9713e100587-link">节点启动时的流计算自动订阅</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎入门初级高频量价因子策略的实现-d9713e100633" class="topicref" data-id="cep-引擎入门初级高频量价因子策略的实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/getting_started_with_cep_engine.html" id="cep-引擎入门初级高频量价因子策略的实现-d9713e100633-link">CEP 引擎入门：初级高频量价因子策略的实现</a></div></div></li><li role="treeitem"><div data-tocid="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679" class="topicref" data-id="cep-引擎应用股票中高频-cta-策略实现与并行回测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/cta_strategy_implementation_and_backtesting.html" id="cep-引擎应用股票中高频-cta-策略实现与并行回测-d9713e100679-link">CEP 引擎应用：股票中高频 CTA 策略实现与并行回测</a></div></div></li><li role="treeitem"><div data-tocid="流计算时延统计与性能优化-d9713e100725" class="topicref" data-id="流计算时延统计与性能优化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_timer.html" id="流计算时延统计与性能优化-d9713e100725-link">流计算时延统计与性能优化</a></div></div></li><li role="treeitem"><div data-tocid="响应式状态引擎-d9713e100771" class="topicref" data-id="响应式状态引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/reactive_state_engine.html" id="响应式状态引擎-d9713e100771-link">响应式状态引擎</a></div></div></li><li role="treeitem"><div data-tocid="流数据功能应用-d9713e100817" class="topicref" data-id="流数据功能应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_tutorial.html" id="流数据功能应用-d9713e100817-link">流数据功能应用</a></div></div></li><li role="treeitem"><div data-tocid="数据回放-d9713e100863" class="topicref" data-id="数据回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_replay.html" id="数据回放-d9713e100863-link">数据回放</a></div></div></li><li role="treeitem" class="active"><div data-tocid="使用-dolphindb-class-来开发流计算状态算子-d9713e100909" class="topicref" data-id="使用-dolphindb-class-来开发流计算状态算子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stateful_stream_operators.html" id="使用-dolphindb-class-来开发流计算状态算子-d9713e100909-link">使用 DolphinDB Class 来开发流计算状态算子</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">使用 DolphinDB Class 来开发流计算状态算子</h1><div class="- topic/body body"></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="前言"><h2 class="- topic/title title topictitle2" id="ariaid-title2">前言</h2><div class="- topic/body body"><p class="- topic/p p">随着实时数据流处理需求的不断增长，高效、可扩展的流计算框架变得愈发重要。DolphinDB 作为一款高性能分布式时间序列数据库，不仅在数据存储和查询上表现出色，还通过引入面向对象编程（OOP）编程范式，使得开发者能够通过封装、继承、多态等特性，提升代码的灵活性、可维护性和复用性。本文通过两个实际应用案例，详细介绍如何利用 OOP 在 DolphinDB 中开发状态引擎算子，展示 OOP 在流计算中的应用。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title3" id="1-关于oop"><h2 class="- topic/title title topictitle2" id="ariaid-title3">1. 关于OOP</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 从 3.00.0 版本开始支持面向对象编程。面向对象编程（OOP）是非常重要的编程范式，其通过封装、继承、多态等特性，提升代码的灵活性、可维护性和复用性，提升代码的模块化，实现低耦合高内聚。</p><p class="- topic/p p">在 DolphinDB 中，OOP 可应用于多种场景，例如：</p><ul class="- topic/ul ul"><li class="- topic/li li">用于开发流计算状态引擎中的状态算子。在未提供 OOP 时，某些状态算子的开发过程中需要使用复杂的高阶函数，不便于理解代码；某些状态算子需要通过状态函数插件进行开发，开发成本过高。而通过 OOP 编程自定义算子则可以使代码结构清晰，容易理解。</li><li class="- topic/li li">在复杂事件处理（CEP）引擎中，可以利用 OOP 定义事件和编写 Monitor。</li></ul><p class="- topic/p p">本教程将主要介绍 OOP 在状态引擎中的应用。</p></div></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title4" id="2-dolphindb-oop-编程概要"><h2 class="- topic/title title topictitle2" id="ariaid-title4">2. DolphinDB OOP 编程概要</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="21-类的定义"><h3 class="- topic/title title topictitle3" id="ariaid-title5">2.1 类的定义</h3><div class="- topic/body body"><p class="- topic/p p">类的定义格式如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>class 类名 {
  属性1 :: 类型1
  属性2 :: 类型2
  // ...
  // 和类名同名的方法成为构造函数，有且只有一个
  def 类名(arg1, arg2 /*,...*/) {
    属性1 = arg1
    属性2 = arg2
    // ...
  }
  // 需要注意，成员变量和成员函数不能同名。
  def 方法(arg1, arg2 /*, ...*/) {
    // ...
  }
}</code></pre><p class="- topic/p p">例如，我们要定义一个 Person 类，包含两个成员变量：name 和 age。其中，name 是字符串，age 是整数。该类还包含了一个构造函数和 name 成员变量的 getter/setter。</p><p class="- topic/p p">定义如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>class Person {
  // 变量声明在方法声明之前
  name :: STRING
  age :: INT
  // 定义构造函数
  def Person(name_, age_) { // 参数名不能和属性名相同，否则会覆盖属性名
    name = name_
    age = age_
  }
  def setName(newName) {
    name = newName
  }
  def getName() {
    return name
  }
}</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="22-对象的使用"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.2 对象的使用</h3><div class="- topic/body body"><p class="- topic/p p">可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">object.method()</code> 的形式调用对象的成员函数；通过 <code class="+ topic/ph pr-d/codeph ph codeph">object.member</code> 的形式访问对象的属性。需要注意，和 Python 等脚本语言不同，无法直接通过对 <code class="+ topic/ph pr-d/codeph ph codeph">object.member </code>赋值修改成员变量。如果需要为成员变量赋值，需要创建并使用相应的 setter 方法进行赋值。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>p = Person("Zhang San", 30)
print(p.getName())
// 调用对象的方法
p.setName("Li Si")
print(p.getName())
// 引用对象的属性
print(p.name)
p.name = "Wang Wu" // 报错：禁止对对象的属性直接赋值</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="23-对象属性类型标注"><h3 class="- topic/title title topictitle3" id="ariaid-title7">2.3 对象属性类型标注</h3><div class="- topic/body body"><p class="- topic/p p">定义成员变量的格式为：<code class="+ topic/ph pr-d/codeph ph codeph">成员变量名 :: 类型标注</code>。</p><p class="- topic/p p">其中类型标注可以是：</p><ul class="- topic/ul ul"><li class="- topic/li li">标量：包括所有的基本类型，如 INT, DOUBLE, STRING，以及时间类型。</li><li class="- topic/li li">向量：如 DOUBLE VECTOR, STRING VECTOR 或者 Array Vector：INT[] VECTOR。</li><li class="- topic/li li">其他形式/类型不限：如果是其他类型（如字典、函数等），或者不希望限定变量类型，可以把类型标注写成 ANY。</li></ul><p class="- topic/p p">例如：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a :: INT
b :: DOUBLE VECTOR
handler :: ANY</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="24-变量解析"><h3 class="- topic/title title topictitle3" id="ariaid-title8">2.4 变量解析</h3><div class="- topic/body body"><p class="- topic/p p">方法中使用到的变量的解析顺序：</p><ol class="- topic/ol ol"><li class="- topic/li li">方法参数</li><li class="- topic/li li">对象属性</li><li class="- topic/li li">共享变量</li></ol><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>share table(1:0, `sym`val, [SYMBOL, INT]) as tbl
go
class Test2 {
  a :: INT
  b :: DOUBLE
  def Test2() {
    a = 1
    b = 2.0
  }
  def method(b) {
    print(b) // 解析为函数参数 b；如果需要访问成员变量 b，需要使用 self，见下一小节
    print(a) // 解析为对象属性 a
    print(tbl) // 解析为共享变量 tbl
    print(qwert) // 变量不存在，报错
  }
}</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="25-self-语法"><h3 class="- topic/title title topictitle3" id="ariaid-title9">2.5 self 语法</h3><div class="- topic/body body"><p class="- topic/p p">通过 “self” 变量在类的方法中获取对象本身，其类似于 Python 中的 self，或者 Java、C++ 中的 this。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def doSomething(a) {
  // ...
}

class A{
	a :: INT
	b :: INT
	def A() {
		a = 1
		b = 2
	}
	def createCallback() {
		return doSomething{self}
	}
	def nameShadow(b) {
		print(b)
		print(self.b)
	}
}
a = A()
handler = a.createCallback()
a.nameShadow(3)</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title10" id="3-应用案例"><h2 class="- topic/title title topictitle2" id="ariaid-title10">3. 应用案例</h2><div class="- topic/body body"><p class="- topic/p p">Reactive State Engine（RSE）是DolphinDB中的一个高性能、可扩展的计算框架，专门用于处理实时流数据。RSE 通过状态算子在数据流中捕捉并维护状态，从而实现增量计算和复杂事件处理。下面我们通过两个案例介绍一下如何利用 OOP 来开发状态引擎算子。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="31-累计求和算子mycumsum"><h3 class="- topic/title title topictitle3" id="ariaid-title11">3.1 累计求和算子：MyCumSum</h3><div class="- topic/body body"><p class="- topic/p p">在状态引擎内部，<code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code> 算子实现了累计求和的功能。这个功能在状态引擎内的实现非常简单，本节不展开说明，仅说明如何利用 OOP 重新实现该算子。</p><p class="- topic/p p">首先，定义一个类 <code class="+ topic/ph pr-d/codeph ph codeph">MyCumSum</code>，并将算子的状态定义为类的成员变量。</p><p class="- topic/p p">其次，在类中实现 <code class="+ topic/ph pr-d/codeph ph codeph">append</code> 方法，用于实现累计求和的功能。<code class="+ topic/ph pr-d/codeph ph codeph">append</code> 的参数是逐行输入的数据，返回的结果将作为计算结果输出。</p><p class="- topic/p p">最后，定义一个状态引擎，并指定 <code class="+ topic/ph pr-d/codeph ph codeph">MyCumSum.append()</code> 为引擎的算子。向引擎中输入数据，并查看计算结果。</p><p class="- topic/p p">代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>class MyCumSum {
  sum :: DOUBLE
  def MyCumSum() {
    sum = 0.0
  }
  def append(value) {
    sum = sum + value
    return sum
  }
}

inputTable = table(1:0, `sym`val, [SYMBOL, DOUBLE])
result = table(1000:0, `sym`res, [SYMBOL, DOUBLE])

rse = createReactiveStateEngine(
          name="reactiveDemo",
          metrics = [&lt;MyCumSum().append(val)&gt;],
          dummyTable=inputTable,
          outputTable=result,
          keyColumn="sym")

data = table(take(`A, 100) as sym, rand(100.0, 100) as val)
rse.append!(data)

select * from data
select * from result</code></pre><p class="- topic/p p">进行一次运行，随机生成出来的输入数据和对应输出为：</p><p class="- topic/p p"><img class="- topic/image image" src="images/stateful_stream_operators/1.png"/><br/>
输入数据</p><p class="- topic/p p"><img class="- topic/image image" src="images/stateful_stream_operators/2.png"/><br/>
输出数据</p><p class="- topic/p p">可以看到，我们编写的 OOP 算子实现了分组的累加求和，与状态引擎内置的 <code class="+ topic/ph pr-d/codeph ph codeph">cumsum</code> 算子的功能一致。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="32-线性递归"><h3 class="- topic/title title topictitle3" id="ariaid-title12">3.2 线性递归</h3><div class="- topic/body body"><p class="- topic/p p">在未提供 OOP  时，状态引擎计算线性递归时需要通过内置函数 <code class="+ topic/ph pr-d/codeph ph codeph">stateIterate</code> 实现。使用<code class="+ topic/ph pr-d/codeph ph codeph">stateIterate</code> 需要指定用于迭代计算的函数，迭代结果和 <em class="+ topic/ph hi-d/i ph i">X</em> 的关联系数，使用的输入数据列，以及初始化窗口的长度，并最终在指定的输出列中输出结果。<code class="+ topic/ph pr-d/codeph ph codeph">stateIterate</code> 的计算规则参考文档：<a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/funcs/s/stateIterate" target="_blank" rel="external noopener">statelterate</a>。实现代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>trade = table(take("A", 6) join take("B", 6) as sym,  1..12 as val0,  take(10, 12) as val1)

inputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])
outputTable = table(100:0, `sym`factor, [STRING, DOUBLE])
engine = createReactiveStateEngine(
  name="rsTest",
  metrics=&lt;[stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])]&gt;,
  dummyTable=inputTable,
  outputTable=outputTable,
  keyColumn=["sym"],
  keepOrder=true)

engine.append!(trade)
select * from outputTable</code></pre><p class="- topic/p p">上例中的 <code class="+ topic/ph pr-d/codeph ph codeph">stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])</code> 基于 <code class="+ topic/ph pr-d/codeph ph codeph">stateIterate</code> 的计算规则，实现了线性递归，但仅从这一行代码无法理解其中的计算规则，对用户的使用可能造成困扰。如果通过 OOP 改写此函数的实现逻辑，则代码结构会清晰很多：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>trade = table(take("A", 6) join take("B", 6) as sym,  1..12 as val0,  take(10, 12) as val1)

inputTable = streamTable(1:0, `sym`val0`val1, [SYMBOL, INT, INT])
outputTable = table(100:0, `sym`factor, [STRING, DOUBLE])

class MyIterateOperator {
	movingWindow :: DOUBLE VECTOR
	k :: INT
	def	MyIterateOperator() {
		k = 0
		movingWindow = double([])
	}
	def append(X, initial) {
		if (k &lt; 3) {
			k = k + 1
			movingWindow = movingWindow join initial
			return double(initial)
		}
		result = 0.5 * X + 0.5 * sum(movingWindow)
		movingWindow = movingWindow[1:] join result
		return double(result)
	}
}
engine2 = createReactiveStateEngine(
  name="rsTest2",
  metrics=&lt;[MyIterateOperator().append(val0, val1)]&gt;,
  dummyTable=inputTable,
  outputTable=outputTable,
  keyColumn=["sym"],
  keepOrder=true)
  
engine2.append!(trade)
select * from outputTable</code></pre><p class="- topic/p p">可以看到，当窗口长度小于3时，算子直接返回init中的结果；当窗口长度大于等于3时，算子的append方法将长度为3的窗口中数据的和与X中的值做加权平均；最终实现了和 <code class="+ topic/ph pr-d/codeph ph codeph">stateIterate(val0, val1, 3, msum{, 3}, [0.5, 0.5])</code> 相同的功能。</p><p class="- topic/p p">虽然通过 OOP 实现线性递归的代码行数有所增加，但它结构清晰，提高了代码的可读性，同时简化了调试过程。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="4-小结和展望"><h2 class="- topic/title title topictitle2" id="ariaid-title13">4. 小结和展望</h2><div class="- topic/body body"><p class="- topic/p p">通过本教程的两个应用案例，我们可以看到如何在 DolphinDB 中利用 OOP（面向对象编程）开发状态引擎算子。这种方式相比直接调用引擎提供的算子，具有可读性强、结构清晰的优点。在当前实现中，DolphinDB的 OOP 仍然采用解释执行的方式，相比原生 C++ 实现速度较慢。</p><p class="- topic/p p">目前，在响应式状态引擎中，一些有状态的高阶函数迭代算子和无状态的自定义函数算子已经可以通过即时编译（JIT）技术优化，用脚本编写的自定义函数算子的性能可以达到原生 C++ 实现的水平；但是，目前状态引擎中使用 OOP 编写的有状态的算子还没有支持 JIT 。未来，我们计划使用 JIT 技术进一步优化响应式状态引擎中的 OOP 的应用，直接将类中定义的有状态算子编译为机器码运行，以期望实现在当前较高的开发效率下也不会损失运行时的效率。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#%E5%89%8D%E8%A8%80" data-tocid="前言">前言</a></li><li class="topic-item"><a href="#1-%E5%85%B3%E4%BA%8Eoop" data-tocid="1-关于oop">1. 关于OOP</a></li><li class="topic-item"><a href="#2-dolphindb-oop-%E7%BC%96%E7%A8%8B%E6%A6%82%E8%A6%81" data-tocid="2-dolphindb-oop-编程概要">2. DolphinDB OOP 编程概要</a><ul><li class="topic-item"><a href="#21-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89" data-tocid="21-类的定义">2.1 类的定义</a></li><li class="topic-item"><a href="#22-%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8" data-tocid="22-对象的使用">2.2 对象的使用</a></li><li class="topic-item"><a href="#23-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8" data-tocid="23-对象属性类型标注">2.3 对象属性类型标注</a></li><li class="topic-item"><a href="#24-%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90" data-tocid="24-变量解析">2.4 变量解析</a></li><li class="topic-item"><a href="#25-self-%E8%AF%AD%E6%B3%95" data-tocid="25-self-语法">2.5 self 语法</a></li></ul></li><li class="topic-item"><a href="#3-%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B" data-tocid="3-应用案例">3. 应用案例</a><ul><li class="topic-item"><a href="#31-%E7%B4%AF%E8%AE%A1%E6%B1%82%E5%92%8C%E7%AE%97%E5%AD%90mycumsum" data-tocid="31-累计求和算子mycumsum">3.1 累计求和算子：MyCumSum</a></li><li class="topic-item"><a href="#32-%E7%BA%BF%E6%80%A7%E9%80%92%E5%BD%92" data-tocid="32-线性递归">3.2 线性递归</a></li></ul></li><li class="topic-item"><a href="#4-%E5%B0%8F%E7%BB%93%E5%92%8C%E5%B1%95%E6%9C%9B" data-tocid="4-小结和展望">4. 小结和展望</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>