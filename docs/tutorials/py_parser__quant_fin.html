<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="面向读者 有 Python 编程基础的 DolphinDB 初学者 本教程教学内容 如何在 DolphinDB 中用 Python 语言开发因子代码，并完成计算和入库存储 如何在 DolphinDB 中用 Python 语言创建各种不同频率的因子存储库表 如何在 DolphinDB 中用 Python 语言开发各种场景的因子计算代码 DolphinDB Python Parser（简称 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="python-parser-在金融量化分析场景的应用入门"/><title>Python Parser 在金融量化分析场景的应用入门</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;python-parser-在金融量化分析场景的应用入门&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Python Parser 在金融量化分析场景的应用入门&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;面向读者&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;有 Python 编程基础的 DolphinDB 初学者&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本教程教学内容&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;如何在 DolphinDB 中用 Python 语言开发因子代码，并完成计算和入库存储&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;10:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;如何在 DolphinDB 中用 Python 语言创建各种不同频率的因子存储库表&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;如何在 DolphinDB 中用 Python 语言开发各种场景的因子计算代码&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB Python Parser（简称 Python Parser）是 Python 语言的一个 DolphinDB 实现。目前 Python Parser 支持了 Python 中最常用的语法，并兼容了 DolphinDB 部分独有的语法。通过 Python Parser，用户可以在 DolphinDB 支持的编程 IDE 中用 Python 语言编写脚本，然后提交给 DolphinDB Server 进行解析执行并得到结果。Python Parser 打破了全局解释锁（GIL, Global Interpreter Lock）的限制，能够方便地实现分布式并行计算。Python Parser 对 Python 语法的兼容，降低了用户上手 DolphinDB 的难度。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本教程基于量化投研中的因子挖掘场景，展示如何用 Python Parser 在 DolphinDB 上快速完成因子开发，包括因子计算和结果存储。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:99;134:83&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-基于逐笔数据挖掘日频因子全流程&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1. 基于逐笔数据挖掘日频因子全流程&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;19:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;11-历史数据存储&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.1. 历史数据存储&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;21:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;23:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;在用 Python Parser 进行因子计算代码开发前，必须先把历史行情数据存入 DolphinDB，包括日 K 线、分钟 K 线、逐笔数据和 Level-1/Level-2 快照数据等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;25:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;关于历史数据存储的问题，DolphinDB 已经发布多篇相关教程，在此不再赘述：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;27:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通用行情数据导入教程：《&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;stockdata_csv_import_demo.md&#34; xtrc=&#34;xref:1;27:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;国内股票行情数据导入实例&lt;/xref&gt;》、《&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;LoadDataForPoc.md&#34; xtrc=&#34;xref:2;27:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;金融 PoC 用户历史数据导入指导手册之股票 level2 逐笔篇&lt;/xref&gt;》&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通联历史行情数据导入教程：《&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;../modules/easyTLDataImport/easytl_data_import.md&#34; xtrc=&#34;xref:3;28:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDBModules::easyTLDataImport 通联历史数据自动化导入功能模块使用教程&lt;/xref&gt;》&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;29:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;文本数据导入教程：《&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;md&#34; format=&#34;dita&#34; href=&#34;import_data.md&#34; xtrc=&#34;xref:4;29:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; type=&#34;topic&#34;&gt;&lt;?ditaot usertext?&gt;数据导入教程&lt;/xref&gt;》&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;上述教程代码都基于 DolphinDB 语法开发，在 DolphinDB 支持的编程 IDE 中执行代码时要选择 DolphinDB 语法解释器。选择方式如下：&lt;/p&gt;&lt;ol class=&#34;- topic/ol &#34; xtrc=&#34;ol:1;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;34:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:3;34:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;GUI 客户端&lt;/b&gt;：建议下载官网的最新版本：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://www.dolphindb.cn/product#downloads&#34; scope=&#34;external&#34; xtrc=&#34;xref:5;34:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB GUI&lt;/xref&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;36:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;使用前，应在 DolphinDB GUI 中确保语言下拉菜单已开启：点击 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:4;36:42&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;File&lt;/b&gt;&#34;../modules/easyTLDataImport/easytl_data_import.md&#34;guage dropdown** 复选框。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_0.png&#34; title=&#34;GUI 首选项&#34; xtrc=&#34;image:1;38:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;532&#34; dita-ot:image-height=&#34;410&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;40:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;此后，即可在 GUI 用户界面中的语言选择菜单中选择 DolphinDB 语法解释器。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_1.png&#34; title=&#34;GUI 配置界面&#34; xtrc=&#34;image:2;42:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;890&#34; dita-ot:image-height=&#34;219&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;47:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;47:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:5;47:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Visual Studio Code（VS Code）编辑器 + DolphinDB VS Code 插件&lt;/b&gt;：建议下载最新版 VS Code 插件：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://www.dolphindb.cn/product#downloads&#34; scope=&#34;external&#34; xtrc=&#34;xref:6;47:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;Visual Studio Code extension for DolphinDB&lt;/xref&gt;。本教程基于 V2.0.1041 开发。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;49:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;在 VS Code 的 &lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:6;49:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Settings&lt;/b&gt; 界面搜索 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;49:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt; @ext:dolphindb.dolphindb-vscode connections&lt;/codeph&gt; 后，编辑 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;49:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;settings.json&lt;/codeph&gt;，在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;49:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;dolphindb.connections&lt;/codeph&gt; 一节中，指定“python”条目。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;51:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;51:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&#34;python&#34;: true&lt;/codeph&gt; 表示使用 Python Parser 语法解释器；&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;51:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&#34;python&#34;: false&lt;/codeph&gt; 表示使用 DolphinDB 语法解释器。&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_2.png&#34; title=&#34;VS Code 配置界面&#34; xtrc=&#34;image:3;53:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;405&#34; dita-ot:image-height=&#34;316&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;57:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;为了能够成功运行本章节示例代码，可以先执行下述代码模拟生成少量逐笔成交数据：（需要将 csvDir 变量修改为 DolphinDB 部署服务器上 tradeData.csv 的实际目录，示例数据见&lt;xref class=&#34;- topic/xref &#34; dita-ot:orig-format=&#34;markdown&#34; format=&#34;dita&#34; href=&#34;#附件&#34; xtrc=&#34;xref:7;57:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;附件&lt;/xref&gt;）&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;59:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;def createTB(): dbName, tbName = &#34;dfs://TL_Level2&#34;, &#34;trade&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按天 VALUE 分区 + 股票代码 SecurityID HASH 50 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2020.01.01, 2021.01.01)) db2 = database(&#34;&#34;, ddb.HASH, [ddb.SYMBOL, 50].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine=&#34;TSDB&#34;) schemaTB = table(array(ddb.INT, 0) as ChannelNo, array(ddb.LONG, 0) as ApplSeqNum, array(ddb.SYMBOL, 0) as MDStreamID, array(ddb.LONG, 0) as BidApplSeqNum, array(ddb.LONG, 0) as OfferApplSeqNum, array(ddb.SYMBOL, 0) as SecurityID, array(ddb.SYMBOL, 0) as SecurityIDSource, array(ddb.DOUBLE, 0) as TradePrice, array(ddb.LONG, 0) as TradeQty, array(ddb.SYMBOL, 0) as ExecType, array(ddb.TIMESTAMP, 0) as TradeTime, array(ddb.TIME, 0) as LocalTime, array(ddb.LONG, 0) as SeqNo, array(ddb.INT, 0) as DataStatus, array(ddb.DOUBLE, 0) as TradeMoney, array(ddb.SYMBOL, 0) as TradeBSFlag, array(ddb.LONG, 0) as BizIndex, array(ddb.SYMBOL, 0) as OrderKind, array(ddb.SYMBOL, 0) as Market) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;TradeTime&#34;, &#34;SecurityID&#34;].toddb(), compressMethods={&#34;TradeTime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;SecurityID&#34;, &#34;TradeTime&#34;].toddb(), keepDuplicates=ddb.ALL) def loadData(csvDir): # 创建存储逐笔成交的库表 createTB() # 读示例数据 name = [&#34;ChannelNo&#34;, &#34;ApplSeqNum&#34;, &#34;MDStreamID&#34;, &#34;BidApplSeqNum&#34;, &#34;OfferApplSeqNum&#34;, &#34;SecurityID&#34;, &#34;SecurityIDSource&#34;, &#34;TradePrice&#34;, &#34;TradeQty&#34;, &#34;ExecType&#34;, &#34;TradeTime&#34;, &#34;LocalTime&#34;, &#34;SeqNo&#34;, &#34;DataStatus&#34;, &#34;TradeMoney&#34;, &#34;TradeBSFlag&#34;, &#34;BizIndex&#34;, &#34;OrderKind&#34;, &#34;Market&#34;].toddb() type = [&#34;INT&#34;, &#34;LONG&#34;, &#34;SYMBOL&#34;, &#34;LONG&#34;, &#34;LONG&#34;, &#34;SYMBOL&#34;, &#34;SYMBOL&#34;, &#34;DOUBLE&#34;, &#34;LONG&#34;, &#34;SYMBOL&#34;, &#34;TIMESTAMP&#34;, &#34;TIME&#34;, &#34;LONG&#34;, &#34;INT&#34;, &#34;DOUBLE&#34;, &#34;SYMBOL&#34;, &#34;LONG&#34;, &#34;SYMBOL&#34;, &#34;SYMBOL&#34;].toddb() t = loadText(csvDir, schema=table(name, type)) # append! 数据入库 loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;).append!(t) # 统计库内数据量 rowCount = select count(*) from loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;) # 181,683 print(rowCount) # 执行 loadData 函数, 需要将 csvDir 变量修改为 ddb 部署服务器上 csv 的实际目录 csvDir = &#34;/home/v2/下载/data/tradeData.csv&#34; loadData(csvDir)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;111:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本教程中的所有示例代码都是用 Python Parser 语法开发的，所以必须选择 Python Parser 语法解释器执行，GUI 编程工具解释器选择界面如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_3.png&#34; title=&#34;Python Parser 语法解释器&#34; xtrc=&#34;image:4;113:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;894&#34; dita-ot:image-height=&#34;220&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;12-创建日频因子存储库表&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;117:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;117:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.2. 创建日频因子存储库表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;117:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;119:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过因子存储最佳实践，日频因子存储库表创建示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;121:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://dayFactorDB&#34;, &#34;dayFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按年 RANGE 分区 + 因子名维度 VALUE 分区 db1 = database(&#34;&#34;, ddb.RANGE, date(datetimeAdd(1980.01M,seq(0,80)*12,'M'))) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb()) # 查看分区表结构 pt = loadTable(dbName, tbName) pt.schema()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:7;150:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;存储结构&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:10;152:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;对于多因子数据场景，用户可以选择&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:8;152:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;窄表&lt;/b&gt;和&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:9;152:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;宽表&lt;/b&gt;两种模式。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:11;153:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;窄表模式把因子名存为一列，而宽表模式则把每个因子存为一列。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:12;154:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;经测试在数据查询方面两种模式相差不大，但在增加因子、删除因子和更新因子等数据运维方面窄表模式性能显著优于宽表模式。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:13;155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本教程示例代码为&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:10;155:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;窄表&lt;/b&gt;存储最佳方案。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:11;157:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;分区存储&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:5;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:14;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB 支持数据分区存储，对于不同分区数据支持多线程并行写入，对于同一个分区数据支持并发查询。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:15;160:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;经测试日频因子数据采用“&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:12;160:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按年 + 因子名&lt;/b&gt;”的组合分区方式存储，综合性能最佳。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:13;162:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;分区内分组排序存储&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:6;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:16;164:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB 的 TSDB 存储引擎提供排序键设置，每一个分区的数据写在一个或多个 level file 中，每一个 level file 内部的数据按照指定的列进行排序且创建索引。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:17;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;排序列中除了最后一列的其他列通常为在点查中过滤条件会用到的列，其唯一值组合称为 SortKeys。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:18;166:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;为保证性能最优，每个分区的 SortKeys 建议不超过 1000 个。当 SortKeys 较多时，可以通过设置 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;166:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;sortKeyMappingFunction&lt;/i&gt; 对 SortKeys 降维。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:19;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;经测试日频因子数据采用“&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:14;167:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid+tradetime&lt;/b&gt;”的方式进行排序，sortKeyMapping 设置为 500 综合性能最佳。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:20;168:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB 默认数据存储的压缩算法为 lz4，对于时间、日期类型的数据，建议指定采用 Delta（delta-of-delta encoding） 压缩算法存储，提高存储的压缩比。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;13-当日尾盘成交占比因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.3. 当日尾盘成交占比因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;170:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;172:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;基于逐笔成交数据计算当日尾盘成交占比因子的计算公式如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_4.png&#34; xtrc=&#34;image:5;174:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;256&#34; dita-ot:image-height=&#34;73&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;176:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中 BCVP&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:1;176:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 日期的尾盘成交占比；Vol&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:2;176:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 日期的总成交量；Vol&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:3;176:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t,14:30-15:00&lt;/sub&gt; 表示 t 日期的 14:30—15:00 的成交量之和。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;178:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;180:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def beforeClosingVolumePercent(trade): tradeTime = trade[&#34;TradeTime&#34;].astype(ddb.TIME) beforeClosingVolume = trade[&#34;TradeQty&#34;][(tradeTime &amp;gt;= 14:30:00.000)&amp;amp;(tradeTime &amp;lt;= 15:00:00.000)].sum() totalVolume = trade[&#34;TradeQty&#34;].sum() res = beforeClosingVolume / totalVolume return pd.Series([res], [&#34;BCVP&#34;]) # 指定计算某一天的因子 tradeTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;) df = pd.DataFrame(tradeTB, index=&#34;Market&#34;, lazy=True) res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;TradeQty&#34;]].groupby([&#34;SecurityID&#34;]).apply(beforeClosingVolumePercent)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;198:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:7;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:21;200:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;200:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;beforeClosingVolumePercent&lt;/codeph&gt; 的函数体是按照 Python 语法进行开发的。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:22;201:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;201:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradeTime = trade[&#34;TradeTime&#34;].astype(ddb.TIME)&lt;/codeph&gt; 逐笔成交数据中的 TradeTime 以时间戳 TIMESTAMP 的数据类型存入数据库。数据类型的转化可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;201:110&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;astype()&lt;/codeph&gt; 函数。其中的类型关键字，需要加上 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;201:138&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;ddb&lt;/codeph&gt; 的前缀。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:23;202:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB 中的时间常量的格式：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;202:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;yyyy.MM.ddTHH:mm:ss.SSS&lt;/codeph&gt;，比如：14:30:00.000、2023.02.01、2023.02.01T14:30:00.000&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:24;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;203:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradeTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;203:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;trade&#34; 的元数据取回到内存。此时变量 tradeTB 只包含元数据，库内数据并未取到内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:25;204:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;204:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(tradeTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;204:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;204:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;204:156&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:26;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;205:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:27;206:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;206:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:28;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;207:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby.apply&lt;/codeph&gt; 实现了并行计算。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;14-存入数据库&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.4. 存入数据库&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;上一节中的计算结果 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;211:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;res&lt;/codeph&gt; 是当前会话中的一个本地内存变量，关闭会话便会被释放，所以需要把计算结果存入数据库中的分区表中，达到持久化的目的。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;把因子计算结果从内存存储到磁盘上的示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;215:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;# res 是一个 Series, 需要将计算结果转化成窄表格式（共4列：tradetime, securityid, factorname, value） result = res.reset_index().rename(columns={&#34;SecurityID&#34;:&#34;securityid&#34;}) result[&#34;tradetime&#34;] = 2023.02.01 result = result.melt(id_vars=[&#34;tradetime&#34;, &#34;securityid&#34;],value_vars=[&#34;BCVP&#34;],var_name=&#34;factorname&#34;,value_name=&#34;value&#34;) # 存入数据库 loadTable(dbName, tbName).append!(result.to_table()) # 查看库内数据量 select count(*) from loadTable(dbName, tbName)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;228:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:8;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:29;230:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子库用窄表方式存储，需要先将 DataFrame 转化为和因子库统一的 4 列的格式：tradetime, securityid, factorname, value。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:30;231:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因为上述示例只计算了一天的因子，结果中没有日期信息，所以需要增加日期信息。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:31;232:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;232:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;melt&lt;/codeph&gt; 函数，将宽表转化为窄表。当计算出多个因子值时，可以修改参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;232:43&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;value_vars&lt;/i&gt;=[“factorname1“, “factorname2“, …]。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:32;233:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;233:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;result.to_table()&lt;/codeph&gt; 用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;233:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;.to_table()&lt;/codeph&gt; 函数将 no-lazy 模式的 DataFrame 转化为 DolphinDB 中的内存表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:33;234:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;234:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;append!&lt;/codeph&gt; 函数，将因子结果存入数据库。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-创建因子存储库表&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2. 创建因子存储库表&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;236:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;238:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;不同频率的因子数据每日数据量是不同的，DolphinDB 的分区方案主要是根据数据量来制定的，以窄表模式存储的数据量统计如下：&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;8&#34; xtrc=&#34;tgroup:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:2;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:3;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:4;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:5;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:6;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:7;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col8&#34; colnum=&#34;8&#34; xtrc=&#34;colspec:8;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:1;240:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:15;240:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;类型&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:2;240:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:16;240:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;标的数&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:3;240:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:17;240:22&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子数&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:4;240:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:18;240:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;频率&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:5;240:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:19;240:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:6;240:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:20;240:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;数据量 (TB)&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:7;240:64&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:21;240:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;数据行数 (亿行)&lt;/b&gt;&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:8;240:80&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:22;240:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日新增数据 (GB)&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:1;242:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:2;242:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:9;242:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;股票&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:10;242:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:11;242:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:12;242:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日频&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:13;242:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;11 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:14;242:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.4&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:15;242:74&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,337&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:16;242:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.9&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:3;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:17;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;股票&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:18;243:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:19;243:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:20;243:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10 分钟&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:21;243:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;11 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:22;243:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;58.3&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:23;243:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;32,076&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:24;243:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;22.4&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:4;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:25;244:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;股票&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:26;244:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:27;244:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:28;244:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 分钟&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:29;244:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;11 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:30;244:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;583.4&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:31;244:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;320,760&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:32;244:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;223.5&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:5;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:33;245:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;股票&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:34;245:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:35;245:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:36;245:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3 秒&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:37;245:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:38;245:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;126.8&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:39;245:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;58,080&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:40;245:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;536.4&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:6;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:41;246:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;股票&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:42;246:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:43;246:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:44;246:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 秒&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:45;246:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:46;246:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;380.3&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:47;246:76&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;174,240&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:48;246:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,609.3&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:7;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:49;247:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;期货&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:50;247:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;200&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:51;247:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,000&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:52;247:37&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500 毫秒&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:53;247:47&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 年&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:54;247:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;35.2&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:55;247:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;16,117&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col8&#34; dita-ot:x=&#34;8&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:56;247:96&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;148.9&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;249:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;为了方便用户快速上手 DolphinDB，我们通过因子存储最佳实践，总结了常用频率因子的最优存储方案，并给出了示例代码，如果用户没有时间了解分区的原理，直接复用官方提供的库表创建示例代码即可。&lt;/p&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:2;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;5&#34; xtrc=&#34;tgroup:2;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:9;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:10;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:11;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:12;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:13;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:2;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:8;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:57;251:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:23;251:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子库&lt;/b&gt;&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:58;251:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:24;251:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;分区方案&lt;/b&gt;&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:59;251:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:25;251:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;分区列&lt;/b&gt;&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:60;251:93&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:26;251:94&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;排序列（sortColumns）&lt;/b&gt;&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:61;251:116&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:27;251:117&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;sortKeyMap&lt;/b&gt;&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:2;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:9;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:62;253:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:63;253:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按年 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:64;253:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:65;253:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:66;253:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:10;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:67;254:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 分钟频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:68;254:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按天 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:69;254:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:70;254:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:71;254:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:11;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:72;255:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10 分钟频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:73;255:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按月 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:74;255:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:75;255:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:76;255:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:12;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:77;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3s 快照频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:78;256:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按日 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:79;256:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:80;256:91&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:81;256:119&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:13;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:82;257:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:83;257:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按日 + 因子名 + 股票代码维度：HASH 10&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:84;257:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname + securityid&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:85;257:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:86;257:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;不降维&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:14;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:87;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1s 频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:88;258:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按小时 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:89;258:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:90;258:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:91;258:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:15;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:92;259:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;期货 500ms 频&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:93;259:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;时间维度按日 + 因子名&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:94;259:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradetime + factorname&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:95;259:92&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;securityid + tradetime&lt;/entry&gt;&lt;entry align=&#34;left&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:96;259:120&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;500&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-日频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.1. 日频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;261:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;263:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;265:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://dayFactorDB&#34;, &#34;dayFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按年 RANGE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.RANGE, date(datetimeAdd(1980.01M,seq(0,80)*12,'M'))) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-1-分钟频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.2. 1 分钟频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;290:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 分钟频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;294:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://minuteFactorDB&#34;, &#34;minuteFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2021.01.01, 2021.12.31)) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;23-10-分钟频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.3. 10 分钟频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;319:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;321:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10 分钟频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;323:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://tenMinutesFactorDB&#34;, &#34;tenMinutesFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按月 VALUE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2023.01M, 2023.06M)) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;24-3-秒快照频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.4. 3 秒快照频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;348:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;350:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3 秒快照频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;352:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://level2FactorDB&#34;, &#34;level2FactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2022.01.01, 2022.12.31)) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;25-逐笔频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.5. 逐笔频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;379:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;381:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://tickFactorDB&#34;, &#34;tickFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区 + 股票代码 HASH 10 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2022.01.01, 2022.12.31)) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db3 = database(&#34;&#34;, ddb.HASH, [ddb.SYMBOL, 10].toddb()) db = database(dbName, ddb.COMPO, [db1, db2, db3].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;, &#34;securityid&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL)&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;26-1-秒频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;407:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;407:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.6. 1 秒频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;407:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;409:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1 秒频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;411:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://secondFactorDB&#34;, &#34;secondFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按小时 VALUE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(datehour(2022.01.01T00:00:00), datehour(2022.01.31T00:00:00))) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;27-期货-500-毫秒频因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.7. 期货 500 毫秒频因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;期货 500 毫秒频因子数据库和分区表的创建示例代码：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;440:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb dbName, tbName = &#34;dfs://futuresFactorDB&#34;, &#34;futuresFactorTB&#34; # 数据库如果存在，删除该数据库 if existsDatabase(dbName): dropDatabase(dbName) # 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区 db1 = database(&#34;&#34;, ddb.VALUE, seq(2021.01.01, 2021.12.31)) db2 = database(&#34;&#34;, ddb.VALUE, [&#34;f1&#34;,&#34;f2&#34;].toddb()) db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK') # 创建分区表 schemaTB = table(array(ddb.DATE, 0) as tradetime, array(ddb.SYMBOL, 0) as securityid, array(ddb.SYMBOL, 0) as factorname, array(ddb.DOUBLE, 0) as value) db.createPartitionedTable(schemaTB, tbName, partitionColumns=[&#34;tradetime&#34;, &#34;factorname&#34;].toddb(), compressMethods={&#34;tradetime&#34;:&#34;delta&#34;}.toddb(), sortColumns=[&#34;securityid&#34;, &#34;tradetime&#34;].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3--量化因子计算代码开发&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3. 量化因子计算代码开发&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;464:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;466:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节基于股票行情数据，选取了一些具有代表性的因子，用 Python Parser 进行了实现，旨在指导用户进行自定义因子的转写和开发。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-双均线因子&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.1. 双均线因子&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;468:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;470:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;双均线就是根据两条周期不一样的均线的相对位置来跟踪趋势的一种方法，本教程我们使用双均线交叉的方式来判断买卖方向：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:9;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:34;472:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;短周期均线&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:28;472:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;从下向上&lt;/b&gt;突破长周期均线时，意味着当前时间段具有上涨趋势，突破点就是常说的&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:29;472:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;金叉&lt;/b&gt;，是股票的&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:30;472:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;买入信号&lt;/b&gt;，在代码里，使用前一短均值小于前一长均值且当前短均值大于当前长均值的方式来判断金叉，赋予信号值为 1；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:35;473:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;短周期均线&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:31;473:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;从上向下&lt;/b&gt;跌破长周期均线时，意味着当前时间段具有下跌趋势，跌破点就是常说的&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:32;473:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;死叉&lt;/b&gt;，是股票的&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:33;473:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;卖出信号&lt;/b&gt;，在代码里，使用前一短均值大于前一长均值且当前短均值小于当前长均值的方式来判断金叉，赋予信号值为 -1。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;475:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;在这里我们使用简单移动平均（Simple Moving Average），其中 n 为窗口大小：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_1.png&#34; xtrc=&#34;image:6;477:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;268&#34; dita-ot:image-height=&#34;85&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;479:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;在下边的例子中我们使用了全市场 2020.07.01 至 2023.07.19 的日频股票数据来进行计算，在实际使用中可以自由更换数据频率，如分钟频率，小时频率等。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;481:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;483:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 调用数据 df = loadTable(&#34;dfs://Daily_adj_price&#34;, &#34;data&#34;) df = pd.DataFrame(df, &#34;TRADE_DATE&#34;, True) # 定义计算 ma 金叉死叉信号生成的方法 def signal_ma(data_chunk, short, long): #分别计算出5日和20日均线及其前一根均线 data_chunk['ma_5'] = data_chunk['CLOSE_PRICE_1'].fillna(0).rolling(int(short)).mean() data_chunk['ma_20'] = data_chunk['CLOSE_PRICE_1'].fillna(0).rolling(int(long)).mean() data_chunk['pre_ma5'] = data_chunk['ma_5'].shift(1) data_chunk['pre_ma20'] = data_chunk['ma_20'].shift(1) # 通过df[contion]方式按列进行条件，判断出金叉死叉信号 data_chunk['signal'] = 0 data_chunk.loc[((data_chunk.loc[:,'pre_ma5']&amp;lt; data_chunk.loc[:,'pre_ma20'])&amp;amp; (data_chunk.loc[:,'ma_5'] &amp;gt; data_chunk.loc[:,'ma_20'])), &#34;signal&#34;] = 1 data_chunk.loc[((data_chunk.loc[:,'pre_ma5']&amp;gt; data_chunk.loc[:,'pre_ma20']) &amp;amp; (data_chunk.loc[:,'ma_5'] &amp;lt; data_chunk.loc[:,'ma_20'])), &#34;signal&#34;] = -1 return data_chunk # 生成信号 combined_results = df.groupby('SECURITY_ID').apply(signal_ma,5,20)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;508:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:10;510:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:36;510:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过使用 pandas 包中的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;510:19&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.groupby()&lt;/codeph&gt; + &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;510:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;apply&lt;/codeph&gt; 的方式&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:37;511:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;实现了按照股票代码分组后对前复权的收盘价使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;511:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;rolling().mean()&lt;/codeph&gt; 求出移动平均线，并根据长短期均线之间的位置关系来判断出金叉死叉进而产生信号：1 代表多头信号，-1 代表空头信号，0 则为目前没有信号。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:38;512:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;在计算双均线金叉死叉信号的时候，Python Pandas 版本的实现逻辑和代码同 Python Parser 保持了一致，因此在使用时无需额外操作即可在二者之间切换。此外，Python 解析器底层自动实现的批处理加速功能，省去了 Python 实现批处理所需的额外工作，更为高效。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-十档净委买增额&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.2. 十档净委买增额&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;514:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;516:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节展示了如何基于 Level2 快照行情数据计算十档净委买增额。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;518:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;十档净委买增额因子指的是在有效十档范围内买方资金总体增加量，即所有买价变化量的总和，计算公式如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_2.png&#34; xtrc=&#34;image:7;520:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;735&#34; dita-ot:image-height=&#34;95&#34; dita-ot:horizontal-dpi=&#34;72&#34; dita-ot:vertical-dpi=&#34;72&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;522:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中 level10_Diff&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:4;522:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻的十档净委买增额；bid&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:5;522:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;i,t&lt;/sub&gt; 表示 t 时刻的第 i 档买方报价；bidQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:6;522:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;i,t&lt;/sub&gt; 表示 t 时刻的第 i 档买方挂单数量；指示函数 I 表示报价是否在有效释放范围内。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;524:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;有效十档范围内表示不考虑已不在十档范围内的档位，即表示只考虑以下区间的档位：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_3.png&#34; xtrc=&#34;image:8;526:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;567&#34; dita-ot:image-height=&#34;85&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;528:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;最后，对过去 n 时间窗口内的十档净委买增额求和。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;530:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;532:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def level10Diff(df, lag=20): temp = df[[&#34;TradeTime&#34;, &#34;SecurityID&#34;]] temp[&#34;bid&#34;] = df[&#34;BidPrice&#34;].fillna(0) temp[&#34;bidAmt&#34;] = df[&#34;BidOrderQty&#34;].fillna(0) * df[&#34;BidPrice&#34;].fillna(0) temp[&#34;prevbid&#34;] = temp[&#34;bid&#34;].shift(1).fillna(0) temp[&#34;prevbidAmt&#34;] = temp[&#34;bidAmt&#34;].shift(1).fillna(0) temp[&#34;bidMin&#34;] = temp[&#34;bid&#34;].apply(&#34;min&#34;) temp[&#34;bidMax&#34;] = temp[&#34;bid&#34;].apply(&#34;max&#34;) temp[&#34;prevbidMin&#34;] = temp[&#34;bidMin&#34;].shift(1).fillna(0) temp[&#34;prevbidMax&#34;] = temp[&#34;bidMax&#34;].shift(1).fillna(0) temp[&#34;pmin&#34;] = temp[[&#34;bidMin&#34;, &#34;prevbidMin&#34;]].max(axis=1) temp[&#34;pmax&#34;] = temp[[&#34;bidMax&#34;, &#34;prevbidMax&#34;]].max(axis=1) amount = temp[&#34;bidAmt&#34;]*((temp[&#34;bid&#34;]&amp;gt;=temp[&#34;pmin&#34;])&amp;amp;(temp[&#34;bid&#34;]&amp;lt;=temp[&#34;pmax&#34;])) lastAmount = temp[&#34;prevbidAmt&#34;]*((temp[&#34;prevbid&#34;]&amp;gt;=temp[&#34;pmin&#34;])&amp;amp;(temp[&#34;prevbid&#34;]&amp;lt;=temp[&#34;pmax&#34;])) temp[&#34;amtDiff&#34;] = amount.apply(&#34;sum&#34;) - lastAmount.apply(&#34;sum&#34;) temp[&#34;amtDiff&#34;] = temp[&#34;amtDiff&#34;].rolling(lag, 1).sum() return temp[[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;amtDiff&#34;]].fillna(0) # 指定计算某一天一只股票的因子 snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;) df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True) df = df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)] res = level10Diff(df.compute(), 20) # 指定计算某一天的因子 snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;) df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True) res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;BidPrice&#34;, &#34;BidOrderQty&#34;]].groupby([&#34;SecurityID&#34;]).apply(lambda x:level10Diff(x, 20))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;567:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:11;569:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:39;569:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;569:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Level2 快照行情数据拥有十档行情量价数据。针对这种类型相同、含义相近的数据，可以考虑使用 DolphinDB 的 Array Vector 类型来存储。在 DolphinDB 里 Array Vector 是一种特殊的向量，用于存储可变长度的二维数组。上述代码就是基于十档行情用 Array Vector 类型存储的数据库开发的，其中“BidPrice”、“BidOrderQty”都是 ArrayVector 的列。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:40;570:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;570:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;表中 Array Vector 类型的列转化为 DataFrame 中的一列之后，其中每个元素为 List。 &lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_4.png&#34; xtrc=&#34;image:9;571:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;1289&#34; dita-ot:image-height=&#34;243&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/p&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:41;573:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;573:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;针对 Array Vector 转化的列，Python Parser 中支持四则运算、比较等基础运算（比如两列相乘 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;573:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[&#34;BidOrderQty&#34;].fillna(0) * df[&#34;BidPrice&#34;].fillna(0)&lt;/codeph&gt;）；其他运算需要使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;573:128&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;apply&lt;/codeph&gt; 函数（比如求每一行的最小值 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;573:150&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;temp[&#34;bid&#34;].apply(&#34;min&#34;)&lt;/codeph&gt;）。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:42;574:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;574:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;对于内置函数 (比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;574:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;max&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;574:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;min&lt;/codeph&gt;/&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;574:26&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;sum&lt;/codeph&gt; 等)，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;574:38&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;apply&lt;/codeph&gt; 函数时，传入字符串和传入函数是有区别的。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:12;575:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:43;575:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;传入字符串时，比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;575:15&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;temp[&#34;bid&#34;].apply(&#34;max&#34;)&lt;/codeph&gt;，首先会去找 series 类里有没有实现这个函数，如果有，就用 series 的这个函数；如果没有，就去找内置函数。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:44;576:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;传入函数时，比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:34;576:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;temp[&#34;bid&#34;].apply(max)&lt;/codeph&gt;，会直接使用内置函数。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/li&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;578:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;​ 综上，对于 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:35;578:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;apply&lt;/codeph&gt; + 内置函数 的情况下，一般建议用户传入字符串。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:13;580:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:45;580:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:36;580:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;shift(1)&lt;/codeph&gt; 的方式获取上一笔快照的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:46;581:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:37;581:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;rolling().sum()&lt;/codeph&gt; 的方式求滑动窗口内十档净委买增额的和。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:47;582:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:38;582:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:39;582:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;snapshot&#34; 的元数据取回到内存。此时变量 snapshotTB 只包含元数据，库内数据并未取到内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:48;583:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:40;583:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:41;583:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;583:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;583:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:49;584:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:42;584:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:50;585:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:43;585:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:51;586:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy 模式下不允许直接改变 DataFrame 的值。因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:44;586:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;level10Diff&lt;/codeph&gt; 函数里面有 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:45;586:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;temp[&#34;bid&#34;] = df[&#34;BidPrice&#34;].fillna(0)&lt;/codeph&gt; 的操作，所以对直接过滤出来的 df 直接调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:46;586:121&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;level10Diff(df, 20)&lt;/codeph&gt; 会报错： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:47;586:148&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Lazy-model DataFrame does not support update value.&lt;/codeph&gt; 需要使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:48;586:207&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df.compute()&lt;/codeph&gt; 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:52;587:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:49;587:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby.apply&lt;/codeph&gt; 实现了并行计算。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;33-价格变动与一档量差的回归系数&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;589:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;589:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.3. 价格变动与一档量差的回归系数&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;589:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;591:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节展示了如何基于 Level2 快照行情数据计算价格变动与一档量差的回归系数。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;593:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;回归模型：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_5.png&#34; xtrc=&#34;image:10;595:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;270&#34; dita-ot:image-height=&#34;88&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:56;597:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中，&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:14;599:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:53;599:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;ΔP&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:7;599:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻的价格变动；lastPrice&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:8;599:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻的最新价格；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:54;600:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;NVOL&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:9;600:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻的买卖一档量差；bidQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:10;600:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,t&lt;/sub&gt; 表示 t 时刻的买方一档挂单笔数；askQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:11;600:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1,t&lt;/sub&gt; 表示 t 时刻的卖方一档挂单笔数；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:55;601:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;α 表示截距；λ 表示斜率；εt 表示 t 时刻的残差。&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:57;603:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中回归系数 λ 为目标因子值。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:58;605:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;607:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def priceSensitivityOrderFlowImbalance(df): deltaP = 10000*df[&#34;LastPrice&#34;].diff().fillna(0) bidQty1 = df[&#34;BidOrderQty&#34;].values[0] askQty1 = df[&#34;OfferOrderQty&#34;].values[0] NVOL = bidQty1 - askQty1 res = beta(deltaP.values, NVOL) return pd.Series([res], [&#34;priceSensitivityOrderFlowImbalance&#34;]) # 指定计算某一天一只股票的因子 snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;) df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True) df = df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)] res = priceSensitivityOrderFlowImbalance(df.compute()) # 指定计算某一天的因子 snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;) df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True) res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;SecurityID&#34;, &#34;LastPrice&#34;, &#34;BidOrderQty&#34;, &#34;OfferOrderQty&#34;]].groupby([&#34;SecurityID&#34;]).apply(priceSensitivityOrderFlowImbalance) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:59;632:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:15;634:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:56;634:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:60;634:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Level2 快照行情数据拥有十档行情量价数据。针对这种类型相同、含义相近的数据，可以考虑使用 DolphinDB 的 Array Vector 类型来存储。在 DolphinDB 里 Array Vector 是一种特殊的向量，用于存储可变长度的二维数组。上述代码就是基于十档行情用 Array Vector 类型存储的数据库开发的，其中“BidOrderQty”，“OfferOrderQty”都是 ArrayVector 的列。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:57;635:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:61;635:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;表中 Array Vector 类型的列转化为 DataFrame 中的一列之后，其中每个元素为 List。 &lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_6.png&#34; xtrc=&#34;image:11;636:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;1289&#34; dita-ot:image-height=&#34;243&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/p&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:58;638:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:62;638:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;针对 ArrayVector 类型，DolphinDB 开发了很多内置函数提升 Array Vector 的易用性和计算性能，比如 row 系列函数。所以除了 上一章节的例子中使用的 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:50;638:95&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;apply&lt;/codeph&gt; 函数，也可以考虑将其通过 values 属性将 Series 转化为 DolphinDB 的类型，使用 DolphinDB 的内置函数，比如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:51;638:174&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[&#34;BidOrderQty&#34;].values[0]&lt;/codeph&gt; 取 Array Vector 的第一列。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:59;639:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:63;639:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:52;639:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;diff(1)&lt;/codeph&gt; 的方式计算一阶差分。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:60;640:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:64;640:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;最新价 LastPrice 使用 DOUBLE 类型存储，因为量价的数量级相差较大，所以将价格变动扩大 10000 倍。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:61;641:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:65;641:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;目前 Python Parser 只支持 pandas 中的函数，暂时还不支持 statsmodels、sklearn.linear_model 等数据分析包。所以不能直接计算回归系数。但是 DolphinDB 内置函数中，有 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:53;641:117&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;beta&lt;/codeph&gt; / &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:54;641:126&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;ols&lt;/codeph&gt; 等函数可以求回归系数。所以这里选择用 values 属性将 Series 转化为 DolphinDB 的向量，使得后续可以调用 DolphinDB 的内置函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:55;641:213&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;beta&lt;/codeph&gt;。比如，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:56;641:223&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;beta(deltaP.values, NVOL)&lt;/codeph&gt;。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:62;642:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:66;642:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:57;642:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;snapshotTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;snapshot&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:58;642:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;snapshot&#34; 的元数据取回到内存。此时变量 snapshotTB 只包含元数据，库内数据并未取到内存。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:63;643:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:67;643:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:59;643:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(snapshotTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:60;643:65&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;643:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;643:159&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:64;644:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:68;644:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:61;644:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:65;645:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:69;645:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:62;645:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:66;646:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:70;646:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;不允许 lazy 和 no-lazy 的数据直接计算。当输入的 df 是 lazy 模式时，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:63;646:49&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[&#34;LastPrice&#34;].diff()&lt;/codeph&gt; 操作会保留 lazy 模式，所以 deltaP 是 lazy 模式；&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:64;646:108&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[&#34;BidOrderQty&#34;].apply(lambda x:x[0])&lt;/codeph&gt; 则会直接触发计算，所以 NVOL 是 no-lazy 模式。所以对直接过滤出来的 df 直接调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:65;646:200&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;priceSensitivityOrderFlowImbalance(df)&lt;/codeph&gt; ，执行到 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:66;646:246&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;NVOL*deltaP&lt;/codeph&gt; 时会报错： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:67;646:266&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;The operation args should be both lazy or not lazy.&lt;/codeph&gt; 需要使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:68;646:325&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df.compute()&lt;/codeph&gt; 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。&lt;/p&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:67;647:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:71;647:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:69;647:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby.apply&lt;/codeph&gt; 实现了并行计算。&lt;/p&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;34-主动成交量占比&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;649:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;649:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.4. 主动成交量占比&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;649:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:72;651:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节展示了如何基于 Level2 逐笔成交数据计算主动成交量占比。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:73;653:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;主动成交占比即主动成交量占总成交量的比例，其计算公式如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_7.png&#34; xtrc=&#34;image:12;655:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;382&#34; dita-ot:image-height=&#34;161&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:74;657:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中 tradeQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:12;657:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;i&lt;/sub&gt; 表示 i 时刻的成交量；actVolume&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:13;657:46&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻起的前 lag 笔订单的主动成交量之和；totalVolume&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:14;657:97&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻起的前 lag 笔订单的总成交量；指示函数 I 含义如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_8.png&#34; xtrc=&#34;image:13;659:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;353&#34; dita-ot:image-height=&#34;57&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:75;661:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;663:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def actVolumePercent(trade, lag): res = trade[[&#34;TradeTime&#34;, &#34;SecurityID&#34;]] actVolume = (trade[&#34;TradeQty&#34;]*(trade['BidApplSeqNum'] &amp;gt; trade['OfferApplSeqNum'])).rolling(lag).sum() totalVolume = trade[&#34;TradeQty&#34;].rolling(lag).sum() res[&#34;actVolumePercent&#34;] = actVolume/totalVolume return res # 指定计算某一天一只股票的因子 tradeTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;) df = pd.DataFrame(tradeTB, index=&#34;Market&#34;, lazy=True) df = df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)] res = actVolumePercent(df.compute(), 60) # 指定计算某一天的因子 tradeTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;) df = pd.DataFrame(tradeTB, index=&#34;Market&#34;, lazy=True) res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;TradeQty&#34;, &#34;BidApplSeqNum&#34;, &#34;OfferApplSeqNum&#34;]].groupby([&#34;SecurityID&#34;]).apply(lambda x: actVolumePercent(x, 60))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:76;687:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:16;689:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:68;689:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过条件 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:70;689:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;trade['BidApplSeqNum'] &amp;gt; trade['OfferApplSeqNum']&lt;/codeph&gt; 过滤出主动成交订单。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:69;690:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:71;690:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;rolling(lag).sum()&lt;/codeph&gt; 的方式计算前 lag 笔订单的成交量之和。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:70;691:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:72;691:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradeTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;trade&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:73;691:56&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;trade&#34; 的元数据取回到内存。此时变量 tradeTB 只包含元数据，库内数据并未取到内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:71;692:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:74;692:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(tradeTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:75;692:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;692:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;692:156&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:72;693:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:76;693:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:73;694:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:77;694:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:74;695:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy 模式下不允许直接改变 DataFrame 的值。因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:78;695:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;actVolumePercent&lt;/codeph&gt; 函数里面有 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:79;695:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;res[&#34;actVolumePercent&#34;] = actVolume/totalVolume&lt;/codeph&gt; 的操作，所以对直接过滤出来的 df 直接调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:80;695:135&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;actVolumePercent(df, 60)&lt;/codeph&gt; 会报错： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:81;695:167&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Lazy-model DataFrame does not support update value.&lt;/codeph&gt; 需要使用 df.compute() 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:75;696:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 groupby.apply 实现了并行计算。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;35-早盘买卖单大小比&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.5. 早盘买卖单大小比&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;698:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:77;700:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节展示了如何基于 Level2 逐笔委托数据计算早盘买卖单大小比。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:78;702:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;早盘买卖单大小比即早盘时间段买入订单平均委托量占卖出订单平均委托量的比例的对数，其计算公式如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_9.png&#34; xtrc=&#34;image:14;704:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;400&#34; dita-ot:image-height=&#34;184&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:79;706:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中 openBidVol 表示早盘时间段买入订单平均委托量；openAskVol 表示早盘时间段卖出订单平均委托量；orderQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:15;706:68&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻的委托量；&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:80;708:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;​ I&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:16;708:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;bid&lt;/sub&gt; 是指示函数，当订单为买方委托单时值为 1，否则为 0；I&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:17;708:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;ask&lt;/sub&gt; 是指示函数，当订单为卖方委托单时值为 1，否则为 0。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:81;710:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;712:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def openBidVolDvdAskVol(df): tradeTime = df[&#34;TradeTime&#34;].astype(ddb.TIME) openBidVolume = df[&#34;OrderQty&#34;][(tradeTime &amp;gt;= 09:30:00.000)&amp;amp;(tradeTime &amp;lt;= 10:30:00.000)&amp;amp;((df[&#34;Side&#34;]==&#34;1&#34;)|(df[&#34;Side&#34;]==&#34;B&#34;))].mean() openAskVolume = df[&#34;OrderQty&#34;][(tradeTime &amp;gt;= 09:30:00.000)&amp;amp;(tradeTime &amp;lt;= 10:30:00.000)&amp;amp;((df[&#34;Side&#34;]==&#34;2&#34;)|(df[&#34;Side&#34;]==&#34;S&#34;))].mean() if((openBidVolume&amp;gt;0)&amp;amp;(openAskVolume&amp;gt;0)): res = log(openBidVolume / openAskVolume) else: res = None return pd.Series([res], [&#34;openBidVolDvdAskVol&#34;]) # 指定计算某一天一只股票的因子 orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;) df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True) df = df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)] res = openBidVolDvdAskVol(df) # 指定计算某一天的因子 orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;) df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True) df = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01] res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;OrderQty&#34;, &#34;Side&#34;]].groupby([&#34;SecurityID&#34;]).apply(openBidVolDvdAskVol)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:82;740:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:17;742:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:76;742:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:82;742:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;tradeTime = df[&#34;TradeTime&#34;].astype(ddb.TIME)&lt;/codeph&gt; 逐笔委托数据中的 TradeTime 以时间戳 TIMESTAMP 的数据类型存入数据库。数据类型的转化可以使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:83;742:107&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;astype()&lt;/codeph&gt; 函数。其中的类型关键字，需要加上 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:84;742:135&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;ddb&lt;/codeph&gt; 的前缀。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:77;743:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB 中的时间常量的格式：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:85;743:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;yyyy.MM.ddTHH:mm:ss.SSS&lt;/codeph&gt;，比如：09:30:00.000、2023.02.01、2023.02.01T09:30:00.000&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:78;744:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通联数据中深交所和上交所的买卖方向用的不一样的枚举值。上交所：买单“B”，卖单“S”；深交所：买单“1”，卖单“2”。所以在判断买卖单的时候，增加了“或逻辑”（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:86;744:83&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;|&lt;/codeph&gt;）的判断。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:79;745:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:87;745:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;if((openBidVolume&amp;gt;0)&amp;amp;(openAskVolume&amp;gt;0))&lt;/codeph&gt; 这部分做了一个数据校验，避免出现某些股票早盘没有委托单时，早盘委托量为空的情况。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:80;746:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:88;746:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:89;746:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;entrust&#34; 的元数据取回到内存。此时变量 orderTB 只包含元数据，库内数据并未取到内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:81;747:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:90;747:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:91;747:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:11;747:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:12;747:156&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:82;748:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:92;748:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001”这一天一只股票的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:83;749:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:93;749:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:84;750:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:94;750:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby.apply&lt;/codeph&gt; 实现了并行计算。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;36-委托量加权平均委托价格&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.6. 委托量加权平均委托价格&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;752:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:83;754:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本章节展示了如何基于 Level2 逐笔委托数据计算委托量加权平均委托价格。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:84;756:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;委托量加权平均委托价格是将多笔委托单的委托价格按各自的委托量加权而算出的平均价格，其计算公式如下：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_10.png&#34; xtrc=&#34;image:15;758:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34; dita-ot:image-width=&#34;379&#34; dita-ot:image-height=&#34;100&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:85;760:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;其中 vwap&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:18;760:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;t&lt;/sub&gt; 表示 t 时刻起的前 lag 笔委托单的委托量加权平均委托价格；orderQty&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:19;760:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;i&lt;/sub&gt; 表示 i 时刻委托单的委托量；orderPrice&lt;sub class=&#34;+ topic/ph hi-d/sub &#34; xtrc=&#34;sub:20;760:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;i&lt;/sub&gt; 表示 i 时刻委托单的委托价格。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:86;762:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子计算示例代码如下：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;764:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;import pandas as pd import dolphindb as ddb # 定义因子函数 def volumeWeightedAvgPrice(df, lag): res = df[[&#34;TradeTime&#34;, &#34;SecurityID&#34;]] totalAmount = (df[&#34;OrderQty&#34;]*df[&#34;Price&#34;]).rolling(lag).sum() totalVolume = df[&#34;OrderQty&#34;].rolling(lag).sum() res[&#34;volumeWeightedAvgPrice&#34;] = totalAmount / totalVolume return res # 指定计算某一天一只股票的因子 orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;) df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True) df = df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)] res = volumeWeightedAvgPrice(df.compute(), 60) # 指定计算某一天的因子 orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;) df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True) res = df[df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01][[&#34;TradeTime&#34;, &#34;SecurityID&#34;, &#34;OrderQty&#34;, &#34;Price&#34;]].groupby([&#34;SecurityID&#34;]).apply(lambda x: volumeWeightedAvgPrice(x, 60))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:87;788:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例代码解析：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:18;790:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:85;790:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:95;790:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;rolling(lag).sum()&lt;/codeph&gt; 的方式分别计算前 lag 笔委托单的总委托金额和总委托量&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:86;791:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:96;791:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;orderTB = loadTable(&#34;dfs://TL_Level2&#34;, &#34;entrust&#34;)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:97;791:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;loadTable&lt;/codeph&gt; 函数，将 &#34;dfs://TL_Level2&#34; 数据库下的分布式表 &#34;entrust&#34; 的元数据取回到内存。此时变量 orderTB 只包含元数据，库内数据并未取到内存。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:87;792:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:98;792:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df = pd.DataFrame(orderTB, index=&#34;Market&#34;, lazy=True)&lt;/codeph&gt; 通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:99;792:62&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;pd.DataFrame()&lt;/codeph&gt; 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:13;792:112&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;index&lt;/i&gt; 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:14;792:156&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy&lt;/i&gt; 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:88;793:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:100;793:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df[(df[&#34;TradeTime&#34;].astype(ddb.DATE)==2023.02.01)&amp;amp;(df[&#34;SecurityID&#34;]==&#34;000001&#34;)]&lt;/codeph&gt; 指定取库内 2023.02.01 的“000001”这一天一只股票的数据。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:89;794:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;建议在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:101;794:7&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby&lt;/codeph&gt; 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:90;795:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;lazy 模式下不允许直接改变 DataFrame 的值。因为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:102;795:35&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;volumeWeightedAvgPrice&lt;/codeph&gt; 函数里面有 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:103;795:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;res[&#34;orderWeightPrice&#34;] = totalAmount/totalVolume&lt;/codeph&gt; 的操作，所以对直接过滤出来的 df 直接调用函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:104;795:143&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;volumeWeightedAvgPrice(df, 60)&lt;/codeph&gt; 会报错： &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:105;795:181&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Lazy-model DataFrame does not support update value.&lt;/codeph&gt; 需要使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:106;795:240&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;df.compute()&lt;/codeph&gt; 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:91;796:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:107;796:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;groupby.apply&lt;/codeph&gt; 实现了并行计算。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-性能测试&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;798:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;798:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4. 性能测试&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;798:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-性能测试环境&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;800:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;800:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4.1. 性能测试环境&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;800:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:3;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;2&#34; xtrc=&#34;tgroup:3;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:14;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:15;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:3;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:16;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:97;802:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;CPU 类型&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:98;802:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Intel(R) Xeon(R) Gold 5220R CPU @ 2.20GHz&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:3;804:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:17;804:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:99;804:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逻辑 CPU 总数&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:100;804:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;24&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:18;805:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:101;805:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;内存&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:102;805:14&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;256 GB&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:19;806:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:103;806:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;OS&lt;/entry&gt;&lt;entry class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:104;806:16&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;CentOS Linux release 7.9.2009 (Core)&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-性能测试结果&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;808:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;808:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4.2. 性能测试结果&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;808:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:88;810:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:34;810:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;测试数据&lt;/b&gt;&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:19;812:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:92;812:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2023 年单个交易所某日的 level-2 全天数据&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:20;813:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:93;813:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;快照数据：24,313,086 行 × 62 列 [约 20.6 GB]&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:94;814:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔成交：108,307,125 行 × 19 列 [约 11.0 GB]&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:95;815:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔委托：141,182,534 行 × 16 列 [约 11.6 GB]&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;table class=&#34;- topic/table &#34; xtrc=&#34;table:4;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;tgroup class=&#34;- topic/tgroup &#34; cols=&#34;7&#34; xtrc=&#34;tgroup:4;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col1&#34; colnum=&#34;1&#34; xtrc=&#34;colspec:16;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col2&#34; colnum=&#34;2&#34; xtrc=&#34;colspec:17;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col3&#34; colnum=&#34;3&#34; xtrc=&#34;colspec:18;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col4&#34; colnum=&#34;4&#34; xtrc=&#34;colspec:19;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col5&#34; colnum=&#34;5&#34; xtrc=&#34;colspec:20;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col6&#34; colnum=&#34;6&#34; xtrc=&#34;colspec:21;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;colspec class=&#34;- topic/colspec &#34; colname=&#34;col7&#34; colnum=&#34;7&#34; xtrc=&#34;colspec:22;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;/&gt;&lt;thead class=&#34;- topic/thead &#34; xtrc=&#34;thead:4;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:20;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:105;817:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;数据源&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:106;817:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:107;817:40&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Python Parser 运行耗时&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:108;817:61&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB Scripts 运行耗时&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:109;817:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Python 运行耗时&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:110;817:100&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB Scripts / python parser 性能对比&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;1&#34; xtrc=&#34;entry:111;817:141&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;Python / python parser 性能对比&lt;/entry&gt;&lt;/row&gt;&lt;/thead&gt;&lt;tbody class=&#34;- topic/tbody &#34; xtrc=&#34;tbody:4;819:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:21;819:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:112;819:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日频 K 线&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:113;819:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;双均线因子 (单只股票）&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:114;819:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10.88 ms&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:115;819:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;9.07 ms&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:116;819:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;30 ms&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:117;819:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.836&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;2&#34; xtrc=&#34;entry:118;819:150&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.757&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:22;820:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:119;820:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;日频 K 线&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:120;820:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;双均线因子 (全市场股票）&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:121;820:32&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.1 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:122;820:57&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.566 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:123;820:86&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;14.01 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:124;820:104&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.515&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;3&#34; xtrc=&#34;entry:125;820:149&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;12.74&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:23;821:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:126;821:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;快照行情&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:127;821:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;十档净委买增额&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:128;821:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4.3 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:129;821:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.4 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:130;821:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;49.4 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:131;821:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.326&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;4&#34; xtrc=&#34;entry:132;821:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;11.488&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:24;822:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:133;822:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;快照行情&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:134;822:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;价格变动与一档量差的回归系数&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:135;822:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;2.8 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:136;822:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.34 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:137;822:81&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;25.5 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:138;822:99&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.019&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;5&#34; xtrc=&#34;entry:139;822:144&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;9.107&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:25;823:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:140;823:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔成交&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:141;823:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;主动成交量占比&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:142;823:34&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;6.9 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:143;823:59&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.2 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:144;823:88&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;52.9 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:145;823:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.174&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;6&#34; xtrc=&#34;entry:146;823:151&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;7.667&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:26;824:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:147;824:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔成交&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:148;824:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;当日尾盘成交占比&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:149;824:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4.1 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:150;824:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.31 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:151;824:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;19.6 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:152;824:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.076&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;7&#34; xtrc=&#34;entry:153;824:150&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;4.780&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:27;825:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:154;825:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔委托&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:155;825:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;早盘买卖单大小比&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:156;825:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5.8 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:157;825:58&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.64 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:158;825:87&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;21.1 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:159;825:105&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.110&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;8&#34; xtrc=&#34;entry:160;825:150&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;3.638&lt;/entry&gt;&lt;/row&gt;&lt;row class=&#34;- topic/row &#34; xtrc=&#34;row:28;826:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col1&#34; dita-ot:x=&#34;1&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:161;826:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;逐笔委托&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col2&#34; dita-ot:x=&#34;2&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:162;826:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;委托量加权平均委托价格&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col3&#34; dita-ot:x=&#34;3&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:163;826:30&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;7.2 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col4&#34; dita-ot:x=&#34;4&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:164;826:55&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;1.4 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col5&#34; dita-ot:x=&#34;5&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:165;826:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;77.2 s&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col6&#34; dita-ot:x=&#34;6&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:166;826:102&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;0.194&lt;/entry&gt;&lt;entry align=&#34;center&#34; class=&#34;- topic/entry &#34; colname=&#34;col7&#34; dita-ot:x=&#34;7&#34; dita-ot:y=&#34;9&#34; xtrc=&#34;entry:167;826:147&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;10.722&lt;/entry&gt;&lt;/row&gt;&lt;/tbody&gt;&lt;/tgroup&gt;&lt;/table&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;5. 总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;828:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:89;830:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;DolphinDB Python Parser 支持 Python 的常用语法，并兼容了 DolphinDB 部分独有语法。相比于 Python API，Python Parser 能够方便地访问 DolphinDB 库内的数据，减少了网络层面的开销；并且针对 groupby 等函数底层自动实现并行计算，提高计算性能。相比于 DolphinDB Scripts，Python Parser 兼容常用 Python 语法，学习难度更低，用户可以轻松上手 DolphinDB。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:90;832:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;本教程针对量化金融中最常见的因子计算场景，提供了一种基于 Python Parser 开发因子的解决方案，包括不同频率因子库的存储方案和基于不同频率不同数据源的基础因子开发代码，并且因子计算性能和 Python 多进程框架相比能有 5 倍以上的提升。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-附件&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;6. 附件&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;834:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:21;836:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:96;836:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;示例数据：&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;data/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/tradeData.zip&#34; xtrc=&#34;xref:8;836:8&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;tradeData.zip&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:97;837:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子实现 DolphinDB 版本：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:22;838:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:98;838:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/当日尾盘成交占比.txt&#34; xtrc=&#34;xref:9;838:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;当日尾盘成交占比.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:99;839:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/价格变动与一档量差的回归系数.txt&#34; xtrc=&#34;xref:10;839:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;价格变动与一档量差的回归系数.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:100;840:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/十档净委买增额.txt&#34; xtrc=&#34;xref:11;840:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;十档净委买增额.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:101;841:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/双均线.txt&#34; xtrc=&#34;xref:12;841:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;双均线.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:102;842:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/委托量加权平均委托价格.txt&#34; xtrc=&#34;xref:13;842:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;委托量加权平均委托价格.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:103;843:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/早盘买卖单大小比.txt&#34; xtrc=&#34;xref:14;843:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;早盘买卖单大小比.txt&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:104;844:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;txt&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_DolphinDB版本/主动成交量占比.txt&#34; xtrc=&#34;xref:15;844:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;主动成交量占比.txt&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:105;845:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;因子实现 Python 版本：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:23;846:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:106;846:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;zip&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/双均线.zip&#34; xtrc=&#34;xref:16;846:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;双均线&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:107;847:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/当日尾盘成交占比.ipynb&#34; xtrc=&#34;xref:17;847:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;当日尾盘成交占比.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:108;848:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/价格变动与一档量差的回归系数.ipynb&#34; xtrc=&#34;xref:18;848:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;价格变动与一档量差的回归系数.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:109;849:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/十档委买增额.ipynb&#34; xtrc=&#34;xref:19;849:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;十档委买增额.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:110;850:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/委托量加权平均委托价格.ipynb&#34; xtrc=&#34;xref:20;850:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;委托量加权平均委托价格.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:111;851:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/早盘买卖单大小比.ipynb&#34; xtrc=&#34;xref:21;851:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;早盘买卖单大小比.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:112;852:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;xref class=&#34;- topic/xref &#34; format=&#34;ipynb&#34; href=&#34;script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/因子实现_Python版本/主动成交量占比.ipynb&#34; xtrc=&#34;xref:22;852:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/py_parser__quant_fin.md&#34;&gt;&lt;?ditaot usertext?&gt;主动成交量占比.ipynb&lt;/xref&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/py_parser__quant_fin.md"/><meta name="wh-out-relpath" content="tutorials/py_parser__quant_fin.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="python-parser-在金融量化分析场景的应用入门" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/OHLC_2.html">金融场景案例</a></div></div></li><li class="active"><div class="topicref" data-id="python-parser-在金融量化分析场景的应用入门"><div class="title"><a href="../tutorials/py_parser__quant_fin.html">Python Parser 在金融量化分析场景的应用入门</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="k-线计算-d9713e102569" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="k-线计算-d9713e102569-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="使用-klinechart-展示-dolphindb-k-线-d9713e102615" class="topicref" data-id="使用-klinechart-展示-dolphindb-k-线" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/displaying_the_dolphindb_k-line_with_klinechart.html" id="使用-klinechart-展示-dolphindb-k-线-d9713e102615-link">使用 KLineChart 展示 DolphinDB K 线</a></div></div></li><li role="treeitem"><div data-tocid="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661" class="topicref" data-id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_HDF5_vs_DolphinDB.html" id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661-link">Python + HDF5 因子计算与 DolphinDB 一体化因子计算方案对比</a></div></div></li><li role="treeitem"><div data-tocid="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707" class="topicref" data-id="python--文件存储与-dolphindb-因子计算性能比较" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_VS_PythonFile_Storage.html" id="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707-link">Python + 文件存储与 DolphinDB 因子计算性能比较</a></div></div></li><li role="treeitem" class="active"><div data-tocid="python-parser-在金融量化分析场景的应用入门-d9713e102753" class="topicref" data-id="python-parser-在金融量化分析场景的应用入门" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/py_parser__quant_fin.html" id="python-parser-在金融量化分析场景的应用入门-d9713e102753-link">Python Parser 在金融量化分析场景的应用入门</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e102799" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc_2.html" id="处理-level-2-行情数据实例-d9713e102799-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="存储金融数据的分区方案最佳实践-d9713e102845" class="topicref" data-id="存储金融数据的分区方案最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_partitioned_storage.html" id="存储金融数据的分区方案最佳实践-d9713e102845-link">存储金融数据的分区方案最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="公募基金历史数据基础分析教程-d9713e102891" class="topicref" data-id="公募基金历史数据基础分析教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/public_fund_basic_analysis.html" id="公募基金历史数据基础分析教程-d9713e102891-link">公募基金历史数据基础分析教程</a></div></div></li><li role="treeitem"><div data-tocid="股票行情回放-d9713e102937" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay_2.html" id="股票行情回放-d9713e102937-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="搭建行情回放服务的最佳实践-d9713e102983" class="topicref" data-id="搭建行情回放服务的最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/appendices_market_replay_bp.html" id="搭建行情回放服务的最佳实践-d9713e102983-link">搭建行情回放服务的最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="国内股票行情数据导入实例-d9713e103029" class="topicref" data-id="国内股票行情数据导入实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stockdata_csv_import_demo.html" id="国内股票行情数据导入实例-d9713e103029-link">国内股票行情数据导入实例</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e103076" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV_2.html" id="基金份额参考价值-iopv-计算-d9713e103076-link">基金份额参考价值 IOPV 计算</a></div></div></li><li role="treeitem"><div data-tocid="基于快照行情的股票和基金-k-线合成-d9713e103122" class="topicref" data-id="基于快照行情的股票和基金-k-线合成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k.html" id="基于快照行情的股票和基金-k-线合成-d9713e103122-link">基于快照行情的股票和基金 K 线合成</a></div></div></li><li role="treeitem"><div data-tocid="计算基金日频因子-d9713e103168" class="topicref" data-id="计算基金日频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/fund_factor_contrasted_by_py.html" id="计算基金日频因子-d9713e103168-link">计算基金日频因子</a></div></div></li><li role="treeitem"><div data-tocid="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214" class="topicref" data-id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/orderBookSnapshotEngine.html" id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214-link">基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</a></div></div></li><li role="treeitem"><div data-tocid="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260" class="topicref" data-id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/LoadDataForPoc.html" id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260-link">金融 PoC 用户历史数据导入指导手册之股票 Level-2 逐笔篇</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e103306" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility_2.html" id="金融实时实际波动率预测-d9713e103306-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e103352" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant_2.html" id="金融因子流式实现-d9713e103352-link">金融因子流式实现</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e103398" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features_2.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e103398-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc_2.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="量化金融范例-d9713e103490" class="topicref" data-id="量化金融范例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/quant_finance_examples.html" id="量化金融范例-d9713e103490-link">量化金融范例</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e103536" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000_2.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e103536-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="深度不平衡买卖压力指标波动率计算-d9713e103583" class="topicref" data-id="深度不平衡买卖压力指标波动率计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/sql_performance_optimization_wap_di_rv.html" id="深度不平衡买卖压力指标波动率计算-d9713e103583-link">深度不平衡、买卖压力指标、波动率计算</a></div></div></li><li role="treeitem"><div data-tocid="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629" class="topicref" data-id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/insight_plugin_orderbook_engine_application.html" id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629-link">实时合成自定义频订单簿快照：DolphinDB INSIGHT 行情插件与订单簿引擎应用</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e103675" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order_2.html" id="实时计算分钟资金流-d9713e103675-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算高频因子-d9713e103721" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming_2.html" id="实时计算高频因子-d9713e103721-link">实时计算高频因子</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e103767" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily_2.html" id="实时计算日累计逐单资金流-d9713e103767-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e103813" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc_2.html" id="实时计算涨幅榜-d9713e103813-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="实时选取外汇行情多价源最优价-d9713e103859" class="topicref" data-id="实时选取外汇行情多价源最优价" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_price_selection.html" id="实时选取外汇行情多价源最优价-d9713e103859-link">实时选取外汇行情多价源最优价</a></div></div></li><li role="treeitem"><div data-tocid="外汇掉期估值计算-d9713e103905" class="topicref" data-id="外汇掉期估值计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/FxSwapValuation.html" id="外汇掉期估值计算-d9713e103905-link">外汇掉期估值计算</a></div></div></li><li role="treeitem"><div data-tocid="因子计算平台构建-d9713e103951" class="topicref" data-id="因子计算平台构建" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_Celery.html" id="因子计算平台构建-d9713e103951-link">因子计算平台构建</a></div></div></li><li role="treeitem"><div data-tocid="因子计算最佳实践-d9713e103997" class="topicref" data-id="因子计算最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practice_for_factor_calculation.html" id="因子计算最佳实践-d9713e103997-link">因子计算最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="mvo_tutorial-d9713e104043" class="topicref" data-id="mvo_tutorial" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/MVO.html" id="mvo_tutorial-d9713e104043-link">优化投资组合：DolphinDB 最优化求解系列函数应用指南</a></div></div></li><li role="treeitem"><div data-tocid="中高频多因子库存储最佳实践-d9713e104090" class="topicref" data-id="中高频多因子库存储最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_multi_factor.html" id="中高频多因子库存储最佳实践-d9713e104090-link">中高频多因子库存储最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136" class="topicref" data-id="alphalens-在-dolphindb-中的应用因子分析建模实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Practical_Factor_Analysis_Modeling.html" id="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136-link">Alphalens 在 DolphinDB 中的应用：因子分析建模实践</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-dolphinscheduler-的集成-d9713e104182" class="topicref" data-id="dolphindb-与-dolphinscheduler-的集成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphinscheduler_integration.html" id="dolphindb-与-dolphinscheduler-的集成-d9713e104182-link">DolphinDB 与 DolphinScheduler 的集成</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-python-airflow-最佳实践-d9713e104228" class="topicref" data-id="dolphindb-与-python-airflow-最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_airflow.html" id="dolphindb-与-python-airflow-最佳实践-d9713e104228-link">DolphinDB 与 Python AirFlow 最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="gplearn-d9713e104274" class="topicref" data-id="gplearn" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/gplearn.html" id="gplearn-d9713e104274-link">Shark GPLearn 快速上手</a></div></div></li><li role="treeitem"><div data-tocid="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320" class="topicref" data-id="利用jit加速计算-etf-期权隐含波动率和希腊值" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/IV_Greeks_Calculation_for_ETF_Options_Using_JIT.html" id="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320-link">利用JIT加速计算 ETF 期权隐含波动率和希腊值</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366" class="topicref" data-id="基于-dolphindb-的-brinson-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/brinson.html" id="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366-link">基于 DolphinDB 的 Brinson 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412" class="topicref" data-id="基于-dolphindb-的-campisi-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/campisi.html" id="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412-link">基于 DolphinDB 的 Campisi 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="期货分钟频cta策略回测案例-d9713e104458" class="topicref" data-id="期货分钟频cta策略回测案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/futures_minute_frequency_cta_strategy_backtest_example.html" id="期货分钟频cta策略回测案例-d9713e104458-link">期货分钟频CTA策略回测案例</a></div></div></li><li role="treeitem"><div data-tocid="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504" class="topicref" data-id="exchdata-交易所历史股票数据自动化导入功能模块使用教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/exchdata_exchange_historical_stock_data_auto_import_module_tutorial.html" id="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504-link">ExchData 交易所历史股票数据自动化导入功能模块使用教程</a></div></div></li><li role="treeitem"><div data-tocid="ficc_func_uasge_and_performance-d9713e104550" class="topicref" data-id="ficc_func_uasge_and_performance" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_func_uasge_and_performance.html" id="ficc_func_uasge_and_performance-d9713e104550-link">FICC 固收系列函数使用示例及性能</a></div></div></li><li role="treeitem"><div data-tocid="title1-d9713e104597" class="topicref" data-id="title1" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_funcs_application.html" id="title1-d9713e104597-link">FICC 固收系列函数应用场景</a></div></div></li><li role="treeitem"><div data-tocid="最优化函数_socp_的使用及转化案例-d9713e104643" class="topicref" data-id="最优化函数_socp_的使用及转化案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/socp_usage_case.html" id="最优化函数_socp_的使用及转化案例-d9713e104643-link">最优化函数 socp 的使用及转化案例</a></div></div></li><li role="treeitem"><div data-tocid="k_line_calculation-d9713e104689" class="topicref" data-id="k_line_calculation" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k_line_calculation%20.html" id="k_line_calculation-d9713e104689-link">基于期货快照行情数据计算合约 K 线以及主连行情</a></div></div></li><li role="treeitem"><div data-tocid="backtest_introduction_usage-d9713e104735" class="topicref" data-id="backtest_introduction_usage" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/backtest_introduction_usage.html" id="backtest_introduction_usage-d9713e104735-link">融资融券策略回测使用说明及回测案例</a></div></div></li><li role="treeitem"><div data-tocid="stock_backtest-d9713e104781" class="topicref" data-id="stock_backtest" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_backtest.html" id="stock_backtest-d9713e104781-link">股票中低频投资组合回测案例实现</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">Python Parser 在金融量化分析场景的应用入门</h1><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">面向读者</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">有 Python 编程基础的 DolphinDB 初学者</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">本教程教学内容</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">如何在 DolphinDB 中用 Python 语言开发因子代码，并完成计算和入库存储</li><li class="- topic/li li">如何在 DolphinDB 中用 Python 语言创建各种不同频率的因子存储库表</li><li class="- topic/li li">如何在 DolphinDB 中用 Python 语言开发各种场景的因子计算代码</li></ul><p class="- topic/p p">DolphinDB Python Parser（简称 Python Parser）是 Python 语言的一个 DolphinDB 实现。目前 Python Parser 支持了 Python 中最常用的语法，并兼容了 DolphinDB 部分独有的语法。通过 Python Parser，用户可以在 DolphinDB 支持的编程 IDE 中用 Python 语言编写脚本，然后提交给 DolphinDB Server 进行解析执行并得到结果。Python Parser 打破了全局解释锁（GIL, Global Interpreter Lock）的限制，能够方便地实现分布式并行计算。Python Parser 对 Python 语法的兼容，降低了用户上手 DolphinDB 的难度。</p><p class="- topic/p p">本教程基于量化投研中的因子挖掘场景，展示如何用 Python Parser 在 DolphinDB 上快速完成因子开发，包括因子计算和结果存储。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-基于逐笔数据挖掘日频因子全流程"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 基于逐笔数据挖掘日频因子全流程</h2><div class="- topic/body body"></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-历史数据存储"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1. 历史数据存储</h3><div class="- topic/body body"><p class="- topic/p p">在用 Python Parser 进行因子计算代码开发前，必须先把历史行情数据存入 DolphinDB，包括日 K 线、分钟 K 线、逐笔数据和 Level-1/Level-2 快照数据等。</p><p class="- topic/p p">关于历史数据存储的问题，DolphinDB 已经发布多篇相关教程，在此不再赘述：</p><ul class="- topic/ul ul"><li class="- topic/li li">通用行情数据导入教程：《<a class="- topic/xref xref" href="stockdata_csv_import_demo.html">国内股票行情数据导入实例</a>》、《<a class="- topic/xref xref" href="LoadDataForPoc.html">金融 PoC 用户历史数据导入指导手册之股票 level2 逐笔篇</a>》</li><li class="- topic/li li">通联历史行情数据导入教程：《<a class="- topic/xref xref" href="../modules/easyTLDataImport/easytl_data_import.html">DolphinDBModules::easyTLDataImport 通联历史数据自动化导入功能模块使用教程</a>》</li><li class="- topic/li li">文本数据导入教程：《<a class="- topic/xref xref" href="import_data.html">数据导入教程</a>》</li></ul><p class="- topic/p p">上述教程代码都基于 DolphinDB 语法开发，在 DolphinDB 支持的编程 IDE 中执行代码时要选择 DolphinDB 语法解释器。选择方式如下：</p><ol class="- topic/ol ol"><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">GUI 客户端</strong>：建议下载官网的最新版本：<a class="- topic/xref xref" href="https://www.dolphindb.cn/product#downloads" target="_blank" rel="external noopener">DolphinDB GUI</a>。</p><p class="- topic/p p">使用前，应在 DolphinDB GUI 中确保语言下拉菜单已开启：点击 <strong class="+ topic/ph hi-d/b ph b">File</strong>"../modules/easyTLDataImport/easytl_data_import.md"guage dropdown** 复选框。</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_0.png"/><br/><p class="- topic/p p">此后，即可在 GUI 用户界面中的语言选择菜单中选择 DolphinDB 语法解释器。</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_1.png"/><br/></li><li class="- topic/li li"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">Visual Studio Code（VS Code）编辑器 + DolphinDB VS Code 插件</strong>：建议下载最新版 VS Code 插件：<a class="- topic/xref xref" href="https://www.dolphindb.cn/product#downloads" target="_blank" rel="external noopener">Visual Studio Code extension for DolphinDB</a>。本教程基于 V2.0.1041 开发。</p><p class="- topic/p p">在 VS Code 的 <strong class="+ topic/ph hi-d/b ph b">Settings</strong> 界面搜索 <code class="+ topic/ph pr-d/codeph ph codeph"> @ext:dolphindb.dolphindb-vscode connections</code> 后，编辑 <code class="+ topic/ph pr-d/codeph ph codeph">settings.json</code>，在 <code class="+ topic/ph pr-d/codeph ph codeph">dolphindb.connections</code> 一节中，指定“python”条目。</p><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">"python": true</code> 表示使用 Python Parser 语法解释器；<code class="+ topic/ph pr-d/codeph ph codeph">"python": false</code> 表示使用 DolphinDB 语法解释器。</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_2.png"/><br/></li></ol><p class="- topic/p p">为了能够成功运行本章节示例代码，可以先执行下述代码模拟生成少量逐笔成交数据：（需要将 csvDir 变量修改为 DolphinDB 部署服务器上 tradeData.csv 的实际目录，示例数据见<a class="- topic/xref xref" href="#%E9%99%84%E4%BB%B6">附件</a>）</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def createTB():
    dbName, tbName = "dfs://TL_Level2", "trade"
    # 数据库如果存在，删除该数据库
    if existsDatabase(dbName):
        dropDatabase(dbName)
    # 创建数据库：时间维度按天 VALUE 分区 + 股票代码 SecurityID HASH 50 分区
    db1 = database("", ddb.VALUE, seq(2020.01.01, 2021.01.01))
    db2 = database("", ddb.HASH, [ddb.SYMBOL, 50].toddb())
    db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine="TSDB")
    schemaTB = table(array(ddb.INT, 0) as ChannelNo,
                    array(ddb.LONG, 0) as ApplSeqNum,
                    array(ddb.SYMBOL, 0) as MDStreamID,
                    array(ddb.LONG, 0) as BidApplSeqNum,
                    array(ddb.LONG, 0) as OfferApplSeqNum,
                    array(ddb.SYMBOL, 0) as SecurityID,
                    array(ddb.SYMBOL, 0) as SecurityIDSource,
                    array(ddb.DOUBLE, 0) as TradePrice,
                    array(ddb.LONG, 0) as TradeQty,
                    array(ddb.SYMBOL, 0) as ExecType,
                    array(ddb.TIMESTAMP, 0) as TradeTime,
                    array(ddb.TIME, 0) as LocalTime,
                    array(ddb.LONG, 0) as SeqNo,
                    array(ddb.INT, 0) as DataStatus,
                    array(ddb.DOUBLE, 0) as TradeMoney,
                    array(ddb.SYMBOL, 0) as TradeBSFlag,
                    array(ddb.LONG, 0) as BizIndex,
                    array(ddb.SYMBOL, 0) as OrderKind,
                    array(ddb.SYMBOL, 0) as Market)
    db.createPartitionedTable(schemaTB, tbName, partitionColumns=["TradeTime", "SecurityID"].toddb(), compressMethods={"TradeTime":"delta"}.toddb(), sortColumns=["SecurityID", "TradeTime"].toddb(), keepDuplicates=ddb.ALL)

def loadData(csvDir):
    # 创建存储逐笔成交的库表
    createTB()

    # 读示例数据
    name = ["ChannelNo", "ApplSeqNum", "MDStreamID", "BidApplSeqNum", "OfferApplSeqNum", "SecurityID", "SecurityIDSource", "TradePrice", "TradeQty", "ExecType", "TradeTime", "LocalTime", "SeqNo", "DataStatus", "TradeMoney", "TradeBSFlag", "BizIndex", "OrderKind", "Market"].toddb()
    type = ["INT", "LONG", "SYMBOL", "LONG", "LONG", "SYMBOL", "SYMBOL", "DOUBLE", "LONG", "SYMBOL", "TIMESTAMP", "TIME", "LONG", "INT", "DOUBLE", "SYMBOL", "LONG", "SYMBOL", "SYMBOL"].toddb()
    t = loadText(csvDir, schema=table(name, type))

    # append! 数据入库
    loadTable("dfs://TL_Level2", "trade").append!(t)

    # 统计库内数据量
    rowCount = select count(*) from loadTable("dfs://TL_Level2", "trade")      #	181,683
    print(rowCount)

# 执行 loadData 函数, 需要将 csvDir 变量修改为 ddb 部署服务器上 csv 的实际目录
csvDir = "/home/v2/下载/data/tradeData.csv"
loadData(csvDir)</code></pre><p class="- topic/p p">本教程中的所有示例代码都是用 Python Parser 语法开发的，所以必须选择 Python Parser 语法解释器执行，GUI 编程工具解释器选择界面如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_3.png"/><br/></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-创建日频因子存储库表"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2. 创建日频因子存储库表</h3><div class="- topic/body body"><p class="- topic/p p">通过因子存储最佳实践，日频因子存储库表创建示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://dayFactorDB", "dayFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按年 RANGE 分区 + 因子名维度 VALUE 分区
db1 = database("", ddb.RANGE, date(datetimeAdd(1980.01M,seq(0,80)*12,'M')))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())

# 查看分区表结构
pt = loadTable(dbName, tbName)
pt.schema()</code></pre><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">存储结构</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">对于多因子数据场景，用户可以选择<strong class="+ topic/ph hi-d/b ph b">窄表</strong>和<strong class="+ topic/ph hi-d/b ph b">宽表</strong>两种模式。</li><li class="- topic/li li">窄表模式把因子名存为一列，而宽表模式则把每个因子存为一列。</li><li class="- topic/li li">经测试在数据查询方面两种模式相差不大，但在增加因子、删除因子和更新因子等数据运维方面窄表模式性能显著优于宽表模式。</li><li class="- topic/li li">本教程示例代码为<strong class="+ topic/ph hi-d/b ph b">窄表</strong>存储最佳方案。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">分区存储</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">DolphinDB 支持数据分区存储，对于不同分区数据支持多线程并行写入，对于同一个分区数据支持并发查询。</li><li class="- topic/li li">经测试日频因子数据采用“<strong class="+ topic/ph hi-d/b ph b">时间维度按年 + 因子名</strong>”的组合分区方式存储，综合性能最佳。</li></ul><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">分区内分组排序存储</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">DolphinDB 的 TSDB 存储引擎提供排序键设置，每一个分区的数据写在一个或多个 level file 中，每一个 level file 内部的数据按照指定的列进行排序且创建索引。</li><li class="- topic/li li">排序列中除了最后一列的其他列通常为在点查中过滤条件会用到的列，其唯一值组合称为 SortKeys。</li><li class="- topic/li li">为保证性能最优，每个分区的 SortKeys 建议不超过 1000 个。当 SortKeys 较多时，可以通过设置 <em class="+ topic/ph hi-d/i ph i">sortKeyMappingFunction</em> 对 SortKeys 降维。</li><li class="- topic/li li">经测试日频因子数据采用“<strong class="+ topic/ph hi-d/b ph b">securityid+tradetime</strong>”的方式进行排序，sortKeyMapping 设置为 500 综合性能最佳。</li><li class="- topic/li li">DolphinDB 默认数据存储的压缩算法为 lz4，对于时间、日期类型的数据，建议指定采用 Delta（delta-of-delta encoding） 压缩算法存储，提高存储的压缩比。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="13-当日尾盘成交占比因子"><h3 class="- topic/title title topictitle3" id="ariaid-title5">1.3. 当日尾盘成交占比因子</h3><div class="- topic/body body"><p class="- topic/p p">基于逐笔成交数据计算当日尾盘成交占比因子的计算公式如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/1_4.png"/><br/><p class="- topic/p p">其中 BCVP<sub class="+ topic/ph hi-d/sub ph sub">t</sub>  表示 t 日期的尾盘成交占比；Vol<sub class="+ topic/ph hi-d/sub ph sub">t</sub>  表示 t 日期的总成交量；Vol<sub class="+ topic/ph hi-d/sub ph sub">t,14:30-15:00</sub> 表示 t 日期的 14:30—15:00 的成交量之和。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def beforeClosingVolumePercent(trade):
    tradeTime = trade["TradeTime"].astype(ddb.TIME)
    beforeClosingVolume = trade["TradeQty"][(tradeTime &gt;= 14:30:00.000)&amp;(tradeTime &lt;= 15:00:00.000)].sum()
    totalVolume = trade["TradeQty"].sum()
    res = beforeClosingVolume / totalVolume
    return pd.Series([res], ["BCVP"])

# 指定计算某一天的因子
tradeTB = loadTable("dfs://TL_Level2", "trade")
df = pd.DataFrame(tradeTB, index="Market", lazy=True)
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["TradeTime", "SecurityID", "TradeQty"]].groupby(["SecurityID"]).apply(beforeClosingVolumePercent)</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li">因子函数 <code class="+ topic/ph pr-d/codeph ph codeph">beforeClosingVolumePercent</code> 的函数体是按照 Python 语法进行开发的。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">tradeTime = trade["TradeTime"].astype(ddb.TIME)</code> 逐笔成交数据中的 TradeTime 以时间戳 TIMESTAMP 的数据类型存入数据库。数据类型的转化可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">astype()</code> 函数。其中的类型关键字，需要加上 <code class="+ topic/ph pr-d/codeph ph codeph">ddb</code> 的前缀。</li><li class="- topic/li li">DolphinDB 中的时间常量的格式：<code class="+ topic/ph pr-d/codeph ph codeph">yyyy.MM.ddTHH:mm:ss.SSS</code>，比如：14:30:00.000、2023.02.01、2023.02.01T14:30:00.000</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">tradeTB = loadTable("dfs://TL_Level2", "trade")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "trade" 的元数据取回到内存。此时变量 tradeTB 只包含元数据，库内数据并未取到内存。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(tradeTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</li><li class="- topic/li li">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</li><li class="- topic/li li">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 <code class="+ topic/ph pr-d/codeph ph codeph">groupby.apply</code> 实现了并行计算。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="14-存入数据库"><h3 class="- topic/title title topictitle3" id="ariaid-title6">1.4. 存入数据库</h3><div class="- topic/body body"><p class="- topic/p p">上一节中的计算结果 <code class="+ topic/ph pr-d/codeph ph codeph">res</code> 是当前会话中的一个本地内存变量，关闭会话便会被释放，所以需要把计算结果存入数据库中的分区表中，达到持久化的目的。</p><p class="- topic/p p">把因子计算结果从内存存储到磁盘上的示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code># res 是一个 Series, 需要将计算结果转化成窄表格式（共4列：tradetime, securityid, factorname, value）
result = res.reset_index().rename(columns={"SecurityID":"securityid"})
result["tradetime"] = 2023.02.01
result = result.melt(id_vars=["tradetime", "securityid"],value_vars=["BCVP"],var_name="factorname",value_name="value")

# 存入数据库
loadTable(dbName, tbName).append!(result.to_table())

# 查看库内数据量
select count(*) from loadTable(dbName, tbName)</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li">因子库用窄表方式存储，需要先将 DataFrame 转化为和因子库统一的 4 列的格式：tradetime, securityid, factorname, value。</li><li class="- topic/li li">因为上述示例只计算了一天的因子，结果中没有日期信息，所以需要增加日期信息。</li><li class="- topic/li li">使用 <code class="+ topic/ph pr-d/codeph ph codeph">melt</code> 函数，将宽表转化为窄表。当计算出多个因子值时，可以修改参数 <em class="+ topic/ph hi-d/i ph i">value_vars</em>=[“factorname1“, “factorname2“, …]。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">result.to_table()</code> 用 <code class="+ topic/ph pr-d/codeph ph codeph">.to_table()</code> 函数将 no-lazy 模式的 DataFrame 转化为 DolphinDB 中的内存表。</li><li class="- topic/li li">通过 <code class="+ topic/ph pr-d/codeph ph codeph">append!</code> 函数，将因子结果存入数据库。</li></ul></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="2-创建因子存储库表"><h2 class="- topic/title title topictitle2" id="ariaid-title7">2. 创建因子存储库表</h2><div class="- topic/body body"><p class="- topic/p p">不同频率的因子数据每日数据量是不同的，DolphinDB 的分区方案主要是根据数据量来制定的，以窄表模式存储的数据量统计如下：</p><div class="table-container"><table class="- topic/table table" data-cols="8"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__1"><strong class="+ topic/ph hi-d/b ph b">类型</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__2"><strong class="+ topic/ph hi-d/b ph b">标的数</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__3"><strong class="+ topic/ph hi-d/b ph b">因子数</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__4"><strong class="+ topic/ph hi-d/b ph b">频率</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__5"><strong class="+ topic/ph hi-d/b ph b">时间</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__6"><strong class="+ topic/ph hi-d/b ph b">数据量 (TB)</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__7"><strong class="+ topic/ph hi-d/b ph b">数据行数 (亿行)</strong></th><th class="- topic/entry entry colsep-0 rowsep-0" id="2-创建因子存储库表__entry__8"><strong class="+ topic/ph hi-d/b ph b">日新增数据 (GB)</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">股票</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">5,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">10,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">日频</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">11 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">2.4</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">1,337</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">0.9</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">股票</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">5,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">10,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">10 分钟</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">11 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">58.3</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">32,076</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">22.4</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">股票</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">5,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">10,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">1 分钟</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">11 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">583.4</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">320,760</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">223.5</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">股票</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">5,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">1,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">3 秒</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">1 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">126.8</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">58,080</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">536.4</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">股票</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">5,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">1,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">1 秒</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">1 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">380.3</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">174,240</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">1,609.3</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__1">期货</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__2">200</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__3">1,000</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__4">500 毫秒</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__5">1 年</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__6">35.2</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__7">16,117</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__8">148.9</td></tr></tbody></table></div><p class="- topic/p p">为了方便用户快速上手 DolphinDB，我们通过因子存储最佳实践，总结了常用频率因子的最优存储方案，并给出了示例代码，如果用户没有时间了解分区的原理，直接复用官方提供的库表创建示例代码即可。</p><div class="table-container"><table class="- topic/table table" data-cols="5"><caption></caption><colgroup><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-创建因子存储库表__entry__57"><strong class="+ topic/ph hi-d/b ph b">因子库</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-创建因子存储库表__entry__58"><strong class="+ topic/ph hi-d/b ph b">分区方案</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-创建因子存储库表__entry__59"><strong class="+ topic/ph hi-d/b ph b">分区列</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-创建因子存储库表__entry__60"><strong class="+ topic/ph hi-d/b ph b">排序列（sortColumns）</strong></th><th class="- topic/entry entry align-left colsep-0 rowsep-0" id="2-创建因子存储库表__entry__61"><strong class="+ topic/ph hi-d/b ph b">sortKeyMap</strong></th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">日频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按年 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">1 分钟频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按天 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">10 分钟频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按月 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">3s 快照频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按日 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">逐笔频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按日 + 因子名 + 股票代码维度：HASH 10</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname + securityid</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">不降维</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">1s 频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按小时 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__57">期货 500ms 频</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__58">时间维度按日 + 因子名</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__59">tradetime + factorname</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__60">securityid + tradetime</td><td class="- topic/entry entry align-left colsep-0 rowsep-0" headers="2-创建因子存储库表__entry__61">500</td></tr></tbody></table></div></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="21-日频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title8">2.1. 日频因子</h3><div class="- topic/body body"><p class="- topic/p p">日频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://dayFactorDB", "dayFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按年 RANGE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.RANGE, date(datetimeAdd(1980.01M,seq(0,80)*12,'M')))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="22-1-分钟频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title9">2.2. 1 分钟频因子</h3><div class="- topic/body body"><p class="- topic/p p">1 分钟频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://minuteFactorDB", "minuteFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.VALUE, seq(2021.01.01, 2021.12.31))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="23-10-分钟频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title10">2.3. 10 分钟频因子</h3><div class="- topic/body body"><p class="- topic/p p">10 分钟频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://tenMinutesFactorDB", "tenMinutesFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按月 VALUE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.VALUE, seq(2023.01M, 2023.06M))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title11" id="24-3-秒快照频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title11">2.4. 3 秒快照频因子</h3><div class="- topic/body body"><p class="- topic/p p">3 秒快照频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://level2FactorDB", "level2FactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.VALUE, seq(2022.01.01, 2022.12.31))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="25-逐笔频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title12">2.5. 逐笔频因子</h3><div class="- topic/body body"><p class="- topic/p p">逐笔频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://tickFactorDB", "tickFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区 + 股票代码 HASH 10 分区
db1 = database("", ddb.VALUE, seq(2022.01.01, 2022.12.31))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db3 = database("", ddb.HASH, [ddb.SYMBOL, 10].toddb())
db = database(dbName, ddb.COMPO, [db1, db2, db3].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname", "securityid"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL)</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="26-1-秒频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title13">2.6. 1 秒频因子</h3><div class="- topic/body body"><p class="- topic/p p">1 秒频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://secondFactorDB", "secondFactorTB"

# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按小时 VALUE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.VALUE, seq(datehour(2022.01.01T00:00:00), datehour(2022.01.31T00:00:00)))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="27-期货-500-毫秒频因子"><h3 class="- topic/title title topictitle3" id="ariaid-title14">2.7. 期货 500 毫秒频因子</h3><div class="- topic/body body"><p class="- topic/p p">期货 500 毫秒频因子数据库和分区表的创建示例代码：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

dbName, tbName = "dfs://futuresFactorDB", "futuresFactorTB"
# 数据库如果存在，删除该数据库
if existsDatabase(dbName):
    dropDatabase(dbName)

# 创建数据库：时间维度按天 VALUE 分区 + 因子名 VALUE 分区
db1 = database("", ddb.VALUE, seq(2021.01.01, 2021.12.31))
db2 = database("", ddb.VALUE, ["f1","f2"].toddb())
db = database(dbName, ddb.COMPO, [db1, db2].toddb(), engine='TSDB', atomic='CHUNK')

# 创建分区表
schemaTB = table(array(ddb.DATE, 0) as tradetime, 
                array(ddb.SYMBOL, 0) as securityid, 
                array(ddb.SYMBOL, 0) as factorname, 
                array(ddb.DOUBLE, 0) as value)

db.createPartitionedTable(schemaTB, tbName, partitionColumns=["tradetime", "factorname"].toddb(), compressMethods={"tradetime":"delta"}.toddb(), 
                        sortColumns=["securityid", "tradetime"].toddb(), keepDuplicates=ddb.ALL, sortKeyMappingFunction=[lambda x:hashBucket(x, 500)].toddb())</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title15" id="3--量化因子计算代码开发"><h2 class="- topic/title title topictitle2" id="ariaid-title15">3.  量化因子计算代码开发</h2><div class="- topic/body body"><p class="- topic/p p">本章节基于股票行情数据，选取了一些具有代表性的因子，用 Python Parser 进行了实现，旨在指导用户进行自定义因子的转写和开发。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="31-双均线因子"><h3 class="- topic/title title topictitle3" id="ariaid-title16">3.1. 双均线因子</h3><div class="- topic/body body"><p class="- topic/p p">双均线就是根据两条周期不一样的均线的相对位置来跟踪趋势的一种方法，本教程我们使用双均线交叉的方式来判断买卖方向：</p><ul class="- topic/ul ul"><li class="- topic/li li">短周期均线<strong class="+ topic/ph hi-d/b ph b">从下向上</strong>突破长周期均线时，意味着当前时间段具有上涨趋势，突破点就是常说的<strong class="+ topic/ph hi-d/b ph b">金叉</strong>，是股票的<strong class="+ topic/ph hi-d/b ph b">买入信号</strong>，在代码里，使用前一短均值小于前一长均值且当前短均值大于当前长均值的方式来判断金叉，赋予信号值为 1；</li><li class="- topic/li li">短周期均线<strong class="+ topic/ph hi-d/b ph b">从上向下</strong>跌破长周期均线时，意味着当前时间段具有下跌趋势，跌破点就是常说的<strong class="+ topic/ph hi-d/b ph b">死叉</strong>，是股票的<strong class="+ topic/ph hi-d/b ph b">卖出信号</strong>，在代码里，使用前一短均值大于前一长均值且当前短均值小于当前长均值的方式来判断金叉，赋予信号值为 -1。</li></ul><p class="- topic/p p">在这里我们使用简单移动平均（Simple Moving Average），其中 n 为窗口大小：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_1.png"/><br/><p class="- topic/p p">在下边的例子中我们使用了全市场 2020.07.01 至 2023.07.19 的日频股票数据来进行计算，在实际使用中可以自由更换数据频率，如分钟频率，小时频率等。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 调用数据
df = loadTable("dfs://Daily_adj_price", "data")
df = pd.DataFrame(df, "TRADE_DATE", True)

# 定义计算 ma 金叉死叉信号生成的方法
def signal_ma(data_chunk, short, long):
    #分别计算出5日和20日均线及其前一根均线
    data_chunk['ma_5'] = data_chunk['CLOSE_PRICE_1'].fillna(0).rolling(int(short)).mean()
    data_chunk['ma_20'] = data_chunk['CLOSE_PRICE_1'].fillna(0).rolling(int(long)).mean()
    data_chunk['pre_ma5'] = data_chunk['ma_5'].shift(1)
    data_chunk['pre_ma20'] =  data_chunk['ma_20'].shift(1)
    # 通过df[contion]方式按列进行条件，判断出金叉死叉信号
    data_chunk['signal'] = 0
    data_chunk.loc[((data_chunk.loc[:,'pre_ma5']&lt; data_chunk.loc[:,'pre_ma20'])&amp; (data_chunk.loc[:,'ma_5'] &gt; data_chunk.loc[:,'ma_20'])), "signal"] = 1
    data_chunk.loc[((data_chunk.loc[:,'pre_ma5']&gt; data_chunk.loc[:,'pre_ma20']) &amp; (data_chunk.loc[:,'ma_5'] &lt; data_chunk.loc[:,'ma_20'])), "signal"] = -1
    return data_chunk

# 生成信号
combined_results = df.groupby('SECURITY_ID').apply(signal_ma,5,20)</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li">通过使用 pandas 包中的 <code class="+ topic/ph pr-d/codeph ph codeph">pd.groupby()</code> + <code class="+ topic/ph pr-d/codeph ph codeph">apply</code> 的方式</li><li class="- topic/li li">实现了按照股票代码分组后对前复权的收盘价使用 <code class="+ topic/ph pr-d/codeph ph codeph">rolling().mean()</code> 求出移动平均线，并根据长短期均线之间的位置关系来判断出金叉死叉进而产生信号：1 代表多头信号，-1 代表空头信号，0 则为目前没有信号。</li><li class="- topic/li li">在计算双均线金叉死叉信号的时候，Python Pandas 版本的实现逻辑和代码同 Python Parser 保持了一致，因此在使用时无需额外操作即可在二者之间切换。此外，Python 解析器底层自动实现的批处理加速功能，省去了 Python 实现批处理所需的额外工作，更为高效。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title17" id="32-十档净委买增额"><h3 class="- topic/title title topictitle3" id="ariaid-title17">3.2. 十档净委买增额</h3><div class="- topic/body body"><p class="- topic/p p">本章节展示了如何基于 Level2 快照行情数据计算十档净委买增额。</p><p class="- topic/p p">十档净委买增额因子指的是在有效十档范围内买方资金总体增加量，即所有买价变化量的总和，计算公式如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_2.png"/><br/><p class="- topic/p p">其中 level10_Diff<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻的十档净委买增额；bid<sub class="+ topic/ph hi-d/sub ph sub">i,t</sub>  表示 t 时刻的第 i 档买方报价；bidQty<sub class="+ topic/ph hi-d/sub ph sub">i,t</sub> 表示 t 时刻的第 i 档买方挂单数量；指示函数 I 表示报价是否在有效释放范围内。</p><p class="- topic/p p">有效十档范围内表示不考虑已不在十档范围内的档位，即表示只考虑以下区间的档位：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_3.png"/><br/><p class="- topic/p p">最后，对过去 n 时间窗口内的十档净委买增额求和。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def level10Diff(df, lag=20):
    temp = df[["TradeTime", "SecurityID"]]
    temp["bid"] = df["BidPrice"].fillna(0)
    temp["bidAmt"] = df["BidOrderQty"].fillna(0) * df["BidPrice"].fillna(0)
    temp["prevbid"] = temp["bid"].shift(1).fillna(0)
    temp["prevbidAmt"] = temp["bidAmt"].shift(1).fillna(0)
    temp["bidMin"] = temp["bid"].apply("min")
    temp["bidMax"] = temp["bid"].apply("max")
    temp["prevbidMin"] = temp["bidMin"].shift(1).fillna(0)
    temp["prevbidMax"] = temp["bidMax"].shift(1).fillna(0)
    temp["pmin"] = temp[["bidMin", "prevbidMin"]].max(axis=1)
    temp["pmax"] = temp[["bidMax", "prevbidMax"]].max(axis=1)
    amount = temp["bidAmt"]*((temp["bid"]&gt;=temp["pmin"])&amp;(temp["bid"]&lt;=temp["pmax"]))
    lastAmount = temp["prevbidAmt"]*((temp["prevbid"]&gt;=temp["pmin"])&amp;(temp["prevbid"]&lt;=temp["pmax"]))
    temp["amtDiff"] = amount.apply("sum") - lastAmount.apply("sum")
    temp["amtDiff"] = temp["amtDiff"].rolling(lag, 1).sum()
    return temp[["TradeTime", "SecurityID", "amtDiff"]].fillna(0)

# 指定计算某一天一只股票的因子
snapshotTB = loadTable("dfs://TL_Level2", "snapshot")
df = pd.DataFrame(snapshotTB, index="Market", lazy=True)
df = df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]
res = level10Diff(df.compute(), 20)

# 指定计算某一天的因子
snapshotTB = loadTable("dfs://TL_Level2", "snapshot")
df = pd.DataFrame(snapshotTB, index="Market", lazy=True)
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["TradeTime", "SecurityID", "BidPrice", "BidOrderQty"]].groupby(["SecurityID"]).apply(lambda x:level10Diff(x, 20))</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">Level2 快照行情数据拥有十档行情量价数据。针对这种类型相同、含义相近的数据，可以考虑使用 DolphinDB 的 Array Vector 类型来存储。在 DolphinDB 里 Array Vector 是一种特殊的向量，用于存储可变长度的二维数组。上述代码就是基于十档行情用 Array Vector 类型存储的数据库开发的，其中“BidPrice”、“BidOrderQty”都是 ArrayVector 的列。</p></li><li class="- topic/li li"><p class="- topic/p p">表中 Array Vector 类型的列转化为 DataFrame 中的一列之后，其中每个元素为 List。
<img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_4.png"/><br/></p><li class="- topic/li li"><p class="- topic/p p">针对 Array Vector 转化的列，Python Parser 中支持四则运算、比较等基础运算（比如两列相乘 <code class="+ topic/ph pr-d/codeph ph codeph">df["BidOrderQty"].fillna(0) * df["BidPrice"].fillna(0)</code>）；其他运算需要使用 <code class="+ topic/ph pr-d/codeph ph codeph">apply</code> 函数（比如求每一行的最小值 <code class="+ topic/ph pr-d/codeph ph codeph">temp["bid"].apply("min")</code>）。</p></li><li class="- topic/li li"><p class="- topic/p p">对于内置函数 (比如 <code class="+ topic/ph pr-d/codeph ph codeph">max</code>/<code class="+ topic/ph pr-d/codeph ph codeph">min</code>/<code class="+ topic/ph pr-d/codeph ph codeph">sum</code> 等)，使用 <code class="+ topic/ph pr-d/codeph ph codeph">apply</code> 函数时，传入字符串和传入函数是有区别的。</p><ul class="- topic/ul ul"><li class="- topic/li li">传入字符串时，比如 <code class="+ topic/ph pr-d/codeph ph codeph">temp["bid"].apply("max")</code>，首先会去找 series 类里有没有实现这个函数，如果有，就用 series 的这个函数；如果没有，就去找内置函数。</li><li class="- topic/li li">传入函数时，比如 <code class="+ topic/ph pr-d/codeph ph codeph">temp["bid"].apply(max)</code>，会直接使用内置函数。</li></ul></li></li><p class="- topic/p p">​         综上，对于 <code class="+ topic/ph pr-d/codeph ph codeph">apply</code> + 内置函数 的情况下，一般建议用户传入字符串。</p><ul class="- topic/ul ul"><li class="- topic/li li">使用 <code class="+ topic/ph pr-d/codeph ph codeph">shift(1)</code> 的方式获取上一笔快照的数据。</li><li class="- topic/li li">使用 <code class="+ topic/ph pr-d/codeph ph codeph">rolling().sum()</code> 的方式求滑动窗口内十档净委买增额的和。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">snapshotTB = loadTable("dfs://TL_Level2", "snapshot")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "snapshot" 的元数据取回到内存。此时变量 snapshotTB 只包含元数据，库内数据并未取到内存。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(snapshotTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</li><li class="- topic/li li">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</li><li class="- topic/li li">lazy 模式下不允许直接改变 DataFrame 的值。因为 <code class="+ topic/ph pr-d/codeph ph codeph">level10Diff</code> 函数里面有 <code class="+ topic/ph pr-d/codeph ph codeph">temp["bid"] = df["BidPrice"].fillna(0)</code> 的操作，所以对直接过滤出来的 df 直接调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">level10Diff(df, 20)</code> 会报错： <code class="+ topic/ph pr-d/codeph ph codeph">Lazy-model DataFrame does not support update value.</code> 需要使用 <code class="+ topic/ph pr-d/codeph ph codeph">df.compute()</code> 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。</li><li class="- topic/li li">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 <code class="+ topic/ph pr-d/codeph ph codeph">groupby.apply</code> 实现了并行计算。</li></ul></ul></div><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title18" id="33-价格变动与一档量差的回归系数"><h4 class="- topic/title title topictitle4" id="ariaid-title18">3.3. 价格变动与一档量差的回归系数</h4><div class="- topic/body body"><p class="- topic/p p">本章节展示了如何基于 Level2 快照行情数据计算价格变动与一档量差的回归系数。</p><p class="- topic/p p">回归模型：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_5.png"/><br/><p class="- topic/p p">其中，</p><ul class="- topic/ul ul"><li class="- topic/li li">ΔP<sub class="+ topic/ph hi-d/sub ph sub">t</sub>  表示 t 时刻的价格变动；lastPrice<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻的最新价格；</li><li class="- topic/li li">NVOL<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻的买卖一档量差；bidQty<sub class="+ topic/ph hi-d/sub ph sub">1,t</sub> 表示 t 时刻的买方一档挂单笔数；askQty<sub class="+ topic/ph hi-d/sub ph sub">1,t</sub> 表示 t 时刻的卖方一档挂单笔数；</li><li class="- topic/li li">α 表示截距；λ 表示斜率；εt 表示 t 时刻的残差。</li></ul><p class="- topic/p p">其中回归系数  λ 为目标因子值。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def priceSensitivityOrderFlowImbalance(df):  
    deltaP = 10000*df["LastPrice"].diff().fillna(0)
    bidQty1 = df["BidOrderQty"].values[0]
    askQty1 = df["OfferOrderQty"].values[0]
    NVOL = bidQty1 - askQty1
    res = beta(deltaP.values, NVOL)
    return pd.Series([res], ["priceSensitivityOrderFlowImbalance"])

# 指定计算某一天一只股票的因子
snapshotTB = loadTable("dfs://TL_Level2", "snapshot")
df = pd.DataFrame(snapshotTB, index="Market", lazy=True)
df = df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]
res = priceSensitivityOrderFlowImbalance(df.compute())
  
# 指定计算某一天的因子
snapshotTB = loadTable("dfs://TL_Level2", "snapshot")
df = pd.DataFrame(snapshotTB, index="Market", lazy=True)
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["SecurityID", "LastPrice", "BidOrderQty", "OfferOrderQty"]].groupby(["SecurityID"]).apply(priceSensitivityOrderFlowImbalance) </code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li"><p class="- topic/p p">Level2 快照行情数据拥有十档行情量价数据。针对这种类型相同、含义相近的数据，可以考虑使用 DolphinDB 的 Array Vector 类型来存储。在 DolphinDB 里 Array Vector 是一种特殊的向量，用于存储可变长度的二维数组。上述代码就是基于十档行情用 Array Vector 类型存储的数据库开发的，其中“BidOrderQty”，“OfferOrderQty”都是 ArrayVector 的列。</p></li><li class="- topic/li li"><p class="- topic/p p">表中 Array Vector 类型的列转化为 DataFrame 中的一列之后，其中每个元素为 List。
<img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_6.png"/><br/></p><li class="- topic/li li"><p class="- topic/p p">针对 ArrayVector 类型，DolphinDB 开发了很多内置函数提升 Array Vector 的易用性和计算性能，比如 row 系列函数。所以除了 上一章节的例子中使用的 <code class="+ topic/ph pr-d/codeph ph codeph">apply</code> 函数，也可以考虑将其通过 values 属性将 Series 转化为 DolphinDB 的类型，使用 DolphinDB 的内置函数，比如 <code class="+ topic/ph pr-d/codeph ph codeph">df["BidOrderQty"].values[0]</code> 取 Array Vector 的第一列。</p></li><li class="- topic/li li"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">diff(1)</code> 的方式计算一阶差分。</p></li><li class="- topic/li li"><p class="- topic/p p">最新价 LastPrice 使用 DOUBLE 类型存储，因为量价的数量级相差较大，所以将价格变动扩大 10000 倍。</p></li><li class="- topic/li li"><p class="- topic/p p">目前 Python Parser 只支持 pandas 中的函数，暂时还不支持 statsmodels、sklearn.linear_model 等数据分析包。所以不能直接计算回归系数。但是 DolphinDB 内置函数中，有 <code class="+ topic/ph pr-d/codeph ph codeph">beta</code> / <code class="+ topic/ph pr-d/codeph ph codeph">ols</code> 等函数可以求回归系数。所以这里选择用  values 属性将 Series 转化为 DolphinDB 的向量，使得后续可以调用 DolphinDB 的内置函数 <code class="+ topic/ph pr-d/codeph ph codeph">beta</code>。比如，<code class="+ topic/ph pr-d/codeph ph codeph">beta(deltaP.values, NVOL)</code>。</p></li><li class="- topic/li li"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">snapshotTB = loadTable("dfs://TL_Level2", "snapshot")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "snapshot" 的元数据取回到内存。此时变量 snapshotTB 只包含元数据，库内数据并未取到内存。</p></li><li class="- topic/li li"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(snapshotTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</p></li><li class="- topic/li li"><p class="- topic/p p">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。</p></li><li class="- topic/li li"><p class="- topic/p p">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</p></li><li class="- topic/li li"><p class="- topic/p p">不允许 lazy 和 no-lazy 的数据直接计算。当输入的 df 是 lazy 模式时，<code class="+ topic/ph pr-d/codeph ph codeph">df["LastPrice"].diff()</code> 操作会保留 lazy 模式，所以 deltaP 是 lazy 模式；<code class="+ topic/ph pr-d/codeph ph codeph">df["BidOrderQty"].apply(lambda x:x[0])</code> 则会直接触发计算，所以 NVOL 是 no-lazy 模式。所以对直接过滤出来的 df 直接调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">priceSensitivityOrderFlowImbalance(df)</code> ，执行到 <code class="+ topic/ph pr-d/codeph ph codeph">NVOL*deltaP</code> 时会报错： <code class="+ topic/ph pr-d/codeph ph codeph">The operation args should be both lazy or not lazy.</code> 需要使用 <code class="+ topic/ph pr-d/codeph ph codeph">df.compute()</code> 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。</p></li><li class="- topic/li li"><p class="- topic/p p">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 <code class="+ topic/ph pr-d/codeph ph codeph">groupby.apply</code> 实现了并行计算。</p></li></li></ul></div><article class="- topic/topic topic nested4" aria-labelledby="ariaid-title19" id="34-主动成交量占比"><h5 class="- topic/title title topictitle5" id="ariaid-title19">3.4. 主动成交量占比</h5><div class="- topic/body body"><p class="- topic/p p">本章节展示了如何基于 Level2 逐笔成交数据计算主动成交量占比。</p><p class="- topic/p p">主动成交占比即主动成交量占总成交量的比例，其计算公式如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_7.png"/><br/><p class="- topic/p p">其中 tradeQty<sub class="+ topic/ph hi-d/sub ph sub">i</sub> 表示 i 时刻的成交量；actVolume<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻起的前 lag 笔订单的主动成交量之和；totalVolume<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻起的前 lag 笔订单的总成交量；指示函数 I 含义如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_8.png"/><br/><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def actVolumePercent(trade, lag):   
    res = trade[["TradeTime", "SecurityID"]]
    actVolume = (trade["TradeQty"]*(trade['BidApplSeqNum'] &gt; trade['OfferApplSeqNum'])).rolling(lag).sum()
    totalVolume = trade["TradeQty"].rolling(lag).sum()
    res["actVolumePercent"] = actVolume/totalVolume
    return res

# 指定计算某一天一只股票的因子
tradeTB = loadTable("dfs://TL_Level2", "trade")
df = pd.DataFrame(tradeTB, index="Market", lazy=True)
df = df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]
res = actVolumePercent(df.compute(), 60)
  
# 指定计算某一天的因子
tradeTB = loadTable("dfs://TL_Level2", "trade")
df = pd.DataFrame(tradeTB, index="Market", lazy=True)
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["TradeTime", "SecurityID", "TradeQty", "BidApplSeqNum", "OfferApplSeqNum"]].groupby(["SecurityID"]).apply(lambda x: actVolumePercent(x, 60))</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li">通过条件 <code class="+ topic/ph pr-d/codeph ph codeph">trade['BidApplSeqNum'] &gt; trade['OfferApplSeqNum']</code> 过滤出主动成交订单。</li><li class="- topic/li li">通过 <code class="+ topic/ph pr-d/codeph ph codeph">rolling(lag).sum()</code> 的方式计算前 lag 笔订单的成交量之和。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">tradeTB = loadTable("dfs://TL_Level2", "trade")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "trade" 的元数据取回到内存。此时变量 tradeTB 只包含元数据，库内数据并未取到内存。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(tradeTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</li><li class="- topic/li li">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001“这一天一只股票的数据。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</li><li class="- topic/li li">lazy 模式下不允许直接改变 DataFrame 的值。因为 <code class="+ topic/ph pr-d/codeph ph codeph">actVolumePercent</code> 函数里面有 <code class="+ topic/ph pr-d/codeph ph codeph">res["actVolumePercent"] = actVolume/totalVolume</code> 的操作，所以对直接过滤出来的 df 直接调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">actVolumePercent(df, 60)</code> 会报错： <code class="+ topic/ph pr-d/codeph ph codeph">Lazy-model DataFrame does not support update value.</code> 需要使用 df.compute() 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。</li><li class="- topic/li li">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 groupby.apply 实现了并行计算。</li></ul></div></article><article class="- topic/topic topic nested4" aria-labelledby="ariaid-title20" id="35-早盘买卖单大小比"><h5 class="- topic/title title topictitle5" id="ariaid-title20">3.5. 早盘买卖单大小比</h5><div class="- topic/body body"><p class="- topic/p p">本章节展示了如何基于 Level2 逐笔委托数据计算早盘买卖单大小比。</p><p class="- topic/p p">早盘买卖单大小比即早盘时间段买入订单平均委托量占卖出订单平均委托量的比例的对数，其计算公式如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_9.png"/><br/><p class="- topic/p p">其中 openBidVol 表示早盘时间段买入订单平均委托量；openAskVol 表示早盘时间段卖出订单平均委托量；orderQty<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻的委托量；</p><p class="- topic/p p">​         I<sub class="+ topic/ph hi-d/sub ph sub">bid</sub> 是指示函数，当订单为买方委托单时值为 1，否则为 0；I<sub class="+ topic/ph hi-d/sub ph sub">ask</sub> 是指示函数，当订单为卖方委托单时值为 1，否则为 0。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def openBidVolDvdAskVol(df):
    tradeTime = df["TradeTime"].astype(ddb.TIME)
    openBidVolume = df["OrderQty"][(tradeTime &gt;= 09:30:00.000)&amp;(tradeTime &lt;= 10:30:00.000)&amp;((df["Side"]=="1")|(df["Side"]=="B"))].mean()
    openAskVolume = df["OrderQty"][(tradeTime &gt;= 09:30:00.000)&amp;(tradeTime &lt;= 10:30:00.000)&amp;((df["Side"]=="2")|(df["Side"]=="S"))].mean()
    if((openBidVolume&gt;0)&amp;(openAskVolume&gt;0)):
        res = log(openBidVolume / openAskVolume)
    else:
        res = None
    return pd.Series([res], ["openBidVolDvdAskVol"])

# 指定计算某一天一只股票的因子
orderTB = loadTable("dfs://TL_Level2", "entrust")
df = pd.DataFrame(orderTB, index="Market", lazy=True)
df = df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]
res = openBidVolDvdAskVol(df)
  
# 指定计算某一天的因子
orderTB = loadTable("dfs://TL_Level2", "entrust")
df = pd.DataFrame(orderTB, index="Market", lazy=True)
df = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01]
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["TradeTime", "SecurityID", "OrderQty", "Side"]].groupby(["SecurityID"]).apply(openBidVolDvdAskVol)</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">tradeTime = df["TradeTime"].astype(ddb.TIME)</code> 逐笔委托数据中的 TradeTime 以时间戳 TIMESTAMP 的数据类型存入数据库。数据类型的转化可以使用 <code class="+ topic/ph pr-d/codeph ph codeph">astype()</code> 函数。其中的类型关键字，需要加上 <code class="+ topic/ph pr-d/codeph ph codeph">ddb</code> 的前缀。</li><li class="- topic/li li">DolphinDB 中的时间常量的格式：<code class="+ topic/ph pr-d/codeph ph codeph">yyyy.MM.ddTHH:mm:ss.SSS</code>，比如：09:30:00.000、2023.02.01、2023.02.01T09:30:00.000</li><li class="- topic/li li">通联数据中深交所和上交所的买卖方向用的不一样的枚举值。上交所：买单“B”，卖单“S”；深交所：买单“1”，卖单“2”。所以在判断买卖单的时候，增加了“或逻辑”（<code class="+ topic/ph pr-d/codeph ph codeph">|</code>）的判断。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">if((openBidVolume&gt;0)&amp;(openAskVolume&gt;0))</code> 这部分做了一个数据校验，避免出现某些股票早盘没有委托单时，早盘委托量为空的情况。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">orderTB = loadTable("dfs://TL_Level2", "entrust")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "entrust" 的元数据取回到内存。此时变量 orderTB 只包含元数据，库内数据并未取到内存。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(orderTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</li><li class="- topic/li li">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001”这一天一只股票的数据。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</li><li class="- topic/li li">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 <code class="+ topic/ph pr-d/codeph ph codeph">groupby.apply</code> 实现了并行计算。</li></ul></div></article><article class="- topic/topic topic nested4" aria-labelledby="ariaid-title21" id="36-委托量加权平均委托价格"><h5 class="- topic/title title topictitle5" id="ariaid-title21">3.6. 委托量加权平均委托价格</h5><div class="- topic/body body"><p class="- topic/p p">本章节展示了如何基于 Level2 逐笔委托数据计算委托量加权平均委托价格。</p><p class="- topic/p p">委托量加权平均委托价格是将多笔委托单的委托价格按各自的委托量加权而算出的平均价格，其计算公式如下：</p><img class="- topic/image image" src="images/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/3_10.png"/><br/><p class="- topic/p p">其中 vwap<sub class="+ topic/ph hi-d/sub ph sub">t</sub> 表示 t 时刻起的前 lag 笔委托单的委托量加权平均委托价格；orderQty<sub class="+ topic/ph hi-d/sub ph sub">i</sub> 表示 i 时刻委托单的委托量；orderPrice<sub class="+ topic/ph hi-d/sub ph sub">i</sub> 表示 i 时刻委托单的委托价格。</p><p class="- topic/p p">因子计算示例代码如下：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>import pandas as pd
import dolphindb as ddb

# 定义因子函数
def volumeWeightedAvgPrice(df, lag):
    res = df[["TradeTime", "SecurityID"]]
    totalAmount = (df["OrderQty"]*df["Price"]).rolling(lag).sum()
    totalVolume = df["OrderQty"].rolling(lag).sum()
    res["volumeWeightedAvgPrice"] = totalAmount / totalVolume
    return res

# 指定计算某一天一只股票的因子
orderTB = loadTable("dfs://TL_Level2", "entrust")
df = pd.DataFrame(orderTB, index="Market", lazy=True)
df = df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]
res = volumeWeightedAvgPrice(df.compute(), 60)
  
# 指定计算某一天的因子
orderTB = loadTable("dfs://TL_Level2", "entrust")
df = pd.DataFrame(orderTB, index="Market", lazy=True)
res = df[df["TradeTime"].astype(ddb.DATE)==2023.02.01][["TradeTime", "SecurityID", "OrderQty", "Price"]].groupby(["SecurityID"]).apply(lambda x: volumeWeightedAvgPrice(x, 60))</code></pre><p class="- topic/p p">示例代码解析：</p><ul class="- topic/ul ul"><li class="- topic/li li">通过 <code class="+ topic/ph pr-d/codeph ph codeph">rolling(lag).sum()</code> 的方式分别计算前 lag 笔委托单的总委托金额和总委托量</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">orderTB = loadTable("dfs://TL_Level2", "entrust")</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">loadTable</code> 函数，将 "dfs://TL_Level2" 数据库下的分布式表 "entrust" 的元数据取回到内存。此时变量 orderTB 只包含元数据，库内数据并未取到内存。</li><li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">df = pd.DataFrame(orderTB, index="Market", lazy=True)</code> 通过 <code class="+ topic/ph pr-d/codeph ph codeph">pd.DataFrame()</code> 函数，将 DolphinDB 的表转化为数据框。对于分布式表而言，<em class="+ topic/ph hi-d/i ph i">index</em> 为必填参数，可以指定表中的任意一列，该列仅作为索引，后续可以不参与计算；<em class="+ topic/ph hi-d/i ph i">lazy</em> 参数指定计算是否立即执行，必须指定为 True，表示该 DataFrame 会存储所有函数调用，尽可能延迟计算，以减少计算带来的性能消耗。</li><li class="- topic/li li">可以通过 df[过滤条件] 的形式选出库内指定范围的数据。比如：<code class="+ topic/ph pr-d/codeph ph codeph">df[(df["TradeTime"].astype(ddb.DATE)==2023.02.01)&amp;(df["SecurityID"]=="000001")]</code> 指定取库内 2023.02.01 的“000001”这一天一只股票的数据。</li><li class="- topic/li li">建议在 <code class="+ topic/ph pr-d/codeph ph codeph">groupby</code> 执行计算函数之前，先对数据列进行过滤，只取出计算需要的列。可以降低内存使用，减少数据读取与拷贝的开销。</li><li class="- topic/li li">lazy 模式下不允许直接改变 DataFrame 的值。因为 <code class="+ topic/ph pr-d/codeph ph codeph">volumeWeightedAvgPrice</code> 函数里面有 <code class="+ topic/ph pr-d/codeph ph codeph">res["orderWeightPrice"] = totalAmount/totalVolume</code> 的操作，所以对直接过滤出来的 df 直接调用函数 <code class="+ topic/ph pr-d/codeph ph codeph">volumeWeightedAvgPrice(df, 60)</code> 会报错： <code class="+ topic/ph pr-d/codeph ph codeph">Lazy-model DataFrame does not support update value.</code> 需要使用 <code class="+ topic/ph pr-d/codeph ph codeph">df.compute()</code> 将 lazy 模式的 DataFrame 强制触发计算，转化为 no-lazy 模式的 DataFrame。</li><li class="- topic/li li">可以通过 .groupby(分组列).apply(函数) 的方式实现分组计算，Python Parser 内部对 <code class="+ topic/ph pr-d/codeph ph codeph">groupby.apply</code> 实现了并行计算。</li></ul></div></article></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title22" id="4-性能测试"><h4 class="- topic/title title topictitle4" id="ariaid-title22">4. 性能测试</h4><div class="- topic/body body"></div><article class="- topic/topic topic nested4" aria-labelledby="ariaid-title23" id="41-性能测试环境"><h5 class="- topic/title title topictitle5" id="ariaid-title23">4.1. 性能测试环境</h5><div class="- topic/body body"><div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry colsep-0 rowsep-0" id="41-性能测试环境__entry__1">CPU 类型</th><th class="- topic/entry entry colsep-0 rowsep-0" id="41-性能测试环境__entry__2">Intel(R) Xeon(R) Gold 5220R CPU @ 2.20GHz</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__1">逻辑 CPU 总数</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__2">24</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__1">内存</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__2">256 GB</td></tr><tr class="- topic/row"><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__1">OS</td><td class="- topic/entry entry colsep-0 rowsep-0" headers="41-性能测试环境__entry__2">CentOS Linux release 7.9.2009 (Core)</td></tr></tbody></table></div></div></article><article class="- topic/topic topic nested4" aria-labelledby="ariaid-title24" id="42-性能测试结果"><h5 class="- topic/title title topictitle5" id="ariaid-title24">4.2. 性能测试结果</h5><div class="- topic/body body"><p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试数据</strong></p><ul class="- topic/ul ul"><li class="- topic/li li">2023 年单个交易所某日的 level-2 全天数据<ul class="- topic/ul ul"><li class="- topic/li li">快照数据：24,313,086 行 × 62 列 [约 20.6 GB]</li><li class="- topic/li li">逐笔成交：108,307,125 行 × 19 列 [约 11.0 GB]</li><li class="- topic/li li">逐笔委托：141,182,534 行 × 16 列 [约 11.6 GB]</li></ul></li></ul><div class="table-container"><table class="- topic/table table" data-cols="7"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead"><tr class="- topic/row"><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__1">数据源</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__2">因子</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__3">Python Parser 运行耗时</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__4">DolphinDB Scripts 运行耗时</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__5">Python 运行耗时</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__6">DolphinDB Scripts / python parser 性能对比</th><th class="- topic/entry entry align-center colsep-0 rowsep-0" id="42-性能测试结果__entry__7">Python / python parser 性能对比</th></tr></thead><tbody class="- topic/tbody tbody"><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">日频 K 线</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">双均线因子 (单只股票）</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">10.88 ms</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">9.07 ms</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">30 ms</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.836</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">2.757</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">日频 K 线</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">双均线因子 (全市场股票）</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">1.1 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">0.566 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">14.01 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.515</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">12.74</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">快照行情</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">十档净委买增额</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">4.3 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">1.4 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">49.4 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.326</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">11.488</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">快照行情</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">价格变动与一档量差的回归系数</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">2.8 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">0.34 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">25.5 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.019</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">9.107</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">逐笔成交</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">主动成交量占比</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">6.9 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">1.2 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">52.9 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.174</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">7.667</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">逐笔成交</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">当日尾盘成交占比</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">4.1 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">0.31 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">19.6 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.076</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">4.780</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">逐笔委托</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">早盘买卖单大小比</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">5.8 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">0.64 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">21.1 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.110</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">3.638</td></tr><tr class="- topic/row"><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__1">逐笔委托</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__2">委托量加权平均委托价格</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__3">7.2 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__4">1.4 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__5">77.2 s</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__6">0.194</td><td class="- topic/entry entry align-center colsep-0 rowsep-0" headers="42-性能测试结果__entry__7">10.722</td></tr></tbody></table></div></div></article></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title25" id="5-总结"><h4 class="- topic/title title topictitle4" id="ariaid-title25">5. 总结</h4><div class="- topic/body body"><p class="- topic/p p">DolphinDB Python Parser 支持 Python 的常用语法，并兼容了 DolphinDB 部分独有语法。相比于 Python API，Python Parser 能够方便地访问 DolphinDB 库内的数据，减少了网络层面的开销；并且针对 groupby 等函数底层自动实现并行计算，提高计算性能。相比于 DolphinDB Scripts，Python Parser 兼容常用 Python 语法，学习难度更低，用户可以轻松上手 DolphinDB。</p><p class="- topic/p p">本教程针对量化金融中最常见的因子计算场景，提供了一种基于 Python Parser 开发因子的解决方案，包括不同频率因子库的存储方案和基于不同频率不同数据源的基础因子开发代码，并且因子计算性能和 Python 多进程框架相比能有 5 倍以上的提升。</p></div></article><article class="- topic/topic topic nested3" aria-labelledby="ariaid-title26" id="6-附件"><h4 class="- topic/title title topictitle4" id="ariaid-title26">6. 附件</h4><div class="- topic/body body"><ul class="- topic/ul ul"><li class="- topic/li li">示例数据：<a class="- topic/xref xref" href="data/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/tradeData.zip">tradeData.zip</a></li><li class="- topic/li li">因子实现 DolphinDB 版本：<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E5%BD%93%E6%97%A5%E5%B0%BE%E7%9B%98%E6%88%90%E4%BA%A4%E5%8D%A0%E6%AF%94.txt">当日尾盘成交占比.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E4%BB%B7%E6%A0%BC%E5%8F%98%E5%8A%A8%E4%B8%8E%E4%B8%80%E6%A1%A3%E9%87%8F%E5%B7%AE%E7%9A%84%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0.txt">价格变动与一档量差的回归系数.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E5%8D%81%E6%A1%A3%E5%87%80%E5%A7%94%E4%B9%B0%E5%A2%9E%E9%A2%9D.txt">十档净委买增额.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E5%8F%8C%E5%9D%87%E7%BA%BF.txt">双均线.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E5%A7%94%E6%89%98%E9%87%8F%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%A7%94%E6%89%98%E4%BB%B7%E6%A0%BC.txt">委托量加权平均委托价格.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E6%97%A9%E7%9B%98%E4%B9%B0%E5%8D%96%E5%8D%95%E5%A4%A7%E5%B0%8F%E6%AF%94.txt">早盘买卖单大小比.txt</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_DolphinDB%E7%89%88%E6%9C%AC/%E4%B8%BB%E5%8A%A8%E6%88%90%E4%BA%A4%E9%87%8F%E5%8D%A0%E6%AF%94.txt">主动成交量占比.txt</a></li></ul></li><li class="- topic/li li">因子实现 Python 版本：<ul class="- topic/ul ul"><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E5%8F%8C%E5%9D%87%E7%BA%BF.zip">双均线</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E5%BD%93%E6%97%A5%E5%B0%BE%E7%9B%98%E6%88%90%E4%BA%A4%E5%8D%A0%E6%AF%94.ipynb">当日尾盘成交占比.ipynb</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E4%BB%B7%E6%A0%BC%E5%8F%98%E5%8A%A8%E4%B8%8E%E4%B8%80%E6%A1%A3%E9%87%8F%E5%B7%AE%E7%9A%84%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0.ipynb">价格变动与一档量差的回归系数.ipynb</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E5%8D%81%E6%A1%A3%E5%A7%94%E4%B9%B0%E5%A2%9E%E9%A2%9D.ipynb">十档委买增额.ipynb</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E5%A7%94%E6%89%98%E9%87%8F%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%A7%94%E6%89%98%E4%BB%B7%E6%A0%BC.ipynb">委托量加权平均委托价格.ipynb</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E6%97%A9%E7%9B%98%E4%B9%B0%E5%8D%96%E5%8D%95%E5%A4%A7%E5%B0%8F%E6%AF%94.ipynb">早盘买卖单大小比.ipynb</a></li><li class="- topic/li li"><a class="- topic/xref xref" href="script/DolphinDB_Python_Parser_Intro_for_Quantitative_Finance/%E5%9B%A0%E5%AD%90%E5%AE%9E%E7%8E%B0_Python%E7%89%88%E6%9C%AC/%E4%B8%BB%E5%8A%A8%E6%88%90%E4%BA%A4%E9%87%8F%E5%8D%A0%E6%AF%94.ipynb">主动成交量占比.ipynb</a></li></ul></li></ul></div></article></article></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E5%9F%BA%E4%BA%8E%E9%80%90%E7%AC%94%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E6%97%A5%E9%A2%91%E5%9B%A0%E5%AD%90%E5%85%A8%E6%B5%81%E7%A8%8B" data-tocid="1-基于逐笔数据挖掘日频因子全流程">1. 基于逐笔数据挖掘日频因子全流程</a><ul><li class="topic-item"><a href="#11-%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8" data-tocid="11-历史数据存储">1.1. 历史数据存储</a></li><li class="topic-item"><a href="#12-%E5%88%9B%E5%BB%BA%E6%97%A5%E9%A2%91%E5%9B%A0%E5%AD%90%E5%AD%98%E5%82%A8%E5%BA%93%E8%A1%A8" data-tocid="12-创建日频因子存储库表">1.2. 创建日频因子存储库表</a></li><li class="topic-item"><a href="#13-%E5%BD%93%E6%97%A5%E5%B0%BE%E7%9B%98%E6%88%90%E4%BA%A4%E5%8D%A0%E6%AF%94%E5%9B%A0%E5%AD%90" data-tocid="13-当日尾盘成交占比因子">1.3. 当日尾盘成交占比因子</a></li><li class="topic-item"><a href="#14-%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93" data-tocid="14-存入数据库">1.4. 存入数据库</a></li></ul></li><li class="topic-item"><a href="#2-%E5%88%9B%E5%BB%BA%E5%9B%A0%E5%AD%90%E5%AD%98%E5%82%A8%E5%BA%93%E8%A1%A8" data-tocid="2-创建因子存储库表">2. 创建因子存储库表</a><ul><li class="topic-item"><a href="#21-%E6%97%A5%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="21-日频因子">2.1. 日频因子</a></li><li class="topic-item"><a href="#22-1-%E5%88%86%E9%92%9F%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="22-1-分钟频因子">2.2. 1 分钟频因子</a></li><li class="topic-item"><a href="#23-10-%E5%88%86%E9%92%9F%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="23-10-分钟频因子">2.3. 10 分钟频因子</a></li><li class="topic-item"><a href="#24-3-%E7%A7%92%E5%BF%AB%E7%85%A7%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="24-3-秒快照频因子">2.4. 3 秒快照频因子</a></li><li class="topic-item"><a href="#25-%E9%80%90%E7%AC%94%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="25-逐笔频因子">2.5. 逐笔频因子</a></li><li class="topic-item"><a href="#26-1-%E7%A7%92%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="26-1-秒频因子">2.6. 1 秒频因子</a></li><li class="topic-item"><a href="#27-%E6%9C%9F%E8%B4%A7-500-%E6%AF%AB%E7%A7%92%E9%A2%91%E5%9B%A0%E5%AD%90" data-tocid="27-期货-500-毫秒频因子">2.7. 期货 500 毫秒频因子</a></li></ul></li><li class="topic-item"><a href="#3--%E9%87%8F%E5%8C%96%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97%E4%BB%A3%E7%A0%81%E5%BC%80%E5%8F%91" data-tocid="3--量化因子计算代码开发">3.  量化因子计算代码开发</a><ul><li class="topic-item"><a href="#31-%E5%8F%8C%E5%9D%87%E7%BA%BF%E5%9B%A0%E5%AD%90" data-tocid="31-双均线因子">3.1. 双均线因子</a></li><li class="topic-item"><a href="#32-%E5%8D%81%E6%A1%A3%E5%87%80%E5%A7%94%E4%B9%B0%E5%A2%9E%E9%A2%9D" data-tocid="32-十档净委买增额">3.2. 十档净委买增额</a><ul><li class="topic-item"><a href="#33-%E4%BB%B7%E6%A0%BC%E5%8F%98%E5%8A%A8%E4%B8%8E%E4%B8%80%E6%A1%A3%E9%87%8F%E5%B7%AE%E7%9A%84%E5%9B%9E%E5%BD%92%E7%B3%BB%E6%95%B0" data-tocid="33-价格变动与一档量差的回归系数">3.3. 价格变动与一档量差的回归系数</a><ul><li class="topic-item"><a href="#34-%E4%B8%BB%E5%8A%A8%E6%88%90%E4%BA%A4%E9%87%8F%E5%8D%A0%E6%AF%94" data-tocid="34-主动成交量占比">3.4. 主动成交量占比</a></li><li class="topic-item"><a href="#35-%E6%97%A9%E7%9B%98%E4%B9%B0%E5%8D%96%E5%8D%95%E5%A4%A7%E5%B0%8F%E6%AF%94" data-tocid="35-早盘买卖单大小比">3.5. 早盘买卖单大小比</a></li><li class="topic-item"><a href="#36-%E5%A7%94%E6%89%98%E9%87%8F%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%A7%94%E6%89%98%E4%BB%B7%E6%A0%BC" data-tocid="36-委托量加权平均委托价格">3.6. 委托量加权平均委托价格</a></li></ul></li><li class="topic-item"><a href="#4-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="4-性能测试">4. 性能测试</a><ul><li class="topic-item"><a href="#41-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83" data-tocid="41-性能测试环境">4.1. 性能测试环境</a></li><li class="topic-item"><a href="#42-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C" data-tocid="42-性能测试结果">4.2. 性能测试结果</a></li></ul></li><li class="topic-item"><a href="#5-%E6%80%BB%E7%BB%93" data-tocid="5-总结">5. 总结</a></li><li class="topic-item"><a href="#6-%E9%99%84%E4%BB%B6" data-tocid="6-附件">6. 附件</a></li></ul></li></ul></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>