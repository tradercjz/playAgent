<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="Orderbook 是交易市场上买卖双方正在报价的不同价格的列表。Orderbook 快照反应了特定时刻市场上的交易意图，比如交易活跃的证券标的往往有着密集的 Orderbook。Orderbook 快照对量化金融的交易策略、风险管理和市场分析等方面都具有重要意义。 通常交易所可以提供实时和历史的行情快照数据，快照中除 Orderbook ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎"/><title>基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214"/><meta name="wh-source-relpath" content="tutorials/orderBookSnapshotEngine.dita"/><meta name="wh-out-relpath" content="tutorials/orderBookSnapshotEngine.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/OHLC_2.html">金融场景案例</a></div></div></li><li class="active"><div class="topicref" data-id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎"><div class="title"><a href="../tutorials/orderBookSnapshotEngine.html">基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="k-线计算-d9713e102569" class="topicref" data-id="k-线计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="k-线计算-d9713e102569-link">K 线计算</a></div></div></li><li role="treeitem"><div data-tocid="使用-klinechart-展示-dolphindb-k-线-d9713e102615" class="topicref" data-id="使用-klinechart-展示-dolphindb-k-线" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/displaying_the_dolphindb_k-line_with_klinechart.html" id="使用-klinechart-展示-dolphindb-k-线-d9713e102615-link">使用 KLineChart 展示 DolphinDB K 线</a></div></div></li><li role="treeitem"><div data-tocid="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661" class="topicref" data-id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_HDF5_vs_DolphinDB.html" id="python--hdf5-因子计算与-dolphindb-一体化因子计算方案对比-d9713e102661-link">Python + HDF5 因子计算与 DolphinDB 一体化因子计算方案对比</a></div></div></li><li role="treeitem"><div data-tocid="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707" class="topicref" data-id="python--文件存储与-dolphindb-因子计算性能比较" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_VS_PythonFile_Storage.html" id="python--文件存储与-dolphindb-因子计算性能比较-d9713e102707-link">Python + 文件存储与 DolphinDB 因子计算性能比较</a></div></div></li><li role="treeitem"><div data-tocid="python-parser-在金融量化分析场景的应用入门-d9713e102753" class="topicref" data-id="python-parser-在金融量化分析场景的应用入门" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/py_parser__quant_fin.html" id="python-parser-在金融量化分析场景的应用入门-d9713e102753-link">Python Parser 在金融量化分析场景的应用入门</a></div></div></li><li role="treeitem"><div data-tocid="处理-level-2-行情数据实例-d9713e102799" class="topicref" data-id="处理-level-2-行情数据实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_stk_data_proc_2.html" id="处理-level-2-行情数据实例-d9713e102799-link">处理 Level-2 行情数据实例</a></div></div></li><li role="treeitem"><div data-tocid="存储金融数据的分区方案最佳实践-d9713e102845" class="topicref" data-id="存储金融数据的分区方案最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_partitioned_storage.html" id="存储金融数据的分区方案最佳实践-d9713e102845-link">存储金融数据的分区方案最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="公募基金历史数据基础分析教程-d9713e102891" class="topicref" data-id="公募基金历史数据基础分析教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/public_fund_basic_analysis.html" id="公募基金历史数据基础分析教程-d9713e102891-link">公募基金历史数据基础分析教程</a></div></div></li><li role="treeitem"><div data-tocid="股票行情回放-d9713e102937" class="topicref" data-id="股票行情回放" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_market_replay_2.html" id="股票行情回放-d9713e102937-link">股票行情回放</a></div></div></li><li role="treeitem"><div data-tocid="搭建行情回放服务的最佳实践-d9713e102983" class="topicref" data-id="搭建行情回放服务的最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/appendices_market_replay_bp.html" id="搭建行情回放服务的最佳实践-d9713e102983-link">搭建行情回放服务的最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="国内股票行情数据导入实例-d9713e103029" class="topicref" data-id="国内股票行情数据导入实例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stockdata_csv_import_demo.html" id="国内股票行情数据导入实例-d9713e103029-link">国内股票行情数据导入实例</a></div></div></li><li role="treeitem"><div data-tocid="基金份额参考价值-iopv-计算-d9713e103076" class="topicref" data-id="基金份额参考价值-iopv-计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_IOPV_2.html" id="基金份额参考价值-iopv-计算-d9713e103076-link">基金份额参考价值 IOPV 计算</a></div></div></li><li role="treeitem"><div data-tocid="基于快照行情的股票和基金-k-线合成-d9713e103122" class="topicref" data-id="基于快照行情的股票和基金-k-线合成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k.html" id="基于快照行情的股票和基金-k-线合成-d9713e103122-link">基于快照行情的股票和基金 K 线合成</a></div></div></li><li role="treeitem"><div data-tocid="计算基金日频因子-d9713e103168" class="topicref" data-id="计算基金日频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/fund_factor_contrasted_by_py.html" id="计算基金日频因子-d9713e103168-link">计算基金日频因子</a></div></div></li><li role="treeitem" class="active"><div data-tocid="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214" class="topicref" data-id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/orderBookSnapshotEngine.html" id="基于逐笔数据合成高频-orderbookdolphindb-orderbook-引擎-d9713e103214-link">基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</a></div></div></li><li role="treeitem"><div data-tocid="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260" class="topicref" data-id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/LoadDataForPoc.html" id="金融-poc-用户历史数据导入指导手册之股票-level-2-逐笔篇-d9713e103260-link">金融 PoC 用户历史数据导入指导手册之股票 Level-2 逐笔篇</a></div></div></li><li role="treeitem"><div data-tocid="金融实时实际波动率预测-d9713e103306" class="topicref" data-id="金融实时实际波动率预测" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ml_volatility_2.html" id="金融实时实际波动率预测-d9713e103306-link">金融实时实际波动率预测</a></div></div></li><li role="treeitem"><div data-tocid="金融因子流式实现-d9713e103352" class="topicref" data-id="金融因子流式实现" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/str_comp_fin_quant_2.html" id="金融因子流式实现-d9713e103352-link">金融因子流式实现</a></div></div></li><li role="treeitem"><div data-tocid="开发股票波动率预测模型的-676-个输入特征-d9713e103398" class="topicref" data-id="开发股票波动率预测模型的-676-个输入特征" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/metacode_derived_features_2.html" id="开发股票波动率预测模型的-676-个输入特征-d9713e103398-link">开发股票波动率预测模型的 676 个输入特征</a></div></div></li><li role="treeitem"><div data-tocid="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444" class="topicref" data-id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/l2_snapshot_factor_calc_2.html" id="快速搭建-level-2-快照数据流批一体因子计算平台最佳实践-d9713e103444-link">快速搭建 Level-2 快照数据流批一体因子计算平台最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="量化金融范例-d9713e103490" class="topicref" data-id="量化金融范例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/quant_finance_examples.html" id="量化金融范例-d9713e103490-link">量化金融范例</a></div></div></li><li role="treeitem"><div data-tocid="流式计算中证-1000-指数主买主卖交易量-d9713e103536" class="topicref" data-id="流式计算中证-1000-指数主买主卖交易量" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/CSI_1000_2.html" id="流式计算中证-1000-指数主买主卖交易量-d9713e103536-link">流式计算中证 1000 指数主买/主卖交易量</a></div></div></li><li role="treeitem"><div data-tocid="深度不平衡买卖压力指标波动率计算-d9713e103583" class="topicref" data-id="深度不平衡买卖压力指标波动率计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/sql_performance_optimization_wap_di_rv.html" id="深度不平衡买卖压力指标波动率计算-d9713e103583-link">深度不平衡、买卖压力指标、波动率计算</a></div></div></li><li role="treeitem"><div data-tocid="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629" class="topicref" data-id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/insight_plugin_orderbook_engine_application.html" id="实时合成自定义频订单簿快照dolphindb-insight-行情插件与订单簿引擎应用-d9713e103629-link">实时合成自定义频订单簿快照：DolphinDB INSIGHT 行情插件与订单簿引擎应用</a></div></div></li><li role="treeitem"><div data-tocid="实时计算分钟资金流-d9713e103675" class="topicref" data-id="实时计算分钟资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_order_by_order_2.html" id="实时计算分钟资金流-d9713e103675-link">实时计算分钟资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算高频因子-d9713e103721" class="topicref" data-id="实时计算高频因子" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hf_factor_streaming_2.html" id="实时计算高频因子-d9713e103721-link">实时计算高频因子</a></div></div></li><li role="treeitem"><div data-tocid="实时计算日累计逐单资金流-d9713e103767" class="topicref" data-id="实时计算日累计逐单资金流" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_capital_flow_daily_2.html" id="实时计算日累计逐单资金流-d9713e103767-link">实时计算日累计逐单资金流</a></div></div></li><li role="treeitem"><div data-tocid="实时计算涨幅榜-d9713e103813" class="topicref" data-id="实时计算涨幅榜" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/rt_stk_price_inc_calc_2.html" id="实时计算涨幅榜-d9713e103813-link">实时计算涨幅榜</a></div></div></li><li role="treeitem"><div data-tocid="实时选取外汇行情多价源最优价-d9713e103859" class="topicref" data-id="实时选取外汇行情多价源最优价" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_price_selection.html" id="实时选取外汇行情多价源最优价-d9713e103859-link">实时选取外汇行情多价源最优价</a></div></div></li><li role="treeitem"><div data-tocid="外汇掉期估值计算-d9713e103905" class="topicref" data-id="外汇掉期估值计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/FxSwapValuation.html" id="外汇掉期估值计算-d9713e103905-link">外汇掉期估值计算</a></div></div></li><li role="treeitem"><div data-tocid="因子计算平台构建-d9713e103951" class="topicref" data-id="因子计算平台构建" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Python_Celery.html" id="因子计算平台构建-d9713e103951-link">因子计算平台构建</a></div></div></li><li role="treeitem"><div data-tocid="因子计算最佳实践-d9713e103997" class="topicref" data-id="因子计算最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practice_for_factor_calculation.html" id="因子计算最佳实践-d9713e103997-link">因子计算最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="mvo_tutorial-d9713e104043" class="topicref" data-id="mvo_tutorial" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/MVO.html" id="mvo_tutorial-d9713e104043-link">优化投资组合：DolphinDB 最优化求解系列函数应用指南</a></div></div></li><li role="treeitem"><div data-tocid="中高频多因子库存储最佳实践-d9713e104090" class="topicref" data-id="中高频多因子库存储最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/best_practices_for_multi_factor.html" id="中高频多因子库存储最佳实践-d9713e104090-link">中高频多因子库存储最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136" class="topicref" data-id="alphalens-在-dolphindb-中的应用因子分析建模实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Practical_Factor_Analysis_Modeling.html" id="alphalens-在-dolphindb-中的应用因子分析建模实践-d9713e104136-link">Alphalens 在 DolphinDB 中的应用：因子分析建模实践</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-dolphinscheduler-的集成-d9713e104182" class="topicref" data-id="dolphindb-与-dolphinscheduler-的集成" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphinscheduler_integration.html" id="dolphindb-与-dolphinscheduler-的集成-d9713e104182-link">DolphinDB 与 DolphinScheduler 的集成</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-与-python-airflow-最佳实践-d9713e104228" class="topicref" data-id="dolphindb-与-python-airflow-最佳实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_airflow.html" id="dolphindb-与-python-airflow-最佳实践-d9713e104228-link">DolphinDB 与 Python AirFlow 最佳实践</a></div></div></li><li role="treeitem"><div data-tocid="gplearn-d9713e104274" class="topicref" data-id="gplearn" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/gplearn.html" id="gplearn-d9713e104274-link">Shark GPLearn 快速上手</a></div></div></li><li role="treeitem"><div data-tocid="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320" class="topicref" data-id="利用jit加速计算-etf-期权隐含波动率和希腊值" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/IV_Greeks_Calculation_for_ETF_Options_Using_JIT.html" id="利用jit加速计算-etf-期权隐含波动率和希腊值-d9713e104320-link">利用JIT加速计算 ETF 期权隐含波动率和希腊值</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366" class="topicref" data-id="基于-dolphindb-的-brinson-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/brinson.html" id="基于-dolphindb-的-brinson-绩效归因模型实践-d9713e104366-link">基于 DolphinDB 的 Brinson 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412" class="topicref" data-id="基于-dolphindb-的-campisi-绩效归因模型实践" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/campisi.html" id="基于-dolphindb-的-campisi-绩效归因模型实践-d9713e104412-link">基于 DolphinDB 的 Campisi 绩效归因模型实践</a></div></div></li><li role="treeitem"><div data-tocid="期货分钟频cta策略回测案例-d9713e104458" class="topicref" data-id="期货分钟频cta策略回测案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/futures_minute_frequency_cta_strategy_backtest_example.html" id="期货分钟频cta策略回测案例-d9713e104458-link">期货分钟频CTA策略回测案例</a></div></div></li><li role="treeitem"><div data-tocid="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504" class="topicref" data-id="exchdata-交易所历史股票数据自动化导入功能模块使用教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/exchdata_exchange_historical_stock_data_auto_import_module_tutorial.html" id="exchdata-交易所历史股票数据自动化导入功能模块使用教程-d9713e104504-link">ExchData 交易所历史股票数据自动化导入功能模块使用教程</a></div></div></li><li role="treeitem"><div data-tocid="ficc_func_uasge_and_performance-d9713e104550" class="topicref" data-id="ficc_func_uasge_and_performance" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_func_uasge_and_performance.html" id="ficc_func_uasge_and_performance-d9713e104550-link">FICC 固收系列函数使用示例及性能</a></div></div></li><li role="treeitem"><div data-tocid="title1-d9713e104597" class="topicref" data-id="title1" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ficc_funcs_application.html" id="title1-d9713e104597-link">FICC 固收系列函数应用场景</a></div></div></li><li role="treeitem"><div data-tocid="最优化函数_socp_的使用及转化案例-d9713e104643" class="topicref" data-id="最优化函数_socp_的使用及转化案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/socp_usage_case.html" id="最优化函数_socp_的使用及转化案例-d9713e104643-link">最优化函数 socp 的使用及转化案例</a></div></div></li><li role="treeitem"><div data-tocid="k_line_calculation-d9713e104689" class="topicref" data-id="k_line_calculation" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/k_line_calculation%20.html" id="k_line_calculation-d9713e104689-link">基于期货快照行情数据计算合约 K 线以及主连行情</a></div></div></li><li role="treeitem"><div data-tocid="backtest_introduction_usage-d9713e104735" class="topicref" data-id="backtest_introduction_usage" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/backtest_introduction_usage.html" id="backtest_introduction_usage-d9713e104735-link">融资融券策略回测使用说明及回测案例</a></div></div></li><li role="treeitem"><div data-tocid="stock_backtest-d9713e104781" class="topicref" data-id="stock_backtest" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/stock_backtest.html" id="stock_backtest-d9713e104781-link">股票中低频投资组合回测案例实现</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1">
    <h1 class="- topic/title title topictitle1" id="ariaid-title1">基于逐笔数据合成高频 Orderbook：DolphinDB Orderbook 引擎</h1>
    <div class="- topic/body body">
        <p class="- topic/p p">Orderbook 是交易市场上买卖双方正在报价的不同价格的列表。Orderbook 快照反应了特定时刻市场上的交易意图，比如交易活跃的证券标的往往有着密集的
            Orderbook。Orderbook 快照对量化金融的交易策略、风险管理和市场分析等方面都具有重要意义。</p>
        <p class="- topic/p p">通常交易所可以提供实时和历史的行情快照数据，快照中除 Orderbook 以外还包括最新成交价等成交信息。以沪深两市的股票为例，交易所提供了 3 秒频率的 10 档
            Orderbook，也称为 Level-2 快照。随着高频量化交易的发展和实时处理系统能力的提升，3 秒频率的 Orderbook 已经无法满足 T0
            等高频策略的需求。量化团队迫切需要更高频和更丰富的行情快照信息，使其在实盘中能够更快的掌握最新的市场变化。</p>
        <p class="- topic/p p">为了满足上述需求，一些量化团队会尝试通过逐笔数据合成
            Orderbook，但是投入后便会发现困难重重，在解决合成结果的正确性、实时合成的低延时等关键问题上都需要投入巨大的研发资源。为了满足业界对高频 Orderbook
            的个性化需求，同时降低用户的开发成本，DolphinDB 基于其在高性能流计算上的技术储备，以及和金融客户的紧密业务合作，推出了经过正确性校验的高性能 Orderbook
            引擎。用户只需要通过 <code class="+ topic/ph pr-d/codeph ph codeph">createOrderbookSnapshotEngine</code> 函数即可定义 Orderbook
            引擎，再通过向引擎输入符合约定的逐笔成交和逐笔委托数据来合成 Orderbook。</p>
        <p class="- topic/p p">在业务上，Orderbook 引擎支持以下功能：</p>
        <ul class="- topic/ul ul">
            <li class="- topic/li li">支持多个交易所的多种证券类型，比如深交所股票</li>
            <li class="- topic/li li">支持任意深度和任意频率的 Orderbook</li>
            <li class="- topic/li li">支持成交明细、委托明细、撤单明细等丰富的衍生指标</li>
            <li class="- topic/li li">支持用户自定义指标</li>
        </ul>
        <p class="- topic/p p">在实时技术上，Orderbook 引擎支持以下功能：</p>
        <ul class="- topic/ul ul">
            <li class="- topic/li li">支持流批一体</li>
            <li class="- topic/li li">支持多种时间概念，比如事件时间、机器时间</li>
            <li class="- topic/li li">支持灵活的触发机制，比如不同股票之间相互触发</li>
        </ul>
        <p class="- topic/p p">Orderbook 引擎需要在商业版 license 的基础上额外开通 Orderbook 引擎功能，欢迎联系小助手或销售申请试用。此外，本文全部代码需要运行在 2.00.12
            及以上版本的 DolphinDB server 上。</p>
    </div>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="orderbook-引擎orderbook-snapshot-engine工作原理">
        <h2 class="- topic/title title topictitle2" id="ariaid-title2">1. Orderbook 引擎（Orderbook Snapshot Engine）工作原理</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">Orderbook 引擎是一个内置的计算组件，通过 <code class="+ topic/ph pr-d/codeph ph codeph">createOrderbookSnapshotEngine</code>
                函数可以创建引擎，再通过向引擎输入符合约定的逐笔成交和逐笔委托数据来触发计算。引擎的计算结果包括多档量价、逐笔明细、用户自定义指标等丰富的行情信息，计算结果会被输出到目标表。</p>
            <p class="- topic/p p">本章介绍 Orderbook 引擎在合成逻辑、时间窗口、乱序数据处理等方面的内部实现原理，以及 Orderbook
                引擎目前对不同交易规则的支持性。若对原理没有兴趣，可以直接跳至第二章开始具体的 Orderbook 合成代码实现。</p>
        </div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="orderbook-的合成逻辑">
            <h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1 Orderbook 的合成逻辑</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">Orderbook 引擎采用基于消减的合成逻辑，仅需输入逐笔委托与逐笔成交数据即可：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">在一个通道内，按 ApplSeqNum 有序逐条处理逐笔数据。ApplSeqNum 为交易所原始消息记录号，也称为 BizIndex，同频道内自 1
                        开始计数；</li>
                    <li class="- topic/li li">当收到委托时缓存委托单的价格和量，当收到成交和撤单时，从缓存中减去对应委托单的价格和量；</li>
                    <li class="- topic/li li">通过引擎内部缓存的委托单信息可以计算出每个报价的委托量、委托笔数等信息。</li>
                </ul>
                <p class="- topic/p p">整体的合成逻辑如上，在此基础上也会遵循交易规则修正后再输出
                    Orderbook，以保证输出结果的准确性。比如对于深交所股票，引擎支持创业板价格笼子判断，部分报价会因为触发价格笼子规则而不体现在 Orderbook
                    中，用户可以通过参数控制是否启动该规则。</p>
                <p class="- topic/p p">通过将引擎计算结果与交易所发布的 3 秒快照进行比较，可以验证引擎内部合成逻辑的正确性。具体的校验方案与实现脚本见本文第 5 章。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="对时间窗口的处理">
            <h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2 对时间窗口的处理</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">Orderbook 快照表示了某个时刻的 Orderbook
                    截面，截面表示的窗口范围以及何时进行截面都由引擎自动控制。接下来我们介绍引擎在窗口时间、触发窗口的时机等方面的工作原理。</p>
                <p class="- topic/p p">当 Orderbook 引擎设置的输出频率为 1 秒时，若输出一条时间戳字段为 10:00:00 的计算结果，该计算结果表示的是时间戳小于等于 10:00:00
                    的全部逐笔形成的最新 Orderbook。一些窗口指标如当前周期内成交量，则对应的是在 (09:59:59, 10:00:00]
                    这个左开右闭区间内的逐笔数据的总成交量。仅有时间戳为 14:57:00 的结果的含义稍有不同，引擎的输出到 14:57:00
                    就会停止，即引擎的处理与输出不包含收盘集合竞价阶段，所以 14:57:00 的计算结果对应 (14:56:59, 14:57:00)
                    这个左开右开区间内的逐笔数据。</p>
                <p class="- topic/p p">在实时合成时，逐笔数据逐条进入引擎，引擎需要一个规则来判断何时窗口内的逐笔数据全部到齐了。以输出 10:00:00 的 Orderbook
                    为例，判断规则是一旦收到一条时间戳大于 10:00:00 的逐笔数据（包含委托和成交），则认为应该输出 10:00:00
                    的计算结果了。计算结果中不包含触发输出的这条逐笔数据。此判断规则可以基于单支标的或全部标的。当指定单支标的时，每支标的收到一条时间戳大于 10:00:00
                    的逐笔数据时，仅触发计算并输出该标的的 Orderbook。当指定全部标的时，收到任意标的的时间戳大于 10:00:00 的逐笔数据时，触发计算并输出全部标的的
                    Orderbook。</p>
                <p class="- topic/p p">此外，若某一段时间的逐笔数据空缺，则输出也会空缺，以午盘休市为例，引擎不会输出11:30:01-12:59:59 时间戳的
                    Orderbook，因为没有这段时间的逐笔数据。</p>
                <p class="- topic/p p">严格地按照逐笔数据里的时间戳截取 Orderbook
                    快照，将能够保证实盘和历史计算总能得到一致的结果，实现“流批一体”。根据已有的落地实践经验，在实盘中，我们推荐将一个通道中全部的标的视为一个整体，用全部标的的事件时间（即数据中的交易时间字段）来判断何时截取快照，这种方式能够保证尽快且准确地推出
                    Orderbook 快照。此外，为了满足不同的场景需求，后续版本中也将推出基于机器时间的 Orderbook 处理，即机器时间每经过一个时间间隔输出一次最新的
                    Orderbook。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title5" id="对乱序数据的处理">
            <h3 class="- topic/title title topictitle3" id="ariaid-title5">1.3 对乱序数据的处理</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">在实盘环境中，接入到系统中的逐笔数据可能发生乱序，如不能正确处理乱序会影响 Orderbook
                    合成的正确性。在交易所内部系统中，每个交易通道中的标的发生的委托和成交事件都会被赋予一个顺序号，即
                    ApplSeqNum。这个顺序号反映了事件在交易所内部实际发生的顺序。数据乱序，是指可能是由于网络延迟或其他技术问题导致的事件没有严格按照 ApplSeqNum
                    到达数据处理系统。因此，数据处理系统收到的逐笔数据可能需要重新排序，以确保它们反映了在交易所内部实际发生的顺序。</p>
                <p class="- topic/p p">例如，如果标的A的逐笔成交比对应的逐笔委托先到达，引擎按到达顺序处理，先处理成交再处理委托则会得到错误的 Orderbook 结果。为此，Orderbook
                    引擎支持指定输入数据中的 ApplSeqNum 字段，引擎会检测并缓存 ApplSeqNum 发跳变的数据，在接收到正确 ApplSeqNum
                    的数据后再计算输出，可以保证 Orderbook 合成的正确性。用户可以根据业务需求和接收到的数据质量，选择是否开启处理乱序数据的功能。</p>
                <p class="- topic/p p">下图展示了收到不同的 ApplSeqNum 时的处理方式，从左至右表示了时间先后顺序，即最先收到ApplSeqNum=1的输入数据。</p>
                <div class="table-container"><table class="- topic/table table" data-cols="8"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead">
                            <tr class="- topic/row">
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__1">收到的 ApplSeqNum</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__2">1</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__3">2</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__4">5</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__5">6</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__6">9</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__7">3</th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="对乱序数据的处理__entry__8">4</th>
                            </tr>
                        </thead><tbody class="- topic/tbody tbody">
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__1">此次处理的 ApplSeqNum</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__2">处理1</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__3">处理2</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__4">无处理（缓存5）</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__5">无处理（缓存5、6）</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__6">无处理（缓存5、6、9）</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__7">处理3</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="对乱序数据的处理__entry__8">遍历处理4、5、6（缓存9）</td>
                            </tr>
                        </tbody></table></div>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="证券类型和规则的支持性">
            <h3 class="- topic/title title topictitle3" id="ariaid-title6">1.4 证券类型和规则的支持性</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">2.00.12及以上版本，支持沪深两市的股票、基金以及可转债等证券类型的 Orderbook 合成。更具体的规则支持性如下：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">通过参数控制是否包含创业板价格笼子规则。深交所股票默认按全面注册制启动以前的规则处理的，其中包含创业板价格笼子规则；</li>
                    <li class="- topic/li li">包含对市价单、本方最优单等委托单的处理逻辑，能够以正确的价格输出到 Orderbook 上；</li>
                    <li class="- topic/li li">沪深可转债按2022年08月启动的新规进行处理；</li>
                    <li class="- topic/li li">不包含上市前5日创业板的特殊规则，即不保证创业板标的上市前5日的 Orderbook 正确性；</li>
                    <li class="- topic/li li">不包含上市首日主板的特殊规则，即不保证主板标的上市首日的 Orderbook 正确性。</li>
                </ul>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title7" id="输入数据准备">
        <h2 class="- topic/title title topictitle2" id="ariaid-title7">2. 输入数据准备</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">Orderbook 引擎的计算正确性依赖于输入数据的正确性，因此对于输入数据有着较为严格的要求。本节讲解对输入数据的要求和具体示例。</p>
        </div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title8" id="数据处理注意事项">
            <h3 class="- topic/title title topictitle3" id="ariaid-title8">2.1 数据处理注意事项</h3>
            <div class="- topic/body body">
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">
                        <strong class="+ topic/ph hi-d/b ph b">成交和委托的合并表</strong>
                    </li>
                </ul>
                <p class="- topic/p p">Orderbook 引擎的输入为一张表，该表需要同时包含逐笔成交数据和逐笔委托数据。将逐笔成交、逐笔委托处理成相同的表结构可以存储到同一张输入表中。</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">
                        <strong class="+ topic/ph hi-d/b ph b">完整的必选输入字段</strong>
                    </li>
                </ul>
                <p class="- topic/p p">输入数据至少包含以下 10 个字段，引擎计算依赖这 10 种数据内容。引擎创建时必须指定参数
                    <em class="+ topic/ph hi-d/i ph i">inputColMap</em>，该参数为字典，其指定了引擎计算需要的各种数据内容对应的输入数据中的字段名称。此外，输入表中可以冗余其他字段。</p>
                <div class="table-container"><table class="- topic/table table frame-all" id="数据处理注意事项__table_twv_1bq_wdc" data-ofbid="数据处理注意事项__table_twv_1bq_wdc" data-cols="3"><caption></caption><colgroup><col style="width:17.391304347826086%"/><col style="width:17.565217391304348%"/><col style="width:65.04347826086956%"/></colgroup><thead class="- topic/thead thead">
                        <tr class="- topic/row">
                            <th class="- topic/entry entry colsep-1 rowsep-1" id="数据处理注意事项__table_twv_1bq_wdc__entry__1">key</th>
                            <th class="- topic/entry entry colsep-1 rowsep-1" id="数据处理注意事项__table_twv_1bq_wdc__entry__2">value 对应的字段类型</th>
                            <th class="- topic/entry entry colsep-0 rowsep-1" id="数据处理注意事项__table_twv_1bq_wdc__entry__3">含义</th>
                        </tr>
                    </thead><tbody class="- topic/tbody tbody">
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"codeColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">SYMBOL</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">证券代码（如300010.SZ）</td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"timeColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">TIME</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">交易时间</td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"typeColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">INT</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">交易类型：<ul class="- topic/ul ul" id="数据处理注意事项__ul_w52_ghv_x1c" data-ofbid="数据处理注意事项__ul_w52_ghv_x1c">
                                    <li class="- topic/li li">如果是逐笔委托单，则：1 表示市价；2 表示限价；3 表示本方最优；10 表示撤单（仅上交所）；11
                                        市场状态（仅上交所）</li>
                                    <li class="- topic/li li">如果是逐笔成交单，则：0 表示成交；1 表示撤单（仅深交所）</li>
                                </ul></td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"priceColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">LONG</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">价格，真实价格*10000</td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"qtyColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">LONG</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">数量（股数）</td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"buyOrderColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">LONG</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">
                                <ul class="- topic/ul ul" id="数据处理注意事项__ul_vcp_txz_x1c" data-ofbid="数据处理注意事项__ul_vcp_txz_x1c">
                                    <li class="- topic/li li">逐笔成交：对应其原始成交中的买方委托序号。</li>
                                    <li class="- topic/li li">逐笔委托：<ul class="- topic/ul ul" id="数据处理注意事项__ul_x52_ghv_x1c" data-ofbid="数据处理注意事项__ul_x52_ghv_x1c">
                                            <li class="- topic/li li">上交所：填充原始委托中的原始订单号，即上交所在新增、删除订单时用以标识订单的唯一编号（OrderNo
                                                字段）</li>
                                            <li class="- topic/li li">深交所：填充 0。此字段为深交所为了补全上交所数据格式而增加的冗余列</li>
                                        </ul></li>
                                </ul>
                            </td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"sellOrderColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">LONG</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">
                                <ul class="- topic/ul ul" id="数据处理注意事项__ul_ggr_vxz_x1c" data-ofbid="数据处理注意事项__ul_ggr_vxz_x1c">
                                    <li class="- topic/li li">逐笔成交：对应其原始成交中的卖方委托序号。</li>
                                    <li class="- topic/li li">逐笔委托：<ul class="- topic/ul ul" id="数据处理注意事项__ul_y52_ghv_x1c" data-ofbid="数据处理注意事项__ul_y52_ghv_x1c">
                                            <li class="- topic/li li">上交所：填充原始委托中的原始订单号，即上交所在新增、删除订单时用以标识订单的唯一编号（OrderNo
                                                字段）</li>
                                            <li class="- topic/li li">深交所：填充 0。此字段深交所为了补全上交所数据格式而增加的冗余列</li>
                                        </ul></li>
                                </ul>
                            </td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"sideColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">INT</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">买卖方向：1 表示买单；2 表示卖单<p class="- topic/p p">说明：</p><ul class="- topic/ul ul" id="数据处理注意事项__ul_z52_ghv_x1c" data-ofbid="数据处理注意事项__ul_z52_ghv_x1c">
                                    <li class="- topic/li li">委托单的 BSFlag，必填</li>
                                    <li class="- topic/li li">撤单的 BSFlag 由原始委托单决定买卖方向，必填</li>
                                    <li class="- topic/li li">成交单的 BSFlag，不影响结果，非必填</li>
                                </ul></td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"msgTypeColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">INT</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">数据类型：<ul class="- topic/ul ul" id="数据处理注意事项__ul_r4p_w2t_2bc" data-ofbid="数据处理注意事项__ul_r4p_w2t_2bc">
                                    <li class="- topic/li li">0 表示逐笔委托；</li>
                                    <li class="- topic/li li">1 表示逐笔成交；</li>
                                    <li class="- topic/li li">-1 表示产品状态。</li>
                                </ul></td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"seqColumn"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">LONG</td>
                            <td class="- topic/entry entry colsep-0 rowsep-1" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">一个通道内从 1 开始递增的逐笔数据序号。深交所为 appseqlnum 字段，若深交所数据中包含 index 字段，也可以使用
                                index；上交所为 bizIndex 字段。</td>
                        </tr>
                        <tr class="- topic/row">
                            <td class="- topic/entry entry colsep-1 rowsep-0" headers="数据处理注意事项__table_twv_1bq_wdc__entry__1">"receiveTime"</td>
                            <td class="- topic/entry entry colsep-1 rowsep-0" headers="数据处理注意事项__table_twv_1bq_wdc__entry__2">NANOTIMESTAMP</td>
                            <td class="- topic/entry entry colsep-0 rowsep-0" headers="数据处理注意事项__table_twv_1bq_wdc__entry__3">逐笔数据的接收时间</td>
                        </tr>
                    </tbody></table></div>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">
                        <p class="- topic/p p">
                            <strong class="+ topic/ph hi-d/b ph b">规范的枚举值</strong>
                        </p>
                        <p class="- topic/p p">Orderbook 引擎约定了以上字段中的枚举类型列中的枚举值。输入表中的枚举值必须符合约定才能得到正确结果。如 BSFlag
                            字段，约定1代表买方向， 2代表卖方向。</p>
                    </li>
                    <li class="- topic/li li">
                        <p class="- topic/p p">
                            <strong class="+ topic/ph hi-d/b ph b">seqColumn 列的注意事项</strong>
                        </p>
                        <ul class="- topic/ul ul">
                            <li class="- topic/li li">深交所的委托单中的 seqColumn 列表示了委托单号，之后撤单和成交时都需要找到这个对应的委托单号，因此 seqColumn
                                代表的值必须正确。</li>
                            <li class="- topic/li li">除上述含义以外，seqColumn 列还可以用于判断逐笔数据的处理顺序。Orderbook 引擎创建时指定参数
                                    <em class="+ topic/ph hi-d/i ph i">orderBySeq</em>=false，则引擎依赖输入数据进入引擎的先后顺序逐条处理。创建时若指定参数
                                    <em class="+ topic/ph hi-d/i ph i">orderBySeq</em>=true，则引擎依赖 seqColumn 列中值的大小顺序逐条处理数据，工作原理见
                                    <a class="- topic/xref xref" href="#%E5%AF%B9%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86">1.3 对输入数据乱序的处理小节</a>。</li>
                            <li class="- topic/li li">深交所股票、深交所可转债、深交所基金、上交所可转债分别在各自的通道中。上交所的基金和股票会在同一通道内。一个通道内的
                                ApplSeqNum 从1开始连续编号。</li>
                        </ul>
                    </li>
                    <li class="- topic/li li">
                        <p class="- topic/p p">
                            <strong class="+ topic/ph hi-d/b ph b">对于同一个 Orderbook 引擎，至多只能输入一天一个通道的全部标的</strong>
                        </p>
                    </li>
                </ul>
                <p class="- topic/p p">引擎内部为每支标的维护一个累积的 Orderbook，并且不会在新的交易日清除前一天的状态，因此引擎不允许跨越多个交易日计算
                    Orderbook。此外，若引擎的触发机制是任意到来一支标的的最新数据就触发全部标的输出（参数
                    <em class="+ topic/ph hi-d/i ph i">triggerType</em>=”mutual”），那么用同一个引擎处理多个通道（原始逐笔数据中的 ChannelNo ）也是不建议的，因为多个通道按
                    ApplSeqNum 递增排序后，逐笔时间字段可能不再递增，则将导致提前触发输出。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="历史批计算的输入数据处理方案">
            <h3 class="- topic/title title topictitle3" id="ariaid-title9">2.2 历史批计算的输入数据处理方案</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">通常逐笔成交数据和逐笔委托数据以不同的表结构存储在不同的文件或者数据库表中，本例提供批量合并成交和委托至同一张表中的示例。由于深交所数据和上交所数据的差异，本章分为两个小节逐一介绍。</p>
            </div>
            <article class="- topic/topic topic nested3" aria-labelledby="ariaid-title10" id="深交所股票">
                <h4 class="- topic/title title topictitle4" id="ariaid-title10">2.2.1 深交所股票</h4>
                <div class="- topic/body body">
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">输入数据</strong>
                    </p>
                    <p class="- topic/p p">逐笔成交数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/trans.zip">trans.csv</a></p>
                    <p class="- topic/p p">逐笔委托数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/orders.zip">orders.csv</a></p>
                    <p class="- topic/p p">数据共包含2022.06.01当天5支深交所股票的完整逐笔数据。</p>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">示例脚本</strong>
                    </p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>/*
 *  功能：将深交所逐笔成交和委托写入同一张表 OrderTrans
 */
// 登录
login("admin", "123456")
// 创建合并表 OrderTrans
name = `SecurityID`Date`Time`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo
type = `SYMBOL`DATE`TIME`INT`INT`LONG`LONG`INT`LONG`LONG`LONG`INT
OrderTrans = table(1:0, name, type)
// 指定待加载的文件路径
orderPath = "./orders.csv"
transPath = "./trans.csv"
// 指定枚举值的映射关系
tradeTypeMap = dict([0, 1], [0, 1])
orderTypeMap = dict([1, 2, 3], [1, 2, 3])
BSFlagMap = dict([1, 2], [1, 2])

// 加载csv文件并处理order为特定的表结构	
orderTemp = select 
		SecurityID, MDDate, temporalParse(lpad(string(MDTime), 9, `0), "HHmmssSSS") as Time, 0 as SourceType, orderTypeMap[OrderType] as Type, OrderPrice*10000 as Price, OrderQty as Qty, BSFlagMap[OrderBSFlag] as BSFlag, 0 as BuyNo, 0 as SellNo, ApplSeqNum, ChannelNo
		from loadText(orderPath)
OrderTrans.append!(orderTemp)
// 加载csv文件并处理transaction为特定的表结构
tradeTemp = select 
		SecurityID, MDDate, temporalParse(lpad(string(MDTime), 9, `0), "HHmmssSSS") as Time, 1 as SourceType, tradeTypeMap[TradeType] as Type, TradePrice*10000 as Price, TradeQty as Qty, BSFlagMap[TradeBSFlag] as BSFlag, TradeBuyNo as BuyNo, TradeSellNo as SellNo, ApplSeqNum, ChannelNo
		from loadText(transPath)
OrderTrans.append!(tradeTemp)
// 保存合并结果
saveText(OrderTrans, "./orderTrans.csv")</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li">处理深交所委托时，BuyNo 和 SellNo 均置为 0，即无实际意义。深交所的逐笔委托数据中，ApplSeqNum
                            字段用于标识委托单的唯一编号。当一个成交发生时，成交单中的 TradeBuyNo 和TradeSellNo 字段分别对应买方和卖方委托单的
                            ApplSeqNum 。</li>
                        <li class="- topic/li li">注意，这里用 3 个字典来处理了枚举值的映射关系，字典的 key 是原始文件中的值，字典的 value 是 Orderbook
                            引擎规定的枚举值。</li>
                    </ul>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tradeTypeMap = dict([0, 1], [0, 1])
orderTypeMap = dict([1, 2, 3], [1, 2, 3])
BSFlagMap = dict([1, 2], [1, 2])</code></pre>
                    <p class="- topic/p p">本例比较特殊，原始文件与 Orderbook 引擎枚举值一致。如果原始文件使用其他数据源，需要修改字典的 key
                        值为原始文件中的枚举值。以通联的深交所数据为例，则映射关系应该指定如下：</p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>tradeTypeMap = dict([70, 52] , [0 ,1])
orderTypeMap = dict([49, 50, 85], [1, 2, 3])
BSFlagMap = dict([49, 50] , [1, 2])</code></pre>
                </div>
            </article>
            <article class="- topic/topic topic nested3" aria-labelledby="ariaid-title11" id="上交所股票">
                <h4 class="- topic/title title topictitle4" id="ariaid-title11">2.2.2 上交所股票</h4>
                <div class="- topic/body body">
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">输入数据</strong>
                    </p>
                    <p class="- topic/p p">逐笔成交数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/SHtrans.zip">SHtrans.csv</a></p>
                    <p class="- topic/p p">逐笔委托数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/SHorders.zip">SHorders.csv</a></p>
                    <p class="- topic/p p">数据共包含2023.07.11当天5支上交所股票的完整逐笔数据。</p>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">示例脚本</strong>
                    </p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>/*
 *  功能：将上交所逐笔成交和委托写入同一张表 OrderTrans
 */
// 登录
login("admin", "123456")
// 创建合并表 OrderTrans
name = `SecurityID`Date`Time`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo
type = `SYMBOL`DATE`TIME`INT`INT`LONG`LONG`INT`LONG`LONG`LONG`INT
OrderTrans = table(1:0, name, type)
// 指定待加载的文件路径
orderPath = "/home/ytxie/orderbookServer/vOrderbook/server//SHorders.csv"
transPath = "/home/ytxie/orderbookServer/vOrderbook/server/SHtrans.csv"
// 指定枚举值的映射关系
orderTypeMap = dict([2, 10], [2, 10])
BSFlagMap = dict([1, 2], [1, 2])

// 加载csv文件并处理order为特定的表结构	
orderTemp = select 
		SecurityID, MDDate, MDTime, 0 as SourceType, orderTypeMap[OrderType] as Type, OrderPrice*10000 as Price, OrderQty as Qty, BSFlagMap[OrderBSFlag] as BSFlag, OrderNo as BuyNo, OrderNo as SellNo, ApplSeqNum, ChannelNo
		from loadText(orderPath)
OrderTrans.append!(orderTemp)
// 加载csv文件并处理transaction为特定的表结构
tradeTemp = select 
		SecurityID, MDDate, MDTime as Time, 1 as SourceType, 0 as Type, TradePrice*10000 as Price, TradeQty as Qty, BSFlagMap[TradeBSFlag] as BSFlag, TradeBuyNo as BuyNo, TradeSellNo as SellNo, ApplSeqNum, ChannelNo
		from loadText(transPath)
OrderTrans.append!(tradeTemp)
// 保存合并结果
saveText(OrderTrans, "./SHorderTrans.csv")</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li">处理上交所委托时，BuyNo 和 SellNo 均置为 OrderNo。上交所的逐笔委托数据中，OrderNo
                            字段用于标识委托单的唯一编号。当一个成交发生时，成交单中的 TradeBuyNo 和TradeSellNo 字段分别对应买方和卖方委托单的
                            OrderNo 。</li>
                        <li class="- topic/li li">若您使用的上交所逐笔中包含 bizIndex 字段，bizIndex 字段和 ApplSeqNum
                            字段的等价的，即上交所逐笔中会包含其中的某一个，表示一个通道内全部逐笔从 1 开始的编号。</li>
                        <li class="- topic/li li">上交所逐笔成交数据中不包含成交类型字段，因此成交数据的 Type 字段全部以 0 填充。</li>
                        <li class="- topic/li li">注意，这里用 2 个字典来处理了枚举值的映射关系，字典的 key 是原始文件中的值，字典的 value 是 Orderbook
                            引擎规定的枚举值。本例比较特殊，原始文件与 Orderbook 引擎枚举值一致。如果原始文件使用其他数据源，需要修改字典的 key
                                    值为原始文件中的枚举值。<ul class="- topic/ul ul"><li class="- topic/li li">指定 orderTypeMap 时，上交所不包含市价单，因此只需要区分下单 2 和撤单
                                    10 。</li></ul></li>
                    </ul>
                </div>
            </article>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="实时流计算的输入数据处理方案">
            <h3 class="- topic/title title topictitle3" id="ariaid-title12">2.3 实时流计算的输入数据处理方案</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">在实时数据接入 Orderbook 引擎时，建议保证逐笔成交和逐笔委托以交易所发送的真实顺序有序写入 DolphinDB 流数据表中。如果逐笔数据在抵达
                    DolphinDB 服务器时 ApplSeqnum 出现乱序，可以在创建引擎时指定 <em class="+ topic/ph hi-d/i ph i">orderBySeq</em>=true，由引擎保证按
                    seqColumn 的顺序处理数据。实时数据接入的大致流程如下:</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">首先在 DolphinDB 中创建流数据表，可以是共享流数据表，也可以是持久化流数据表。</li>
                    <li class="- topic/li li">其次，通过行情 sdk 同时订阅逐笔成交和逐笔委托数据。在行情 sdk 的回调函数中解析收到的逐笔成交和逐笔委托数据、转换枚举值。</li>
                    <li class="- topic/li li">最后，将同一个通道的逐笔成交和逐笔委托数据写入同一张流数据表 。</li>
                </ul>
                <p class="- topic/p p">一般有两种方式将实时数据源接入 DolphinDB server 中：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">方案一：使用行情数据源插件。目前，amdQuote、INSIGHT 插件已经支持将委托和成交接收到同一张表中，并且内置实现了枚举值转换。通过 amd
                        插件/insight 插件可以直接接收到 Orderbook 引擎期望的输入数据。<ul class="- topic/ul ul"><li class="- topic/li li">amd 插件： <a class="- topic/xref xref" href="../plugins/amdquote/amdquote.html">amdQuote（LINUX）</a></li><li class="- topic/li li">insight 插件：<a class="- topic/xref xref" href="../plugins/insight/insight.html">INSIGHT</a></li><li class="- topic/li li">其余行情插件也将陆续支持此功能，最新进展见官网文档。如有需求也可以联系
                                DolphinDB 小助手进一步咨询。</li></ul></li>
                    <li class="- topic/li li">方案二：使用 DolphinDB API 编写外部程序，推荐使用 <code class="+ topic/ph pr-d/codeph ph codeph">MultithreadedTableWriter</code>
                        接口往 DolphinDB 实时写入数据，具体开发可以参考上述流程和插件源码。</li>
                </ul>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title13" id="orderbook-合成">
        <h2 class="- topic/title title topictitle2" id="ariaid-title13">3. Orderbook 合成</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">Orderbook 引擎内置了合成逻辑，同时提供了丰富的可选参数。用户通过参数可以自定义输出结果中的频率、Orderbook 深度、指标字段等。本章循序渐进介绍如何使用
                    <code class="+ topic/ph pr-d/codeph ph codeph">createOrderbookSnapshotEngine</code> 函数创建 Orderbook 引擎，并输入数据得到自定义的
                Orderbook。</p>
            <p class="- topic/p p">首先，第一小节介绍合成 1 秒频率的 Orderbook，输出引擎默认的 Orderbook 内容，包括基础的 Orderbook 信息和成交信息，帮助用户掌握
                Orderbook 引擎最基础的使用方法。</p>
            <p class="- topic/p p">其次，第二小节介绍合成包含逐笔成交明细的 Orderbook。用户将通过 <em class="+ topic/ph hi-d/i ph i">outputColMap</em> 参数自定义所需的 Orderbook
                字段，以获得比普通行情快照更丰富的衍生指标。</p>
            <p class="- topic/p p">最后，第三小节介绍合成包含用户自定义指标的 Orderbook，用户将基于引擎提供的全部指标和 <em class="+ topic/ph hi-d/i ph i">userDefinedMetrics</em>
                参数实现自定义指标，自定义指标将和 Orderbook 一起计算输出。</p>
        </div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title14" id="合成-1-秒频率-orderbook">
            <h3 class="- topic/title title topictitle3" id="ariaid-title14">3.1 合成 1 秒频率 Orderbook</h3>
            <article class="- topic/topic topic nested3" aria-labelledby="ariaid-title15" id="创建-orderbook-引擎">
                <h4 class="- topic/title title topictitle4" id="ariaid-title15">3.1.1 创建 Orderbook 引擎</h4>
                <div class="- topic/body body">
                    <p class="- topic/p p">首先创建 Orderbook 引擎，以下脚本中名为“demo”的 Orderbook 引擎的功能是每1秒计算输出深交所股票10档
                        Orderbook。</p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 定义引擎参数outputTable，即指定输出表
suffix = string(1..10)
colNames = `SecurityID`timestamp`lastAppSeqNum`tradingPhaseCode`modified`turnover`volume`tradeNum`totalTurnover`totalVolume`totalTradeNum`lastPx`highPx`lowPx`ask`bid`askVol`bidVol`preClosePx`abnormal  join ("bids" + suffix) join ("bidVolumes" + suffix) join ("bidOrderNums" + suffix) join ("asks" + suffix)  join ("askVolumes" + suffix) join ("askOrderNums" + suffix) 
colTypes = [SYMBOL,TIMESTAMP,LONG,INT,BOOL,DOUBLE,LONG,INT,DOUBLE,LONG,INT,DOUBLE,DOUBLE,DOUBLE,DOUBLE,DOUBLE,LONG,LONG,DOUBLE,BOOL] join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) join take(DOUBLE, 10) join take(LONG, 10) join take(INT, 10) 
outTable = table(1:0, colNames, colTypes)
// 定义引擎参数dummyTable，即指定输入表的表结构
colNames = `SecurityID`Date`Time`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo
colTypes = [SYMBOL, DATE, TIME, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]
dummyOrderTrans = table(1:0, colNames, colTypes)
// 定义引擎参数inputColMap，即指定输入表各字段的含义
inputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)
// 定义引擎参数prevClose，即昨日收盘价，prevClose不影响最终的输出结果中除昨日收盘价以外的其他字段
prevClose = dict(`000400.SZ`300274.SZ`300288.SZ`300122.SZ`300918.SZ, [1.1, 2.2, 3.3, 4.4, 5.5])
// 创建引擎，每1s计算输出深交所股票10档 Orderbook
engine = createOrderBookSnapshotEngine(name="demo", exchange="XSHE", orderbookDepth=10, intervalInMilli=1000, date=2022.01.10, startTime=09:30:00.000, prevClose=prevClose, dummyTable=dummyOrderTrans, inputColMap=inputColMap, outputTable=outTable, orderBySeq=false)</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">exchange</em> 指定证券类型，决定了引擎使用的交易规则。“XSHE”表示深交所股票。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">orderbookDepth</em> 指定 Orderbook 深度。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">intervalInMilli</em> 为输出的时间间隔，单位为毫秒，决定了输出的快照频率。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">date</em> 日期，输出结果中的 timestamp 时间列的日期由此参数决定。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">startTime</em> 开始输出的时间戳。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">prevClose</em>
                            昨收价，通过当日逐笔并不能计算出昨收价，所以需要以静态数据的形式传入。本例传入了模拟的昨收价，实际使用中可以从数据库表中获得。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">dummyTable</em> 为输入表表结构。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">inputColMap</em> 指定指定映射关系来识别计算所需的字段。只有 *inputColMap *指定的字段才是引擎必须的。本例的
                                <em class="+ topic/ph hi-d/i ph i">dummyTable</em> 中的 Date、ChannelNo 都是冗余的，并不会被引擎使用。</li>
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">outTable</em>
                            输出表，引擎的计算结果会写到该表中。输出表的字段名可自行指定，但字段类型和顺序必须保持与示例相同。这是因为引擎输出时并不感知字段名，而是按一个固定的表结构组织计算结果后写入输出表。在实时场景中，如果输出表还需要被订阅，必须将
                            outTable 表定义为一个共享流数据表，示例如下：</li>
                    </ul>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>share(table(1:0, colNames, colTypes), "outTable")</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li"><em class="+ topic/ph hi-d/i ph i">orderBySeq</em> 表示是否根据逐笔数据中的 seqColumn 列判断处理顺序，工作原理请参考 <a class="- topic/xref xref" href="#%E5%AF%B9%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86">1.3 小节</a>。后文中我们输入的数据仅包含几支股票，所以它们的 seqColumn
                            列的值一定不连续，此处设置
                            <em class="+ topic/ph hi-d/i ph i">orderBySeq</em>=false，要求引擎按数据输入的先后顺序直接处理，而由用户保证数据输入的顺序符合实际的业务含义。</li>
                    </ul>
                    <p class="- topic/p p">通过以下脚本可以释放掉引擎：</p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>dropStreamEngine("demo")</code></pre>
                </div>
            </article>
            <article class="- topic/topic topic nested3" aria-labelledby="ariaid-title16" id="历史批计算调用">
                <h4 class="- topic/title title topictitle4" id="ariaid-title16">3.1.2 历史批计算调用</h4>
                <div class="- topic/body body">
                    <p class="- topic/p p">DolphinDB 流计算引擎均实现了数据表（table）的接口，可以通过 <code class="+ topic/ph pr-d/codeph ph codeph">tableInsert</code> 或者
                            <code class="+ topic/ph pr-d/codeph ph codeph">append!</code> 函数，向 Orderbook 引擎批量注入处理好的输入数据实现批计算。</p>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">（1）深交所股票</strong>
                    </p>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">输入数据</strong>
                    </p>
                    <p class="- topic/p p">2.2.1 小节处理后的深交所逐笔数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/orderTrans.zip">orderTrans.csv</a></p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadText("./orderTrans.csv") order by ApplSeqNum
getStreamEngine("demo").append!(t)</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li">数据注入引擎之前，一定要按 ApplSeqNum 字段进行排序操作，否则会影响输出结果。</li>
                        <li class="- topic/li li">对于同一个引擎，建议最多只输入当天同一个通道的全部逐笔数据。以上两点的具体解释见 2.1 输入数据处理注意事项。</li>
                        <li class="- topic/li li">此处的表 t 必须和在 <a class="- topic/xref xref" href="#%E5%90%88%E6%88%90-1-%E7%A7%92%E9%A2%91%E7%8E%87-orderbook">3.1 合成 1 秒频率 orderbook</a>中
                            dummyOrderTrans 表结构一致。</li>
                        <li class="- topic/li li">在客户端中执行 <code class="+ topic/ph pr-d/codeph ph codeph">getStreamEngine("demo").append!(t)</code>
                            ，意味着在当前会话中单线程进行计算。当前会话会被阻塞，直到引擎完成对表 t 中全部逐笔数据的处理。可以通过
                                <code class="+ topic/ph pr-d/codeph ph codeph">submitjob</code>
                            提交后台作业来同时对多个不同的引擎的进行写入操作，以实现并行计算。例如，可以根据通道号和日期分组进行并行计算。</li>
                    </ul>
                    <p class="- topic/p p">输出结果表 outTable 如下：</p>
                    <br/><img class="- topic/image image" src="images/orderBookSnapshotEngine/3_1.png" alt="01"/><br/>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">（2）上交所股票</strong>
                    </p>
                    <p class="- topic/p p">创建 Orderbook 引擎时，指定 <em class="+ topic/ph hi-d/i ph i">exchange</em>="XSHG" 即可计算上交所股票的 Orderbook。将 <a class="- topic/xref xref" href="#%E5%88%9B%E5%BB%BA-orderbook-%E5%BC%95%E6%93%8E">3.1.1</a>中的代码做如下修改：</p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>engine = createOrderBookSnapshotEngine(name="demo", exchange="XSHG", orderbookDepth=10, intervalInMilli=1000, date=2022.01.10, startTime=09:30:00.000, prevClose=prevClose, dummyTable=dummyOrderTrans, inputColMap=inputColMap, outputTable=outTable, orderBySeq=false)</code></pre>
                    <p class="- topic/p p">
                        <strong class="+ topic/ph hi-d/b ph b">输入数据</strong>
                    </p>
                    <p class="- topic/p p"><a class="- topic/xref xref" href="#%E5%8E%86%E5%8F%B2%E6%89%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88">2.2.2 小节</a>处理后的上交所逐笔数据文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/SHorderTrans.zip">SHorderTrans.csv</a></p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadText("./SHorderTrans.csv") order by ApplSeqNum
getStreamEngine("demo").append!(t)</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li">注意事项同深交所</li>
                    </ul>
                </div>
            </article>
            <article class="- topic/topic topic nested3" aria-labelledby="ariaid-title17" id="实时流计算调用">
                <h4 class="- topic/title title topictitle4" id="ariaid-title17">3.1.3 实时流计算调用</h4>
                <div class="- topic/body body">
                    <p class="- topic/p p">通过 <code class="+ topic/ph pr-d/codeph ph codeph">subscribeTable</code> 函数订阅共享流数据表 orderTrans，handler 可以直接指定为
                        Orderbook 引擎。</p>
                    <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>subscribeTable(tableName="orderTrans", actionName="orderbookDemo", handler=getStreamEngine("demo"), msgAsTable=True)</code></pre>
                    <ul class="- topic/ul ul">
                        <li class="- topic/li li">需要保证表 orderTrans 中最多仅包含一个通道的逐笔数据；</li>
                        <li class="- topic/li li">若需要合成沪深股票两种 Orderbook，则需要创建不同的 Orderbook 引擎；</li>
                        <li class="- topic/li li">可以由 <a class="- topic/xref xref" href="#%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88">2.3 小节</a>提到的插件或者 API
                            方案将实时数据写入流数据表 orderTrans 。</li>
                    </ul>
                </div>
            </article>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="合成包含衍生指标如逐笔成交明细的-orderbook">
            <h3 class="- topic/title title topictitle3" id="ariaid-title18">3.2 合成包含衍生指标（如逐笔成交明细）的 Orderbook</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">首先创建 Orderbook 引擎，以下脚本中名为“demo”的 Orderbook 引擎的功能是每1秒计算输出深交所股票10档
                    Orderbook，并且扩展了逐笔成交明细字段。</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 获取 Orderbook 引擎的输出表结构
depth = 10
orderBookAsArray =true
outputColMap, outputTableSch = genOutputColumnsForOBSnapshotEngine(basic=true, time=true, depth=(depth, orderBookAsArray), tradeDetail=true, orderDetail=false, withdrawDetail=false, orderBookDetailDepth=0, prevDetail=false)
// 定义引擎参数outputTable，即指定输出表
outTable = table(1:0, outputTableSch.schema().colDefs.name, outputTableSch.schema().colDefs.typeString)
// 定义引擎参数dummyTable，即指定输入表的表结构
colNames = `SecurityID`Date`Time`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo`ReceiveTime
colTypes = [SYMBOL, DATE, TIME, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT, NANOTIMESTAMP]
dummyOrderTrans = table(1:0, colNames, colTypes)
// 定义引擎参数inputColMap，即指定输入表各字段的含义
inputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn`receiveTime, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum`ReceiveTime)
// 定义引擎参数prevClose，即昨日收盘价，prevClose不影响最终的输出结果中除昨日收盘价以外的其他字段
prevClose = dict(`000400.SZ`300274.SZ`300288.SZ`300122.SZ`300918.SZ, [1.1, 2.2, 3.3, 4.4, 5.5])
// 创建引擎，每1s计算输出深交所股票10档 Orderbook
engine = createOrderBookSnapshotEngine(name="demo", exchange="XSHE", orderbookDepth=depth, intervalInMilli=1000, date=2022.01.10, startTime=09:30:00.000,  prevClose=prevClose, dummyTable=dummyOrderTrans, inputColMap=inputColMap, outputTable=outTable, orderBySeq=false, outputColMap=outputColMap, orderBookAsArray=orderBookAsArray)</code></pre>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">与上一小节不同，在调用 <code class="+ topic/ph pr-d/codeph ph codeph">createOrderBookSnapshotEngine</code> 函数创建引擎时，本节指定了
                            <em class="+ topic/ph hi-d/i ph i">outputColMap</em> 参数，用于选择需要输出的字段。而上一小节没有指定 <em class="+ topic/ph hi-d/i ph i">outputColMap</em>
                            ，则输出了默认的字段。<em class="+ topic/ph hi-d/i ph i">outputColMap</em> 的具体使用方式和引擎的默认输出请参考
                            <code class="+ topic/ph pr-d/codeph ph codeph">createOrderBookSnapshotEngine</code> 函数的用户手册。</li>
                    <li class="- topic/li li">为了方便用户使用 <em class="+ topic/ph hi-d/i ph i">outputColMap</em> 参数选择需要输出的字段，DophinDB server
                            提供了<code class="+ topic/ph pr-d/codeph ph codeph">genOutputColumnsForOBSnapshotEngine</code>
                            函数，该函数返回要求引擎输出包含的字段以及对应的输出表结构。<code class="+ topic/ph pr-d/codeph ph codeph">genOutputColumnsForOBSnapshotEngine</code>
                        函数的参数是用于指定输出字段，本节设置 <em class="+ topic/ph hi-d/i ph i">basic</em>、<em class="+ topic/ph hi-d/i ph i">time</em>、<em class="+ topic/ph hi-d/i ph i">depth</em> 和
                            <em class="+ topic/ph hi-d/i ph i">tradeDetail</em> 为 true ，其余都设置为 false，表示只需要基础成交信息、时间、Orderbook
                        以及成交明细字段。</li>
                    <li class="- topic/li li"><code class="+ topic/ph pr-d/codeph ph codeph">genOutputColumnsForOBSnapshotEngine</code> 函数的参数 <em class="+ topic/ph hi-d/i ph i">time</em>=true
                        时会返回多个时间字段，它们同样是引擎可以输出指标。这些时间字段是可选的，主要功能是方便统计计算性能，其包含每条计算结果输出时的系统时间，以及触发计算结果输出的原始逐笔的接收时间。为此，在指定
                            <em class="+ topic/ph hi-d/i ph i">inputColMap</em> 参数时需要包含 ReceiveTime 这个key，使引擎能获取输入的每条逐笔数据的接收时间。</li>
                    <li class="- topic/li li">此外，本节还指定了 <em class="+ topic/ph hi-d/i ph i">orderBookAsArray</em>=true，表示以 array vector 的形式输出多档量价，即 10
                        档买方价格存储在同一个字段中。反之，10 档买方价格分别存储在 10 个字段中。</li>
                </ul>
                <p class="- topic/p p">接着，将历史数据注入 Orderbook 引擎。与上一小节不同，本节的输入数据多了一列
                    <code class="+ topic/ph pr-d/codeph ph codeph">ReceiveTime</code>，表示每条逐笔数据的接收时间。</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadText("./orderTrans.csv") order by ApplSeqNum
update t set ReceiveTime = now(true) // 构造接收时间列
getStreamEngine("demo").append!(t)</code></pre>
                <p class="- topic/p p">输出结果表 outTable 如下：</p>
                <br/><img class="- topic/image image" src="images/orderBookSnapshotEngine/3_2.png" alt="02"/><br/>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="合成包含用户自定义指标的-orderbook">
            <h3 class="- topic/title title topictitle3" id="ariaid-title19">3.3 合成包含用户自定义指标的 Orderbook</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">首先创建 Orderbook 引擎，以下脚本中名为“demo”的 Orderbook 引擎的功能是每 1 秒计算输出深交所股票 10 档
                    Orderbook，并且扩展了 4 个用户自定义指标，指标定义如下：</p>
                <div class="table-container"><table class="- topic/table table" data-cols="2"><caption></caption><colgroup><col/><col/></colgroup><thead class="- topic/thead thead">
                            <tr class="- topic/row">
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="合成包含用户自定义指标的-orderbook__entry__1">
                                    <strong class="+ topic/ph hi-d/b ph b">指标名称</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="合成包含用户自定义指标的-orderbook__entry__2">
                                    <strong class="+ topic/ph hi-d/b ph b">含义</strong>
                                </th>
                            </tr>
                        </thead><tbody class="- topic/tbody tbody">
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__1">AvgBuyDuration</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__2">过去 1 秒内，成交中买方的平均挂单时长</td>
                            </tr>
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__1">AvgSellDuration</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__2">过去 1 秒内，成交中卖方的平均挂单时长</td>
                            </tr>
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__1">BuyWithdrawQty</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__2">过去 1 秒内，买方撤单的总量</td>
                            </tr>
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__1">SellWithdrawQty</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="合成包含用户自定义指标的-orderbook__entry__2">过去 1 秒内，卖方撤单的总量</td>
                            </tr>
                        </tbody></table></div>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 定义 Orderbook 深度等
depth = 10
orderBookAsArray =true
outputColMap = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(depth, orderBookAsArray), tradeDetail=true, orderDetail=false, withdrawDetail=true, orderBookDetailDepth=0, prevDetail=false)[0]
// 定义引擎参数 dummyTable，即指定输入表的表结构
colNames = `SecurityID`Date`Time`SourceType`Type`Price`Qty`BSFlag`BuyNo`SellNo`ApplSeqNum`ChannelNo
colTypes = [SYMBOL, DATE, TIME, INT, INT, LONG, LONG, INT, LONG, LONG, LONG, INT]
dummyOrderTrans = table(1:0, colNames, colTypes)
// 定义引擎参数 inputColMap，即指定输入表各字段的含义
inputColMap = dict(`codeColumn`timeColumn`typeColumn`priceColumn`qtyColumn`buyOrderColumn`sellOrderColumn`sideColumn`msgTypeColumn`seqColumn, `SecurityID`Time`Type`Price`Qty`BuyNo`SellNo`BSFlag`SourceType`ApplSeqNum)
// 定义引擎参数 prevClose，即昨日收盘价，prevClose不影响最终的输出结果中除昨日收盘价以外的其他字段
prevClose = dict(STRING, DOUBLE)
//// 定义用户自定义因子
def userDefinedFunc(t){
        AvgBuyDuration = rowAvg(t.TradeMDTimeList-t.TradeOrderBuyNoTimeList).int()
        AvgSellDuration = rowAvg(t.TradeMDTimeList-t.TradeOrderSellNoTimeList).int()        
        BuyWithdrawQty = rowSum(t.WithdrawBuyQtyList)
        SellWithdrawQty = rowSum(t.WithdrawSellQtyList)
        return (AvgBuyDuration, AvgSellDuration, BuyWithdrawQty, SellWithdrawQty)
}
// 定义 Orderbook 引擎的输出表
outputTableSch = genOutputColumnsForOBSnapshotEngine(basic=true, time=false, depth=(depth, orderBookAsArray), tradeDetail=false, orderDetail=false, withdrawDetail=false, orderBookDetailDepth=0, prevDetail=false)[1]
colNames = outputTableSch.schema().colDefs.name join (`AvgBuyDuration`AvgSellDuration`BuyWithdrawQty`SellWithdrawQty)
colTypes = outputTableSch.schema().colDefs.typeString join (`INT`INT`INT`INT) 
outTable = table(1:0, colNames, colTypes)
// 创建引擎，每1s计算输出深交所股票10档 Orderbook
try{dropStreamEngine(`demo)} catch(ex){}
engine = createOrderBookSnapshotEngine(name="demo", exchange="XSHE", orderbookDepth=depth, intervalInMilli=1000, date=2022.01.10, startTime=09:30:00.000,  prevClose=prevClose, dummyTable=dummyOrderTrans, inputColMap=inputColMap, outputTable=outTable, outputColMap=outputColMap, orderBookAsArray=orderBookAsArray, userDefinedMetrics=userDefinedFunc)</code></pre>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">创建引擎时指定了 <em class="+ topic/ph hi-d/i ph i">userDefinedMetrics</em>
                        参数，它是一个一元函数，用于自定义指标的计算逻辑。该函数的入参必须是一张表，这张表的每一行是一个标的的快照，快照的每一列是
                            <em class="+ topic/ph hi-d/i ph i">outputColMap</em> 参数指定的引擎内置指标。用户可以操作这些引擎内置的指标实现自定义指标。本节中我们用引擎提供的两笔
                        Orderbook 快照之间的逐笔成交明细和撤单明细，计算了这个窗口内的挂单时长和撤单量等指标。</li>
                    <li class="- topic/li li">注意，当指定 <em class="+ topic/ph hi-d/i ph i">userDefinedMetrics</em> 参数后，引擎的输出表结构不再和 <em class="+ topic/ph hi-d/i ph i">outputColMap</em>
                        参数的内容一一对应，而是仅包含两部分内容：一部分是
                            <code class="+ topic/ph pr-d/codeph ph codeph">genOutputColumnsForOBSnapshotEngine</code> 函数对应的 <em class="+ topic/ph hi-d/i ph i">basic</em>
                        和 <em class="+ topic/ph hi-d/i ph i">depth</em> 指标；另一部分是用户自定义指标。</li>
                </ul>
                <p class="- topic/p p">接着，用历史数据注入 Orderbook 引擎。</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadText("./orderTrans.csv") order by ApplSeqNum
getStreamEngine("demo").append!(t)</code></pre>
                <p class="- topic/p p">输出结果表 outTable 如下，红框部分为用户自定义指标：</p>
                <br/><img class="- topic/image image" src="images/orderBookSnapshotEngine/3_3.png" alt="03"/><br/>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="性能测试">
        <h2 class="- topic/title title topictitle2" id="ariaid-title20">4. 性能测试</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">基于 <a class="- topic/xref xref" href="#%E5%90%88%E6%88%90%E5%8C%85%E5%90%AB%E8%A1%8D%E7%94%9F%E6%8C%87%E6%A0%87%E5%A6%82%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86%E7%9A%84-orderbook">3.2</a>创建的包含衍生指标（如逐笔成交明细）的
                Orderbook，我们分别测试了引擎在历史批计算和实时流计算中的计算性能。</p>
        </div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="历史批计算性能">
            <h3 class="- topic/title title topictitle3" id="ariaid-title21">4.1 历史批计算性能</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">我们对 Orderbook 引擎直接注入了一天一整个通道的六百多支深交所股票，使用 timer 语句测试计算耗时。测试显示 1 秒频率的 Orderbook 仅需
                    1 分 57 秒。由于 10 毫秒频率的 Orderbook 的数据量大约是 1 秒频率的 3 倍多，输出耗时的增加导致了 10 毫秒频率的 Orderbook
                    的总耗时会更高。</p>
                <p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试结果</strong>：</p>
                <div class="table-container"><table class="- topic/table table" data-cols="7"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead">
                            <tr class="- topic/row">
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__1">
                                    <strong class="+ topic/ph hi-d/b ph b">证券类型</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__2">
                                    <strong class="+ topic/ph hi-d/b ph b">标的数量</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__3">
                                    <strong class="+ topic/ph hi-d/b ph b">Orderbook频率</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__4">
                                    <strong class="+ topic/ph hi-d/b ph b">Orderbook深度</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__5">
                                    <strong class="+ topic/ph hi-d/b ph b">并行度</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__6">
                                    <strong class="+ topic/ph hi-d/b ph b">Orderbook结果表总行数</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="历史批计算性能__entry__7">
                                    <strong class="+ topic/ph hi-d/b ph b">完成输出一天 Orderbook 的总耗时</strong>
                                </th>
                            </tr>
                        </thead><tbody class="- topic/tbody tbody">
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__1">深交所股票</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__2">659 支（一个通道）</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__3">1 秒</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__4">10</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__5">1</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__6">5,044,166</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__7">1 分 57 秒</td>
                            </tr>
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__1">深交所股票</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__2">659 支（一个通道）</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__3">10 毫秒</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__4">10</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__5">1</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__6">17,363,953</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="历史批计算性能__entry__7">5 分 5 秒</td>
                            </tr>
                        </tbody></table></div>
                <p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试环境</strong>：</p>
                <p class="- topic/p p">DolphinDB：2.00.12 2024.04.02</p>
                <p class="- topic/p p">物理服务器：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">内核： Linux 3.10.0-1160.el7.x86_64 x86_64</li>
                    <li class="- topic/li li">CPU：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz</li>
                    <li class="- topic/li li">Mem：503 GB</li>
                </ul>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title22" id="实时流计算性能">
            <h3 class="- topic/title title topictitle3" id="ariaid-title22">4.2 实时流计算性能</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">我们测试了在实盘中，通过 INSIGHT 行情数据源插件实时接收深交所全市场股票的逐步数据，通过发布订阅实时写入 Orderbook
                    引擎的计算耗时。由于深交所股票分布在 4 个通道中，因此我们创建了4个不同的 Orderbook 引擎分别在4个消费线程上运行。测试显示，1 秒频率
                    Orderbook 快照的单条响应耗时约 0.67 毫秒，即收到触发输出的逐笔数据后仅 0.67 毫秒即可推出最新的快照。</p>
                <p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试结果</strong>：</p>
                <div class="table-container"><table class="- topic/table table" data-cols="6"><caption></caption><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead class="- topic/thead thead">
                            <tr class="- topic/row">
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__1">
                                    <strong class="+ topic/ph hi-d/b ph b">证券类型</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__2">
                                    <strong class="+ topic/ph hi-d/b ph b">标的数量</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__3">
                                    <strong class="+ topic/ph hi-d/b ph b">Orderbook频率</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__4">
                                    <strong class="+ topic/ph hi-d/b ph b">Orderbook深度</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__5">
                                    <strong class="+ topic/ph hi-d/b ph b">并行度</strong>
                                </th>
                                <th class="- topic/entry entry colsep-0 rowsep-0" id="实时流计算性能__entry__6">
                                    <strong class="+ topic/ph hi-d/b ph b">响应耗时</strong>
                                </th>
                            </tr>
                        </thead><tbody class="- topic/tbody tbody">
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__1">深交所股票</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__2">2755 支</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__3">1 秒</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__4">10</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__5">4</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__6">0.67 毫秒</td>
                            </tr>
                            <tr class="- topic/row">
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__1">深交所股票</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__2">2755 支</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__3">10 毫秒</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__4">10</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__5">4</td>
                                <td class="- topic/entry entry colsep-0 rowsep-0" headers="实时流计算性能__entry__6">0.84 毫秒</td>
                            </tr>
                        </tbody></table></div>
                <p class="- topic/p p">注：响应耗时不仅包含引擎内部的计算耗时，也包含逐笔数据发布并写入计算引擎的耗时。在实盘中，通过 UpdateTime2 - UpdateTime1
                    可以计算出每一条快照的响应耗时，其中 UpdateTime2 是由引擎记录的完成计算的时刻，UpdateTime1 是系统接收到逐笔数据的时刻（
                    ReceiveTime 字段），每条快照的 UpdateTime1 取触发该条快照输出的那一条逐笔数据的接收时刻。</p>
                <p class="- topic/p p"><strong class="+ topic/ph hi-d/b ph b">测试环境</strong>：</p>
                <p class="- topic/p p">DolphinDB：2.00.12 2024.04.02</p>
                <p class="- topic/p p">物理服务器：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">系统：CentOS Linux release 7.9.2009 (Core)</li>
                    <li class="- topic/li li">内核： Linux 3.10.0-1160.el7.x86_64 x86_64</li>
                    <li class="- topic/li li">CPU：Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz</li>
                    <li class="- topic/li li">Mem：503 GB</li>
                </ul>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title23" id="orderbook-正确性校验">
        <h2 class="- topic/title title topictitle2" id="ariaid-title23">5. Orderbook 正确性校验</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">校验可以分为以下两步，一是校验输入数据无异常，二是校验合成结果中各个指标计算正确。本章仅提供基础成交信息和 Orderbook 信息的校验，不包含衍生指标的校验。</p>
        </div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="校验输入数据无异常">
            <h3 class="- topic/title title topictitle3" id="ariaid-title24">5.1 校验输入数据无异常</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">检查输出结果表中的 abnormal 字段全为
                    false，表示快照合成过程中没有出现接收到成交或者撤单时找不到逐笔委托的情况，即表示输入数据没有缺失或者乱序。测试代码如下，outTable 表为
                    Orderbook 引擎的输出结果表。</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>outTable = loadText("./engineOutput.csv")
@testing: case = "abnormal"
assert (exec count(*) from outTable where bool(abnormal)=true)==0</code></pre>
                <p class="- topic/p p">以上代码执行后，若无任何返回则代表测试通过，若返回 abnormal 则表示测试失败。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title25" id="校验输出结果中的各个指标字段符合交易所规则">
            <h3 class="- topic/title title topictitle3" id="ariaid-title25">5.2 校验输出结果中的各个指标字段符合交易所规则</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">在通过 <a class="- topic/xref xref" href="#%E6%A0%A1%E9%AA%8C%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%A0%E5%BC%82%E5%B8%B8">5.1 小节</a>的校验后，可以以交易所原始的 3s
                    快照作为基准，对合成结果的各个指标字段进行正确性校验。</p>
                <p class="- topic/p p">注意，不能按时间戳直接关联来比较两者，因为交易所的快照和逐笔数据是两个系统产生并发出的，这导致交易所快照的时间戳与逐笔数据的时间戳并不一致。Orderbook
                    快照其实是某一个时刻的 Orderbook 的截面，假设我们能得到足够密集的截面，那么交易所原始 3s
                    快照将是其子集。因此，推荐以合成出的高频快照是否包含全部的交易所快照来判断合成结果是否正确。</p>
                <p class="- topic/p p">以深交所股票为例，通过 Orderbook 引擎生成 10ms 频率的快照，以交易所 3 秒快照被 10ms 合成快照覆盖的多少来评价 Orderbook
                    引擎的正确性。一条 3s 快照能够在 10 ms 快照结果中找到一条相同买卖十档盘口的记录且所有被找出的 10 ms 快照数据的时间戳有序递增，则认为该条 3s
                    快照被覆盖。</p>
                <p class="- topic/p p">
                    <strong class="+ topic/ph hi-d/b ph b">输入数据</strong>
                </p>
                <p class="- topic/p p">此处仅以深交所数据为示例，引擎合成结果文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/engineOutput10s.zip">engineOutput10s.csv</a></p>
                <p class="- topic/p p">交易所 3s 快照文件：<a class="- topic/xref xref" href="script/orderBookSnapshotEngine/tick.zip">tick.csv</a></p>
                <p class="- topic/p p">
                    <strong class="+ topic/ph hi-d/b ph b">比对脚本</strong>
                </p>
                <p class="- topic/p p">以下两段脚本共同完成对一支股票一天的合成结果进行校验。首先关联两份不同的 Orderbook 数据：</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 登录
login("admin", "123456")
// 指定比对股票和日期
id ="300274.SZ"
compareDate=2022.06.01
// 获取原始的快照数据
orgTickPath = "./tick.csv"
originTick = select * from loadText(orgTickPath) where SecurityID=id and MDDate=compareDate and ((MDTime between 09:30:00.000:11:30:00.000) or (MDTime between 13:00:00.000:14:56:59.000)) order by MDTime
// 获取生成的快照数据
genTickPath = "./engineOutput10s.csv"
generateTick = select * from loadText(genTickPath)  where SecurityID=id and date(timestamp)=compareDate order by timestamp
// 设置真实快照数据比对字段
orgColNames = `SecurityID`MDTime`LastPx`HighPx`LowPx`TotalBidQty`TotalOfferQty join ("BuyPrice" + string(1..10))  join ("BuyOrderQty" + string(1..10)) join ("BuyNumOrders" + string(1..10)) join ("SellPrice" + string(1..10)) join ("SellOrderQty" + string(1..10)) join ("SellNumOrders" + string(1..10)) 
// 设置生成快照数据比对字段
genColNames = `SecurityID`timestamp`lastPx`highPx`lowPx`bidVol`askVol join ("bids" + string(1..10))  join ("bidVolumes" + string(1..10)) join ("bidOrderNums" + string(1..10)) join ("asks" + string(1..10)) join ("askVolumes" + string(1..10)) join ("askOrderNums" + string(1..10)) 
// 计算快照表的content 形式数据展示表
def calContent(contentColNames, tickTable, format="0.00"){
	contentStr=concat("format(" +contentColNames[2:] +", \""+format+"\")", "+\",\"+")
	contentSql=parseExpr(contentStr)
           	return sql(select=(sqlCol(contentColNames[0]),sqlCol(contentColNames[1]),sqlColAlias(contentSql, "Content")), from=tickTable).eval()
}
// 生成原始快照表比对content表
originContent=calContent(orgColNames, originTick, "0.00")
// 生成合成快照表比对content表
generateContent=calContent(genColNames, generateTick, "0.00")
// 两个快照表进行Content 比对，以原始快照表为左表
jointable =  select * from lsj(originContent as a ,generateContent as b, `Content, `Content)</code></pre>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">originTick 表为交易所 3s 快照，generateTick 为 Orderbook 引擎输出的 10ms 快照。</li>
                    <li class="- topic/li li">orgColNames 和 genColNames 为向量，前两个元素为股票 id
                        和日期列名，其余为需要进行数值比对的指标列名。注意：不要指定和当前周期有关的指标，比如当前周期内成交量，因为两个快照的频率不同，所以这类指标是一定无法重合的。</li>
                    <li class="- topic/li li">calContent 函数的功能是将快照中的多个指标字段按字符串拼接为一个字符串类型的字段 content 。format
                        参数指定了数据的精度，股票需要设置为”0.00”，表示两位小数精度，可转债需要设置为“0.000”，表示三位小数精度。</li>
                    <li class="- topic/li li">最后通过 lsj 将两个快照表的 content 进行左半连接，3s 快照表为左表，关联的结果表 jointable 行数和 3s
                        快照表一致。</li>
                </ul>
                <p class="- topic/p p">以下脚本对关联结果表 jointable 进行统计和校验：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">第一个测试 case，测试 3 秒快照被 10ms 合成快照覆盖率大于等于 99，若不通过则返回 Not Covered</li>
                    <li class="- topic/li li">第二个测试 case，测试 3 秒快照对应的全部 10 ms 合成快照按时间戳有序，若不通过则返回 Not In Order。</li>
                </ul>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>// 3 秒快照被 10ms 合成快照覆盖率大于等于100 ，断言为测试通过
@testing: case = "Not Covered"
assert (exec count(b_SecurityID)\count(*)*100 as coverage from jointable ) &gt;= 99
// 3 秒快照的全部 10 ms 合成快照按时间戳有序，断言为测试通过
flag = true 
if(at(deltas(jointable.timestamp)[1:]&lt;=0).size()==0) {
	break
}else { 
	leftTime = 09:15:00.000
	for (row in originContent){
		genCon = exec Content from generateContent where time(timestamp)&gt;= leftTime 
		genTime = exec time(timestamp) from generateContent where time(timestamp)&gt;= leftTime 
		findGenTime = genTime[genCon.find(row.Content)]
		if (findGenTime==NULL){
			flag=false
			break
		} else { 
			leftTime=findGenTime
		}
	}
}
@testing: case = "Not In Order"
assert flag</code></pre>
                <p class="- topic/p p">如果上述校验不通过，可以减少比对的字段数量来定位具体有问题字段。校验不通过的原因主要有：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">输入数据的预处理不正确。正确处理方式请参考第 2 章检查。</li>
                    <li class="- topic/li li">引擎输出结果与交易所 3s 快照的精度差异，比如引擎输出的总成交金额为小数，有一些数据源的总成交金额为整数。</li>
                    <li class="- topic/li li">空值和0的差异，上述样例脚本如果遇到空值和0比较时，则认为校验不通过。可以通过以下脚本，将快照数据中的空值全部置0，再进行校验：</li>
                </ul>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>originTick = nullFill(originTick, 0)
generateTick = nullFill(generateTick, 0)</code></pre>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title26" id="其他辅助功能">
        <h2 class="- topic/title title topictitle2" id="ariaid-title26">6. 其他辅助功能</h2>
        <div class="- topic/body body"></div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title27" id="按时间偏移后分批输出">
            <h3 class="- topic/title title topictitle3" id="ariaid-title27">6.1 按时间偏移后分批输出</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">引擎的可选参数 <em class="+ topic/ph hi-d/i ph i">outputIntervalOffsetMap</em> 为字典，用于指定输出表中股票被触发计算的时间偏移量。字典的 key
                    为字符串类型，表示标的 id，字典的 value 为整型，表示偏移量（单位：毫秒）。依然以合成 1s 频率 Orderbook 为例，假设有三支标的
                    id1、id2、id3，通过 <em class="+ topic/ph hi-d/i ph i">outputIntervalOffsetMap</em> 参数（dict(["id1","id2","id3"], [0,
                    50, 50])）可以实现下图的效果。</p>
                <br/><img class="- topic/image image" src="images/orderBookSnapshotEngine/6_1.png" alt="04"/><br/>
                <p class="- topic/p p">上图中两组标的在不同时间点产生快照，id1 这支标的的输出数据时间戳为 hh:MM:00.000，id2、id3 这两支标的的输出时间戳为
                    hh:MM:ss.050 ，即整秒过50ms。</p>
                <p class="- topic/p p">合理使用本参数能够带来如下优化：一方面减少输出的数据量可以减少每批快照输出的耗时，更重要的是减少同一个时间点输出的标的数量，可以减少下游消费的压力，保证下游能更充费利用计算资源。否则总是在同一个时刻发送大量数据，对于下游消费来说可能会导致一段时间特别忙碌，一段时间特别空闲，不能合理利用资源。</p>
                <p class="- topic/p p">示例代码，3.1 的代码做以下补充修改：</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>outputIntervalOffsetMap =dict(`300288.SZ`300122.SZ`300918.SZ, [50, 50, 50])
engine = createOrderBookSnapshotEngine(name="demo", exchange="XSHE", orderbookDepth=10, intervalInMilli=1000, date=2022.06.01, startTime=09:15:00.000, prevClose=prevClose, dummyTable=dummyOrderTrans, inputColMap=inputColMap, outputTable=outTable, outputIntervalOffsetMap=outputIntervalOffsetMap)</code></pre>
                <p class="- topic/p p">300288.SZ、300122.SZ、300918.SZ 三支股票将在整秒过 50ms 输出，其余股票因为未指定偏移量则仍然在整秒输出。</p>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title28" id="常见问题解答faq">
        <h2 class="- topic/title title topictitle2" id="ariaid-title28">7. 常见问题解答（FAQ）</h2>
        <div class="- topic/body body"></div>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title29" id="输入表的表结构一定要和示例一致吗">
            <h3 class="- topic/title title topictitle3" id="ariaid-title29">7.1 输入表的表结构一定要和示例一致吗</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">不是，通过参数 <em class="+ topic/ph hi-d/i ph i">inputColMap</em> 指定映射关系来识别计算所需的字段即可。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title30" id="输出表的表结构一定要和示例一致吗">
            <h3 class="- topic/title title topictitle3" id="ariaid-title30">7.2 输出表的表结构一定要和示例一致吗</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">不是，通过参数 <em class="+ topic/ph hi-d/i ph i">outputColMap</em> 指定指定需要输出的字段。注意 outputTable 的表结构需要与之对齐。</p>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title31" id="输出结果中的-abnormal-字段为-true-是什么原因呢">
            <h3 class="- topic/title title topictitle3" id="ariaid-title31">7.3 输出结果中的 abnormal 字段为 true 是什么原因呢</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">引擎收到成交数据、撤单数据时会在其内部维护的 Orderbook
                    中找对应的委托，如果找不到，则认为发生异常。异常时会同时有两种提示，一是会在日志中报错，二是会将之后的输出结果中该股票的 abnormal 字段全部设置为
                    true。日志报错如下：</p>
                <br/><img class="- topic/image image" src="images/orderBookSnapshotEngine/7_1.png" alt="image"/><br/>
                <p class="- topic/p p">如果 abnormal 为 true ，建议排查是否发生了以下任意一种情况：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">排查是否发生了逐笔数据乱序或者丢失。这可能造成成交或撤单数据到达引擎之前，对应的委托数据并没有到达；</li>
                    <li class="- topic/li li">排查 <em class="+ topic/ph hi-d/i ph i">inputColMap</em>
                        对应的列是否有异常，比如买卖单号为空等异常情况，这可能造成成交数据中的委托单号和原始委托号并不能对应上。</li>
                </ul>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title32" id="输入数据是不是必须包含-bsflag-字段如果-bsflag-为-n未知应该怎么处理">
            <h3 class="- topic/title title topictitle3" id="ariaid-title32">7.4 输入数据是不是必须包含 BSFlag 字段？如果 BSFlag 为 N（未知），应该怎么处理</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">委托、撤单的 BSFlag 是必须的，Orderbook 结果的正确性依赖委托和撤单的 BSFlag 字段。成交的 BSFlag 不是必须的，但是也建议包含成交的
                    BSFlag。</p>
                <p class="- topic/p p">若您的原始逐笔数据里撤单和成交都没有 BSFlag 字段，可以通过以下逻辑补充出引擎所需的 BSFlag：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">撤单：卖单撤单则 BSFlag 为2，买单撤单则 BSFlag 为1；</li>
                    <li class="- topic/li li">成交：卖方主动成交则 BSFlag 为2，买方主动成交则 BSFlag 为1。</li>
                </ul>
                <p class="- topic/p p">以深交所为例，假设您的撤单记录中有 BuyNo 和 SellNo，其中一方为委托单号，另一方为 0，则在 <a class="- topic/xref xref" href="#%E5%8E%86%E5%8F%B2%E6%89%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88">2.2 小节</a>预处理输入数据方法的基础上，可以增加如下对 BSFlag
                    的判断。对成交记录同样适用，对于 BSFlag 为 N （未知）也适用。</p>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>iif(SellNo&gt;BuyNo, 2, 1) as BSFlag</code></pre>
            </div>
        </article>
        <article class="- topic/topic topic nested2" aria-labelledby="ariaid-title33" id="输入数据后引擎一直没有输出或者输出的结果很少是什么原因造成的">
            <h3 class="- topic/title title topictitle3" id="ariaid-title33">7.5 输入数据后，引擎一直没有输出或者输出的结果很少，是什么原因造成的</h3>
            <div class="- topic/body body">
                <p class="- topic/p p">有两种情况可能造成上述现象：</p>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">情况1：若设置了 <em class="+ topic/ph hi-d/i ph i">orderBySeq</em>=true（注意，对于上交所股票该参数默认为 true，其余默认为 false），可能因为输入数据的
                        seqColumn 不连续造成以上现象。此时，日志里有异常提示。日志示例如下，省略号（...）为具体异常内容，timestamp
                        指的是合成出的那一条快照的时间戳。</li>
                </ul>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>expected seq num: ...,  unordered buffer size: ..., the last seq num get: ...</code></pre>
                <ul class="- topic/ul ul">
                    <li class="- topic/li li">情况2：若设置了 <em class="+ topic/ph hi-d/i ph i">skipCrossedMarket</em>=true（注意，2.00.11.2及以上版本该参数默认为 true），
                        当买一卖一价倒挂时（bidPrice1 &gt;= askPrice1），该条 Orderbook 将不会输出。为了方便排查这种情况，在 2.00.12
                        及以上版本，日志里增加了对应的异常提示。日志示例如下，省略号（...）为具体异常内容：</li>
                </ul>
                <pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>orderBook engine abnormal snapshot.symbol: ... ,ask price ... ,bids price: ... ,timestamp:...);</code></pre>
            </div>
        </article>
    </article>
    <article class="- topic/topic topic nested1" aria-labelledby="ariaid-title34" id="总结">
        <h2 class="- topic/title title topictitle2" id="ariaid-title34">8. 总结</h2>
        <div class="- topic/body body">
            <p class="- topic/p p">本文首先介绍了 DolphinDB Orderbook
                引擎的工作原理，包括其支持的各类证券和交易规则。接着，文章深入解释了引擎的核心功能，并通过历史与实时数据的应用实例，突显其在不同情境下的适用性。文末提供了
                Orderbook 数据正确性的验证方法和针对常见问题的分析，助用户快速理解 Orderbook 引擎的运作机制，轻松掌握 Orderbook 引擎的使用方法。</p>
        </div>
    </article>
</article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#orderbook-%E5%BC%95%E6%93%8Eorderbook-snapshot-engine%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" data-tocid="orderbook-引擎orderbook-snapshot-engine工作原理">1. Orderbook 引擎（Orderbook Snapshot Engine）工作原理</a><ul><li class="topic-item"><a href="#orderbook-%E7%9A%84%E5%90%88%E6%88%90%E9%80%BB%E8%BE%91" data-tocid="orderbook-的合成逻辑">1.1 Orderbook 的合成逻辑</a></li><li class="topic-item"><a href="#%E5%AF%B9%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E7%9A%84%E5%A4%84%E7%90%86" data-tocid="对时间窗口的处理">1.2 对时间窗口的处理</a></li><li class="topic-item"><a href="#%E5%AF%B9%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86" data-tocid="对乱序数据的处理">1.3 对乱序数据的处理</a></li><li class="topic-item"><a href="#%E8%AF%81%E5%88%B8%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A7%84%E5%88%99%E7%9A%84%E6%94%AF%E6%8C%81%E6%80%A7" data-tocid="证券类型和规则的支持性">1.4 证券类型和规则的支持性</a></li></ul></li><li class="topic-item"><a href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87" data-tocid="输入数据准备">2. 输入数据准备</a><ul><li class="topic-item"><a href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" data-tocid="数据处理注意事项">2.1 数据处理注意事项</a></li><li class="topic-item"><a href="#%E5%8E%86%E5%8F%B2%E6%89%B9%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88" data-tocid="历史批计算的输入数据处理方案">2.2 历史批计算的输入数据处理方案</a><ul><li class="topic-item"><a href="#%E6%B7%B1%E4%BA%A4%E6%89%80%E8%82%A1%E7%A5%A8" data-tocid="深交所股票">2.2.1 深交所股票</a></li><li class="topic-item"><a href="#%E4%B8%8A%E4%BA%A4%E6%89%80%E8%82%A1%E7%A5%A8" data-tocid="上交所股票">2.2.2 上交所股票</a></li></ul></li><li class="topic-item"><a href="#%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97%E7%9A%84%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88" data-tocid="实时流计算的输入数据处理方案">2.3 实时流计算的输入数据处理方案</a></li></ul></li><li class="topic-item"><a href="#orderbook-%E5%90%88%E6%88%90" data-tocid="orderbook-合成">3. Orderbook 合成</a><ul><li class="topic-item"><a href="#%E5%90%88%E6%88%90-1-%E7%A7%92%E9%A2%91%E7%8E%87-orderbook" data-tocid="合成-1-秒频率-orderbook">3.1 合成 1 秒频率 Orderbook</a><ul><li class="topic-item"><a href="#%E5%88%9B%E5%BB%BA-orderbook-%E5%BC%95%E6%93%8E" data-tocid="创建-orderbook-引擎">3.1.1 创建 Orderbook 引擎</a></li><li class="topic-item"><a href="#%E5%8E%86%E5%8F%B2%E6%89%B9%E8%AE%A1%E7%AE%97%E8%B0%83%E7%94%A8" data-tocid="历史批计算调用">3.1.2 历史批计算调用</a></li><li class="topic-item"><a href="#%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97%E8%B0%83%E7%94%A8" data-tocid="实时流计算调用">3.1.3 实时流计算调用</a></li></ul></li><li class="topic-item"><a href="#%E5%90%88%E6%88%90%E5%8C%85%E5%90%AB%E8%A1%8D%E7%94%9F%E6%8C%87%E6%A0%87%E5%A6%82%E9%80%90%E7%AC%94%E6%88%90%E4%BA%A4%E6%98%8E%E7%BB%86%E7%9A%84-orderbook" data-tocid="合成包含衍生指标如逐笔成交明细的-orderbook">3.2 合成包含衍生指标（如逐笔成交明细）的 Orderbook</a></li><li class="topic-item"><a href="#%E5%90%88%E6%88%90%E5%8C%85%E5%90%AB%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E6%A0%87%E7%9A%84-orderbook" data-tocid="合成包含用户自定义指标的-orderbook">3.3 合成包含用户自定义指标的 Orderbook</a></li></ul></li><li class="topic-item"><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" data-tocid="性能测试">4. 性能测试</a><ul><li class="topic-item"><a href="#%E5%8E%86%E5%8F%B2%E6%89%B9%E8%AE%A1%E7%AE%97%E6%80%A7%E8%83%BD" data-tocid="历史批计算性能">4.1 历史批计算性能</a></li><li class="topic-item"><a href="#%E5%AE%9E%E6%97%B6%E6%B5%81%E8%AE%A1%E7%AE%97%E6%80%A7%E8%83%BD" data-tocid="实时流计算性能">4.2 实时流计算性能</a></li></ul></li><li class="topic-item"><a href="#orderbook-%E6%AD%A3%E7%A1%AE%E6%80%A7%E6%A0%A1%E9%AA%8C" data-tocid="orderbook-正确性校验">5. Orderbook 正确性校验</a><ul><li class="topic-item"><a href="#%E6%A0%A1%E9%AA%8C%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%A0%E5%BC%82%E5%B8%B8" data-tocid="校验输入数据无异常">5.1 校验输入数据无异常</a></li><li class="topic-item"><a href="#%E6%A0%A1%E9%AA%8C%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84%E5%90%84%E4%B8%AA%E6%8C%87%E6%A0%87%E5%AD%97%E6%AE%B5%E7%AC%A6%E5%90%88%E4%BA%A4%E6%98%93%E6%89%80%E8%A7%84%E5%88%99" data-tocid="校验输出结果中的各个指标字段符合交易所规则">5.2 校验输出结果中的各个指标字段符合交易所规则</a></li></ul></li><li class="topic-item"><a href="#%E5%85%B6%E4%BB%96%E8%BE%85%E5%8A%A9%E5%8A%9F%E8%83%BD" data-tocid="其他辅助功能">6. 其他辅助功能</a><ul><li class="topic-item"><a href="#%E6%8C%89%E6%97%B6%E9%97%B4%E5%81%8F%E7%A7%BB%E5%90%8E%E5%88%86%E6%89%B9%E8%BE%93%E5%87%BA" data-tocid="按时间偏移后分批输出">6.1 按时间偏移后分批输出</a></li></ul></li><li class="topic-item"><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94faq" data-tocid="常见问题解答faq">7. 常见问题解答（FAQ）</a><ul><li class="topic-item"><a href="#%E8%BE%93%E5%85%A5%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%80%E5%AE%9A%E8%A6%81%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%B8%80%E8%87%B4%E5%90%97" data-tocid="输入表的表结构一定要和示例一致吗">7.1 输入表的表结构一定要和示例一致吗</a></li><li class="topic-item"><a href="#%E8%BE%93%E5%87%BA%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%BB%93%E6%9E%84%E4%B8%80%E5%AE%9A%E8%A6%81%E5%92%8C%E7%A4%BA%E4%BE%8B%E4%B8%80%E8%87%B4%E5%90%97" data-tocid="输出表的表结构一定要和示例一致吗">7.2 输出表的表结构一定要和示例一致吗</a></li><li class="topic-item"><a href="#%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%AD%E7%9A%84-abnormal-%E5%AD%97%E6%AE%B5%E4%B8%BA-true-%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%91%A2" data-tocid="输出结果中的-abnormal-字段为-true-是什么原因呢">7.3 输出结果中的 abnormal 字段为 true 是什么原因呢</a></li><li class="topic-item"><a href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E6%98%AF%E4%B8%8D%E6%98%AF%E5%BF%85%E9%A1%BB%E5%8C%85%E5%90%AB-bsflag-%E5%AD%97%E6%AE%B5%E5%A6%82%E6%9E%9C-bsflag-%E4%B8%BA-n%E6%9C%AA%E7%9F%A5%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86" data-tocid="输入数据是不是必须包含-bsflag-字段如果-bsflag-为-n未知应该怎么处理">7.4 输入数据是不是必须包含 BSFlag 字段？如果 BSFlag 为 N（未知），应该怎么处理</a></li><li class="topic-item"><a href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%90%8E%E5%BC%95%E6%93%8E%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E8%BE%93%E5%87%BA%E6%88%96%E8%80%85%E8%BE%93%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E5%BE%88%E5%B0%91%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E9%80%A0%E6%88%90%E7%9A%84" data-tocid="输入数据后引擎一直没有输出或者输出的结果很少是什么原因造成的">7.5 输入数据后，引擎一直没有输出或者输出的结果很少，是什么原因造成的</a></li></ul></li><li class="topic-item"><a href="#%E6%80%BB%E7%BB%93" data-tocid="总结">8. 总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>