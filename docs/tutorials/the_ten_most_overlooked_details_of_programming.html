<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh" data-whc_version="26.0">
    <head><link rel="shortcut icon" href="../favicon.ico"/><link rel="icon" href="../favicon.ico"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="description" content="在 DolphinDB 中，无论是数据导入、数据分析还是流计算，编程都是关键的基础。而在编程中，想要更高效更优雅地写脚本，并避免一些常见问题，则需要注意一些细节。本篇教程列举10个实用的细节，有助于 DolphinDB 初学者避免分区冲突、类型不一致、计算错误、效率低下、内存膨胀、堆栈溢出等问题，提高使用 DolphinDB 编程脚本的水平。 mr 函数，即 Map-Reduce，是在 ..."/><meta name="DC.rights.owner" content="(C) 版权 2025"/><meta name="copyright" content="(C) 版权 2025"/><meta name="generator" content="DITA-OT"/><meta name="DC.type" content="topic"/><meta name="DC.coverage" content=""/><meta name="DC.relation" content="../tutorials/about_tutorials.html"/><meta name="prodname" content="DolphinDB"/><meta name="brand" content="DolphinDB"/><meta name="DC.creator" content="DolphinDB"/><meta name="DC.publisher" content="DDB N/A DDB 200"/><meta name="DC.format" content="HTML5"/><meta name="DC.identifier" content="编程最容易忽略的十个细节"/><title>编程最容易忽略的十个细节</title><!--  Generated with Oxygen version 26.0, build number 2024012323.  --><meta name="wh-path2root" content="../"/><meta name="wh-toc-id" content="&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;&lt;?workdir /tmp/temp20250305183303418/tutorials?&gt;&lt;?workdir-uri file:/tmp/temp20250305183303418/tutorials/?&gt;&lt;?path2project ../?&gt;&lt;?path2project-uri ../?&gt;&lt;?path2rootmap-uri ../?&gt;&lt;topic xmlns:dita-ot=&#34;http://dita-ot.sourceforge.net/ns/201007/dita-ot&#34; xmlns:ditaarch=&#34;http://dita.oasis-open.org/architecture/2005/&#34; class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;编程最容易忽略的十个细节&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;编程最容易忽略的十个细节&lt;/title&gt;&lt;prolog class=&#34;- topic/prolog &#34;&gt;&lt;author class=&#34;- topic/author &#34; xtrc=&#34;author:1;12:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/author&gt;&lt;publisherinformation class=&#34;- topic/publisher bookmap/publisherinformation &#34; xtrc=&#34;publisherinformation:1;14:31&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:1;15:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;printlocation class=&#34;- topic/data bookmap/printlocation &#34; xtrc=&#34;printlocation:1;16:28&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;N/A&lt;/printlocation&gt; &lt;published class=&#34;- topic/data bookmap/published &#34; xtrc=&#34;published:1;17:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;person class=&#34;- topic/data bookmap/person &#34; xtrc=&#34;person:2;18:25&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DDB&lt;/person&gt; &lt;publishtype class=&#34;- topic/data bookmap/publishtype &#34; value=&#34;HTML&#34; xtrc=&#34;publishtype:1;19:44&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;revisionid class=&#34;- topic/ph bookmap/revisionid &#34; xtrc=&#34;revisionid:1;20:29&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;200&lt;/revisionid&gt; &lt;summary class=&#34;- topic/ph bookmap/summary &#34; xtrc=&#34;summary:1;22:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:1;23:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/published&gt; &lt;data class=&#34;- topic/data &#34; xtrc=&#34;data:2;25:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt; &lt;/publisherinformation&gt;&lt;metadata class=&#34;- topic/metadata &#34;&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:2;39:20&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;audience class=&#34;- topic/audience &#34; xtrc=&#34;audience:1;28:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;category class=&#34;- topic/category &#34; xtrc=&#34;category:1;29:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;/&gt;&lt;prodinfo class=&#34;- topic/prodinfo &#34; xtrc=&#34;prodinfo:1;34:23&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt; &lt;prodname class=&#34;- topic/prodname &#34; xtrc=&#34;prodname:1;35:27&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/prodname&gt; &lt;brand class=&#34;- topic/brand &#34; xtrc=&#34;brand:1;36:24&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/ddb_doc_centre.ditamap&#34;&gt;DolphinDB&lt;/brand&gt; &lt;/prodinfo&gt;&lt;/metadata&gt;&lt;/prolog&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:1;1:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:1;3:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在 DolphinDB 中，无论是数据导入、数据分析还是流计算，编程都是关键的基础。而在编程中，想要更高效更优雅地写脚本，并避免一些常见问题，则需要注意一些细节。本篇教程列举10个实用的细节，有助于 DolphinDB 初学者避免分区冲突、类型不一致、计算错误、效率低下、内存膨胀、堆栈溢出等问题，提高使用 DolphinDB 编程脚本的水平。&lt;/p&gt;&lt;/body&gt;&lt;related-links class=&#34;- topic/related-links &#34;&gt;&lt;linkpool class=&#34;- topic/linkpool &#34; xtrc=&#34;topicref:47;67:36&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;link class=&#34;- topic/link &#34; format=&#34;dita&#34; href=&#34;../tutorials/about_tutorials.dita&#34; mapclass=&#34;- map/topicref bookmap/chapter &#34; role=&#34;parent&#34; scope=&#34;local&#34; type=&#34;topic&#34; xtrc=&#34;topicref:1;5:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/chap_tutorials.ditamap&#34;&gt;&lt;?ditaot usertext?&gt;&lt;linktext class=&#34;- topic/linktext &#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/linktext&gt;&lt;?ditaot usershortdesc?&gt;&lt;desc class=&#34;- topic/desc &#34;&gt;DolphinDB 产品使用教程&lt;/desc&gt;&lt;/link&gt;&lt;/linkpool&gt;&lt;/related-links&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;1-在-mr-中写入分布式表时注意避免分区冲突&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;1. 在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:1;5:9&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 中写入分布式表时注意避免分区冲突&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:2;5:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:2;7:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 函数，即 Map-Reduce，是在 DolphinDB 分布式计算中最常用的函数之一。通常，数据表会被划分为多个分区，每个分区表被视作一个数据源（ds）。&lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:1;7:84&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mapFunc&lt;/i&gt; 参数负责在每个 ds 内部处理数据，可选参数 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:2;7:117&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;reduceFunc&lt;/i&gt; 会将 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:3;7:133&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mapFunc&lt;/i&gt; 的返回值合并或汇总。若未使用 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:4;7:158&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;reduceFunc&lt;/i&gt;，就会直接返回 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:5;7:178&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mapFunc&lt;/i&gt; 的结果，也就是由所有返回值组合成的元组。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:3;9:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在进行复杂计算时，我们通常在分区内计算数据，并在映射过程中直接将其写入另一个数据库表。但是，如果 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:6;9:50&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mapFunc&lt;/i&gt; 中包含写入另一个表的操作，且原库表和结果库表的分区不一致，就可能会遇到写入冲突的报错。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;11-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;1.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:3;11:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:4;13:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;下面使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:3;13:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 对一个时间和标的均为 value 分区的库表做计算，完成后将结果写入一个仅按时间 value 分区的库表中：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:1;15:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;def myMapFunc(table){ minReturn = select `dayReturnSkew as factorname, skew(ratios(close)) as val from loadTable(&#34;dfs://k_minute_level&#34;,&#34;k_minute&#34;) group by date(tradetime) as tradetime, securityid loadTable(&#34;dfs://K_FACTOR_VERTICAL&#34;,&#34;factor_k&#34;).append!(minReturn) } ds = sqlDS(&amp;lt;select * from loadTable(&#34;dfs://k_minute_level&#34;,&#34;k_minute&#34;)&amp;gt;) mr(ds,myMapFunc)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:5;24:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;运行这段代码会报错：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:4;24:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;1 map call(s) failed. The error message for the first failed call is: &amp;lt;ChunkInTransaction&amp;gt;filepath '/K_FAC/TOR_VERTICAL/202001M_202101M/dayReturnSkew/a' has been owned by transaction 27 RefId: S00002&lt;/codeph&gt;。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:6;26:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这是因为上述例子中，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:5;26:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 数据源的分区方式和目标写入库表的分区方式是冲突的，即多个数据源中的计算结果对应了待写入库表的同一个分区。例子中的数据源涉及到三个分区，而计算结果对应的待写入库表只写入一个分区，在三个并行计算完成后，同时往同一个分区写入，会发生分区冲突，抛出异常，写入失败。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:7;28:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这种情况下，每一个 map 的结果写入结果表时，最好是串行写入。串行写入的方法有很多，包括：&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:1;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:1;30:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:6;30:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 中不做写入，只做计算。拿到返回的结果后，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:7;30:33&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;unionAll&lt;/codeph&gt; 将多个结果表进行合并，再一次性写入目标库表。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:2;31:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:8;31:5&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 的 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:7;31:12&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;finalFunc&lt;/i&gt; 中完成合并结果和写入目标库表的操作。&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:3;32:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;如果 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:9;32:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;mr&lt;/codeph&gt; 的计算结果很大，在内存中无法合并结果，则可以将结果写入流表，由流表的 handler 来串行写入目标库表。&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;12-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;1.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:4;34:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:2;36:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;def myMapFuncCorrect(table){ minReturn = select `dayReturnSkew as factorname, skew(ratios(close)) as val from loadTable(&#34;dfs://k_minute_level&#34;,&#34;k_minute&#34;) group by date(tradetime) as tradetime, securityid return minReturn } def unionAndWrite(result){ multi_result = unionAll(result,false) return tableInsert(loadTable(&#34;dfs://K_FACTOR_VERTICAL&#34;,&#34;factor_k&#34;), multi_result) } mr(ds, myMapFuncCorrect, , unionAndWrite)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:8;50:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;上述代码中，我们在 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:8;50:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;finalFunc&lt;/i&gt; 里对各个 ds 的计算结果进行了合并，再将合并结果写入目标库表，可以有效避免分区冲突。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;2-留意空值的数据类型&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;2. 留意空值的数据类型&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:5;54:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:9;56:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在 DolphinDB 中，空值既可以是无特定类型的（如 NULL），也可以是特定类型的（如 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:10;56:48&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;int(NULL)&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:11;56:60&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;double(NULL)&lt;/codeph&gt;、&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:12;56:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;string(NULL)&lt;/codeph&gt; 等）。在向强类型的向量或表中填充或更新空值时，必须确保空值的数据类型与向量类型或表中对应列的类型相匹配。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;21-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:6;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:6;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;2.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:6;58:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:10;60:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;下面这段代码试图更新表中的空值：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:3;62:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;id = `a`b`c val = 1 2 3 t1 = table(id, val) t2 = select NULL as type, * from t1 update t2 set type = &#34;S&#34;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:11;70:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这段代码将会报错：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:13;70:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;The data type of the new values does not match the data type of column type.&lt;/codeph&gt;&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:12;72:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这是因为在生成 t2 时，由于没有指定空值的数据类型，将会生成 VOID 类型的空值，导致 type 列的类型为 VOID。因此，在更新（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:14;72:70&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;update&lt;/codeph&gt;） t2 时，由于 “S” 是 STRING 类型，与 type 列的类型不匹配，便无法将其更新到 type 列中。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;22-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:7;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:7;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;2.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:7;74:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:4;76:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;id = `a`b`c val = 1 2 3 t1 = table(id, val) t2 = select string(NULL) as type, * from t1 update t2 set type = &#34;S&#34;&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:13;84:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;上述代码中，我们在生成 t2 时，显式指定了 type 列空值的类型为 STRING 类型，因此可以正常 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:15;84:54&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;update&lt;/codeph&gt; t2，不会报错。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;3-注意矩阵与表之间的转换&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:8;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:8;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;3. 注意矩阵与表之间的转换&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:8;88:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:14;90:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在做计算的时候，经常会遇到要转换数据结构的情况，譬如将表转为矩阵。但是由于矩阵和表的性质不同，普通转换的时候可能会缺失一些信息（如表的列名、矩阵的行列标签等）。因此，在转换过程中，我们需要注意补充这些缺失的信息。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;31-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:9;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:9;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;3.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:9;92:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:5;94:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t = table(stretch(2020.01.01..2020.01.05, 10) as Date, take(`AAPL`BABA,10) as sym, take(`alpha1,10) as factorName, 0.1 0.2 0.11 0.22 0.13 0.5 0.6 0.4 0.44 0.12 as factorValue) m = exec factorValue from t pivot by Date,sym m&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:15;102:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;输出结果为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:6;104:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt; AAPL BABA ---- ---- 2020.01.01|0.1 0.2 2020.01.02|0.11 0.22 2020.01.03|0.13 0.5 2020.01.04|0.6 0.4 2020.01.05|0.44 0.12&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:16;114:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;随后，将矩阵 m 转换为表：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:7;116:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;table(m)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:17;120:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;预期的输出为：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:8;122:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;Date AAPL BABA ---------- ---- ---- 2020.01.01 0.1 0.2 2020.01.02 0.11 0.22 2020.01.03 0.13 0.5 2020.01.04 0.6 0.4 2020.01.05 0.44 0.12&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:18;132:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;实际输出如下，其中 matrix 的 label 列丢失：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:9;134:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;AAPL BABA ---- ---- 0.1 0.2 0.11 0.22 0.13 0.5 0.6 0.4 0.44 0.12&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:19;144:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;由于矩阵的值不包括矩阵的行标签，因此在矩阵转换为表时，只会把矩阵的值转成表的列。如果需要保证矩阵中的标签列不丢失，并且转成表中的首列，则需要手动添加。反之亦然，如果要将表的内容转为矩阵，那么需要先剔除目标矩阵中的标签列，把目标值的列先转成矩阵，再将标签列手动添加进矩阵。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;32-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:10;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:10;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;3.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:10;146:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:10;148:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;//将矩阵转成正确的表 correctT = table(m.rowNames()) join table(m) //将表转换成正确的矩阵 correctM = matrix(correctT[,1:]).rename!(correctT.Date,correctT.colNames()[1:])&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:20;155:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;矩阵转表时，将矩阵的行标签通过 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:16;155:17&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;rowNames()&lt;/codeph&gt; 函数取出，拼接到转换后的表中。表转矩阵时，将值所在的列转成矩阵，接着用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:17;155:66&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;rename!()&lt;/codeph&gt; 函数给矩阵列和行添加标签。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;4-表连接时注意键值冗余&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;4. 表连接时注意键值冗余&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:11;159:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:21;161:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;表连接是通过连接谓词来合并两张或者多张表的数据，从而创建新表的函数。在进行表连接时，如果连接列存在多条匹配记录，通常会返回所有匹配记录。因此，如果关联列有大量重复值，可能会导致结果表规模急剧膨胀，甚至引发内存溢出（OOM）等问题。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;41-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:12;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:12;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;4.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:12;163:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:22;165:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;下面这段代码将两个表做左连接：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:11;167:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t1 = table(`a`b`c as id, 1 2 3 as val1) t2 = table(`a`a`a`b`b`b`c`c`c as id, 4..12 as val2) t1.lj(t2,`id)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:23;173:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;将会得到结果：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:12;175:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;id val1 val2 -- ---- ---- a 1 4 a 1 5 a 1 6 b 2 7 b 2 8 b 2 9 c 3 10 c 3 11 c 3 12&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:24;189:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这是因为，左连接（&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:18;189:10&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;lj&lt;/codeph&gt;）会返回左表中所有与右表匹配的记录。如果右表中没有匹配的记录，将会返回 NULL；如果右表中有多条匹配记录，将会返回所有的匹配记录。因此，由于右表中的 id 列有很多重复值，实际结果会比左表行数多得多。想要保证返回结果的行数与左表的行数相等，可以使用左半连接 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:19;189:144&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;lsj &lt;/codeph&gt; 函数，如果右表中有多条匹配记录，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:20;189:167&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;lsj&lt;/codeph&gt; 将会取第一条的匹配记录。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;42-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:13;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:13;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;4.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:13;191:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:13;193:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t1 = table(`a`b`c as id, 1 2 3 as val1) t2 = table(`a`a`a`b`b`b`c`c`c as id, 4..12 as val2) t1.lsj(t2,`id)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:25;199:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;如上，我们使用左半连接 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:21;199:13&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;lsj&lt;/codeph&gt; 来连接两个表，就不会出现匹配多次的冗余情况。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;5-sql-中变量名不要与列名同名&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:14;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:14;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;5. SQL 中变量名不要与列名同名&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:14;203:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:26;205:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;DolphinDB 支持多范式编程，包括 SQL 编程、命令式编程和函数式编程。在 SQL 语句中，列名可能与函数名或变量名相同。当三者产生歧义时，DolphinDB 会将其视为列名。若想表示函数的含义，可以在变量名称前加地址符 &amp;amp;。然而，当列名与变量名产生歧义时，就无法通过语法来消除歧义了。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:27;207:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;注意，在 DolphinDB 中的 SQL 中，列名是大小写不敏感的。因此，取变量名时尽量不要与表中字段重名，以免出现不符合预期的返回结果。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;51-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:15;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:15;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;5.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:15;209:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:28;211:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;下面这段代码试图删除指定日期的数据：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:14;213:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t = table(2020.01.01..2020.01.05 as Date) date = 2020.01.01 delete from t where Date = date t.Date&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:29;221:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;正常情况下，这段代码预期会返回向量 [2020.01.02,2020.01.03,2020.01.04,2020.01.05]，但实际会返回空值，表示表 t 中已无数据。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:30;223:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在这个 where 语句中，由于列名具有最高优先级， &#34;=&#34; 右边的 &#34;date&#34; 会优先查找是否存在名为 &#34;date&#34; 的列。由于列名不区分大小写，&#34;=&#34; 右边的 &#34;date&#34; 会被识别为表 t 中的 &#34;Date&#34; 列。因此，在 where 条件中，这样的写法会被解释为 &#34;列date = 列date&#34;，意味着每一条记录都符合 where 条件，从而导致表 t 被清空。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;52-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:16;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:16;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;5.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:16;225:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:31;227:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;避免变量名与列名同名，即把 date 这个变量改成例如 date1 即可。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:15;229:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t = table(2020.01.01..2020.01.05 as Date) date1 = 2020.01.01 delete from t where Date = date1&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;6-使用元编程计算多列数据&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:17;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:17;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;6. 使用元编程计算多列数据&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:17;237:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:32;239:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在使用 SQL 对表的多列进行计算时，手写 SQL 不仅繁琐，而且容易出错。因此，在对表内多列进行计算时，我们可以利用元编程来简化代码逻辑并提高准确性。如果想学习元编程相关的更多内容，可以阅读教程：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/tutorials/meta_programming.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:1;239:100&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;?ditaot usertext?&gt;元编程&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;61-繁琐代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:18;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:18;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;6.1 繁琐代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:18;241:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:16;243:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;date = 2023.01.01..2023.01.10 code = take(`SH0001,10) price = rand(10.0,10) t = table(date,code,price) res = select date, price, code, mmax(price,2) as mmax_2d, mmax(price,5) as mmax_5d, mmax(price,7) as mmax_7d, mmin(price,2) as mmin_2d, mmin(price,5) as mmin_5d, mmax(price,7) as mmin_7d, mavg(price,2) as mavg_2d, mavg(price,5) as mavg_5d, mavg(price,7) as mavg_7d, mstd(price,2) as mstd_2d, mstd(price,5) as mstd_5d, mstd(price,7) as mstd_7d from t context by code&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:33;256:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;手写 SQL 十分繁琐。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;62-优化方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:19;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:19;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;6.2 优化方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:19;258:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:17;260:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;date = 2023.01.01..2023.01.10 code = take(`SH0001,10) price = rand(10.0,10) t = table(date,code,price) factor = `mmax`mmin`mavg`mstd windowSize = 2 5 7 metrics=[&amp;lt;date&amp;gt;,&amp;lt;code&amp;gt;,&amp;lt;price&amp;gt;] f = def (x, y){return sqlCol(`price, partial(funcByName(x),,y), x + &#34;_&#34; + string(y) + &#34;d&#34;)} metrics.appendTuple!(cross(f, factor, windowSize).flatten()) res = sql(select=metrics, from = t, groupBy=sqlCol(`code), groupFlag=0).eval()&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:34;277:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;如上所示，我们使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:22;277:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;cross&lt;/codeph&gt; 函数结合匿名函数，生成了所有需要计算的因子的源代码，并加入到一个 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:9;277:52&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;metrics&lt;/i&gt; 向量中，即可用元编程函数 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:23;277:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;sql&lt;/codeph&gt; 方便地计算得到结果。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;7-注意元组的追加行为&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:20;281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:20;281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;7. 注意元组的追加行为&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:20;281:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:35;283:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在 DolphinDB 中，元组 （ANY VECTOR） 是一种特殊的向量类型，它允许元素类型不一致，其类型可以是表、矩阵、字符串向量、数值向量等。因此，在向元组中添加元素时，我们需要明确是将整个目标添加到元组中，还是将目标中的元素分别添加到元组中。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:36;285:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;例如，在元编程中拼接元代码时，直接拼接可能会得到不符合预期的结果。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;71-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:21;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:21;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;7.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:21;287:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:37;289:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;比如一个表中有这些字段：&#34;dDate&#34;, &#34;symbol&#34;, &#34;open&#34;, &#34;close&#34;, &#34;high&#34;, &#34;low&#34;。目标是对除了日期和 symbol 字段外的其他字段做 demean 操作（原值-平均值）。在用元编程写 &lt;i class=&#34;+ topic/ph hi-d/i &#34; xtrc=&#34;i:10;289:115&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;select&lt;/i&gt; 参数的时候可能会这样写：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:18;292:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;colName = [&#34;dDate&#34;, &#34;symbol&#34;, &#34;open&#34;, &#34;close&#34;, &#34;high&#34;, &#34;low&#34;] colNoCal = sqlCol(colName[0:2]) colCal = each(makeUnifiedCall{demean}, sqlCol(colName[2:])) selects = colNoCal join colCal //预期的行为：(&amp;lt; dDate &amp;gt;,&amp;lt; symbol &amp;gt;,&amp;lt; demean(open) &amp;gt;,&amp;lt; demean(close) &amp;gt;, &amp;lt; demean(high) &amp;gt;,&amp;lt; demean(low) &amp;gt;) //实际的输出：(&amp;lt; dDate &amp;gt;,&amp;lt; symbol &amp;gt;,(&amp;lt; demean(open) &amp;gt;,&amp;lt; demean(close) &amp;gt;, &amp;lt; demean(high) &amp;gt;,&amp;lt; demean(low) &amp;gt;))&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:38;303:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;可以看到实际输出中的元组只有三个元素，第三个元素是一个包含4个元素的元组。由于元组类型可以接受任何类型，因此在将 colCal 这个变量使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:24;303:72&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;join&lt;/codeph&gt; 添加到 colNoCal 时，colCal 将会被整体添加到 colNoCal 中。在元编程中，我们需要将 colCal 中的元素铺开加入到 colNoCal 中，因此需要逐个调用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:25;303:170&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;join&lt;/codeph&gt;，将其一个个加进元组中。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;72-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:22;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:22;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;7.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:22;305:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:19;308:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;metrics = colNoCal metrics.appendTuple!(colCal, wholistic = false) metrics&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:39;314:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;如上所示，我们使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:26;314:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;appendTuple!&lt;/codeph&gt; 函数，当 wholistic 参数为 false 时，就能够将 colCal 中的每一个元素依次追加到 metrics 中，即可得到符合预期的结果。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;8-where-子句正确进行分区剪枝&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:23;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:23;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;8. WHERE 子句正确进行分区剪枝&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:23;318:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:40;320:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在查询分布式表时，我们往往只需要查询部分分区的数据。当数据量较大时，过滤条件的不同写法会造成查询耗时的巨大差异。查询分布式表时，当 WHERE 子句中的过滤条件满足以下要求时，可以进行分区剪枝，加快查询速率。&lt;/p&gt;&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:2;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:4;322:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;当对采用 VALUE 分区、RANGE 分区或 LIST 分区的分布式表做查询时，若 where 子句中某个过滤条件同时满足以下条件，则系统只加载与查询相关的分区，以节省查询耗时：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:3;323:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:5;323:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;仅包含分布式表的原始分区字段、使用关系运算符（&amp;lt;, &amp;lt;=, =, ==, &amp;gt;, &amp;gt;=, in, between）或逻辑运算符（or, and），以及常量（包括常量与常量的运算）；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:6;324:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;非链式条件（例如100&amp;lt; x &amp;lt;200）；&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:7;325:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;过滤逻辑可以缩窄相关分区范围。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:8;326:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;当查询采用 HASH 分区的分布式表时，若 where 子句中某个过滤条件满足以下条件，则系统会进行分区剪枝：&lt;ul class=&#34;- topic/ul &#34; xtrc=&#34;ul:4;327:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;li class=&#34;- topic/li &#34; xtrc=&#34;li:9;327:3&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;包含分布式表的原始分区字段，使用关系运算符（=, ==, in, between）或逻辑运算符（or, and），以及常量（包括常量与常量的运算）。&lt;b class=&#34;+ topic/ph hi-d/b &#34; xtrc=&#34;b:1;327:79&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;注意&lt;/b&gt;：当分区字段是 STRING 类型时，使用 between 运算符不能进行剪枝。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:41;329:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;若 WHERE 子句中的过滤条件不满足以上要求，则会遍历所有分区进行查询。因此，在 WHERE 条件中，需要正确进行分区剪枝。如果想了解 DolphinDB 中关于时间类型的比较和分区剪枝的更多细节，可以阅读：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/tutorials/ddb_comparison_rules_of_time_types.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:2;329:106&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;?ditaot usertext?&gt;DolphinDB 时间类型比较规则&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;81-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:24;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:24;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;8.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:24;331:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:42;333:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;snapshot 是一个分区表，该表按天做了 VALUE 分区，分区字段为 DateTime。下面是错误的查询方式：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:20;336:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t1 = select count(*) from snapshot where temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;gt;= &#34;2020.06.01&#34; and temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;lt;= &#34;2020.06.02&#34; group by SecurityID // 耗时 4145 ms&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:43;344:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;运行如下代码，使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:27;344:11&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;sqlDS&lt;/codeph&gt; 查看该查询涉及的分区数：&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:21;346:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;sqlDS(&amp;lt;select count(*) from snapshot where temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;gt;= &#34;2020.06.01&#34; and temporalFormat(DateTime, &#34;yyyy.MM.dd&#34;) &amp;lt;= &#34;2020.06.02&#34; group by SecurityID&amp;gt;).size() &amp;gt;&amp;gt; 752&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:44;354:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;显然，对于按天分区的 snapshot，查询两天的数据并不应该涉及 752 个分区，说明该查询没有做分区剪枝。这是因为在该查询中，对分区字段套用了 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:28;354:75&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;temporalFormat&lt;/codeph&gt; 函数，先对所有日期进行转换，再去和对应日期比较，因此系统需要扫描所有分区，无法做分区剪枝，导致耗时大大增加。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;82-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:25;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:25;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;8.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:25;356:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:45;358:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;使用 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:29;358:4&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;between&lt;/codeph&gt; 谓词来指定分区字段所在的查询区间，能够正确做到分区剪枝，可以看到正确的查询仅涉及了两个分区，耗时大大减少，仅为 92ms。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:22;361:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;sqlDS(&amp;lt;select count(*) from snapshot where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID&amp;gt;).size() t2 = select count(*) from snapshot where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID&lt;/codeblock&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;9-灵活使用字典和元编程&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:26;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:26;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;9. 灵活使用字典和元编程&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:26;371:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:46;373:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在进行计算时，我们经常会遇到一些通用的公式，这些公式往往以字符串的形式生成。同时，我们希望公式中的变量能够引用会话（session）中已存在的变量。然而 DolphinDB 中没有全局变量，那么如何能实现公式中变量的转换与输出呢？&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;91-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:27;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:27;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;9.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:27;375:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:47;377:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;比如期望在函数内部对变量做计算，例如：”B+C“，得到的结果并不符合预期。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:23;380:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;a = 1 b = 2 def funcA(a,b){ B = a+1 C = b+2 funcExpr = &#34;B+C&#34; return parseExpr(funcExpr).eval() } funcA(a,b) //期望的输出：6 //实际的输出：SQL context is not initialized yet.&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:48;394:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这是因为，&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:30;394:6&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;parseExpr&lt;/codeph&gt; 函数解析变量时，首先搜索会话中的局部变量，再搜索共享变量，但不会搜索函数体内定义的局部变量。因此，需要的变量 B 和 C 均找不到，最终保存。想要找到需要的变量，则应当通过字典传入。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;92-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:28;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:28;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;9.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:28;396:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:24;399:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;a = 1 b = 2 def funcA(a, b){ funcExpr = &#34;B+C&#34; d = dict(`B`C, [a+1, b+2]) return parseExpr(funcExpr, d).eval() } funcA(a, b) &lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:49;410:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;如上所示，我们创建了一个字典 d，作为 &lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:31;410:21&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;parseExpr&lt;/codeph&gt; 的参数，即可完成计算。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;10-避免将大结果集直接返回客户端&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:29;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:29;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;10. 避免将大结果集直接返回客户端&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:29;414:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:50;416:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;在使用 SQL 查询数据时，如果直接将结果返回给客户端而不赋值给变量，不仅会导致结果无法修改和参与后续计算，还可能因为结果集过大而导致 GUI 或 Web 集群管理界面等终端堆栈溢出并抛出异常。因此，在查询数据时，我们应该尽量将结果赋值给一个变量而不是直接返回给客户端。&lt;/p&gt;&lt;/body&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;101-错误代码&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:30;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:30;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;10.1 错误代码&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:30;418:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:51;420:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;下述代码将会在 GUI 抛出异常：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:32;420:18&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;Java heap space&lt;/codeph&gt;，在 Web 集群管理界面抛出异常：&lt;codeph class=&#34;+ topic/ph pr-d/codeph &#34; xtrc=&#34;codeph:33;420:53&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;Out of Memory&lt;/codeph&gt;。&lt;/p&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:25;423:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;select * from loadTable(&#34;dfs://StockData&#34;,&#34;ORDER&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:52;427:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;这是因为如果直接进行查询，数据将会返回到终端，过大的数据量会导致客户端的堆栈溢出。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;102-解决方案&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:31;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:31;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;10.2 解决方案&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:31;429:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;codeblock class=&#34;+ topic/pre pr-d/codeblock &#34; xml:space=&#34;preserve&#34; xtrc=&#34;codeblock:26;432:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;t = select * from loadTable(&#34;dfs://StockData&#34;, &#34;ORDER&#34;)&lt;/codeblock&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:53;436:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;将查询结果赋值给一个变量，能够正常看到结果：&lt;/p&gt;&lt;image class=&#34;- topic/image &#34; href=&#34;images/the_ten_most_overlooked_details_of_programming/10.png&#34; placement=&#34;break&#34; xtrc=&#34;image:1;438:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34; dita-ot:image-width=&#34;757&#34; dita-ot:image-height=&#34;307&#34; dita-ot:horizontal-dpi=&#34;96&#34; dita-ot:vertical-dpi=&#34;96&#34;/&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;&lt;topic class=&#34;- topic/topic &#34; ditaarch:DITAArchVersion=&#34;2.0&#34; domains=&#34;a(props audience) a(props deliveryTarget) a(props otherprops) a(props platform) a(props product)&#34; id=&#34;总结&#34; specializations=&#34;@props/audience @props/deliveryTarget @props/otherprops @props/platform @props/product&#34; xtrc=&#34;topic:32;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;title class=&#34;- topic/title &#34; xtrc=&#34;title:32;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;总结&lt;/title&gt;&lt;body class=&#34;- topic/body &#34; xtrc=&#34;body:32;442:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:54;444:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;本文介绍了使用 DolphinDB 进行编程时，最容易忽略的 10 个细节，涵盖了分区冲突、数据类型处理、元编程、分区剪枝、SQL 查询等多个方面。在编程时忽略这些细节，可能导致程序运行报错或运算结果不符合预期。用户了解了这些细节，并合理进行编程，可以极大提升脚本的质量，提高编程效率。&lt;/p&gt;&lt;p class=&#34;- topic/p &#34; xtrc=&#34;p:55;446:1&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;DolphinDB 文档中心提供了更多使用 DolphinDB 编程的相关教程：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/tutorials/about_tutorials.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:3;446:41&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;?ditaot usertext?&gt;教程&lt;/xref&gt;。如果想浏览更多 SQL 案例，可以阅读教程：&lt;xref class=&#34;- topic/xref &#34; format=&#34;html&#34; href=&#34;https://docs.dolphindb.cn/zh/tutorials/ddb_sql_cases.html&#34; scope=&#34;external&#34; xtrc=&#34;xref:4;446:129&#34; xtrf=&#34;file:/var/lib/jenkins/workspace/packDocCN/documentation/zh/tutorials/the_ten_most_overlooked_details_of_programming.md&#34;&gt;&lt;?ditaot usertext?&gt;SQL 编写案例&lt;/xref&gt;。&lt;/p&gt;&lt;/body&gt;&lt;/topic&gt;&lt;/topic&gt;"/><meta name="wh-source-relpath" content="tutorials/the_ten_most_overlooked_details_of_programming.md"/><meta name="wh-out-relpath" content="tutorials/the_ten_most_overlooked_details_of_programming.html"/>

    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/commons.css?buildId=2024012323"/>
    <link rel="stylesheet" type="text/css" href="../oxygen-webhelp/app/topic.css?buildId=2024012323"/>

    <script src="../oxygen-webhelp/app/options/properties.js?buildId=20250305183303"></script>
    <script src="../oxygen-webhelp/app/localization/strings.js?buildId=2024012323"></script>
    <script src="../oxygen-webhelp/app/search/index/keywords.js?buildId=20250305183303"></script>
    <script defer="defer" src="../oxygen-webhelp/app/commons.js?buildId=2024012323"></script>
    <script defer="defer" src="../oxygen-webhelp/app/topic.js?buildId=2024012323"></script>
<link rel="stylesheet" type="text/css" href="../oxygen-webhelp/template/styles.css?buildId=2024012323"/><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script></head>

    <body id="编程最容易忽略的十个细节" class="wh_topic_page frmBody">
        <a href="#wh_topic_body" class="sr-only sr-only-focusable">
            跳转到主要内容
        </a>
        
        
        
        
        <header class="navbar navbar-default wh_header">
    <div class="container-fluid">
        <div xmlns:whc="http://www.oxygenxml.com/webhelp/components" class="wh_header_flex_container navbar-nav navbar-expand-md navbar-dark">
            <div class="wh_logo_and_publication_title_container">
                <div class="wh_logo_and_publication_title">
                    
                    <a href="https://docs.dolphindb.cn/zh/index.html" class=" wh_logo d-none d-sm-block "><img src="../logo.png" alt="  DolphinDB 文档中心  "/></a>
                    <div class=" wh_publication_title "><a href="../index.html"><span class="booktitle">  <span class="ph mainbooktitle">DolphinDB 文档中心</span>  </span></a></div>
                    
                </div>
                
                
            </div>

            <div class="wh_top_menu_and_indexterms_link collapse navbar-collapse" id="wh_top_menu_and_indexterms_link">
                
                
                
                
            </div>
        <div class=" wh_search_input navbar-form wh_topic_page_search search " role="form">
            
            
            
            <form id="searchForm" method="get" role="search" action="../search.html"><div><input type="search" placeholder="搜索 " class="wh_search_textfield" id="textToSearch" name="searchQuery" aria-label="搜索查询" required="required"/><button type="submit" class="wh_search_button" aria-label="搜索"><span class="search_input_text">搜索</span></button></div></form>
            
            <script src="/vendors/react/umd/react.production.min.js" defer="defer"></script>
<script src="/vendors/react-dom/umd/react-dom.production.min.js" defer="defer"></script>
<script src="/vendors/dayjs/dayjs.min.js" defer="defer"></script>
<script src="/vendors/antd/dist/antd.min.js" defer="defer"></script>
<script src="/vendors/@ant-design/icons/dist/index.umd.min.js" defer="defer"></script>
<script src="/zh/index.js" type="module"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" defer="defer"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer="defer"><!--


--></script>
<script defer="defer"><!--

// 从主页重定向
const currentUrl = window.location.href;

// 判断当前URL是否包含index.html并且路径最后部分是index.html
if (currentUrl.endsWith('index.html')) {
    // 处理根目录下的index.html跳转
    const baseUrl = currentUrl.split('/index.html')[0]; // 获取index.html之前的部分
    const redirectUrl = `${baseUrl}/about/ddb_intro.html`; // 构建跳转路径
    window.location.href = redirectUrl; // 执行跳转
}

--></script>
            
        </div></div>
    </div>
</header>
        
        
         
        
        
        
        <div class="container-fluid" id="wh_topic_container">
            <div class="row">

                <nav class="wh_tools d-print-none navbar-expand-md" aria-label="Tools">
                    
                    <div data-tooltip-position="bottom" class=" wh_breadcrumb "><ol class="d-print-none"><li><span class="home"><a href="../index.html"><span>主页</span></a></span></li><li><div class="topicref" data-id="about_tutorials"><div class="title"><a href="../tutorials/about_tutorials.html"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div></li><li><div class="topicref"><div class="title"><a href="../tutorials/std_sql_ddb.html">编程</a></div></div></li><li class="active"><div class="topicref" data-id="编程最容易忽略的十个细节"><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html">编程最容易忽略的十个细节</a></div></div></li></ol></div>
                    
                    
                    
                    <div class="wh_right_tools">
                        <button class="wh_hide_highlight" aria-label="切换搜索突出显示" title="切换搜索突出显示"></button>
                        <button class="webhelp_expand_collapse_sections" data-next-state="collapsed" aria-label="折叠截面" title="折叠截面"></button>
                        
                        
                        
                        
                        <div class=" wh_print_link print d-none d-md-inline-block "><button onClick="window.print()" title="打印此页" aria-label="打印此页"></button></div>
                        
                        <button type="button" id="wh_toc_button" class="custom-toggler navbar-toggler collapsed wh_toggle_button navbar-light" aria-expanded="false" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc">
                            <span class="navbar-toggler-icon"></span>
                        </button>
                    </div>
                    
                </nav>
            </div>
            
            
            
            
            <div class="wh_content_area">
                <div class="row">
                    
                        <nav id="wh_publication_toc" class="col-lg-3 col-md-3 col-sm-12 d-md-block d-none d-print-none" aria-label="Table of Contents Container">
                            <div id="wh_publication_toc_content">
		                        
                            	<div class=" wh_publication_toc " data-tooltip-position="right"><span class="expand-button-action-labels"><span id="button-expand-action" role="button" aria-label="Expand"></span><span id="button-collapse-action" role="button" aria-label="Collapse"></span><span id="button-pending-action" role="button" aria-label="Pending"></span></span><ul role="tree" aria-label="Table of Contents"><li role="treeitem"><div data-tocid="ddb_intro-d9713e87" class="topicref" data-id="ddb_intro" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../about/ddb_intro.html" id="ddb_intro-d9713e87-link">关于DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="chap1_getstarted-d9713e136" class="topicref" data-id="chap1_getstarted" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../getstarted/chap1_getstarted.html" id="chap1_getstarted-d9713e136-link">快速上手</a><div class="wh-tooltip"><p class="shortdesc">如何快速部署 DolphinDB、建库建表、写入和查询数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="sectionddb_deployment-d9713e189" class="topicref" data-id="sectionddb_deployment" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action sectionddb_deployment-d9713e189-link" class="wh-expand-btn"></span><div class="title"><a href="../deploy/deploy_intro.html" id="sectionddb_deployment-d9713e189-link"><span class="keyword label">部署</span></a><div class="wh-tooltip"><p class="shortdesc">如何在不同的场景中部署 DolphinDB</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259" class="topicref" data-id="new_chap_database_manage_new_chap_dbmanage_landing_page" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/cfg/db_intro.html" id="new_chap_database_manage_new_chap_dbmanage_landing_page-d9713e2259-link"><span class="keyword label">数据库</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 数据库的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_streaming-d9713e3760" class="topicref" data-id="chap7_tutorials_streaming" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_streaming-d9713e3760-link" class="wh-expand-btn"></span><div class="title"><a href="../stream/str_intro.html" id="chap7_tutorials_streaming-d9713e3760-link"><span class="keyword label">流数据</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 流数据引擎及流数据计算的基本概念</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e7513" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e7513-link" class="wh-expand-btn"></span><div class="title"><a href="../db_distr_comp/db_oper/import_data.html" id="tocId-d9713e7513-link">数据迁移</a><div class="wh-tooltip"><p class="shortdesc">如何从不同数据源向 DolphinDB 迁移数据</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap7_tutorials_system_management-d9713e7940" class="topicref" data-id="chap7_tutorials_system_management" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap7_tutorials_system_management-d9713e7940-link" class="wh-expand-btn"></span><div class="title"><a href="../sys_man/om_intro.html" id="chap7_tutorials_system_management-d9713e7940-link"><span class="keyword label">系统运维</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 的系统运维功能及方法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="troubleshooting-d9713e8780" class="topicref" data-id="troubleshooting" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action troubleshooting-d9713e8780-link" class="wh-expand-btn"></span><div class="title"><a href="../error_codes/troubleshooting.html" id="troubleshooting-d9713e8780-link">故障排查</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="about_language_resources-d9713e20911" class="topicref" data-id="about_language_resources" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action about_language_resources-d9713e20911-link" class="wh-expand-btn"></span><div class="title"><a href="../progr/progr_intro.html" id="about_language_resources-d9713e20911-link"><span class="keyword label">编程语言</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 编程基本概念与方法、SQL 在 DolphinDB 的应用</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="functions_references-d9713e30925" class="topicref" data-id="functions_references" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action functions_references-d9713e30925-link" class="wh-expand-btn"></span><div class="title"><a href="../funcs/funcs_intro.html" id="functions_references-d9713e30925-link"><span class="keyword label">函数参考</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 函数分类、语法、详解及示例</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="api_protocol-d9713e94064" class="topicref" data-id="api_protocol" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action api_protocol-d9713e94064-link" class="wh-expand-btn"></span><div class="title"><a href="../api/connapi_intro.html" id="api_protocol-d9713e94064-link"><span class="keyword label">连接器 &amp; API</span></a><div class="wh-tooltip"><p class="shortdesc">面向不同编程语言的 DolphinDB API 及连接器，相关协议和用法</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="chap6_plugin-d9713e94210" class="topicref" data-id="chap6_plugin" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action chap6_plugin-d9713e94210-link" class="wh-expand-btn"></span><div class="title"><a href="../plugins/plg_intro.html" id="chap6_plugin-d9713e94210-link"><span class="keyword label">插件</span></a><div class="wh-tooltip"><p class="shortdesc">多个应用场景的插件使用说明和插件开发指导</p></div></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="third_party-d9713e97904" class="topicref" data-id="third_party" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action third_party-d9713e97904-link" class="wh-expand-btn"></span><div class="title"><a href="../third_party.html" id="third_party-d9713e97904-link">第三方工具</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="about_tutorials-d9713e98227" class="topicref" data-id="about_tutorials" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action about_tutorials-d9713e98227-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/about_tutorials.html" id="about_tutorials-d9713e98227-link"><span class="keyword label">教程</span></a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 产品使用教程</p></div></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98280" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98280-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/new_users_finance.html" id="tocId-d9713e98280-link">新用户入门</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e98327" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e98327-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/database.html" id="tocId-d9713e98327-link">数据库</a></div></div></li><li role="treeitem" aria-expanded="true"><div data-tocid="tocId-d9713e99111" class="topicref" data-state="expanded"><span role="button" tabindex="0" aria-labelledby="button-collapse-action tocId-d9713e99111-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="tocId-d9713e99111-link">编程</a></div></div><ul role="group" class="navbar-nav nav-list"><li role="treeitem"><div data-tocid="sql-标准化-d9713e99112" class="topicref" data-id="sql-标准化" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/std_sql_ddb.html" id="sql-标准化-d9713e99112-link">SQL 标准化</a></div></div></li><li role="treeitem"><div data-tocid="topn-系列函数-d9713e99158" class="topicref" data-id="topn-系列函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_TopN.html" id="topn-系列函数-d9713e99158-link">TopN 系列函数</a></div></div></li><li role="treeitem"><div data-tocid="使用-summary-函数生成大规模数据统计信息-d9713e99204" class="topicref" data-id="使用-summary-函数生成大规模数据统计信息" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/generate_large_scale_statistics_with_summary.html" id="使用-summary-函数生成大规模数据统计信息-d9713e99204-link">使用 summary 函数生成大规模数据统计信息</a></div></div></li><li role="treeitem"><div data-tocid="decimal-类型之于-dolphindb-d9713e99250" class="topicref" data-id="decimal-类型之于-dolphindb" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL.html" id="decimal-类型之于-dolphindb-d9713e99250-link">DECIMAL 类型之于 DolphinDB</a></div></div></li><li role="treeitem"><div data-tocid="计算精度问题与-decimal-类型-d9713e99296" class="topicref" data-id="计算精度问题与-decimal-类型" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DECIMAL_Calculation_Characteristics.html" id="计算精度问题与-decimal-类型-d9713e99296-link">计算精度问题与 DECIMAL 类型</a></div></div></li><li role="treeitem"><div data-tocid="机器学习-d9713e99342" class="topicref" data-id="机器学习" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/machine_learning.html" id="机器学习-d9713e99342-link">机器学习</a></div></div></li><li role="treeitem"><div data-tocid="面板数据处理-d9713e99388" class="topicref" data-id="面板数据处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/panel_data.html" id="面板数据处理-d9713e99388-link">面板数据处理</a></div></div></li><li role="treeitem"><div data-tocid="时区处理-d9713e99434" class="topicref" data-id="时区处理" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/timezone.html" id="时区处理-d9713e99434-link">时区处理</a></div></div></li><li role="treeitem"><div data-tocid="pip-降采样算法-d9713e99480" class="topicref" data-id="pip-降采样算法" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/pip_ddb.html" id="pip-降采样算法-d9713e99480-link">PIP 降采样算法</a></div></div></li><li role="treeitem"><div data-tocid="动态增加字段和计算指标-d9713e99526" class="topicref" data-id="动态增加字段和计算指标" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/add_Column.html" id="动态增加字段和计算指标-d9713e99526-link">动态增加字段和计算指标</a></div></div></li><li role="treeitem"><div data-tocid="利用-dolphindb-高效清洗数据-d9713e99572" class="topicref" data-id="利用-dolphindb-高效清洗数据" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/data_ETL.html" id="利用-dolphindb-高效清洗数据-d9713e99572-link">利用 DolphinDB 高效清洗数据</a></div></div></li><li role="treeitem"><div data-tocid="array-vector-的最佳实践指南-d9713e99619" class="topicref" data-id="array-vector-的最佳实践指南" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Array_Vector.html" id="array-vector-的最佳实践指南-d9713e99619-link">Array Vector 的最佳实践指南</a></div></div></li><li role="treeitem"><div data-tocid="python-到-dolphindb-的函数映射-d9713e99665" class="topicref" data-id="python-到-dolphindb-的函数映射" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/function_mapping_py.html" id="python-到-dolphindb-的函数映射-d9713e99665-link">Python 到 DolphinDB 的函数映射</a></div></div></li><li role="treeitem"><div data-tocid="sql-编写案例-d9713e99711" class="topicref" data-id="sql-编写案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_sql_cases.html" id="sql-编写案例-d9713e99711-link">SQL 编写案例</a></div></div></li><li role="treeitem"><div data-tocid="sql-执行计划-d9713e99757" class="topicref" data-id="sql-执行计划" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/DolphinDB_Explain.html" id="sql-执行计划-d9713e99757-link">SQL 执行计划</a></div></div></li><li role="treeitem"><div data-tocid="启动脚本-d9713e99803" class="topicref" data-id="启动脚本" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/Startup.html" id="启动脚本-d9713e99803-link">启动脚本</a></div></div></li><li role="treeitem"><div data-tocid="窗口计算-d9713e99849" class="topicref" data-id="窗口计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/window_cal.html" id="窗口计算-d9713e99849-link">窗口计算</a></div></div></li><li role="treeitem"><div data-tocid="多范式编程-d9713e99895" class="topicref" data-id="多范式编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/hybrid_programming_paradigms.html" id="多范式编程-d9713e99895-link">多范式编程</a></div></div></li><li role="treeitem"><div data-tocid="函数化编程案例-d9713e99941" class="topicref" data-id="函数化编程案例" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/func_progr_cases.html" id="函数化编程案例-d9713e99941-link">函数化编程案例</a></div></div></li><li role="treeitem"><div data-tocid="基于函数的元编程应用-d9713e99987" class="topicref" data-id="基于函数的元编程应用" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/meta_programming.html" id="基于函数的元编程应用-d9713e99987-link">基于函数的元编程应用</a></div></div></li><li role="treeitem"><div data-tocid="基于-sql-的元编程-d9713e100033" class="topicref" data-id="基于-sql-的元编程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/macro_var_based_metaprogramming.html" id="基于-sql-的元编程-d9713e100033-link">基于 SQL 的元编程</a></div></div></li><li role="treeitem"><div data-tocid="即时编译jit-d9713e100079" class="topicref" data-id="即时编译jit" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/jit.html" id="即时编译jit-d9713e100079-link">即时编译（JIT）</a></div></div></li><li role="treeitem"><div data-tocid="矩阵运算-d9713e100126" class="topicref" data-id="矩阵运算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/matrix.html" id="矩阵运算-d9713e100126-link">矩阵运算</a></div></div></li><li role="treeitem"><div data-tocid="通用计算-d9713e100172" class="topicref" data-id="通用计算" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/general_computing.html" id="通用计算-d9713e100172-link">通用计算</a></div></div></li><li role="treeitem"><div data-tocid="自定义聚合函数-d9713e100218" class="topicref" data-id="自定义聚合函数" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/udaf.html" id="自定义聚合函数-d9713e100218-link">自定义聚合函数</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-时间类型比较规则-d9713e100264" class="topicref" data-id="dolphindb-时间类型比较规则" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/ddb_comparison_rules_of_time_types.html" id="dolphindb-时间类型比较规则-d9713e100264-link">DolphinDB 时间类型比较规则</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-教程概率统计分析-d9713e100310" class="topicref" data-id="dolphindb-教程概率统计分析" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/probabilistic_and_statistical_analysis.html" id="dolphindb-教程概率统计分析-d9713e100310-link">DolphinDB 教程：概率统计分析</a></div></div></li><li role="treeitem" class="active"><div data-tocid="编程最容易忽略的十个细节-d9713e100356" class="topicref" data-id="编程最容易忽略的十个细节" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/the_ten_most_overlooked_details_of_programming.html" id="编程最容易忽略的十个细节-d9713e100356-link">编程最容易忽略的十个细节</a></div></div></li><li role="treeitem"><div data-tocid="dolphindb-数据访问接口开发教程-d9713e100402" class="topicref" data-id="dolphindb-数据访问接口开发教程" data-state="leaf"><span role="button" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/interface_development.html" id="dolphindb-数据访问接口开发教程-d9713e100402-link">DolphinDB 数据访问接口开发教程</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100448" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100448-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming-real-time-correlation-processing_2.html" id="tocId-d9713e100448-link">流数据</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e100955" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e100955-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/scheduledJob_2.html" id="tocId-d9713e100955-link">系统运维</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="模块概述-d9713e101923" class="topicref" data-id="模块概述" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action 模块概述-d9713e101923-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/tu_modules.html" id="模块概述-d9713e101923-link">模块</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e102568" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e102568-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/OHLC_2.html" id="tocId-d9713e102568-link">金融场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e104827" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e104827-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/streaming_engine_anomaly_alerts_2.html" id="tocId-d9713e104827-link">物联网场景案例</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105795" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105795-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/dolphindb_tensor_libtorch_tutorial.html" id="tocId-d9713e105795-link">机器学习</a></div></div></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105842" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105842-link" class="wh-expand-btn"></span><div class="title"><a href="../tutorials/api_performance.html" id="tocId-d9713e105842-link">测试报告</a></div></div></li></ul></li><li role="treeitem" aria-expanded="false"><div data-tocid="tocId-d9713e105982" class="topicref" data-state="not-ready"><span role="button" tabindex="0" aria-labelledby="button-expand-action tocId-d9713e105982-link" class="wh-expand-btn"></span><div class="title"><a href="../rn/server/3_00_2.html" id="tocId-d9713e105982-link">版本说明</a><div class="wh-tooltip"><p class="shortdesc">DolphinDB 版本发布历史</p></div></div></div></li></ul></div>
		                        
                            </div>
                        </nav>
                    
                    
                    <div class="col-lg-7 col-md-9 col-sm-12" id="wh_topic_body">
                        <button id="wh_close_publication_toc_button" class="close-toc-button d-none" aria-label="Toggle publishing table of content" aria-controls="wh_publication_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        <button id="wh_close_topic_toc_button" class="close-toc-button d-none" aria-label="Toggle topic table of content" aria-controls="wh_topic_toc" aria-expanded="true">
                            <span class="close-toc-icon-container">
                                <span class="close-toc-icon"></span>     
                            </span>
                        </button>
                        
                        <div class=" wh_topic_content body "><main role="main"><article class="- topic/topic topic" role="article" aria-labelledby="ariaid-title1"><h1 class="- topic/title title topictitle1" id="ariaid-title1">编程最容易忽略的十个细节</h1><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，无论是数据导入、数据分析还是流计算，编程都是关键的基础。而在编程中，想要更高效更优雅地写脚本，并避免一些常见问题，则需要注意一些细节。本篇教程列举10个实用的细节，有助于 DolphinDB 初学者避免分区冲突、类型不一致、计算错误、效率低下、内存膨胀、堆栈溢出等问题，提高使用 DolphinDB 编程脚本的水平。</p></div><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title2" id="1-在-mr-中写入分布式表时注意避免分区冲突"><h2 class="- topic/title title topictitle2" id="ariaid-title2">1. 在 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 中写入分布式表时注意避免分区冲突</h2><div class="- topic/body body"><p class="- topic/p p"><code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 函数，即 Map-Reduce，是在 DolphinDB 分布式计算中最常用的函数之一。通常，数据表会被划分为多个分区，每个分区表被视作一个数据源（ds）。<em class="+ topic/ph hi-d/i ph i">mapFunc</em> 参数负责在每个 ds 内部处理数据，可选参数 <em class="+ topic/ph hi-d/i ph i">reduceFunc</em> 会将 <em class="+ topic/ph hi-d/i ph i">mapFunc</em> 的返回值合并或汇总。若未使用 <em class="+ topic/ph hi-d/i ph i">reduceFunc</em>，就会直接返回 <em class="+ topic/ph hi-d/i ph i">mapFunc</em> 的结果，也就是由所有返回值组合成的元组。</p><p class="- topic/p p">在进行复杂计算时，我们通常在分区内计算数据，并在映射过程中直接将其写入另一个数据库表。但是，如果 <em class="+ topic/ph hi-d/i ph i">mapFunc</em> 中包含写入另一个表的操作，且原库表和结果库表的分区不一致，就可能会遇到写入冲突的报错。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title3" id="11-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title3">1.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">下面使用 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 对一个时间和标的均为 value 分区的库表做计算，完成后将结果写入一个仅按时间 value 分区的库表中：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myMapFunc(table){
	minReturn = select `dayReturnSkew as factorname, skew(ratios(close)) as val from loadTable("dfs://k_minute_level","k_minute") group by date(tradetime) as tradetime, securityid
	loadTable("dfs://K_FACTOR_VERTICAL","factor_k").append!(minReturn)
}
ds = sqlDS(&lt;select * from  loadTable("dfs://k_minute_level","k_minute")&gt;)
mr(ds,myMapFunc)</code></pre><p class="- topic/p p">运行这段代码会报错：<code class="+ topic/ph pr-d/codeph ph codeph">1 map call(s) failed. The error message for the first failed call is: &lt;ChunkInTransaction&gt;filepath '/K_FAC/TOR_VERTICAL/202001M_202101M/dayReturnSkew/a' has been owned by transaction 27 RefId: S00002</code>。</p><p class="- topic/p p">这是因为上述例子中，<code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 数据源的分区方式和目标写入库表的分区方式是冲突的，即多个数据源中的计算结果对应了待写入库表的同一个分区。例子中的数据源涉及到三个分区，而计算结果对应的待写入库表只写入一个分区，在三个并行计算完成后，同时往同一个分区写入，会发生分区冲突，抛出异常，写入失败。</p><p class="- topic/p p">这种情况下，每一个 map 的结果写入结果表时，最好是串行写入。串行写入的方法有很多，包括：</p><ul class="- topic/ul ul"><li class="- topic/li li">在 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 中不做写入，只做计算。拿到返回的结果后，使用 <code class="+ topic/ph pr-d/codeph ph codeph">unionAll</code> 将多个结果表进行合并，再一次性写入目标库表。</li><li class="- topic/li li">在 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 的 <em class="+ topic/ph hi-d/i ph i">finalFunc</em> 中完成合并结果和写入目标库表的操作。</li><li class="- topic/li li">如果 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 的计算结果很大，在内存中无法合并结果，则可以将结果写入流表，由流表的 handler 来串行写入目标库表。</li></ul></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title4" id="12-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title4">1.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>def myMapFuncCorrect(table){
	minReturn = select `dayReturnSkew as factorname, skew(ratios(close))
	as val from loadTable("dfs://k_minute_level","k_minute") 
    	group by date(tradetime) as tradetime, securityid
	return minReturn
	}
def unionAndWrite(result){
	multi_result = unionAll(result,false)
	return tableInsert(loadTable("dfs://K_FACTOR_VERTICAL","factor_k"), multi_result)
	}
mr(ds, myMapFuncCorrect, , unionAndWrite)</code></pre><p class="- topic/p p">上述代码中，我们在 <em class="+ topic/ph hi-d/i ph i">finalFunc</em> 里对各个 ds 的计算结果进行了合并，再将合并结果写入目标库表，可以有效避免分区冲突。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title5" id="2-留意空值的数据类型"><h2 class="- topic/title title topictitle2" id="ariaid-title5">2. 留意空值的数据类型</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，空值既可以是无特定类型的（如 NULL），也可以是特定类型的（如 <code class="+ topic/ph pr-d/codeph ph codeph">int(NULL)</code>、<code class="+ topic/ph pr-d/codeph ph codeph">double(NULL)</code>、<code class="+ topic/ph pr-d/codeph ph codeph">string(NULL)</code> 等）。在向强类型的向量或表中填充或更新空值时，必须确保空值的数据类型与向量类型或表中对应列的类型相匹配。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title6" id="21-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title6">2.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">下面这段代码试图更新表中的空值：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>id = `a`b`c
val = 1 2 3
t1 = table(id, val)
t2 = select NULL as type, * from t1
update t2 set type = "S"</code></pre><p class="- topic/p p">这段代码将会报错：<code class="+ topic/ph pr-d/codeph ph codeph">The data type of the new values does not match the data type of column type.</code></p><p class="- topic/p p">这是因为在生成 t2 时，由于没有指定空值的数据类型，将会生成 VOID 类型的空值，导致 type 列的类型为 VOID。因此，在更新（<code class="+ topic/ph pr-d/codeph ph codeph">update</code>） t2 时，由于 “S” 是 STRING 类型，与 type 列的类型不匹配，便无法将其更新到 type 列中。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title7" id="22-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title7">2.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>id = `a`b`c
val = 1 2 3
t1 = table(id, val)
t2 = select string(NULL) as type, * from t1
update t2 set type = "S"</code></pre><p class="- topic/p p">上述代码中，我们在生成 t2 时，显式指定了 type 列空值的类型为 STRING 类型，因此可以正常 <code class="+ topic/ph pr-d/codeph ph codeph">update</code> t2，不会报错。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title8" id="3-注意矩阵与表之间的转换"><h2 class="- topic/title title topictitle2" id="ariaid-title8">3. 注意矩阵与表之间的转换</h2><div class="- topic/body body"><p class="- topic/p p">在做计算的时候，经常会遇到要转换数据结构的情况，譬如将表转为矩阵。但是由于矩阵和表的性质不同，普通转换的时候可能会缺失一些信息（如表的列名、矩阵的行列标签等）。因此，在转换过程中，我们需要注意补充这些缺失的信息。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title9" id="31-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title9">3.1 错误代码</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(stretch(2020.01.01..2020.01.05, 10) as Date,
    take(`AAPL`BABA,10) as sym, take(`alpha1,10) as factorName,
    0.1 0.2 0.11 0.22 0.13 0.5 0.6 0.4 0.44 0.12 as factorValue)
m = exec factorValue from t pivot by Date,sym
m</code></pre><p class="- topic/p p">输出结果为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>           AAPL BABA
           ---- ----
2020.01.01|0.1  0.2 
2020.01.02|0.11 0.22
2020.01.03|0.13 0.5 
2020.01.04|0.6  0.4 
2020.01.05|0.44 0.12</code></pre><p class="- topic/p p">随后，将矩阵 m 转换为表：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>table(m)</code></pre><p class="- topic/p p">预期的输出为：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>Date       AAPL BABA
---------- ---- ----
2020.01.01 0.1  0.2 
2020.01.02 0.11 0.22
2020.01.03 0.13 0.5 
2020.01.04 0.6  0.4 
2020.01.05 0.44 0.12</code></pre><p class="- topic/p p">实际输出如下，其中 matrix 的 label 列丢失：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>AAPL BABA
---- ----
0.1  0.2 
0.11 0.22
0.13 0.5 
0.6  0.4 
0.44 0.12</code></pre><p class="- topic/p p">由于矩阵的值不包括矩阵的行标签，因此在矩阵转换为表时，只会把矩阵的值转成表的列。如果需要保证矩阵中的标签列不丢失，并且转成表中的首列，则需要手动添加。反之亦然，如果要将表的内容转为矩阵，那么需要先剔除目标矩阵中的标签列，把目标值的列先转成矩阵，再将标签列手动添加进矩阵。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title10" id="32-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title10">3.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>//将矩阵转成正确的表
correctT = table(m.rowNames()) join table(m)
//将表转换成正确的矩阵
correctM = matrix(correctT[,1:]).rename!(correctT.Date,correctT.colNames()[1:])</code></pre><p class="- topic/p p">矩阵转表时，将矩阵的行标签通过 <code class="+ topic/ph pr-d/codeph ph codeph">rowNames()</code> 函数取出，拼接到转换后的表中。表转矩阵时，将值所在的列转成矩阵，接着用 <code class="+ topic/ph pr-d/codeph ph codeph">rename!()</code> 函数给矩阵列和行添加标签。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title11" id="4-表连接时注意键值冗余"><h2 class="- topic/title title topictitle2" id="ariaid-title11">4. 表连接时注意键值冗余</h2><div class="- topic/body body"><p class="- topic/p p">表连接是通过连接谓词来合并两张或者多张表的数据，从而创建新表的函数。在进行表连接时，如果连接列存在多条匹配记录，通常会返回所有匹配记录。因此，如果关联列有大量重复值，可能会导致结果表规模急剧膨胀，甚至引发内存溢出（OOM）等问题。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title12" id="41-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title12">4.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">下面这段代码将两个表做左连接：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t1 = table(`a`b`c as id, 1 2 3 as val1)
t2 = table(`a`a`a`b`b`b`c`c`c as id, 4..12 as val2)
t1.lj(t2,`id)</code></pre><p class="- topic/p p">将会得到结果：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>id val1 val2
-- ---- ----
a  1    4   
a  1    5   
a  1    6   
b  2    7   
b  2    8   
b  2    9   
c  3    10  
c  3    11  
c  3    12</code></pre><p class="- topic/p p">这是因为，左连接（<code class="+ topic/ph pr-d/codeph ph codeph">lj</code>）会返回左表中所有与右表匹配的记录。如果右表中没有匹配的记录，将会返回 NULL；如果右表中有多条匹配记录，将会返回所有的匹配记录。因此，由于右表中的 id 列有很多重复值，实际结果会比左表行数多得多。想要保证返回结果的行数与左表的行数相等，可以使用左半连接 <code class="+ topic/ph pr-d/codeph ph codeph">lsj </code> 函数，如果右表中有多条匹配记录，<code class="+ topic/ph pr-d/codeph ph codeph">lsj</code> 将会取第一条的匹配记录。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title13" id="42-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title13">4.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t1 = table(`a`b`c as id, 1 2 3 as val1)
t2 = table(`a`a`a`b`b`b`c`c`c as id, 4..12 as val2)
t1.lsj(t2,`id)</code></pre><p class="- topic/p p">如上，我们使用左半连接 <code class="+ topic/ph pr-d/codeph ph codeph">lsj</code> 来连接两个表，就不会出现匹配多次的冗余情况。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title14" id="5-sql-中变量名不要与列名同名"><h2 class="- topic/title title topictitle2" id="ariaid-title14">5. SQL 中变量名不要与列名同名</h2><div class="- topic/body body"><p class="- topic/p p">DolphinDB 支持多范式编程，包括 SQL 编程、命令式编程和函数式编程。在 SQL 语句中，列名可能与函数名或变量名相同。当三者产生歧义时，DolphinDB 会将其视为列名。若想表示函数的含义，可以在变量名称前加地址符 &amp;。然而，当列名与变量名产生歧义时，就无法通过语法来消除歧义了。</p><p class="- topic/p p">注意，在 DolphinDB 中的 SQL 中，列名是大小写不敏感的。因此，取变量名时尽量不要与表中字段重名，以免出现不符合预期的返回结果。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title15" id="51-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title15">5.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">下面这段代码试图删除指定日期的数据：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(2020.01.01..2020.01.05 as Date)

date = 2020.01.01
delete from t where Date = date
t.Date</code></pre><p class="- topic/p p">正常情况下，这段代码预期会返回向量 [2020.01.02,2020.01.03,2020.01.04,2020.01.05]，但实际会返回空值，表示表 t 中已无数据。</p><p class="- topic/p p">在这个 where 语句中，由于列名具有最高优先级， "=" 右边的 "date" 会优先查找是否存在名为 "date" 的列。由于列名不区分大小写，"=" 右边的 "date" 会被识别为表 t 中的 "Date" 列。因此，在 where 条件中，这样的写法会被解释为 "列date = 列date"，意味着每一条记录都符合 where 条件，从而导致表 t 被清空。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title16" id="52-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title16">5.2 解决方案</h3><div class="- topic/body body"><p class="- topic/p p">避免变量名与列名同名，即把 date 这个变量改成例如 date1 即可。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = table(2020.01.01..2020.01.05 as Date)
date1 = 2020.01.01
delete from t where Date = date1</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title17" id="6-使用元编程计算多列数据"><h2 class="- topic/title title topictitle2" id="ariaid-title17">6. 使用元编程计算多列数据</h2><div class="- topic/body body"><p class="- topic/p p">在使用 SQL 对表的多列进行计算时，手写 SQL 不仅繁琐，而且容易出错。因此，在对表内多列进行计算时，我们可以利用元编程来简化代码逻辑并提高准确性。如果想学习元编程相关的更多内容，可以阅读教程：<a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/tutorials/meta_programming.html" target="_blank" rel="external noopener">元编程</a>。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title18" id="61-繁琐代码"><h3 class="- topic/title title topictitle3" id="ariaid-title18">6.1 繁琐代码</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>date = 2023.01.01..2023.01.10
code = take(`SH0001,10)
price = rand(10.0,10)
t = table(date,code,price)

res = select date, price, code, mmax(price,2) as mmax_2d, mmax(price,5) as mmax_5d, 
mmax(price,7) as mmax_7d, mmin(price,2) as mmin_2d, mmin(price,5) as mmin_5d, 
mmax(price,7) as mmin_7d, mavg(price,2) as mavg_2d, mavg(price,5) as mavg_5d, 
mavg(price,7) as mavg_7d, mstd(price,2) as mstd_2d, mstd(price,5) as mstd_5d, 
mstd(price,7) as mstd_7d from t context by code</code></pre><p class="- topic/p p">手写 SQL 十分繁琐。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title19" id="62-优化方案"><h3 class="- topic/title title topictitle3" id="ariaid-title19">6.2 优化方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>date = 2023.01.01..2023.01.10
code = take(`SH0001,10)
price = rand(10.0,10)
t = table(date,code,price)

factor = `mmax`mmin`mavg`mstd
windowSize = 2 5 7
metrics=[&lt;date&gt;,&lt;code&gt;,&lt;price&gt;]

f = def (x, y){return sqlCol(`price, partial(funcByName(x),,y),
		x + "_" + string(y) + "d")}
metrics.appendTuple!(cross(f, factor, windowSize).flatten())

res = sql(select=metrics, from = t, groupBy=sqlCol(`code), groupFlag=0).eval()</code></pre><p class="- topic/p p">如上所示，我们使用 <code class="+ topic/ph pr-d/codeph ph codeph">cross</code> 函数结合匿名函数，生成了所有需要计算的因子的源代码，并加入到一个 <em class="+ topic/ph hi-d/i ph i">metrics</em> 向量中，即可用元编程函数 <code class="+ topic/ph pr-d/codeph ph codeph">sql</code> 方便地计算得到结果。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title20" id="7-注意元组的追加行为"><h2 class="- topic/title title topictitle2" id="ariaid-title20">7. 注意元组的追加行为</h2><div class="- topic/body body"><p class="- topic/p p">在 DolphinDB 中，元组 （ANY VECTOR） 是一种特殊的向量类型，它允许元素类型不一致，其类型可以是表、矩阵、字符串向量、数值向量等。因此，在向元组中添加元素时，我们需要明确是将整个目标添加到元组中，还是将目标中的元素分别添加到元组中。</p><p class="- topic/p p">例如，在元编程中拼接元代码时，直接拼接可能会得到不符合预期的结果。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title21" id="71-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title21">7.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">比如一个表中有这些字段："dDate", "symbol", "open", "close", "high", "low"。目标是对除了日期和 symbol 字段外的其他字段做 demean 操作（原值-平均值）。在用元编程写 <em class="+ topic/ph hi-d/i ph i">select</em> 参数的时候可能会这样写：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>colName = ["dDate", "symbol", "open", "close", "high", "low"]
colNoCal = sqlCol(colName[0:2])
colCal = each(makeUnifiedCall{demean}, sqlCol(colName[2:]))
selects = colNoCal join colCal
//预期的行为：(&lt; dDate &gt;,&lt; symbol &gt;,&lt; demean(open) &gt;,&lt; demean(close) &gt;,
    &lt; demean(high) &gt;,&lt; demean(low) &gt;)
//实际的输出：(&lt; dDate &gt;,&lt; symbol &gt;,(&lt; demean(open) &gt;,&lt; demean(close) &gt;,
    &lt; demean(high) &gt;,&lt; demean(low) &gt;))</code></pre><p class="- topic/p p">可以看到实际输出中的元组只有三个元素，第三个元素是一个包含4个元素的元组。由于元组类型可以接受任何类型，因此在将 colCal 这个变量使用 <code class="+ topic/ph pr-d/codeph ph codeph">join</code> 添加到 colNoCal 时，colCal 将会被整体添加到 colNoCal 中。在元编程中，我们需要将 colCal 中的元素铺开加入到 colNoCal 中，因此需要逐个调用 <code class="+ topic/ph pr-d/codeph ph codeph">join</code>，将其一个个加进元组中。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title22" id="72-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title22">7.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>metrics = colNoCal
metrics.appendTuple!(colCal, wholistic = false)
metrics</code></pre><p class="- topic/p p">如上所示，我们使用 <code class="+ topic/ph pr-d/codeph ph codeph">appendTuple!</code> 函数，当 wholistic 参数为 false 时，就能够将 colCal 中的每一个元素依次追加到 metrics 中，即可得到符合预期的结果。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title23" id="8-where-子句正确进行分区剪枝"><h2 class="- topic/title title topictitle2" id="ariaid-title23">8. WHERE 子句正确进行分区剪枝</h2><div class="- topic/body body"><p class="- topic/p p">在查询分布式表时，我们往往只需要查询部分分区的数据。当数据量较大时，过滤条件的不同写法会造成查询耗时的巨大差异。查询分布式表时，当 WHERE 子句中的过滤条件满足以下要求时，可以进行分区剪枝，加快查询速率。</p><ul class="- topic/ul ul"><li class="- topic/li li">当对采用 VALUE 分区、RANGE 分区或 LIST 分区的分布式表做查询时，若 where 子句中某个过滤条件同时满足以下条件，则系统只加载与查询相关的分区，以节省查询耗时：<ul class="- topic/ul ul"><li class="- topic/li li">仅包含分布式表的原始分区字段、使用关系运算符（&lt;, &lt;=, =, ==, &gt;, &gt;=, in, between）或逻辑运算符（or, and），以及常量（包括常量与常量的运算）；</li><li class="- topic/li li">非链式条件（例如100&lt; x &lt;200）；</li><li class="- topic/li li">过滤逻辑可以缩窄相关分区范围。</li></ul></li><li class="- topic/li li">当查询采用 HASH 分区的分布式表时，若 where 子句中某个过滤条件满足以下条件，则系统会进行分区剪枝：<ul class="- topic/ul ul"><li class="- topic/li li">包含分布式表的原始分区字段，使用关系运算符（=, ==, in, between）或逻辑运算符（or, and），以及常量（包括常量与常量的运算）。<strong class="+ topic/ph hi-d/b ph b">注意</strong>：当分区字段是 STRING 类型时，使用 between 运算符不能进行剪枝。</li></ul></li></ul><p class="- topic/p p">若 WHERE 子句中的过滤条件不满足以上要求，则会遍历所有分区进行查询。因此，在 WHERE 条件中，需要正确进行分区剪枝。如果想了解 DolphinDB 中关于时间类型的比较和分区剪枝的更多细节，可以阅读：<a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/tutorials/ddb_comparison_rules_of_time_types.html" target="_blank" rel="external noopener">DolphinDB 时间类型比较规则</a>。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title24" id="81-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title24">8.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">snapshot 是一个分区表，该表按天做了 VALUE 分区，分区字段为 DateTime。下面是错误的查询方式：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t1 = select count(*) from snapshot 
		   where temporalFormat(DateTime, "yyyy.MM.dd") &gt;= "2020.06.01" and temporalFormat(DateTime, "yyyy.MM.dd") &lt;= "2020.06.02" 
		   group by SecurityID

// 耗时 4145 ms</code></pre><p class="- topic/p p">运行如下代码，使用 <code class="+ topic/ph pr-d/codeph ph codeph">sqlDS</code> 查看该查询涉及的分区数：</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sqlDS(&lt;select count(*) from snapshot 
		   where temporalFormat(DateTime, "yyyy.MM.dd") &gt;= "2020.06.01" and temporalFormat(DateTime, "yyyy.MM.dd") &lt;= "2020.06.02" 
		   group by SecurityID&gt;).size()

&gt;&gt; 752</code></pre><p class="- topic/p p">显然，对于按天分区的 snapshot，查询两天的数据并不应该涉及 752 个分区，说明该查询没有做分区剪枝。这是因为在该查询中，对分区字段套用了 <code class="+ topic/ph pr-d/codeph ph codeph">temporalFormat</code> 函数，先对所有日期进行转换，再去和对应日期比较，因此系统需要扫描所有分区，无法做分区剪枝，导致耗时大大增加。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title25" id="82-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title25">8.2 解决方案</h3><div class="- topic/body body"><p class="- topic/p p">使用 <code class="+ topic/ph pr-d/codeph ph codeph">between</code> 谓词来指定分区字段所在的查询区间，能够正确做到分区剪枝，可以看到正确的查询仅涉及了两个分区，耗时大大减少，仅为 92ms。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>sqlDS(&lt;select count(*) from snapshot 
		   where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID&gt;).size()

t2 = select count(*) from snapshot 
		   where date(DateTime) between 2020.06.01 : 2020.06.02 group by SecurityID</code></pre></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title26" id="9-灵活使用字典和元编程"><h2 class="- topic/title title topictitle2" id="ariaid-title26">9. 灵活使用字典和元编程</h2><div class="- topic/body body"><p class="- topic/p p">在进行计算时，我们经常会遇到一些通用的公式，这些公式往往以字符串的形式生成。同时，我们希望公式中的变量能够引用会话（session）中已存在的变量。然而 DolphinDB 中没有全局变量，那么如何能实现公式中变量的转换与输出呢？</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title27" id="91-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title27">9.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">比如期望在函数内部对变量做计算，例如：”B+C“，得到的结果并不符合预期。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a = 1
b = 2
def funcA(a,b){
	B = a+1
	C = b+2
	funcExpr = "B+C"
	return parseExpr(funcExpr).eval()
	}
funcA(a,b)	
//期望的输出：6
//实际的输出：SQL context is not initialized yet.</code></pre><p class="- topic/p p">这是因为，<code class="+ topic/ph pr-d/codeph ph codeph">parseExpr</code> 函数解析变量时，首先搜索会话中的局部变量，再搜索共享变量，但不会搜索函数体内定义的局部变量。因此，需要的变量 B 和 C 均找不到，最终保存。想要找到需要的变量，则应当通过字典传入。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title28" id="92-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title28">9.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>a = 1
b = 2
def funcA(a, b){
	funcExpr = "B+C"
	d = dict(`B`C, [a+1, b+2])
	return parseExpr(funcExpr, d).eval()
}
funcA(a, b)	</code></pre><p class="- topic/p p">如上所示，我们创建了一个字典 d，作为 <code class="+ topic/ph pr-d/codeph ph codeph">parseExpr</code> 的参数，即可完成计算。</p></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title29" id="10-避免将大结果集直接返回客户端"><h2 class="- topic/title title topictitle2" id="ariaid-title29">10. 避免将大结果集直接返回客户端</h2><div class="- topic/body body"><p class="- topic/p p">在使用 SQL 查询数据时，如果直接将结果返回给客户端而不赋值给变量，不仅会导致结果无法修改和参与后续计算，还可能因为结果集过大而导致 GUI 或 Web 集群管理界面等终端堆栈溢出并抛出异常。因此，在查询数据时，我们应该尽量将结果赋值给一个变量而不是直接返回给客户端。</p></div><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title30" id="101-错误代码"><h3 class="- topic/title title topictitle3" id="ariaid-title30">10.1 错误代码</h3><div class="- topic/body body"><p class="- topic/p p">下述代码将会在 GUI 抛出异常：<code class="+ topic/ph pr-d/codeph ph codeph">Java heap space</code>，在 Web 集群管理界面抛出异常：<code class="+ topic/ph pr-d/codeph ph codeph">Out of Memory</code>。</p><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>select * from loadTable("dfs://StockData","ORDER")</code></pre><p class="- topic/p p">这是因为如果直接进行查询，数据将会返回到终端，过大的数据量会导致客户端的堆栈溢出。</p></div></article><article class="- topic/topic topic nested2" aria-labelledby="ariaid-title31" id="102-解决方案"><h3 class="- topic/title title topictitle3" id="ariaid-title31">10.2 解决方案</h3><div class="- topic/body body"><pre class="+ topic/pre pr-d/codeblock pre codeblock"><code>t = select * from loadTable("dfs://StockData", "ORDER")</code></pre><p class="- topic/p p">将查询结果赋值给一个变量，能够正常看到结果：</p><br/><img class="- topic/image image" src="images/the_ten_most_overlooked_details_of_programming/10.png"/><br/></div></article></article><article class="- topic/topic topic nested1" aria-labelledby="ariaid-title32" id="总结"><h2 class="- topic/title title topictitle2" id="ariaid-title32">总结</h2><div class="- topic/body body"><p class="- topic/p p">本文介绍了使用 DolphinDB 进行编程时，最容易忽略的 10 个细节，涵盖了分区冲突、数据类型处理、元编程、分区剪枝、SQL 查询等多个方面。在编程时忽略这些细节，可能导致程序运行报错或运算结果不符合预期。用户了解了这些细节，并合理进行编程，可以极大提升脚本的质量，提高编程效率。</p><p class="- topic/p p">DolphinDB 文档中心提供了更多使用 DolphinDB 编程的相关教程：<a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/tutorials/about_tutorials.html" target="_blank" rel="external noopener">教程</a>。如果想浏览更多 SQL 案例，可以阅读教程：<a class="- topic/xref xref" href="https://docs.dolphindb.cn/zh/tutorials/ddb_sql_cases.html" target="_blank" rel="external noopener">SQL 编写案例</a>。</p></div></article></article></main></div>
                        
                        
                        
                        
                        
                        
                    </div>
                    
                        <nav role="navigation" id="wh_topic_toc" aria-label="On this page" class="col-lg-2 d-none d-lg-block navbar d-print-none"> 
                            <div id="wh_topic_toc_content">
		                        
	                            <div class=" wh_topic_toc "><div class="wh_topic_label">在本页上</div><ul><li class="topic-item"><a href="#1-%E5%9C%A8-mr-%E4%B8%AD%E5%86%99%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8%E6%97%B6%E6%B3%A8%E6%84%8F%E9%81%BF%E5%85%8D%E5%88%86%E5%8C%BA%E5%86%B2%E7%AA%81" data-tocid="1-在-mr-中写入分布式表时注意避免分区冲突">1. 在 <code class="+ topic/ph pr-d/codeph ph codeph">mr</code> 中写入分布式表时注意避免分区冲突</a><ul><li class="topic-item"><a href="#11-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="11-错误代码">1.1 错误代码</a></li><li class="topic-item"><a href="#12-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="12-解决方案">1.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#2-%E7%95%99%E6%84%8F%E7%A9%BA%E5%80%BC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" data-tocid="2-留意空值的数据类型">2. 留意空值的数据类型</a><ul><li class="topic-item"><a href="#21-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="21-错误代码">2.1 错误代码</a></li><li class="topic-item"><a href="#22-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="22-解决方案">2.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#3-%E6%B3%A8%E6%84%8F%E7%9F%A9%E9%98%B5%E4%B8%8E%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2" data-tocid="3-注意矩阵与表之间的转换">3. 注意矩阵与表之间的转换</a><ul><li class="topic-item"><a href="#31-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="31-错误代码">3.1 错误代码</a></li><li class="topic-item"><a href="#32-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="32-解决方案">3.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#4-%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%B3%A8%E6%84%8F%E9%94%AE%E5%80%BC%E5%86%97%E4%BD%99" data-tocid="4-表连接时注意键值冗余">4. 表连接时注意键值冗余</a><ul><li class="topic-item"><a href="#41-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="41-错误代码">4.1 错误代码</a></li><li class="topic-item"><a href="#42-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="42-解决方案">4.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#5-sql-%E4%B8%AD%E5%8F%98%E9%87%8F%E5%90%8D%E4%B8%8D%E8%A6%81%E4%B8%8E%E5%88%97%E5%90%8D%E5%90%8C%E5%90%8D" data-tocid="5-sql-中变量名不要与列名同名">5. SQL 中变量名不要与列名同名</a><ul><li class="topic-item"><a href="#51-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="51-错误代码">5.1 错误代码</a></li><li class="topic-item"><a href="#52-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="52-解决方案">5.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#6-%E4%BD%BF%E7%94%A8%E5%85%83%E7%BC%96%E7%A8%8B%E8%AE%A1%E7%AE%97%E5%A4%9A%E5%88%97%E6%95%B0%E6%8D%AE" data-tocid="6-使用元编程计算多列数据">6. 使用元编程计算多列数据</a><ul><li class="topic-item"><a href="#61-%E7%B9%81%E7%90%90%E4%BB%A3%E7%A0%81" data-tocid="61-繁琐代码">6.1 繁琐代码</a></li><li class="topic-item"><a href="#62-%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88" data-tocid="62-优化方案">6.2 优化方案</a></li></ul></li><li class="topic-item"><a href="#7-%E6%B3%A8%E6%84%8F%E5%85%83%E7%BB%84%E7%9A%84%E8%BF%BD%E5%8A%A0%E8%A1%8C%E4%B8%BA" data-tocid="7-注意元组的追加行为">7. 注意元组的追加行为</a><ul><li class="topic-item"><a href="#71-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="71-错误代码">7.1 错误代码</a></li><li class="topic-item"><a href="#72-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="72-解决方案">7.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#8-where-%E5%AD%90%E5%8F%A5%E6%AD%A3%E7%A1%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA%E5%89%AA%E6%9E%9D" data-tocid="8-where-子句正确进行分区剪枝">8. WHERE 子句正确进行分区剪枝</a><ul><li class="topic-item"><a href="#81-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="81-错误代码">8.1 错误代码</a></li><li class="topic-item"><a href="#82-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="82-解决方案">8.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#9-%E7%81%B5%E6%B4%BB%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8%E5%92%8C%E5%85%83%E7%BC%96%E7%A8%8B" data-tocid="9-灵活使用字典和元编程">9. 灵活使用字典和元编程</a><ul><li class="topic-item"><a href="#91-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="91-错误代码">9.1 错误代码</a></li><li class="topic-item"><a href="#92-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="92-解决方案">9.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#10-%E9%81%BF%E5%85%8D%E5%B0%86%E5%A4%A7%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%AE%A2%E6%88%B7%E7%AB%AF" data-tocid="10-避免将大结果集直接返回客户端">10. 避免将大结果集直接返回客户端</a><ul><li class="topic-item"><a href="#101-%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81" data-tocid="101-错误代码">10.1 错误代码</a></li><li class="topic-item"><a href="#102-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" data-tocid="102-解决方案">10.2 解决方案</a></li></ul></li><li class="topic-item"><a href="#%E6%80%BB%E7%BB%93" data-tocid="总结">总结</a></li></ul></div>
	                        	
                        	</div>
                        </nav>
                    
                </div>
            </div>
            
            
            
        </div> 
        <footer class="navbar navbar-default wh_footer">
  <div class=" footer-container mx-auto ">
<title>Copyright</title><p><b> ©2025 浙江智臾科技有限公司 浙ICP备18048711号-3</b></p>
  </div>
</footer>
        
        <div id="go2top" class="d-print-none">
            <span class="oxy-icon oxy-icon-up"></span>
        </div>
        
        <div id="modal_img_large" class="modal">
            <span class="close oxy-icon oxy-icon-remove"></span>
            <div id="modal_img_container"></div>
            <div id="caption"></div>
        </div>
        
        
        
    </body>
</html>